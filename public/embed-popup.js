/******/ (() => {
  // webpackBootstrap
  /******/ 'use strict';
  /******/ var __webpack_modules__ = {
    /***/ 54: /***/ (module) => {
      /*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
      module.exports = function (cssWithMappingToString) {
        var list = [];

        // return the list of modules as css string
        list.toString = function toString() {
          return this.map(function (item) {
            var content = '';
            var needLayer = typeof item[5] !== 'undefined';
            if (item[4]) {
              content += '@supports ('.concat(item[4], ') {');
            }
            if (item[2]) {
              content += '@media '.concat(item[2], ' {');
            }
            if (needLayer) {
              content += '@layer'.concat(item[5].length > 0 ? ' '.concat(item[5]) : '', ' {');
            }
            content += cssWithMappingToString(item);
            if (needLayer) {
              content += '}';
            }
            if (item[2]) {
              content += '}';
            }
            if (item[4]) {
              content += '}';
            }
            return content;
          }).join('');
        };

        // import a list of modules into the list
        list.i = function i(modules, media, dedupe, supports, layer) {
          if (typeof modules === 'string') {
            modules = [[null, modules, undefined]];
          }
          var alreadyImportedModules = {};
          if (dedupe) {
            for (var k = 0; k < this.length; k++) {
              var id = this[k][0];
              if (id != null) {
                alreadyImportedModules[id] = true;
              }
            }
          }
          for (var _k = 0; _k < modules.length; _k++) {
            var item = [].concat(modules[_k]);
            if (dedupe && alreadyImportedModules[item[0]]) {
              continue;
            }
            if (typeof layer !== 'undefined') {
              if (typeof item[5] === 'undefined') {
                item[5] = layer;
              } else {
                item[1] = '@layer'
                  .concat(item[5].length > 0 ? ' '.concat(item[5]) : '', ' {')
                  .concat(item[1], '}');
                item[5] = layer;
              }
            }
            if (media) {
              if (!item[2]) {
                item[2] = media;
              } else {
                item[1] = '@media '.concat(item[2], ' {').concat(item[1], '}');
                item[2] = media;
              }
            }
            if (supports) {
              if (!item[4]) {
                item[4] = ''.concat(supports);
              } else {
                item[1] = '@supports ('.concat(item[4], ') {').concat(item[1], '}');
                item[4] = supports;
              }
            }
            list.push(item);
          }
        };
        return list;
      };

      /***/
    },

    /***/ 66: /***/ (module, __unused_webpack_exports, __webpack_require__) => {
      function checkDCE() {
        /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
        if (
          typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||
          typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'
        ) {
          return;
        }
        if (false) {
          // removed by dead control flow
        }
        try {
          // Verify that the code above has been dead code eliminated (DCE'd).
          __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
        } catch (err) {
          // DevTools shouldn't crash React, no matter what.
          // We should still report in case we break this code.
          console.error(err);
        }
      }

      if (true) {
        // DCE check should happen before ReactDOM bundle executes so that
        // DevTools can report bad minification during injection.
        checkDCE();
        module.exports = __webpack_require__(759);
      } // removed by dead control flow
      else {
      }

      /***/
    },

    /***/ 123: /***/ (module, __unused_webpack_exports, __webpack_require__) => {
      if (true) {
        module.exports = __webpack_require__(690);
      } // removed by dead control flow
      else {
      }

      /***/
    },

    /***/ 625: /***/ (module, __webpack_exports__, __webpack_require__) => {
      /* harmony export */ __webpack_require__.d(__webpack_exports__, {
        /* harmony export */ A: () => __WEBPACK_DEFAULT_EXPORT__,
        /* harmony export */
      });
      /* harmony import */ var _node_modules_pnpm_css_loader_7_1_2_webpack_5_102_1_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ =
        __webpack_require__(790);
      /* harmony import */ var _node_modules_pnpm_css_loader_7_1_2_webpack_5_102_1_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default =
        /*#__PURE__*/ __webpack_require__.n(
          _node_modules_pnpm_css_loader_7_1_2_webpack_5_102_1_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__
        );
      /* harmony import */ var _node_modules_pnpm_css_loader_7_1_2_webpack_5_102_1_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ =
        __webpack_require__(54);
      /* harmony import */ var _node_modules_pnpm_css_loader_7_1_2_webpack_5_102_1_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default =
        /*#__PURE__*/ __webpack_require__.n(
          _node_modules_pnpm_css_loader_7_1_2_webpack_5_102_1_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__
        );
      // Imports

      var ___CSS_LOADER_EXPORT___ =
        _node_modules_pnpm_css_loader_7_1_2_webpack_5_102_1_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()(
          _node_modules_pnpm_css_loader_7_1_2_webpack_5_102_1_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()
        );
      // Module
      ___CSS_LOADER_EXPORT___.push([
        module.id,
        `/*! tailwindcss v4.1.13 | MIT License | https://tailwindcss.com */
@layer properties;
@layer theme, base, components, utilities;
@layer theme {
  :root, :host {
    --color-blue-50: oklch(97% 0.014 254.604);
    --color-blue-100: oklch(93.2% 0.032 255.585);
    --color-blue-300: oklch(80.9% 0.105 251.813);
    --color-blue-400: oklch(70.7% 0.165 254.624);
    --color-blue-500: oklch(62.3% 0.214 259.815);
    --color-blue-700: oklch(48.8% 0.243 264.376);
    --color-blue-800: oklch(42.4% 0.199 265.638);
    --color-blue-900: oklch(37.9% 0.146 265.522);
    --color-gray-100: oklch(96.7% 0.003 264.542);
    --color-gray-700: oklch(37.3% 0.034 259.733);
    --color-zinc-50: oklch(98.5% 0 0);
    --color-zinc-200: oklch(92% 0.004 286.32);
    --color-zinc-300: oklch(87.1% 0.006 286.286);
    --color-zinc-400: oklch(70.5% 0.015 286.067);
    --color-zinc-500: oklch(55.2% 0.016 285.938);
    --color-zinc-600: oklch(44.2% 0.017 285.786);
    --color-zinc-700: oklch(37% 0.013 285.805);
    --color-zinc-800: oklch(27.4% 0.006 286.033);
    --color-zinc-900: oklch(21% 0.006 285.885);
    --color-zinc-950: oklch(14.1% 0.005 285.823);
    --color-black: #000;
    --color-white: #fff;
    --spacing: 0.25rem;
    --container-2xl: 42rem;
    --container-3xl: 48rem;
    --container-4xl: 56rem;
    --text-xs: 0.75rem;
    --text-xs--line-height: calc(1 / 0.75);
    --text-sm: 0.875rem;
    --text-sm--line-height: calc(1.25 / 0.875);
    --text-lg: 1.125rem;
    --text-lg--line-height: calc(1.75 / 1.125);
    --text-xl: 1.25rem;
    --text-xl--line-height: calc(1.75 / 1.25);
    --text-2xl: 1.5rem;
    --text-2xl--line-height: calc(2 / 1.5);
    --text-4xl: 2.25rem;
    --text-4xl--line-height: calc(2.5 / 2.25);
    --text-5xl: 3rem;
    --text-5xl--line-height: 1;
    --font-weight-extralight: 200;
    --font-weight-normal: 400;
    --font-weight-medium: 500;
    --font-weight-semibold: 600;
    --font-weight-bold: 700;
    --tracking-tight: -0.025em;
    --tracking-wider: 0.05em;
    --leading-tight: 1.25;
    --leading-relaxed: 1.625;
    --radius-sm: 0.25rem;
    --radius-md: 0.375rem;
    --radius-lg: 0.5rem;
    --radius-2xl: 1rem;
    --radius-3xl: 1.5rem;
    --drop-shadow-md: 0 3px 3px rgb(0 0 0 / 0.12);
    --drop-shadow-2xl: 0 25px 25px rgb(0 0 0 / 0.15);
    --ease-in: cubic-bezier(0.4, 0, 1, 1);
    --ease-out: cubic-bezier(0, 0, 0.2, 1);
    --ease-in-out: cubic-bezier(0.4, 0, 0.2, 1);
    --animate-spin: spin 1s linear infinite;
    --default-transition-duration: 150ms;
    --default-transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
    --default-font-family: var(--font-public-sans), ui-sans-serif, system-ui, sans-serif, 'Apple Color Emoji',
    'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';
    --default-mono-font-family: var(--font-commit-mono), ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
    'Liberation Mono', 'Courier New', monospace;
  }
}
@layer base {
  *, ::after, ::before, ::backdrop, ::file-selector-button {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
    border: 0 solid;
  }
  html, :host {
    line-height: 1.5;
    -webkit-text-size-adjust: 100%;
    tab-size: 4;
    font-family: var(--default-font-family, ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji");
    font-feature-settings: var(--default-font-feature-settings, normal);
    font-variation-settings: var(--default-font-variation-settings, normal);
    -webkit-tap-highlight-color: transparent;
  }
  hr {
    height: 0;
    color: inherit;
    border-top-width: 1px;
  }
  abbr:where([title]) {
    -webkit-text-decoration: underline dotted;
    text-decoration: underline dotted;
  }
  h1, h2, h3, h4, h5, h6 {
    font-size: inherit;
    font-weight: inherit;
  }
  a {
    color: inherit;
    -webkit-text-decoration: inherit;
    text-decoration: inherit;
  }
  b, strong {
    font-weight: bolder;
  }
  code, kbd, samp, pre {
    font-family: var(--default-mono-font-family, ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace);
    font-feature-settings: var(--default-mono-font-feature-settings, normal);
    font-variation-settings: var(--default-mono-font-variation-settings, normal);
    font-size: 1em;
  }
  small {
    font-size: 80%;
  }
  sub, sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
  }
  sub {
    bottom: -0.25em;
  }
  sup {
    top: -0.5em;
  }
  table {
    text-indent: 0;
    border-color: inherit;
    border-collapse: collapse;
  }
  :-moz-focusring {
    outline: auto;
  }
  progress {
    vertical-align: baseline;
  }
  summary {
    display: list-item;
  }
  ol, ul, menu {
    list-style: none;
  }
  img, svg, video, canvas, audio, iframe, embed, object {
    display: block;
    vertical-align: middle;
  }
  img, video {
    max-width: 100%;
    height: auto;
  }
  button, input, select, optgroup, textarea, ::file-selector-button {
    font: inherit;
    font-feature-settings: inherit;
    font-variation-settings: inherit;
    letter-spacing: inherit;
    color: inherit;
    border-radius: 0;
    background-color: transparent;
    opacity: 1;
  }
  :where(select:is([multiple], [size])) optgroup {
    font-weight: bolder;
  }
  :where(select:is([multiple], [size])) optgroup option {
    padding-inline-start: 20px;
  }
  ::file-selector-button {
    margin-inline-end: 4px;
  }
  ::placeholder {
    opacity: 1;
  }
  @supports (not (-webkit-appearance: -apple-pay-button))  or (contain-intrinsic-size: 1px) {
    ::placeholder {
      color: currentcolor;
      @supports (color: color-mix(in lab, red, red)) {
        color: color-mix(in oklab, currentcolor 50%, transparent);
      }
    }
  }
  textarea {
    resize: vertical;
  }
  ::-webkit-search-decoration {
    -webkit-appearance: none;
  }
  ::-webkit-date-and-time-value {
    min-height: 1lh;
    text-align: inherit;
  }
  ::-webkit-datetime-edit {
    display: inline-flex;
  }
  ::-webkit-datetime-edit-fields-wrapper {
    padding: 0;
  }
  ::-webkit-datetime-edit, ::-webkit-datetime-edit-year-field, ::-webkit-datetime-edit-month-field, ::-webkit-datetime-edit-day-field, ::-webkit-datetime-edit-hour-field, ::-webkit-datetime-edit-minute-field, ::-webkit-datetime-edit-second-field, ::-webkit-datetime-edit-millisecond-field, ::-webkit-datetime-edit-meridiem-field {
    padding-block: 0;
  }
  ::-webkit-calendar-picker-indicator {
    line-height: 1;
  }
  :-moz-ui-invalid {
    box-shadow: none;
  }
  button, input:where([type="button"], [type="reset"], [type="submit"]), ::file-selector-button {
    appearance: button;
  }
  ::-webkit-inner-spin-button, ::-webkit-outer-spin-button {
    height: auto;
  }
  [hidden]:where(:not([hidden="until-found"])) {
    display: none !important;
  }
}
@layer utilities {
  .pointer-events-none {
    pointer-events: none;
  }
  .collapse {
    visibility: collapse;
  }
  .invisible {
    visibility: hidden;
  }
  .visible {
    visibility: visible;
  }
  .sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip-path: inset(50%);
    white-space: nowrap;
    border-width: 0;
  }
  .not-sr-only {
    position: static;
    width: auto;
    height: auto;
    padding: 0;
    margin: 0;
    overflow: visible;
    clip-path: none;
    white-space: normal;
  }
  .absolute {
    position: absolute;
  }
  .fixed {
    position: fixed;
  }
  .relative {
    position: relative;
  }
  .static {
    position: static;
  }
  .sticky {
    position: sticky;
  }
  .-inset-1 {
    inset: calc(var(--spacing) * -1);
  }
  .inset-0 {
    inset: calc(var(--spacing) * 0);
  }
  .inset-1 {
    inset: calc(var(--spacing) * 1);
  }
  .inset-x-0 {
    inset-inline: calc(var(--spacing) * 0);
  }
  .inset-x-3 {
    inset-inline: calc(var(--spacing) * 3);
  }
  .inset-x-4 {
    inset-inline: calc(var(--spacing) * 4);
  }
  .top-0 {
    top: calc(var(--spacing) * 0);
  }
  .top-1\\/2 {
    top: calc(1/2 * 100%);
  }
  .top-4 {
    top: calc(var(--spacing) * 4);
  }
  .top-8 {
    top: calc(var(--spacing) * 8);
  }
  .right-2 {
    right: calc(var(--spacing) * 2);
  }
  .right-4 {
    right: calc(var(--spacing) * 4);
  }
  .right-6 {
    right: calc(var(--spacing) * 6);
  }
  .bottom-0 {
    bottom: calc(var(--spacing) * 0);
  }
  .bottom-4 {
    bottom: calc(var(--spacing) * 4);
  }
  .bottom-5 {
    bottom: calc(var(--spacing) * 5);
  }
  .bottom-6 {
    bottom: calc(var(--spacing) * 6);
  }
  .bottom-20 {
    bottom: calc(var(--spacing) * 20);
  }
  .bottom-32 {
    bottom: calc(var(--spacing) * 32);
  }
  .-left-5 {
    left: calc(var(--spacing) * -5);
  }
  .left-0 {
    left: calc(var(--spacing) * 0);
  }
  .left-1\\/2 {
    left: calc(1/2 * 100%);
  }
  .left-4 {
    left: calc(var(--spacing) * 4);
  }
  .left-6 {
    left: calc(var(--spacing) * 6);
  }
  .isolate {
    isolation: isolate;
  }
  .isolation-auto {
    isolation: auto;
  }
  .z-10 {
    z-index: 10;
  }
  .z-20 {
    z-index: 20;
  }
  .z-30 {
    z-index: 30;
  }
  .z-40 {
    z-index: 40;
  }
  .z-50 {
    z-index: 50;
  }
  .col-span-2 {
    grid-column: span 2 / span 2;
  }
  .col-start-1 {
    grid-column-start: 1;
  }
  .col-start-2 {
    grid-column-start: 2;
  }
  .row-span-3 {
    grid-row: span 3 / span 3;
  }
  .row-start-1 {
    grid-row-start: 1;
  }
  .row-start-3 {
    grid-row-start: 3;
  }
  .\\!container {
    width: 100% !important;
    @media (width >= 40rem) {
      max-width: 40rem !important;
    }
    @media (width >= 48rem) {
      max-width: 48rem !important;
    }
    @media (width >= 64rem) {
      max-width: 64rem !important;
    }
    @media (width >= 80rem) {
      max-width: 80rem !important;
    }
    @media (width >= 96rem) {
      max-width: 96rem !important;
    }
  }
  .container {
    width: 100%;
    @media (width >= 40rem) {
      max-width: 40rem;
    }
    @media (width >= 48rem) {
      max-width: 48rem;
    }
    @media (width >= 64rem) {
      max-width: 64rem;
    }
    @media (width >= 80rem) {
      max-width: 80rem;
    }
    @media (width >= 96rem) {
      max-width: 96rem;
    }
  }
  .m-0 {
    margin: calc(var(--spacing) * 0);
  }
  .-mx-1 {
    margin-inline: calc(var(--spacing) * -1);
  }
  .mx-2 {
    margin-inline: calc(var(--spacing) * 2);
  }
  .mx-auto {
    margin-inline: auto;
  }
  .my-1 {
    margin-block: calc(var(--spacing) * 1);
  }
  .mt-0\\.5 {
    margin-top: calc(var(--spacing) * 0.5);
  }
  .mt-1 {
    margin-top: calc(var(--spacing) * 1);
  }
  .mt-2 {
    margin-top: calc(var(--spacing) * 2);
  }
  .mt-6 {
    margin-top: calc(var(--spacing) * 6);
  }
  .mt-12 {
    margin-top: calc(var(--spacing) * 12);
  }
  .mt-40 {
    margin-top: calc(var(--spacing) * 40);
  }
  .-mr-px {
    margin-right: -1px;
  }
  .mr-auto {
    margin-right: auto;
  }
  .mb-2 {
    margin-bottom: calc(var(--spacing) * 2);
  }
  .mb-3 {
    margin-bottom: calc(var(--spacing) * 3);
  }
  .mb-4 {
    margin-bottom: calc(var(--spacing) * 4);
  }
  .mb-8 {
    margin-bottom: calc(var(--spacing) * 8);
  }
  .ml-auto {
    margin-left: auto;
  }
  .line-clamp-1 {
    overflow: hidden;
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 1;
  }
  .\\!hidden {
    display: none !important;
  }
  .block {
    display: block;
  }
  .contents {
    display: contents;
  }
  .flex {
    display: flex;
  }
  .flow-root {
    display: flow-root;
  }
  .grid {
    display: grid;
  }
  .hidden {
    display: none;
  }
  .inline {
    display: inline;
  }
  .inline-block {
    display: inline-block;
  }
  .inline-flex {
    display: inline-flex;
  }
  .inline-grid {
    display: inline-grid;
  }
  .inline-table {
    display: inline-table;
  }
  .list-item {
    display: list-item;
  }
  .table {
    display: table;
  }
  .table-caption {
    display: table-caption;
  }
  .table-cell {
    display: table-cell;
  }
  .table-column {
    display: table-column;
  }
  .table-column-group {
    display: table-column-group;
  }
  .table-footer-group {
    display: table-footer-group;
  }
  .table-header-group {
    display: table-header-group;
  }
  .table-row {
    display: table-row;
  }
  .table-row-group {
    display: table-row-group;
  }
  .aspect-square {
    aspect-ratio: 1 / 1;
  }
  .size-3\\.5 {
    width: calc(var(--spacing) * 3.5);
    height: calc(var(--spacing) * 3.5);
  }
  .size-4 {
    width: calc(var(--spacing) * 4);
    height: calc(var(--spacing) * 4);
  }
  .size-5 {
    width: calc(var(--spacing) * 5);
    height: calc(var(--spacing) * 5);
  }
  .size-6 {
    width: calc(var(--spacing) * 6);
    height: calc(var(--spacing) * 6);
  }
  .size-9 {
    width: calc(var(--spacing) * 9);
    height: calc(var(--spacing) * 9);
  }
  .size-11 {
    width: calc(var(--spacing) * 11);
    height: calc(var(--spacing) * 11);
  }
  .size-12 {
    width: calc(var(--spacing) * 12);
    height: calc(var(--spacing) * 12);
  }
  .size-16 {
    width: calc(var(--spacing) * 16);
    height: calc(var(--spacing) * 16);
  }
  .size-\\[90px\\] {
    width: 90px;
    height: 90px;
  }
  .h-0 {
    height: calc(var(--spacing) * 0);
  }
  .h-4 {
    height: calc(var(--spacing) * 4);
  }
  .h-5 {
    height: calc(var(--spacing) * 5);
  }
  .h-6 {
    height: calc(var(--spacing) * 6);
  }
  .h-8 {
    height: calc(var(--spacing) * 8);
  }
  .h-9 {
    height: calc(var(--spacing) * 9);
  }
  .h-10 {
    height: calc(var(--spacing) * 10);
  }
  .h-16 {
    height: calc(var(--spacing) * 16);
  }
  .h-40 {
    height: calc(var(--spacing) * 40);
  }
  .h-\\[46px\\] {
    height: 46px;
  }
  .h-\\[90px\\] {
    height: 90px;
  }
  .h-\\[480px\\] {
    height: 480px;
  }
  .h-\\[var\\(--radix-select-trigger-height\\)\\] {
    height: var(--radix-select-trigger-height);
  }
  .h-auto {
    height: auto;
  }
  .h-full {
    height: 100%;
  }
  .h-px {
    height: 1px;
  }
  .h-screen {
    height: 100vh;
  }
  .h-svh {
    height: 100svh;
  }
  .max-h-\\(--radix-select-content-available-height\\) {
    max-height: var(--radix-select-content-available-height);
  }
  .min-h-2\\.5 {
    min-height: calc(var(--spacing) * 2.5);
  }
  .min-h-4 {
    min-height: calc(var(--spacing) * 4);
  }
  .min-h-6 {
    min-height: calc(var(--spacing) * 6);
  }
  .min-h-screen {
    min-height: 100vh;
  }
  .min-h-svh {
    min-height: 100svh;
  }
  .w-0\\.5 {
    width: calc(var(--spacing) * 0.5);
  }
  .w-2\\.5 {
    width: calc(var(--spacing) * 2.5);
  }
  .w-4 {
    width: calc(var(--spacing) * 4);
  }
  .w-5 {
    width: calc(var(--spacing) * 5);
  }
  .w-6 {
    width: calc(var(--spacing) * 6);
  }
  .w-48 {
    width: calc(var(--spacing) * 48);
  }
  .w-64 {
    width: calc(var(--spacing) * 64);
  }
  .w-\\[70px\\] {
    width: 70px;
  }
  .w-\\[90px\\] {
    width: 90px;
  }
  .w-\\[180px\\] {
    width: 180px;
  }
  .w-auto {
    width: auto;
  }
  .w-fit {
    width: fit-content;
  }
  .w-full {
    width: 100%;
  }
  .w-px {
    width: 1px;
  }
  .max-w-2xl {
    max-width: var(--container-2xl);
  }
  .max-w-3xl {
    max-width: var(--container-3xl);
  }
  .max-w-4\\/5 {
    max-width: calc(4/5 * 100%);
  }
  .max-w-4xl {
    max-width: var(--container-4xl);
  }
  .max-w-80 {
    max-width: calc(var(--spacing) * 80);
  }
  .max-w-prose {
    max-width: 65ch;
  }
  .min-w-\\[8rem\\] {
    min-width: 8rem;
  }
  .min-w-\\[var\\(--radix-select-trigger-width\\)\\] {
    min-width: var(--radix-select-trigger-width);
  }
  .flex-1 {
    flex: 1;
  }
  .flex-shrink-0 {
    flex-shrink: 0;
  }
  .shrink {
    flex-shrink: 1;
  }
  .shrink-0 {
    flex-shrink: 0;
  }
  .shrink-1 {
    flex-shrink: 1;
  }
  .grow {
    flex-grow: 1;
  }
  .grow-1 {
    flex-grow: 1;
  }
  .border-collapse {
    border-collapse: collapse;
  }
  .origin-\\(--radix-select-content-transform-origin\\) {
    transform-origin: var(--radix-select-content-transform-origin);
  }
  .origin-center {
    transform-origin: center;
  }
  .-translate-x-1\\/2 {
    --tw-translate-x: calc(calc(1/2 * 100%) * -1);
    translate: var(--tw-translate-x) var(--tw-translate-y);
  }
  .-translate-x-full {
    --tw-translate-x: -100%;
    translate: var(--tw-translate-x) var(--tw-translate-y);
  }
  .translate-x-0 {
    --tw-translate-x: calc(var(--spacing) * 0);
    translate: var(--tw-translate-x) var(--tw-translate-y);
  }
  .-translate-y-1\\/2 {
    --tw-translate-y: calc(calc(1/2 * 100%) * -1);
    translate: var(--tw-translate-x) var(--tw-translate-y);
  }
  .-translate-y-full {
    --tw-translate-y: -100%;
    translate: var(--tw-translate-x) var(--tw-translate-y);
  }
  .translate-y-20 {
    --tw-translate-y: calc(var(--spacing) * 20);
    translate: var(--tw-translate-x) var(--tw-translate-y);
  }
  .translate-none {
    translate: none;
  }
  .scale-100 {
    --tw-scale-x: 100%;
    --tw-scale-y: 100%;
    --tw-scale-z: 100%;
    scale: var(--tw-scale-x) var(--tw-scale-y);
  }
  .scale-3d {
    scale: var(--tw-scale-x) var(--tw-scale-y) var(--tw-scale-z);
  }
  .transform {
    transform: var(--tw-rotate-x,) var(--tw-rotate-y,) var(--tw-rotate-z,) var(--tw-skew-x,) var(--tw-skew-y,);
  }
  .animate-spin {
    animation: var(--animate-spin);
  }
  .cursor-default {
    cursor: default;
  }
  .cursor-pointer {
    cursor: pointer;
  }
  .touch-pinch-zoom {
    --tw-pinch-zoom: pinch-zoom;
    touch-action: var(--tw-pan-x,) var(--tw-pan-y,) var(--tw-pinch-zoom,);
  }
  .resize {
    resize: both;
  }
  .scroll-my-1 {
    scroll-margin-block: calc(var(--spacing) * 1);
  }
  .grid-cols-1 {
    grid-template-columns: repeat(1, minmax(0, 1fr));
  }
  .grid-cols-2 {
    grid-template-columns: repeat(2, minmax(0, 1fr));
  }
  .grid-cols-\\[0_1fr\\] {
    grid-template-columns: 0 1fr;
  }
  .grid-cols-\\[1fr_1fr\\] {
    grid-template-columns: 1fr 1fr;
  }
  .grid-rows-1 {
    grid-template-rows: repeat(1, minmax(0, 1fr));
  }
  .grid-rows-\\[90px_1fr_90px\\] {
    grid-template-rows: 90px 1fr 90px;
  }
  .flex-col {
    flex-direction: column;
  }
  .flex-row {
    flex-direction: row;
  }
  .flex-row-reverse {
    flex-direction: row-reverse;
  }
  .flex-wrap {
    flex-wrap: wrap;
  }
  .place-content-center {
    place-content: center;
  }
  .place-content-end {
    place-content: end;
  }
  .place-items-center {
    place-items: center;
  }
  .items-center {
    align-items: center;
  }
  .items-end {
    align-items: flex-end;
  }
  .items-start {
    align-items: flex-start;
  }
  .justify-between {
    justify-content: space-between;
  }
  .justify-center {
    justify-content: center;
  }
  .justify-end {
    justify-content: flex-end;
  }
  .justify-items-start {
    justify-items: start;
  }
  .gap-0 {
    gap: calc(var(--spacing) * 0);
  }
  .gap-0\\.5 {
    gap: calc(var(--spacing) * 0.5);
  }
  .gap-1 {
    gap: calc(var(--spacing) * 1);
  }
  .gap-1\\.5 {
    gap: calc(var(--spacing) * 1.5);
  }
  .gap-2 {
    gap: calc(var(--spacing) * 2);
  }
  .gap-3 {
    gap: calc(var(--spacing) * 3);
  }
  .gap-4 {
    gap: calc(var(--spacing) * 4);
  }
  .gap-5 {
    gap: calc(var(--spacing) * 5);
  }
  .space-y-1 {
    :where(& > :not(:last-child)) {
      --tw-space-y-reverse: 0;
      margin-block-start: calc(calc(var(--spacing) * 1) * var(--tw-space-y-reverse));
      margin-block-end: calc(calc(var(--spacing) * 1) * calc(1 - var(--tw-space-y-reverse)));
    }
  }
  .space-y-2 {
    :where(& > :not(:last-child)) {
      --tw-space-y-reverse: 0;
      margin-block-start: calc(calc(var(--spacing) * 2) * var(--tw-space-y-reverse));
      margin-block-end: calc(calc(var(--spacing) * 2) * calc(1 - var(--tw-space-y-reverse)));
    }
  }
  .space-y-3 {
    :where(& > :not(:last-child)) {
      --tw-space-y-reverse: 0;
      margin-block-start: calc(calc(var(--spacing) * 3) * var(--tw-space-y-reverse));
      margin-block-end: calc(calc(var(--spacing) * 3) * calc(1 - var(--tw-space-y-reverse)));
    }
  }
  .space-y-4 {
    :where(& > :not(:last-child)) {
      --tw-space-y-reverse: 0;
      margin-block-start: calc(calc(var(--spacing) * 4) * var(--tw-space-y-reverse));
      margin-block-end: calc(calc(var(--spacing) * 4) * calc(1 - var(--tw-space-y-reverse)));
    }
  }
  .space-y-6 {
    :where(& > :not(:last-child)) {
      --tw-space-y-reverse: 0;
      margin-block-start: calc(calc(var(--spacing) * 6) * var(--tw-space-y-reverse));
      margin-block-end: calc(calc(var(--spacing) * 6) * calc(1 - var(--tw-space-y-reverse)));
    }
  }
  .space-y-8 {
    :where(& > :not(:last-child)) {
      --tw-space-y-reverse: 0;
      margin-block-start: calc(calc(var(--spacing) * 8) * var(--tw-space-y-reverse));
      margin-block-end: calc(calc(var(--spacing) * 8) * calc(1 - var(--tw-space-y-reverse)));
    }
  }
  .space-y-20 {
    :where(& > :not(:last-child)) {
      --tw-space-y-reverse: 0;
      margin-block-start: calc(calc(var(--spacing) * 20) * var(--tw-space-y-reverse));
      margin-block-end: calc(calc(var(--spacing) * 20) * calc(1 - var(--tw-space-y-reverse)));
    }
  }
  .space-y-reverse {
    :where(& > :not(:last-child)) {
      --tw-space-y-reverse: 1;
    }
  }
  .gap-x-2 {
    column-gap: calc(var(--spacing) * 2);
  }
  .space-x-reverse {
    :where(& > :not(:last-child)) {
      --tw-space-x-reverse: 1;
    }
  }
  .gap-y-0\\.5 {
    row-gap: calc(var(--spacing) * 0.5);
  }
  .divide-x {
    :where(& > :not(:last-child)) {
      --tw-divide-x-reverse: 0;
      border-inline-style: var(--tw-border-style);
      border-inline-start-width: calc(1px * var(--tw-divide-x-reverse));
      border-inline-end-width: calc(1px * calc(1 - var(--tw-divide-x-reverse)));
    }
  }
  .divide-y {
    :where(& > :not(:last-child)) {
      --tw-divide-y-reverse: 0;
      border-bottom-style: var(--tw-border-style);
      border-top-style: var(--tw-border-style);
      border-top-width: calc(1px * var(--tw-divide-y-reverse));
      border-bottom-width: calc(1px * calc(1 - var(--tw-divide-y-reverse)));
    }
  }
  .divide-y-reverse {
    :where(& > :not(:last-child)) {
      --tw-divide-y-reverse: 1;
    }
  }
  .self-center {
    align-self: center;
  }
  .self-start {
    align-self: flex-start;
  }
  .justify-self-end {
    justify-self: flex-end;
  }
  .justify-self-start {
    justify-self: flex-start;
  }
  .truncate {
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  .overflow-auto {
    overflow: auto;
  }
  .overflow-hidden {
    overflow: hidden;
  }
  .overflow-x-hidden {
    overflow-x: hidden;
  }
  .overflow-y-auto {
    overflow-y: auto;
  }
  .overflow-y-scroll {
    overflow-y: scroll;
  }
  .scroll-smooth {
    scroll-behavior: smooth;
  }
  .rounded {
    border-radius: 0.25rem;
  }
  .rounded-2xl {
    border-radius: var(--radius-2xl);
  }
  .rounded-3xl {
    border-radius: var(--radius-3xl);
  }
  .rounded-\\[20px\\] {
    border-radius: 20px;
  }
  .rounded-\\[24px\\] {
    border-radius: 24px;
  }
  .rounded-\\[28px\\] {
    border-radius: 28px;
  }
  .rounded-\\[31px\\] {
    border-radius: 31px;
  }
  .rounded-full {
    border-radius: calc(infinity * 1px);
  }
  .rounded-lg {
    border-radius: var(--radius-lg);
  }
  .rounded-md {
    border-radius: var(--radius-md);
  }
  .rounded-sm {
    border-radius: var(--radius-sm);
  }
  .rounded-s {
    border-start-start-radius: 0.25rem;
    border-end-start-radius: 0.25rem;
  }
  .rounded-ss {
    border-start-start-radius: 0.25rem;
  }
  .rounded-e {
    border-start-end-radius: 0.25rem;
    border-end-end-radius: 0.25rem;
  }
  .rounded-se {
    border-start-end-radius: 0.25rem;
  }
  .rounded-ee {
    border-end-end-radius: 0.25rem;
  }
  .rounded-es {
    border-end-start-radius: 0.25rem;
  }
  .rounded-t {
    border-top-left-radius: 0.25rem;
    border-top-right-radius: 0.25rem;
  }
  .rounded-l {
    border-top-left-radius: 0.25rem;
    border-bottom-left-radius: 0.25rem;
  }
  .rounded-l-none {
    border-top-left-radius: 0;
    border-bottom-left-radius: 0;
  }
  .rounded-tl {
    border-top-left-radius: 0.25rem;
  }
  .rounded-r {
    border-top-right-radius: 0.25rem;
    border-bottom-right-radius: 0.25rem;
  }
  .rounded-tr {
    border-top-right-radius: 0.25rem;
  }
  .rounded-b {
    border-bottom-right-radius: 0.25rem;
    border-bottom-left-radius: 0.25rem;
  }
  .rounded-br {
    border-bottom-right-radius: 0.25rem;
  }
  .rounded-bl {
    border-bottom-left-radius: 0.25rem;
  }
  .border {
    border-style: var(--tw-border-style);
    border-width: 1px;
  }
  .border-x {
    border-inline-style: var(--tw-border-style);
    border-inline-width: 1px;
  }
  .border-y {
    border-block-style: var(--tw-border-style);
    border-block-width: 1px;
  }
  .border-s {
    border-inline-start-style: var(--tw-border-style);
    border-inline-start-width: 1px;
  }
  .border-e {
    border-inline-end-style: var(--tw-border-style);
    border-inline-end-width: 1px;
  }
  .border-t {
    border-top-style: var(--tw-border-style);
    border-top-width: 1px;
  }
  .border-r {
    border-right-style: var(--tw-border-style);
    border-right-width: 1px;
  }
  .border-b {
    border-bottom-style: var(--tw-border-style);
    border-bottom-width: 1px;
  }
  .border-l {
    border-left-style: var(--tw-border-style);
    border-left-width: 1px;
  }
  .border-none {
    --tw-border-style: none;
    border-style: none;
  }
  .border-solid {
    --tw-border-style: solid;
    border-style: solid;
  }
  .border-blue-500 {
    border-color: var(--color-blue-500);
  }
  .border-destructive\\/20 {
    border-color: var(--destructive);
    @supports (color: color-mix(in lab, red, red)) {
      border-color: color-mix(in oklab, var(--destructive) 20%, transparent);
    }
  }
  .border-input {
    border-color: var(--input);
  }
  .border-input\\/50 {
    border-color: var(--input);
    @supports (color: color-mix(in lab, red, red)) {
      border-color: color-mix(in oklab, var(--input) 50%, transparent);
    }
  }
  .border-transparent {
    border-color: transparent;
  }
  .border-zinc-800 {
    border-color: var(--color-zinc-800);
  }
  .bg-accent {
    background-color: var(--accent);
  }
  .bg-background {
    background-color: var(--background);
  }
  .bg-black {
    background-color: var(--color-black);
  }
  .bg-black\\/50 {
    background-color: color-mix(in srgb, #000 50%, transparent);
    @supports (color: color-mix(in lab, red, red)) {
      background-color: color-mix(in oklab, var(--color-black) 50%, transparent);
    }
  }
  .bg-blue-50 {
    background-color: var(--color-blue-50);
  }
  .bg-blue-500\\/10 {
    background-color: color-mix(in srgb, oklch(62.3% 0.214 259.815) 10%, transparent);
    @supports (color: color-mix(in lab, red, red)) {
      background-color: color-mix(in oklab, var(--color-blue-500) 10%, transparent);
    }
  }
  .bg-border {
    background-color: var(--border);
  }
  .bg-card {
    background-color: var(--card);
  }
  .bg-destructive {
    background-color: var(--destructive);
  }
  .bg-destructive\\/10 {
    background-color: var(--destructive);
    @supports (color: color-mix(in lab, red, red)) {
      background-color: color-mix(in oklab, var(--destructive) 10%, transparent);
    }
  }
  .bg-foreground\\/15 {
    background-color: var(--foreground);
    @supports (color: color-mix(in lab, red, red)) {
      background-color: color-mix(in oklab, var(--foreground) 15%, transparent);
    }
  }
  .bg-gray-100 {
    background-color: var(--color-gray-100);
  }
  .bg-muted {
    background-color: var(--muted);
  }
  .bg-muted\\/20 {
    background-color: var(--muted);
    @supports (color: color-mix(in lab, red, red)) {
      background-color: color-mix(in oklab, var(--muted) 20%, transparent);
    }
  }
  .bg-popover {
    background-color: var(--popover);
  }
  .bg-primary {
    background-color: var(--primary);
  }
  .bg-transparent {
    background-color: transparent;
  }
  .bg-white {
    background-color: var(--color-white);
  }
  .bg-zinc-900 {
    background-color: var(--color-zinc-900);
  }
  .bg-zinc-900\\/50 {
    background-color: color-mix(in srgb, oklch(21% 0.006 285.885) 50%, transparent);
    @supports (color: color-mix(in lab, red, red)) {
      background-color: color-mix(in oklab, var(--color-zinc-900) 50%, transparent);
    }
  }
  .bg-zinc-950 {
    background-color: var(--color-zinc-950);
  }
  .bg-linear-to-b {
    --tw-gradient-position: to bottom;
    @supports (background-image: linear-gradient(in lab, red, red)) {
      --tw-gradient-position: to bottom in oklab;
    }
    background-image: linear-gradient(var(--tw-gradient-stops));
  }
  .bg-linear-to-t {
    --tw-gradient-position: to top;
    @supports (background-image: linear-gradient(in lab, red, red)) {
      --tw-gradient-position: to top in oklab;
    }
    background-image: linear-gradient(var(--tw-gradient-stops));
  }
  .\\[background-image\\:conic-gradient\\(from_0deg\\,transparent_0\\%\\,transparent_30\\%\\,var\\(--color-fgAccent\\)_50\\%\\,transparent_70\\%\\,transparent_100\\%\\)\\] {
    background-image: conic-gradient(from 0deg,transparent 0%,transparent 30%,var(--color-fgAccent) 50%,transparent 70%,transparent 100%);
  }
  .from-background {
    --tw-gradient-from: var(--background);
    --tw-gradient-stops: var(--tw-gradient-via-stops, var(--tw-gradient-position), var(--tw-gradient-from) var(--tw-gradient-from-position), var(--tw-gradient-to) var(--tw-gradient-to-position));
  }
  .to-transparent {
    --tw-gradient-to: transparent;
    --tw-gradient-stops: var(--tw-gradient-via-stops, var(--tw-gradient-position), var(--tw-gradient-from) var(--tw-gradient-from-position), var(--tw-gradient-to) var(--tw-gradient-to-position));
  }
  .\\[mask-image\\:linear-gradient\\(0deg\\,rgba\\(0\\,0\\,0\\,0\\.2\\)_0\\%\\,rgba\\(0\\,0\\,0\\,1\\)_5\\%\\,rgba\\(0\\,0\\,0\\,1\\)_95\\%\\,rgba\\(0\\,0\\,0\\,0\\)_100\\%\\)\\] {
    mask-image: linear-gradient(0deg,rgba(0,0,0,0.2) 0%,rgba(0,0,0,1) 5%,rgba(0,0,0,1) 95%,rgba(0,0,0,0) 100%);
  }
  .\\!bg-clip-text {
    background-clip: text !important;
  }
  .bg-repeat {
    background-repeat: repeat;
  }
  .mask-no-clip {
    mask-clip: no-clip;
  }
  .mask-repeat {
    mask-repeat: repeat;
  }
  .object-cover {
    object-fit: cover;
  }
  .p-0\\.5 {
    padding: calc(var(--spacing) * 0.5);
  }
  .p-1 {
    padding: calc(var(--spacing) * 1);
  }
  .p-2 {
    padding: calc(var(--spacing) * 2);
  }
  .p-3 {
    padding: calc(var(--spacing) * 3);
  }
  .p-4 {
    padding: calc(var(--spacing) * 4);
  }
  .p-6 {
    padding: calc(var(--spacing) * 6);
  }
  .p-8 {
    padding: calc(var(--spacing) * 8);
  }
  .px-1\\.5 {
    padding-inline: calc(var(--spacing) * 1.5);
  }
  .px-2 {
    padding-inline: calc(var(--spacing) * 2);
  }
  .px-3 {
    padding-inline: calc(var(--spacing) * 3);
  }
  .px-4 {
    padding-inline: calc(var(--spacing) * 4);
  }
  .px-6 {
    padding-inline: calc(var(--spacing) * 6);
  }
  .px-8 {
    padding-inline: calc(var(--spacing) * 8);
  }
  .py-1 {
    padding-block: calc(var(--spacing) * 1);
  }
  .py-1\\.5 {
    padding-block: calc(var(--spacing) * 1.5);
  }
  .py-2 {
    padding-block: calc(var(--spacing) * 2);
  }
  .py-3 {
    padding-block: calc(var(--spacing) * 3);
  }
  .pt-1 {
    padding-top: calc(var(--spacing) * 1);
  }
  .pt-16 {
    padding-top: calc(var(--spacing) * 16);
  }
  .pt-40 {
    padding-top: calc(var(--spacing) * 40);
  }
  .pr-1\\.5 {
    padding-right: calc(var(--spacing) * 1.5);
  }
  .pr-3 {
    padding-right: calc(var(--spacing) * 3);
  }
  .pr-8 {
    padding-right: calc(var(--spacing) * 8);
  }
  .pb-3 {
    padding-bottom: calc(var(--spacing) * 3);
  }
  .pb-4 {
    padding-bottom: calc(var(--spacing) * 4);
  }
  .pb-\\[150px\\] {
    padding-bottom: 150px;
  }
  .pl-1 {
    padding-left: calc(var(--spacing) * 1);
  }
  .pl-1\\.5 {
    padding-left: calc(var(--spacing) * 1.5);
  }
  .pl-2 {
    padding-left: calc(var(--spacing) * 2);
  }
  .pl-3 {
    padding-left: calc(var(--spacing) * 3);
  }
  .text-center {
    text-align: center;
  }
  .text-left {
    text-align: left;
  }
  .text-right {
    text-align: right;
  }
  .font-mono {
    font-family: var(--font-commit-mono), ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
    'Liberation Mono', 'Courier New', monospace;
  }
  .font-sans {
    font-family: var(--font-public-sans), ui-sans-serif, system-ui, sans-serif, 'Apple Color Emoji',
    'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';
  }
  .text-2xl {
    font-size: var(--text-2xl);
    line-height: var(--tw-leading, var(--text-2xl--line-height));
  }
  .text-4xl {
    font-size: var(--text-4xl);
    line-height: var(--tw-leading, var(--text-4xl--line-height));
  }
  .text-5xl {
    font-size: var(--text-5xl);
    line-height: var(--tw-leading, var(--text-5xl--line-height));
  }
  .text-lg {
    font-size: var(--text-lg);
    line-height: var(--tw-leading, var(--text-lg--line-height));
  }
  .text-sm {
    font-size: var(--text-sm);
    line-height: var(--tw-leading, var(--text-sm--line-height));
  }
  .text-xl {
    font-size: var(--text-xl);
    line-height: var(--tw-leading, var(--text-xl--line-height));
  }
  .text-xs {
    font-size: var(--text-xs);
    line-height: var(--tw-leading, var(--text-xs--line-height));
  }
  .leading-5 {
    --tw-leading: calc(var(--spacing) * 5);
    line-height: calc(var(--spacing) * 5);
  }
  .leading-6 {
    --tw-leading: calc(var(--spacing) * 6);
    line-height: calc(var(--spacing) * 6);
  }
  .leading-tight {
    --tw-leading: var(--leading-tight);
    line-height: var(--leading-tight);
  }
  .font-bold {
    --tw-font-weight: var(--font-weight-bold);
    font-weight: var(--font-weight-bold);
  }
  .font-extralight {
    --tw-font-weight: var(--font-weight-extralight);
    font-weight: var(--font-weight-extralight);
  }
  .font-medium {
    --tw-font-weight: var(--font-weight-medium);
    font-weight: var(--font-weight-medium);
  }
  .font-normal {
    --tw-font-weight: var(--font-weight-normal);
    font-weight: var(--font-weight-normal);
  }
  .font-semibold {
    --tw-font-weight: var(--font-weight-semibold);
    font-weight: var(--font-weight-semibold);
  }
  .tracking-tight {
    --tw-tracking: var(--tracking-tight);
    letter-spacing: var(--tracking-tight);
  }
  .tracking-wider {
    --tw-tracking: var(--tracking-wider);
    letter-spacing: var(--tracking-wider);
  }
  .text-balance {
    text-wrap: balance;
  }
  .text-pretty {
    text-wrap: pretty;
  }
  .text-wrap {
    text-wrap: wrap;
  }
  .text-clip {
    text-overflow: clip;
  }
  .text-ellipsis {
    text-overflow: ellipsis;
  }
  .whitespace-nowrap {
    white-space: nowrap;
  }
  .text-blue-50 {
    color: var(--color-blue-50);
  }
  .text-blue-100 {
    color: var(--color-blue-100);
  }
  .text-blue-400 {
    color: var(--color-blue-400);
  }
  .text-blue-800 {
    color: var(--color-blue-800);
  }
  .text-blue-900 {
    color: var(--color-blue-900);
  }
  .text-card-foreground {
    color: var(--card-foreground);
  }
  .text-destructive {
    color: var(--destructive);
  }
  .text-foreground {
    color: var(--foreground);
  }
  .text-gray-700 {
    color: var(--color-gray-700);
  }
  .text-muted-foreground {
    color: var(--muted-foreground);
  }
  .text-popover-foreground {
    color: var(--popover-foreground);
  }
  .text-primary {
    color: var(--primary);
  }
  .text-primary-foreground {
    color: var(--primary-foreground);
  }
  .text-secondary-foreground {
    color: var(--secondary-foreground);
  }
  .text-transparent {
    color: transparent;
  }
  .text-zinc-50 {
    color: var(--color-zinc-50);
  }
  .text-zinc-300 {
    color: var(--color-zinc-300);
  }
  .text-zinc-400 {
    color: var(--color-zinc-400);
  }
  .text-zinc-500 {
    color: var(--color-zinc-500);
  }
  .text-zinc-600 {
    color: var(--color-zinc-600);
  }
  .capitalize {
    text-transform: capitalize;
  }
  .lowercase {
    text-transform: lowercase;
  }
  .normal-case {
    text-transform: none;
  }
  .uppercase {
    text-transform: uppercase;
  }
  .italic {
    font-style: italic;
  }
  .not-italic {
    font-style: normal;
  }
  .diagonal-fractions {
    --tw-numeric-fraction: diagonal-fractions;
    font-variant-numeric: var(--tw-ordinal,) var(--tw-slashed-zero,) var(--tw-numeric-figure,) var(--tw-numeric-spacing,) var(--tw-numeric-fraction,);
  }
  .lining-nums {
    --tw-numeric-figure: lining-nums;
    font-variant-numeric: var(--tw-ordinal,) var(--tw-slashed-zero,) var(--tw-numeric-figure,) var(--tw-numeric-spacing,) var(--tw-numeric-fraction,);
  }
  .oldstyle-nums {
    --tw-numeric-figure: oldstyle-nums;
    font-variant-numeric: var(--tw-ordinal,) var(--tw-slashed-zero,) var(--tw-numeric-figure,) var(--tw-numeric-spacing,) var(--tw-numeric-fraction,);
  }
  .ordinal {
    --tw-ordinal: ordinal;
    font-variant-numeric: var(--tw-ordinal,) var(--tw-slashed-zero,) var(--tw-numeric-figure,) var(--tw-numeric-spacing,) var(--tw-numeric-fraction,);
  }
  .proportional-nums {
    --tw-numeric-spacing: proportional-nums;
    font-variant-numeric: var(--tw-ordinal,) var(--tw-slashed-zero,) var(--tw-numeric-figure,) var(--tw-numeric-spacing,) var(--tw-numeric-fraction,);
  }
  .slashed-zero {
    --tw-slashed-zero: slashed-zero;
    font-variant-numeric: var(--tw-ordinal,) var(--tw-slashed-zero,) var(--tw-numeric-figure,) var(--tw-numeric-spacing,) var(--tw-numeric-fraction,);
  }
  .stacked-fractions {
    --tw-numeric-fraction: stacked-fractions;
    font-variant-numeric: var(--tw-ordinal,) var(--tw-slashed-zero,) var(--tw-numeric-figure,) var(--tw-numeric-spacing,) var(--tw-numeric-fraction,);
  }
  .tabular-nums {
    --tw-numeric-spacing: tabular-nums;
    font-variant-numeric: var(--tw-ordinal,) var(--tw-slashed-zero,) var(--tw-numeric-figure,) var(--tw-numeric-spacing,) var(--tw-numeric-fraction,);
  }
  .normal-nums {
    font-variant-numeric: normal;
  }
  .line-through {
    text-decoration-line: line-through;
  }
  .no-underline {
    text-decoration-line: none;
  }
  .overline {
    text-decoration-line: overline;
  }
  .underline {
    text-decoration-line: underline;
  }
  .underline-offset-2 {
    text-underline-offset: 2px;
  }
  .underline-offset-4 {
    text-underline-offset: 4px;
  }
  .antialiased {
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }
  .subpixel-antialiased {
    -webkit-font-smoothing: auto;
    -moz-osx-font-smoothing: auto;
  }
  .opacity-0 {
    opacity: 0%;
  }
  .opacity-25 {
    opacity: 25%;
  }
  .opacity-100 {
    opacity: 100%;
  }
  .shadow {
    --tw-shadow: 0 1px 3px 0 var(--tw-shadow-color, rgb(0 0 0 / 0.1)), 0 1px 2px -1px var(--tw-shadow-color, rgb(0 0 0 / 0.1));
    box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);
  }
  .shadow-xs {
    --tw-shadow: 0 1px 2px 0 var(--tw-shadow-color, rgb(0 0 0 / 0.05));
    box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);
  }
  .ring {
    --tw-ring-shadow: var(--tw-ring-inset,) 0 0 0 calc(1px + var(--tw-ring-offset-width)) var(--tw-ring-color, currentcolor);
    box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);
  }
  .inset-ring {
    --tw-inset-ring-shadow: inset 0 0 0 1px var(--tw-inset-ring-color, currentcolor);
    box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);
  }
  .outline-hidden {
    --tw-outline-style: none;
    outline-style: none;
    @media (forced-colors: active) {
      outline: 2px solid transparent;
      outline-offset: 2px;
    }
  }
  .outline {
    outline-style: var(--tw-outline-style);
    outline-width: 1px;
  }
  .blur {
    --tw-blur: blur(8px);
    filter: var(--tw-blur,) var(--tw-brightness,) var(--tw-contrast,) var(--tw-grayscale,) var(--tw-hue-rotate,) var(--tw-invert,) var(--tw-saturate,) var(--tw-sepia,) var(--tw-drop-shadow,);
  }
  .drop-shadow-lg\\/5 {
    --tw-drop-shadow-alpha: 5%;
    --tw-drop-shadow-size: drop-shadow(0 4px 4px var(--tw-drop-shadow-color, oklab(from rgb(0 0 0 / 0.15) l a b / 5%)));
    --tw-drop-shadow: var(--tw-drop-shadow-size);
    filter: var(--tw-blur,) var(--tw-brightness,) var(--tw-contrast,) var(--tw-grayscale,) var(--tw-hue-rotate,) var(--tw-invert,) var(--tw-saturate,) var(--tw-sepia,) var(--tw-drop-shadow,);
  }
  .drop-shadow-lg\\/10 {
    --tw-drop-shadow-alpha: 10%;
    --tw-drop-shadow-size: drop-shadow(0 4px 4px var(--tw-drop-shadow-color, oklab(from rgb(0 0 0 / 0.15) l a b / 10%)));
    --tw-drop-shadow: var(--tw-drop-shadow-size);
    filter: var(--tw-blur,) var(--tw-brightness,) var(--tw-contrast,) var(--tw-grayscale,) var(--tw-hue-rotate,) var(--tw-invert,) var(--tw-saturate,) var(--tw-sepia,) var(--tw-drop-shadow,);
  }
  .drop-shadow-lg\\/20 {
    --tw-drop-shadow-alpha: 20%;
    --tw-drop-shadow-size: drop-shadow(0 4px 4px var(--tw-drop-shadow-color, oklab(from rgb(0 0 0 / 0.15) l a b / 20%)));
    --tw-drop-shadow: var(--tw-drop-shadow-size);
    filter: var(--tw-blur,) var(--tw-brightness,) var(--tw-contrast,) var(--tw-grayscale,) var(--tw-hue-rotate,) var(--tw-invert,) var(--tw-saturate,) var(--tw-sepia,) var(--tw-drop-shadow,);
  }
  .drop-shadow-md\\/3 {
    --tw-drop-shadow-alpha: 3%;
    --tw-drop-shadow-size: drop-shadow(0 3px 3px var(--tw-drop-shadow-color, oklab(from rgb(0 0 0 / 0.12) l a b / 3%)));
    --tw-drop-shadow: var(--tw-drop-shadow-size);
    filter: var(--tw-blur,) var(--tw-brightness,) var(--tw-contrast,) var(--tw-grayscale,) var(--tw-hue-rotate,) var(--tw-invert,) var(--tw-saturate,) var(--tw-sepia,) var(--tw-drop-shadow,);
  }
  .drop-shadow-xl\\/5 {
    --tw-drop-shadow-alpha: 5%;
    --tw-drop-shadow-size: drop-shadow(0 9px 7px var(--tw-drop-shadow-color, oklab(from rgb(0 0 0 / 0.1) l a b / 5%)));
    --tw-drop-shadow: var(--tw-drop-shadow-size);
    filter: var(--tw-blur,) var(--tw-brightness,) var(--tw-contrast,) var(--tw-grayscale,) var(--tw-hue-rotate,) var(--tw-invert,) var(--tw-saturate,) var(--tw-sepia,) var(--tw-drop-shadow,);
  }
  .drop-shadow-xl\\/80 {
    --tw-drop-shadow-alpha: 80%;
    --tw-drop-shadow-size: drop-shadow(0 9px 7px var(--tw-drop-shadow-color, oklab(from rgb(0 0 0 / 0.1) l a b / 80%)));
    --tw-drop-shadow: var(--tw-drop-shadow-size);
    filter: var(--tw-blur,) var(--tw-brightness,) var(--tw-contrast,) var(--tw-grayscale,) var(--tw-hue-rotate,) var(--tw-invert,) var(--tw-saturate,) var(--tw-sepia,) var(--tw-drop-shadow,);
  }
  .drop-shadow {
    --tw-drop-shadow-size: drop-shadow(0 1px 2px var(--tw-drop-shadow-color, rgb(0 0 0 / 0.1))) drop-shadow(0 1px 1px var(--tw-drop-shadow-color, rgb(0 0 0 / 0.06)));
    --tw-drop-shadow: drop-shadow(0 1px 2px rgb(0 0 0 / 0.1)) drop-shadow( 0 1px 1px rgb(0 0 0 / 0.06));
    filter: var(--tw-blur,) var(--tw-brightness,) var(--tw-contrast,) var(--tw-grayscale,) var(--tw-hue-rotate,) var(--tw-invert,) var(--tw-saturate,) var(--tw-sepia,) var(--tw-drop-shadow,);
  }
  .drop-shadow-2xl {
    --tw-drop-shadow-size: drop-shadow(0 25px 25px var(--tw-drop-shadow-color, rgb(0 0 0 / 0.15)));
    --tw-drop-shadow: drop-shadow(var(--drop-shadow-2xl));
    filter: var(--tw-blur,) var(--tw-brightness,) var(--tw-contrast,) var(--tw-grayscale,) var(--tw-hue-rotate,) var(--tw-invert,) var(--tw-saturate,) var(--tw-sepia,) var(--tw-drop-shadow,);
  }
  .drop-shadow-md {
    --tw-drop-shadow-size: drop-shadow(0 3px 3px var(--tw-drop-shadow-color, rgb(0 0 0 / 0.12)));
    --tw-drop-shadow: drop-shadow(var(--drop-shadow-md));
    filter: var(--tw-blur,) var(--tw-brightness,) var(--tw-contrast,) var(--tw-grayscale,) var(--tw-hue-rotate,) var(--tw-invert,) var(--tw-saturate,) var(--tw-sepia,) var(--tw-drop-shadow,);
  }
  .grayscale {
    --tw-grayscale: grayscale(100%);
    filter: var(--tw-blur,) var(--tw-brightness,) var(--tw-contrast,) var(--tw-grayscale,) var(--tw-hue-rotate,) var(--tw-invert,) var(--tw-saturate,) var(--tw-sepia,) var(--tw-drop-shadow,);
  }
  .invert {
    --tw-invert: invert(100%);
    filter: var(--tw-blur,) var(--tw-brightness,) var(--tw-contrast,) var(--tw-grayscale,) var(--tw-hue-rotate,) var(--tw-invert,) var(--tw-saturate,) var(--tw-sepia,) var(--tw-drop-shadow,);
  }
  .sepia {
    --tw-sepia: sepia(100%);
    filter: var(--tw-blur,) var(--tw-brightness,) var(--tw-contrast,) var(--tw-grayscale,) var(--tw-hue-rotate,) var(--tw-invert,) var(--tw-saturate,) var(--tw-sepia,) var(--tw-drop-shadow,);
  }
  .filter {
    filter: var(--tw-blur,) var(--tw-brightness,) var(--tw-contrast,) var(--tw-grayscale,) var(--tw-hue-rotate,) var(--tw-invert,) var(--tw-saturate,) var(--tw-sepia,) var(--tw-drop-shadow,);
  }
  .backdrop-blur {
    --tw-backdrop-blur: blur(8px);
    -webkit-backdrop-filter: var(--tw-backdrop-blur,) var(--tw-backdrop-brightness,) var(--tw-backdrop-contrast,) var(--tw-backdrop-grayscale,) var(--tw-backdrop-hue-rotate,) var(--tw-backdrop-invert,) var(--tw-backdrop-opacity,) var(--tw-backdrop-saturate,) var(--tw-backdrop-sepia,);
    backdrop-filter: var(--tw-backdrop-blur,) var(--tw-backdrop-brightness,) var(--tw-backdrop-contrast,) var(--tw-backdrop-grayscale,) var(--tw-backdrop-hue-rotate,) var(--tw-backdrop-invert,) var(--tw-backdrop-opacity,) var(--tw-backdrop-saturate,) var(--tw-backdrop-sepia,);
  }
  .backdrop-grayscale {
    --tw-backdrop-grayscale: grayscale(100%);
    -webkit-backdrop-filter: var(--tw-backdrop-blur,) var(--tw-backdrop-brightness,) var(--tw-backdrop-contrast,) var(--tw-backdrop-grayscale,) var(--tw-backdrop-hue-rotate,) var(--tw-backdrop-invert,) var(--tw-backdrop-opacity,) var(--tw-backdrop-saturate,) var(--tw-backdrop-sepia,);
    backdrop-filter: var(--tw-backdrop-blur,) var(--tw-backdrop-brightness,) var(--tw-backdrop-contrast,) var(--tw-backdrop-grayscale,) var(--tw-backdrop-hue-rotate,) var(--tw-backdrop-invert,) var(--tw-backdrop-opacity,) var(--tw-backdrop-saturate,) var(--tw-backdrop-sepia,);
  }
  .backdrop-invert {
    --tw-backdrop-invert: invert(100%);
    -webkit-backdrop-filter: var(--tw-backdrop-blur,) var(--tw-backdrop-brightness,) var(--tw-backdrop-contrast,) var(--tw-backdrop-grayscale,) var(--tw-backdrop-hue-rotate,) var(--tw-backdrop-invert,) var(--tw-backdrop-opacity,) var(--tw-backdrop-saturate,) var(--tw-backdrop-sepia,);
    backdrop-filter: var(--tw-backdrop-blur,) var(--tw-backdrop-brightness,) var(--tw-backdrop-contrast,) var(--tw-backdrop-grayscale,) var(--tw-backdrop-hue-rotate,) var(--tw-backdrop-invert,) var(--tw-backdrop-opacity,) var(--tw-backdrop-saturate,) var(--tw-backdrop-sepia,);
  }
  .backdrop-sepia {
    --tw-backdrop-sepia: sepia(100%);
    -webkit-backdrop-filter: var(--tw-backdrop-blur,) var(--tw-backdrop-brightness,) var(--tw-backdrop-contrast,) var(--tw-backdrop-grayscale,) var(--tw-backdrop-hue-rotate,) var(--tw-backdrop-invert,) var(--tw-backdrop-opacity,) var(--tw-backdrop-saturate,) var(--tw-backdrop-sepia,);
    backdrop-filter: var(--tw-backdrop-blur,) var(--tw-backdrop-brightness,) var(--tw-backdrop-contrast,) var(--tw-backdrop-grayscale,) var(--tw-backdrop-hue-rotate,) var(--tw-backdrop-invert,) var(--tw-backdrop-opacity,) var(--tw-backdrop-saturate,) var(--tw-backdrop-sepia,);
  }
  .backdrop-filter {
    -webkit-backdrop-filter: var(--tw-backdrop-blur,) var(--tw-backdrop-brightness,) var(--tw-backdrop-contrast,) var(--tw-backdrop-grayscale,) var(--tw-backdrop-hue-rotate,) var(--tw-backdrop-invert,) var(--tw-backdrop-opacity,) var(--tw-backdrop-saturate,) var(--tw-backdrop-sepia,);
    backdrop-filter: var(--tw-backdrop-blur,) var(--tw-backdrop-brightness,) var(--tw-backdrop-contrast,) var(--tw-backdrop-grayscale,) var(--tw-backdrop-hue-rotate,) var(--tw-backdrop-invert,) var(--tw-backdrop-opacity,) var(--tw-backdrop-saturate,) var(--tw-backdrop-sepia,);
  }
  .transition {
    transition-property: color, background-color, border-color, outline-color, text-decoration-color, fill, stroke, --tw-gradient-from, --tw-gradient-via, --tw-gradient-to, opacity, box-shadow, transform, translate, scale, rotate, filter, -webkit-backdrop-filter, backdrop-filter, display, content-visibility, overlay, pointer-events;
    transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));
    transition-duration: var(--tw-duration, var(--default-transition-duration));
  }
  .transition-\\[border\\,drop-shadow\\] {
    transition-property: border,drop-shadow;
    transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));
    transition-duration: var(--tw-duration, var(--default-transition-duration));
  }
  .transition-\\[color\\,border\\,background-color\\] {
    transition-property: color,border,background-color;
    transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));
    transition-duration: var(--tw-duration, var(--default-transition-duration));
  }
  .transition-\\[color\\,box-shadow\\,background-color\\] {
    transition-property: color,box-shadow,background-color;
    transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));
    transition-duration: var(--tw-duration, var(--default-transition-duration));
  }
  .transition-\\[height\\] {
    transition-property: height;
    transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));
    transition-duration: var(--tw-duration, var(--default-transition-duration));
  }
  .transition-\\[scale\\] {
    transition-property: scale;
    transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));
    transition-duration: var(--tw-duration, var(--default-transition-duration));
  }
  .transition-all {
    transition-property: all;
    transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));
    transition-duration: var(--tw-duration, var(--default-transition-duration));
  }
  .transition-colors {
    transition-property: color, background-color, border-color, outline-color, text-decoration-color, fill, stroke, --tw-gradient-from, --tw-gradient-via, --tw-gradient-to;
    transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));
    transition-duration: var(--tw-duration, var(--default-transition-duration));
  }
  .transition-opacity {
    transition-property: opacity;
    transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));
    transition-duration: var(--tw-duration, var(--default-transition-duration));
  }
  .transition-transform {
    transition-property: transform, translate, scale, rotate;
    transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));
    transition-duration: var(--tw-duration, var(--default-transition-duration));
  }
  .delay-150 {
    transition-delay: 150ms;
  }
  .delay-200 {
    transition-delay: 200ms;
  }
  .duration-150 {
    --tw-duration: 150ms;
    transition-duration: 150ms;
  }
  .duration-200 {
    --tw-duration: 200ms;
    transition-duration: 200ms;
  }
  .duration-250 {
    --tw-duration: 250ms;
    transition-duration: 250ms;
  }
  .duration-300 {
    --tw-duration: 300ms;
    transition-duration: 300ms;
  }
  .ease-in {
    --tw-ease: var(--ease-in);
    transition-timing-function: var(--ease-in);
  }
  .ease-in-out {
    --tw-ease: var(--ease-in-out);
    transition-timing-function: var(--ease-in-out);
  }
  .ease-linear {
    --tw-ease: linear;
    transition-timing-function: linear;
  }
  .ease-out {
    --tw-ease: var(--ease-out);
    transition-timing-function: var(--ease-out);
  }
  .delay-150 {
    animation-delay: calc(150*1ms);
    animation-delay: .15s;
    --tw-animation-delay: calc(150*1ms);
    --tw-animation-delay: .15s;
  }
  .delay-200 {
    animation-delay: calc(200*1ms);
    animation-delay: .2s;
    --tw-animation-delay: calc(200*1ms);
    --tw-animation-delay: .2s;
  }
  .outline-none {
    --tw-outline-style: none;
    outline-style: none;
  }
  .select-none {
    -webkit-user-select: none;
    user-select: none;
  }
  .divide-x-reverse {
    :where(& > :not(:last-child)) {
      --tw-divide-x-reverse: 1;
    }
  }
  .paused {
    animation-play-state: paused;
  }
  .ring-inset {
    --tw-ring-inset: inset;
  }
  .running {
    animation-play-state: running;
  }
  .zoom-in {
    --tw-enter-scale: 0;
  }
  .zoom-out {
    --tw-exit-scale: 0;
  }
  .group-hover\\:translate-x-1 {
    &:is(:where(.group):hover *) {
      @media (hover: hover) {
        --tw-translate-x: calc(var(--spacing) * 1);
        translate: var(--tw-translate-x) var(--tw-translate-y);
      }
    }
  }
  .group-hover\\:translate-y-0 {
    &:is(:where(.group):hover *) {
      @media (hover: hover) {
        --tw-translate-y: calc(var(--spacing) * 0);
        translate: var(--tw-translate-x) var(--tw-translate-y);
      }
    }
  }
  .group-hover\\:opacity-100 {
    &:is(:where(.group):hover *) {
      @media (hover: hover) {
        opacity: 100%;
      }
    }
  }
  .group-data-\\[state\\=off\\]\\/track\\:bg-destructive {
    &:is(:where(.group\\/track)[data-state="off"] *) {
      background-color: var(--destructive);
    }
  }
  .group-data-\\[state\\=on\\]\\/track\\:bg-foreground {
    &:is(:where(.group\\/track)[data-state="on"] *) {
      background-color: var(--foreground);
    }
  }
  .peer-data-\\[state\\=off\\]\\/track\\:bg-destructive\\/20 {
    &:is(:where(.peer\\/track)[data-state="off"] ~ *) {
      background-color: var(--destructive);
      @supports (color: color-mix(in lab, red, red)) {
        background-color: color-mix(in oklab, var(--destructive) 20%, transparent);
      }
    }
  }
  .peer-data-\\[state\\=off\\]\\/track\\:text-destructive {
    &:is(:where(.peer\\/track)[data-state="off"] ~ *) {
      color: var(--destructive);
    }
  }
  .hover\\:scale-105 {
    &:hover {
      @media (hover: hover) {
        --tw-scale-x: 105%;
        --tw-scale-y: 105%;
        --tw-scale-z: 105%;
        scale: var(--tw-scale-x) var(--tw-scale-y);
      }
    }
  }
  .hover\\:scale-110 {
    &:hover {
      @media (hover: hover) {
        --tw-scale-x: 110%;
        --tw-scale-y: 110%;
        --tw-scale-z: 110%;
        scale: var(--tw-scale-x) var(--tw-scale-y);
      }
    }
  }
  .hover\\:border-zinc-700 {
    &:hover {
      @media (hover: hover) {
        border-color: var(--color-zinc-700);
      }
    }
  }
  .hover\\:bg-accent {
    &:hover {
      @media (hover: hover) {
        background-color: var(--accent);
      }
    }
  }
  .hover\\:bg-destructive\\/20 {
    &:hover {
      @media (hover: hover) {
        background-color: var(--destructive);
        @supports (color: color-mix(in lab, red, red)) {
          background-color: color-mix(in oklab, var(--destructive) 20%, transparent);
        }
      }
    }
  }
  .hover\\:bg-foreground\\/10 {
    &:hover {
      @media (hover: hover) {
        background-color: var(--foreground);
        @supports (color: color-mix(in lab, red, red)) {
          background-color: color-mix(in oklab, var(--foreground) 10%, transparent);
        }
      }
    }
  }
  .hover\\:bg-foreground\\/20 {
    &:hover {
      @media (hover: hover) {
        background-color: var(--foreground);
        @supports (color: color-mix(in lab, red, red)) {
          background-color: color-mix(in oklab, var(--foreground) 20%, transparent);
        }
      }
    }
  }
  .hover\\:bg-muted {
    &:hover {
      @media (hover: hover) {
        background-color: var(--muted);
      }
    }
  }
  .hover\\:bg-primary\\/70 {
    &:hover {
      @media (hover: hover) {
        background-color: var(--primary);
        @supports (color: color-mix(in lab, red, red)) {
          background-color: color-mix(in oklab, var(--primary) 70%, transparent);
        }
      }
    }
  }
  .hover\\:bg-zinc-800 {
    &:hover {
      @media (hover: hover) {
        background-color: var(--color-zinc-800);
      }
    }
  }
  .hover\\:bg-zinc-900 {
    &:hover {
      @media (hover: hover) {
        background-color: var(--color-zinc-900);
      }
    }
  }
  .hover\\:text-accent-foreground {
    &:hover {
      @media (hover: hover) {
        color: var(--accent-foreground);
      }
    }
  }
  .hover\\:text-foreground {
    &:hover {
      @media (hover: hover) {
        color: var(--foreground);
      }
    }
  }
  .hover\\:text-muted-foreground {
    &:hover {
      @media (hover: hover) {
        color: var(--muted-foreground);
      }
    }
  }
  .hover\\:text-zinc-200 {
    &:hover {
      @media (hover: hover) {
        color: var(--color-zinc-200);
      }
    }
  }
  .hover\\:underline {
    &:hover {
      @media (hover: hover) {
        text-decoration-line: underline;
      }
    }
  }
  .hover\\:peer-data-\\[state\\=off\\]\\/track\\:text-foreground {
    &:hover {
      @media (hover: hover) {
        &:is(:where(.peer\\/track)[data-state="off"] ~ *) {
          color: var(--foreground);
        }
      }
    }
  }
  .focus\\:scale-105 {
    &:focus {
      --tw-scale-x: 105%;
      --tw-scale-y: 105%;
      --tw-scale-z: 105%;
      scale: var(--tw-scale-x) var(--tw-scale-y);
    }
  }
  .focus\\:bg-accent {
    &:focus {
      background-color: var(--accent);
    }
  }
  .focus\\:bg-destructive\\/20 {
    &:focus {
      background-color: var(--destructive);
      @supports (color: color-mix(in lab, red, red)) {
        background-color: color-mix(in oklab, var(--destructive) 20%, transparent);
      }
    }
  }
  .focus\\:bg-foreground\\/10 {
    &:focus {
      background-color: var(--foreground);
      @supports (color: color-mix(in lab, red, red)) {
        background-color: color-mix(in oklab, var(--foreground) 10%, transparent);
      }
    }
  }
  .focus\\:bg-muted {
    &:focus {
      background-color: var(--muted);
    }
  }
  .focus\\:bg-primary\\/70 {
    &:focus {
      background-color: var(--primary);
      @supports (color: color-mix(in lab, red, red)) {
        background-color: color-mix(in oklab, var(--primary) 70%, transparent);
      }
    }
  }
  .focus\\:text-accent-foreground {
    &:focus {
      color: var(--accent-foreground);
    }
  }
  .focus\\:text-foreground {
    &:focus {
      color: var(--foreground);
    }
  }
  .focus\\:outline-none {
    &:focus {
      --tw-outline-style: none;
      outline-style: none;
    }
  }
  .focus\\:peer-data-\\[state\\=off\\]\\/track\\:text-destructive {
    &:focus {
      &:is(:where(.peer\\/track)[data-state="off"] ~ *) {
        color: var(--destructive);
      }
    }
  }
  .focus-visible\\:border-ring {
    &:focus-visible {
      border-color: var(--ring);
    }
  }
  .focus-visible\\:ring-\\[3px\\] {
    &:focus-visible {
      --tw-ring-shadow: var(--tw-ring-inset,) 0 0 0 calc(3px + var(--tw-ring-offset-width)) var(--tw-ring-color, currentcolor);
      box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);
    }
  }
  .focus-visible\\:ring-destructive\\/20 {
    &:focus-visible {
      --tw-ring-color: var(--destructive);
      @supports (color: color-mix(in lab, red, red)) {
        --tw-ring-color: color-mix(in oklab, var(--destructive) 20%, transparent);
      }
    }
  }
  .focus-visible\\:ring-ring\\/50 {
    &:focus-visible {
      --tw-ring-color: var(--ring);
      @supports (color: color-mix(in lab, red, red)) {
        --tw-ring-color: color-mix(in oklab, var(--ring) 50%, transparent);
      }
    }
  }
  .disabled\\:pointer-events-none {
    &:disabled {
      pointer-events: none;
    }
  }
  .disabled\\:cursor-not-allowed {
    &:disabled {
      cursor: not-allowed;
    }
  }
  .disabled\\:opacity-50 {
    &:disabled {
      opacity: 50%;
    }
  }
  .disabled\\:opacity-100 {
    &:disabled {
      opacity: 100%;
    }
  }
  .has-\\[\\.audiovisualizer\\]\\:w-auto {
    &:has(*:is(.audiovisualizer)) {
      width: auto;
    }
  }
  .has-\\[\\+_\\*\\]\\:rounded-r-none {
    &:has(+ *) {
      border-top-right-radius: 0;
      border-bottom-right-radius: 0;
    }
  }
  .has-\\[\\+_\\*\\]\\:border-r-0 {
    &:has(+ *) {
      border-right-style: var(--tw-border-style);
      border-right-width: 0px;
    }
  }
  .has-\\[\\+_\\*\\]\\:pr-2 {
    &:has(+ *) {
      padding-right: calc(var(--spacing) * 2);
    }
  }
  .has-\\[\\>svg\\]\\:grid-cols-\\[calc\\(var\\(--spacing\\)\\*4\\)_1fr\\] {
    &:has(>svg) {
      grid-template-columns: calc(var(--spacing) * 4) 1fr;
    }
  }
  .has-\\[\\>svg\\]\\:gap-x-3 {
    &:has(>svg) {
      column-gap: calc(var(--spacing) * 3);
    }
  }
  .has-\\[\\>svg\\]\\:px-2\\.5 {
    &:has(>svg) {
      padding-inline: calc(var(--spacing) * 2.5);
    }
  }
  .has-\\[\\>svg\\]\\:px-3 {
    &:has(>svg) {
      padding-inline: calc(var(--spacing) * 3);
    }
  }
  .has-\\[\\>svg\\]\\:px-4 {
    &:has(>svg) {
      padding-inline: calc(var(--spacing) * 4);
    }
  }
  .has-\\[\\~_button\\]\\:block {
    &:has(~ button) {
      display: block;
    }
  }
  .has-\\[\\~_button\\]\\:rounded-r-none {
    &:has(~ button) {
      border-top-right-radius: 0;
      border-bottom-right-radius: 0;
    }
  }
  .has-\\[\\~_button\\]\\:pr-2 {
    &:has(~ button) {
      padding-right: calc(var(--spacing) * 2);
    }
  }
  .has-\\[\\~_button\\]\\:pl-3 {
    &:has(~ button) {
      padding-left: calc(var(--spacing) * 3);
    }
  }
  .aria-invalid\\:border-destructive {
    &[aria-invalid="true"] {
      border-color: var(--destructive);
    }
  }
  .aria-invalid\\:ring-destructive\\/20 {
    &[aria-invalid="true"] {
      --tw-ring-color: var(--destructive);
      @supports (color: color-mix(in lab, red, red)) {
        --tw-ring-color: color-mix(in oklab, var(--destructive) 20%, transparent);
      }
    }
  }
  .data-lk-muted\\:bg-muted {
    &[data-lk-muted] {
      background-color: var(--muted);
    }
  }
  .data-\\[disabled\\]\\:pointer-events-none {
    &[data-disabled] {
      pointer-events: none;
    }
  }
  .data-\\[disabled\\]\\:opacity-50 {
    &[data-disabled] {
      opacity: 50%;
    }
  }
  .data-\\[lk-highlighted\\=true\\]\\:bg-foreground {
    &[data-lk-highlighted="true"] {
      background-color: var(--foreground);
    }
  }
  .data-\\[lk-muted\\=true\\]\\:bg-muted {
    &[data-lk-muted="true"] {
      background-color: var(--muted);
    }
  }
  .data-\\[placeholder\\]\\:text-muted-foreground {
    &[data-placeholder] {
      color: var(--muted-foreground);
    }
  }
  .data-\\[side\\=bottom\\]\\:translate-y-1 {
    &[data-side="bottom"] {
      --tw-translate-y: calc(var(--spacing) * 1);
      translate: var(--tw-translate-x) var(--tw-translate-y);
    }
  }
  .data-\\[side\\=bottom\\]\\:slide-in-from-top-2 {
    &[data-side="bottom"] {
      --tw-enter-translate-y: calc(var(--spacing) * 2*-1);
    }
  }
  .data-\\[side\\=left\\]\\:-translate-x-1 {
    &[data-side="left"] {
      --tw-translate-x: calc(var(--spacing) * -1);
      translate: var(--tw-translate-x) var(--tw-translate-y);
    }
  }
  .data-\\[side\\=left\\]\\:slide-in-from-right-2 {
    &[data-side="left"] {
      --tw-enter-translate-x: calc(var(--spacing) * 2);
    }
  }
  .data-\\[side\\=right\\]\\:translate-x-1 {
    &[data-side="right"] {
      --tw-translate-x: calc(var(--spacing) * 1);
      translate: var(--tw-translate-x) var(--tw-translate-y);
    }
  }
  .data-\\[side\\=right\\]\\:slide-in-from-left-2 {
    &[data-side="right"] {
      --tw-enter-translate-x: calc(var(--spacing) * 2*-1);
    }
  }
  .data-\\[side\\=top\\]\\:-translate-y-1 {
    &[data-side="top"] {
      --tw-translate-y: calc(var(--spacing) * -1);
      translate: var(--tw-translate-x) var(--tw-translate-y);
    }
  }
  .data-\\[side\\=top\\]\\:slide-in-from-bottom-2 {
    &[data-side="top"] {
      --tw-enter-translate-y: calc(var(--spacing) * 2);
    }
  }
  .data-\\[size\\=default\\]\\:h-9 {
    &[data-size="default"] {
      height: calc(var(--spacing) * 9);
    }
  }
  .data-\\[size\\=sm\\]\\:h-8 {
    &[data-size="sm"] {
      height: calc(var(--spacing) * 8);
    }
  }
  .\\*\\:data-\\[slot\\=alert-description\\]\\:text-destructive\\/90 {
    :is(& > *) {
      &[data-slot="alert-description"] {
        color: var(--destructive);
        @supports (color: color-mix(in lab, red, red)) {
          color: color-mix(in oklab, var(--destructive) 90%, transparent);
        }
      }
    }
  }
  .\\*\\:data-\\[slot\\=select-value\\]\\:line-clamp-1 {
    :is(& > *) {
      &[data-slot="select-value"] {
        overflow: hidden;
        display: -webkit-box;
        -webkit-box-orient: vertical;
        -webkit-line-clamp: 1;
      }
    }
  }
  .\\*\\:data-\\[slot\\=select-value\\]\\:flex {
    :is(& > *) {
      &[data-slot="select-value"] {
        display: flex;
      }
    }
  }
  .\\*\\:data-\\[slot\\=select-value\\]\\:items-center {
    :is(& > *) {
      &[data-slot="select-value"] {
        align-items: center;
      }
    }
  }
  .\\*\\:data-\\[slot\\=select-value\\]\\:gap-2 {
    :is(& > *) {
      &[data-slot="select-value"] {
        gap: calc(var(--spacing) * 2);
      }
    }
  }
  .data-\\[state\\=closed\\]\\:animate-out {
    &[data-state="closed"] {
      animation: exit var(--tw-animation-duration,var(--tw-duration,.15s))var(--tw-ease,ease)var(--tw-animation-delay,0s)var(--tw-animation-iteration-count,1)var(--tw-animation-direction,normal)var(--tw-animation-fill-mode,none);
    }
  }
  .data-\\[state\\=closed\\]\\:fade-out-0 {
    &[data-state="closed"] {
      --tw-exit-opacity: calc(0/100);
      --tw-exit-opacity: 0;
    }
  }
  .data-\\[state\\=closed\\]\\:zoom-out-95 {
    &[data-state="closed"] {
      --tw-exit-scale: calc(95*1%);
      --tw-exit-scale: .95;
    }
  }
  .data-\\[state\\=on\\]\\:bg-accent {
    &[data-state="on"] {
      background-color: var(--accent);
    }
  }
  .data-\\[state\\=on\\]\\:bg-blue-500\\/20 {
    &[data-state="on"] {
      background-color: color-mix(in srgb, oklch(62.3% 0.214 259.815) 20%, transparent);
      @supports (color: color-mix(in lab, red, red)) {
        background-color: color-mix(in oklab, var(--color-blue-500) 20%, transparent);
      }
    }
  }
  .data-\\[state\\=on\\]\\:bg-muted {
    &[data-state="on"] {
      background-color: var(--muted);
    }
  }
  .data-\\[state\\=on\\]\\:text-accent-foreground {
    &[data-state="on"] {
      color: var(--accent-foreground);
    }
  }
  .data-\\[state\\=on\\]\\:text-blue-700 {
    &[data-state="on"] {
      color: var(--color-blue-700);
    }
  }
  .data-\\[state\\=on\\]\\:hover\\:bg-blue-500\\/30 {
    &[data-state="on"] {
      &:hover {
        @media (hover: hover) {
          background-color: color-mix(in srgb, oklch(62.3% 0.214 259.815) 30%, transparent);
          @supports (color: color-mix(in lab, red, red)) {
            background-color: color-mix(in oklab, var(--color-blue-500) 30%, transparent);
          }
        }
      }
    }
  }
  .hover\\:data-\\[state\\=on\\]\\:bg-foreground\\/10 {
    &:hover {
      @media (hover: hover) {
        &[data-state="on"] {
          background-color: var(--foreground);
          @supports (color: color-mix(in lab, red, red)) {
            background-color: color-mix(in oklab, var(--foreground) 10%, transparent);
          }
        }
      }
    }
  }
  .data-\\[state\\=open\\]\\:animate-in {
    &[data-state="open"] {
      animation: enter var(--tw-animation-duration,var(--tw-duration,.15s))var(--tw-ease,ease)var(--tw-animation-delay,0s)var(--tw-animation-iteration-count,1)var(--tw-animation-direction,normal)var(--tw-animation-fill-mode,none);
    }
  }
  .data-\\[state\\=open\\]\\:fade-in-0 {
    &[data-state="open"] {
      --tw-enter-opacity: calc(0/100);
      --tw-enter-opacity: 0;
    }
  }
  .data-\\[state\\=open\\]\\:zoom-in-95 {
    &[data-state="open"] {
      --tw-enter-scale: calc(95*1%);
      --tw-enter-scale: .95;
    }
  }
  .md\\:inset-x-12 {
    @media (width >= 48rem) {
      inset-inline: calc(var(--spacing) * 12);
    }
  }
  .md\\:top-12 {
    @media (width >= 48rem) {
      top: calc(var(--spacing) * 12);
    }
  }
  .md\\:bottom-40 {
    @media (width >= 48rem) {
      bottom: calc(var(--spacing) * 40);
    }
  }
  .md\\:left-auto {
    @media (width >= 48rem) {
      left: auto;
    }
  }
  .md\\:mt-0 {
    @media (width >= 48rem) {
      margin-top: calc(var(--spacing) * 0);
    }
  }
  .md\\:block {
    @media (width >= 48rem) {
      display: block;
    }
  }
  .md\\:flex {
    @media (width >= 48rem) {
      display: flex;
    }
  }
  .md\\:hidden {
    @media (width >= 48rem) {
      display: none;
    }
  }
  .md\\:inline {
    @media (width >= 48rem) {
      display: inline;
    }
  }
  .md\\:w-64 {
    @media (width >= 48rem) {
      width: calc(var(--spacing) * 64);
    }
  }
  .md\\:w-\\[360px\\] {
    @media (width >= 48rem) {
      width: 360px;
    }
  }
  .md\\:translate-x-0 {
    @media (width >= 48rem) {
      --tw-translate-x: calc(var(--spacing) * 0);
      translate: var(--tw-translate-x) var(--tw-translate-y);
    }
  }
  .md\\:rounded-r-none {
    @media (width >= 48rem) {
      border-top-right-radius: 0;
      border-bottom-right-radius: 0;
    }
  }
  .md\\:border-r-0 {
    @media (width >= 48rem) {
      border-right-style: var(--tw-border-style);
      border-right-width: 0px;
    }
  }
  .md\\:px-0 {
    @media (width >= 48rem) {
      padding-inline: calc(var(--spacing) * 0);
    }
  }
  .md\\:px-6 {
    @media (width >= 48rem) {
      padding-inline: calc(var(--spacing) * 6);
    }
  }
  .md\\:pr-2 {
    @media (width >= 48rem) {
      padding-right: calc(var(--spacing) * 2);
    }
  }
  .md\\:pb-12 {
    @media (width >= 48rem) {
      padding-bottom: calc(var(--spacing) * 12);
    }
  }
  .md\\:pb-\\[180px\\] {
    @media (width >= 48rem) {
      padding-bottom: 180px;
    }
  }
  .md\\:text-sm {
    @media (width >= 48rem) {
      font-size: var(--text-sm);
      line-height: var(--tw-leading, var(--text-sm--line-height));
    }
  }
  .dark\\:block {
    &:is(.dark *) {
      display: block;
    }
  }
  .dark\\:hidden {
    &:is(.dark *) {
      display: none;
    }
  }
  .dark\\:border-input {
    &:is(.dark *) {
      border-color: var(--input);
    }
  }
  .dark\\:border-muted {
    &:is(.dark *) {
      border-color: var(--muted);
    }
  }
  .dark\\:bg-input\\/30 {
    &:is(.dark *) {
      background-color: var(--input);
      @supports (color: color-mix(in lab, red, red)) {
        background-color: color-mix(in oklab, var(--input) 30%, transparent);
      }
    }
  }
  .dark\\:hover\\:bg-accent\\/50 {
    &:is(.dark *) {
      &:hover {
        @media (hover: hover) {
          background-color: var(--accent);
          @supports (color: color-mix(in lab, red, red)) {
            background-color: color-mix(in oklab, var(--accent) 50%, transparent);
          }
        }
      }
    }
  }
  .dark\\:hover\\:bg-input\\/50 {
    &:is(.dark *) {
      &:hover {
        @media (hover: hover) {
          background-color: var(--input);
          @supports (color: color-mix(in lab, red, red)) {
            background-color: color-mix(in oklab, var(--input) 50%, transparent);
          }
        }
      }
    }
  }
  .dark\\:focus-visible\\:ring-destructive\\/40 {
    &:is(.dark *) {
      &:focus-visible {
        --tw-ring-color: var(--destructive);
        @supports (color: color-mix(in lab, red, red)) {
          --tw-ring-color: color-mix(in oklab, var(--destructive) 40%, transparent);
        }
      }
    }
  }
  .dark\\:aria-invalid\\:ring-destructive\\/40 {
    &:is(.dark *) {
      &[aria-invalid="true"] {
        --tw-ring-color: var(--destructive);
        @supports (color: color-mix(in lab, red, red)) {
          --tw-ring-color: color-mix(in oklab, var(--destructive) 40%, transparent);
        }
      }
    }
  }
  .dark\\:data-\\[state\\=on\\]\\:text-blue-300 {
    &:is(.dark *) {
      &[data-state="on"] {
        color: var(--color-blue-300);
      }
    }
  }
  .\\[\\&_p\\]\\:leading-relaxed {
    & p {
      --tw-leading: var(--leading-relaxed);
      line-height: var(--leading-relaxed);
    }
  }
  .\\[\\&_svg\\]\\:pointer-events-none {
    & svg {
      pointer-events: none;
    }
  }
  .\\[\\&_svg\\]\\:shrink-0 {
    & svg {
      flex-shrink: 0;
    }
  }
  .\\[\\&_svg\\:not\\(\\[class\\*\\=\\'size-\\'\\]\\)\\]\\:size-4 {
    & svg:not([class*='size-']) {
      width: calc(var(--spacing) * 4);
      height: calc(var(--spacing) * 4);
    }
  }
  .\\[\\&_svg\\:not\\(\\[class\\*\\=\\'text-\\'\\]\\)\\]\\:text-muted-foreground {
    & svg:not([class*='text-']) {
      color: var(--muted-foreground);
    }
  }
  .\\[\\&_td\\]\\:p-2 {
    & td {
      padding: calc(var(--spacing) * 2);
    }
  }
  .\\[\\&_td\\:not\\(\\:first-child\\)\\]\\:text-center {
    & td:not(:first-child) {
      text-align: center;
    }
  }
  .\\[\\&_th\\]\\:w-1\\/5 {
    & th {
      width: calc(1/5 * 100%);
    }
  }
  .\\[\\&_th\\]\\:p-2 {
    & th {
      padding: calc(var(--spacing) * 2);
    }
  }
  .\\[\\&_th\\]\\:text-center {
    & th {
      text-align: center;
    }
  }
  .\\[\\&_th\\]\\:font-normal {
    & th {
      --tw-font-weight: var(--font-weight-normal);
      font-weight: var(--font-weight-normal);
    }
  }
  .\\*\\:\\[span\\]\\:last\\:flex {
    :is(& > *) {
      &:is(span) {
        &:last-child {
          display: flex;
        }
      }
    }
  }
  .\\*\\:\\[span\\]\\:last\\:items-center {
    :is(& > *) {
      &:is(span) {
        &:last-child {
          align-items: center;
        }
      }
    }
  }
  .\\*\\:\\[span\\]\\:last\\:gap-2 {
    :is(& > *) {
      &:is(span) {
        &:last-child {
          gap: calc(var(--spacing) * 2);
        }
      }
    }
  }
  .\\[\\&\\:not\\(\\[class\\*\\=\\'text-\\'\\]\\)_svg\\:not\\(\\[class\\*\\=\\'text-\\'\\]\\)\\]\\:text-muted-foreground {
    &:not([class*='text-']) svg:not([class*='text-']) {
      color: var(--muted-foreground);
    }
  }
  .\\[\\&\\>svg\\]\\:size-4 {
    &>svg {
      width: calc(var(--spacing) * 4);
      height: calc(var(--spacing) * 4);
    }
  }
  .\\[\\&\\>svg\\]\\:translate-y-0\\.5 {
    &>svg {
      --tw-translate-y: calc(var(--spacing) * 0.5);
      translate: var(--tw-translate-x) var(--tw-translate-y);
    }
  }
  .\\[\\&\\>svg\\]\\:text-current {
    &>svg {
      color: currentcolor;
    }
  }
}
@property --tw-animation-delay {
  syntax: "*";
  inherits: false;
  initial-value: 0s;
}
@property --tw-animation-direction {
  syntax: "*";
  inherits: false;
  initial-value: normal;
}
@property --tw-animation-duration {
  syntax: "*";
  inherits: false;
}
@property --tw-animation-fill-mode {
  syntax: "*";
  inherits: false;
  initial-value: none;
}
@property --tw-animation-iteration-count {
  syntax: "*";
  inherits: false;
  initial-value: 1;
}
@property --tw-enter-blur {
  syntax: "*";
  inherits: false;
  initial-value: 0;
}
@property --tw-enter-opacity {
  syntax: "*";
  inherits: false;
  initial-value: 1;
}
@property --tw-enter-rotate {
  syntax: "*";
  inherits: false;
  initial-value: 0;
}
@property --tw-enter-scale {
  syntax: "*";
  inherits: false;
  initial-value: 1;
}
@property --tw-enter-translate-x {
  syntax: "*";
  inherits: false;
  initial-value: 0;
}
@property --tw-enter-translate-y {
  syntax: "*";
  inherits: false;
  initial-value: 0;
}
@property --tw-exit-blur {
  syntax: "*";
  inherits: false;
  initial-value: 0;
}
@property --tw-exit-opacity {
  syntax: "*";
  inherits: false;
  initial-value: 1;
}
@property --tw-exit-rotate {
  syntax: "*";
  inherits: false;
  initial-value: 0;
}
@property --tw-exit-scale {
  syntax: "*";
  inherits: false;
  initial-value: 1;
}
@property --tw-exit-translate-x {
  syntax: "*";
  inherits: false;
  initial-value: 0;
}
@property --tw-exit-translate-y {
  syntax: "*";
  inherits: false;
  initial-value: 0;
}
:root {
  --radius: 0.625rem;
  --background: oklch(1 0 0);
  --foreground: oklch(0.145 0 0);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.145 0 0);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.145 0 0);
  --primary: oklch(0.205 0 0);
  --primary-foreground: oklch(0.985 0 0);
  --secondary: oklch(0.97 0 0);
  --secondary-foreground: oklch(0.205 0 0);
  --muted: oklch(0.97 0 0);
  --muted-foreground: oklch(0.556 0 0);
  --accent: oklch(0.97 0 0);
  --accent-foreground: oklch(0.205 0 0);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.922 0 0);
  --input: oklch(0.922 0 0);
  --ring: oklch(0.708 0 0);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.985 0 0);
  --sidebar-foreground: oklch(0.145 0 0);
  --sidebar-primary: oklch(0.205 0 0);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.97 0 0);
  --sidebar-accent-foreground: oklch(0.205 0 0);
  --sidebar-border: oklch(0.922 0 0);
  --sidebar-ring: oklch(0.708 0 0);
}
.dark {
  --background: oklch(0.145 0 0);
  --foreground: oklch(0.985 0 0);
  --card: oklch(0.205 0 0);
  --card-foreground: oklch(0.985 0 0);
  --popover: oklch(0.269 0 0);
  --popover-foreground: oklch(0.985 0 0);
  --primary: oklch(0.922 0 0);
  --primary-foreground: oklch(0.205 0 0);
  --secondary: oklch(0.269 0 0);
  --secondary-foreground: oklch(0.985 0 0);
  --muted: oklch(0.269 0 0);
  --muted-foreground: oklch(0.708 0 0);
  --accent: oklch(0.371 0 0);
  --accent-foreground: oklch(0.985 0 0);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.556 0 0);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.205 0 0);
  --sidebar-foreground: oklch(0.985 0 0);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.269 0 0);
  --sidebar-accent-foreground: oklch(0.985 0 0);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.439 0 0);
}
@layer base {
  * {
    border-color: var(--foreground);
    @supports (color: color-mix(in lab, red, red)) {
      border-color: color-mix(in oklab, var(--foreground) 20%, transparent);
    }
    outline-color: var(--ring);
    @supports (color: color-mix(in lab, red, red)) {
      outline-color: color-mix(in oklab, var(--ring) 50%, transparent);
    }
  }
  body {
    background-color: var(--background);
    color: var(--foreground);
  }
}
@layer utils {
  .animate-text-shimmer {
    animation-delay: 0.5s;
    animation-duration: 3s;
    animation-iteration-count: infinite;
    animation-name: text-shimmer;
    background: var(--muted-foreground)
      gradient(
        linear,
        100% 0,
        0 0,
        from(var(--muted-foreground)),
        color-stop(0.5, var(--secondary-foreground)),
        to(var(--muted-foreground))
      );
    background: var(--muted-foreground) -webkit-gradient(
        linear,
        100% 0,
        0 0,
        from(var(--muted-foreground)),
        color-stop(0.5, var(--secondary-foreground)),
        to(var(--muted-foreground))
      );
    background-repeat: no-repeat;
    background-size: 50% 200%;
    display: inline-block;
  }
  @keyframes text-shimmer {
    0% {
      background-position: -100% 0;
    }
    100% {
      background-position: 250% 0;
    }
  }
}
@property --tw-translate-x {
  syntax: "*";
  inherits: false;
  initial-value: 0;
}
@property --tw-translate-y {
  syntax: "*";
  inherits: false;
  initial-value: 0;
}
@property --tw-translate-z {
  syntax: "*";
  inherits: false;
  initial-value: 0;
}
@property --tw-scale-x {
  syntax: "*";
  inherits: false;
  initial-value: 1;
}
@property --tw-scale-y {
  syntax: "*";
  inherits: false;
  initial-value: 1;
}
@property --tw-scale-z {
  syntax: "*";
  inherits: false;
  initial-value: 1;
}
@property --tw-rotate-x {
  syntax: "*";
  inherits: false;
}
@property --tw-rotate-y {
  syntax: "*";
  inherits: false;
}
@property --tw-rotate-z {
  syntax: "*";
  inherits: false;
}
@property --tw-skew-x {
  syntax: "*";
  inherits: false;
}
@property --tw-skew-y {
  syntax: "*";
  inherits: false;
}
@property --tw-pan-x {
  syntax: "*";
  inherits: false;
}
@property --tw-pan-y {
  syntax: "*";
  inherits: false;
}
@property --tw-pinch-zoom {
  syntax: "*";
  inherits: false;
}
@property --tw-space-y-reverse {
  syntax: "*";
  inherits: false;
  initial-value: 0;
}
@property --tw-space-x-reverse {
  syntax: "*";
  inherits: false;
  initial-value: 0;
}
@property --tw-divide-x-reverse {
  syntax: "*";
  inherits: false;
  initial-value: 0;
}
@property --tw-border-style {
  syntax: "*";
  inherits: false;
  initial-value: solid;
}
@property --tw-divide-y-reverse {
  syntax: "*";
  inherits: false;
  initial-value: 0;
}
@property --tw-gradient-position {
  syntax: "*";
  inherits: false;
}
@property --tw-gradient-from {
  syntax: "<color>";
  inherits: false;
  initial-value: #0000;
}
@property --tw-gradient-via {
  syntax: "<color>";
  inherits: false;
  initial-value: #0000;
}
@property --tw-gradient-to {
  syntax: "<color>";
  inherits: false;
  initial-value: #0000;
}
@property --tw-gradient-stops {
  syntax: "*";
  inherits: false;
}
@property --tw-gradient-via-stops {
  syntax: "*";
  inherits: false;
}
@property --tw-gradient-from-position {
  syntax: "<length-percentage>";
  inherits: false;
  initial-value: 0%;
}
@property --tw-gradient-via-position {
  syntax: "<length-percentage>";
  inherits: false;
  initial-value: 50%;
}
@property --tw-gradient-to-position {
  syntax: "<length-percentage>";
  inherits: false;
  initial-value: 100%;
}
@property --tw-leading {
  syntax: "*";
  inherits: false;
}
@property --tw-font-weight {
  syntax: "*";
  inherits: false;
}
@property --tw-tracking {
  syntax: "*";
  inherits: false;
}
@property --tw-ordinal {
  syntax: "*";
  inherits: false;
}
@property --tw-slashed-zero {
  syntax: "*";
  inherits: false;
}
@property --tw-numeric-figure {
  syntax: "*";
  inherits: false;
}
@property --tw-numeric-spacing {
  syntax: "*";
  inherits: false;
}
@property --tw-numeric-fraction {
  syntax: "*";
  inherits: false;
}
@property --tw-shadow {
  syntax: "*";
  inherits: false;
  initial-value: 0 0 #0000;
}
@property --tw-shadow-color {
  syntax: "*";
  inherits: false;
}
@property --tw-shadow-alpha {
  syntax: "<percentage>";
  inherits: false;
  initial-value: 100%;
}
@property --tw-inset-shadow {
  syntax: "*";
  inherits: false;
  initial-value: 0 0 #0000;
}
@property --tw-inset-shadow-color {
  syntax: "*";
  inherits: false;
}
@property --tw-inset-shadow-alpha {
  syntax: "<percentage>";
  inherits: false;
  initial-value: 100%;
}
@property --tw-ring-color {
  syntax: "*";
  inherits: false;
}
@property --tw-ring-shadow {
  syntax: "*";
  inherits: false;
  initial-value: 0 0 #0000;
}
@property --tw-inset-ring-color {
  syntax: "*";
  inherits: false;
}
@property --tw-inset-ring-shadow {
  syntax: "*";
  inherits: false;
  initial-value: 0 0 #0000;
}
@property --tw-ring-inset {
  syntax: "*";
  inherits: false;
}
@property --tw-ring-offset-width {
  syntax: "<length>";
  inherits: false;
  initial-value: 0px;
}
@property --tw-ring-offset-color {
  syntax: "*";
  inherits: false;
  initial-value: #fff;
}
@property --tw-ring-offset-shadow {
  syntax: "*";
  inherits: false;
  initial-value: 0 0 #0000;
}
@property --tw-outline-style {
  syntax: "*";
  inherits: false;
  initial-value: solid;
}
@property --tw-blur {
  syntax: "*";
  inherits: false;
}
@property --tw-brightness {
  syntax: "*";
  inherits: false;
}
@property --tw-contrast {
  syntax: "*";
  inherits: false;
}
@property --tw-grayscale {
  syntax: "*";
  inherits: false;
}
@property --tw-hue-rotate {
  syntax: "*";
  inherits: false;
}
@property --tw-invert {
  syntax: "*";
  inherits: false;
}
@property --tw-opacity {
  syntax: "*";
  inherits: false;
}
@property --tw-saturate {
  syntax: "*";
  inherits: false;
}
@property --tw-sepia {
  syntax: "*";
  inherits: false;
}
@property --tw-drop-shadow {
  syntax: "*";
  inherits: false;
}
@property --tw-drop-shadow-color {
  syntax: "*";
  inherits: false;
}
@property --tw-drop-shadow-alpha {
  syntax: "<percentage>";
  inherits: false;
  initial-value: 100%;
}
@property --tw-drop-shadow-size {
  syntax: "*";
  inherits: false;
}
@property --tw-backdrop-blur {
  syntax: "*";
  inherits: false;
}
@property --tw-backdrop-brightness {
  syntax: "*";
  inherits: false;
}
@property --tw-backdrop-contrast {
  syntax: "*";
  inherits: false;
}
@property --tw-backdrop-grayscale {
  syntax: "*";
  inherits: false;
}
@property --tw-backdrop-hue-rotate {
  syntax: "*";
  inherits: false;
}
@property --tw-backdrop-invert {
  syntax: "*";
  inherits: false;
}
@property --tw-backdrop-opacity {
  syntax: "*";
  inherits: false;
}
@property --tw-backdrop-saturate {
  syntax: "*";
  inherits: false;
}
@property --tw-backdrop-sepia {
  syntax: "*";
  inherits: false;
}
@property --tw-duration {
  syntax: "*";
  inherits: false;
}
@property --tw-ease {
  syntax: "*";
  inherits: false;
}
@keyframes spin {
  to {
    transform: rotate(360deg);
  }
}
@keyframes enter {
  from {
    opacity: var(--tw-enter-opacity,1);
    transform: translate3d(var(--tw-enter-translate-x,0),var(--tw-enter-translate-y,0),0)scale3d(var(--tw-enter-scale,1),var(--tw-enter-scale,1),var(--tw-enter-scale,1))rotate(var(--tw-enter-rotate,0));
    filter: blur(var(--tw-enter-blur,0));
  }
}
@keyframes exit {
  to {
    opacity: var(--tw-exit-opacity,1);
    transform: translate3d(var(--tw-exit-translate-x,0),var(--tw-exit-translate-y,0),0)scale3d(var(--tw-exit-scale,1),var(--tw-exit-scale,1),var(--tw-exit-scale,1))rotate(var(--tw-exit-rotate,0));
    filter: blur(var(--tw-exit-blur,0));
  }
}
@layer properties {
  @supports ((-webkit-hyphens: none) and (not (margin-trim: inline))) or ((-moz-orient: inline) and (not (color:rgb(from red r g b)))) {
    *, ::before, ::after, ::backdrop {
      --tw-translate-x: 0;
      --tw-translate-y: 0;
      --tw-translate-z: 0;
      --tw-scale-x: 1;
      --tw-scale-y: 1;
      --tw-scale-z: 1;
      --tw-rotate-x: initial;
      --tw-rotate-y: initial;
      --tw-rotate-z: initial;
      --tw-skew-x: initial;
      --tw-skew-y: initial;
      --tw-pan-x: initial;
      --tw-pan-y: initial;
      --tw-pinch-zoom: initial;
      --tw-space-y-reverse: 0;
      --tw-space-x-reverse: 0;
      --tw-divide-x-reverse: 0;
      --tw-border-style: solid;
      --tw-divide-y-reverse: 0;
      --tw-gradient-position: initial;
      --tw-gradient-from: #0000;
      --tw-gradient-via: #0000;
      --tw-gradient-to: #0000;
      --tw-gradient-stops: initial;
      --tw-gradient-via-stops: initial;
      --tw-gradient-from-position: 0%;
      --tw-gradient-via-position: 50%;
      --tw-gradient-to-position: 100%;
      --tw-leading: initial;
      --tw-font-weight: initial;
      --tw-tracking: initial;
      --tw-ordinal: initial;
      --tw-slashed-zero: initial;
      --tw-numeric-figure: initial;
      --tw-numeric-spacing: initial;
      --tw-numeric-fraction: initial;
      --tw-shadow: 0 0 #0000;
      --tw-shadow-color: initial;
      --tw-shadow-alpha: 100%;
      --tw-inset-shadow: 0 0 #0000;
      --tw-inset-shadow-color: initial;
      --tw-inset-shadow-alpha: 100%;
      --tw-ring-color: initial;
      --tw-ring-shadow: 0 0 #0000;
      --tw-inset-ring-color: initial;
      --tw-inset-ring-shadow: 0 0 #0000;
      --tw-ring-inset: initial;
      --tw-ring-offset-width: 0px;
      --tw-ring-offset-color: #fff;
      --tw-ring-offset-shadow: 0 0 #0000;
      --tw-outline-style: solid;
      --tw-blur: initial;
      --tw-brightness: initial;
      --tw-contrast: initial;
      --tw-grayscale: initial;
      --tw-hue-rotate: initial;
      --tw-invert: initial;
      --tw-opacity: initial;
      --tw-saturate: initial;
      --tw-sepia: initial;
      --tw-drop-shadow: initial;
      --tw-drop-shadow-color: initial;
      --tw-drop-shadow-alpha: 100%;
      --tw-drop-shadow-size: initial;
      --tw-backdrop-blur: initial;
      --tw-backdrop-brightness: initial;
      --tw-backdrop-contrast: initial;
      --tw-backdrop-grayscale: initial;
      --tw-backdrop-hue-rotate: initial;
      --tw-backdrop-invert: initial;
      --tw-backdrop-opacity: initial;
      --tw-backdrop-saturate: initial;
      --tw-backdrop-sepia: initial;
      --tw-duration: initial;
      --tw-ease: initial;
      --tw-animation-delay: 0s;
      --tw-animation-direction: normal;
      --tw-animation-duration: initial;
      --tw-animation-fill-mode: none;
      --tw-animation-iteration-count: 1;
      --tw-enter-blur: 0;
      --tw-enter-opacity: 1;
      --tw-enter-rotate: 0;
      --tw-enter-scale: 1;
      --tw-enter-translate-x: 0;
      --tw-enter-translate-y: 0;
      --tw-exit-blur: 0;
      --tw-exit-opacity: 1;
      --tw-exit-rotate: 0;
      --tw-exit-scale: 1;
      --tw-exit-translate-x: 0;
      --tw-exit-translate-y: 0;
    }
  }
}
`,
        '',
        {
          version: 3,
          sources: [
            '<no source>',
            'webpack://./node_modules/.pnpm/tailwindcss@4.1.13/node_modules/tailwindcss/index.css',
            'webpack://./node_modules/.pnpm/tw-animate-css@1.3.8/node_modules/tw-animate-css/dist/tw-animate.css',
            'webpack://./styles/globals.css',
          ],
          names: [],
          mappings:
            'AAAA,kEAAA;AC83BE,iBAAmB;AA93BrB,yCAAyC;AAEzC;EACE;IAiIE,yCAAyC;IACzC,4CAA4C;IAE5C,4CAA4C;IAC5C,4CAA4C;IAC5C,4CAA4C;IAE5C,4CAA4C;IAC5C,4CAA4C;IAC5C,4CAA4C;IAwF5C,4CAA4C;IAM5C,4CAA4C;IAK5C,iCAAiC;IAEjC,yCAAyC;IACzC,4CAA4C;IAC5C,4CAA4C;IAC5C,4CAA4C;IAC5C,4CAA4C;IAC5C,0CAA0C;IAC1C,4CAA4C;IAC5C,0CAA0C;IAC1C,4CAA4C;IA0B5C,mBAAmB;IACnB,mBAAmB;IAEnB,kBAAkB;IAelB,sBAAsB;IACtB,sBAAsB;IACtB,sBAAsB;IAKtB,kBAAkB;IAClB,sCAAsC;IACtC,mBAAmB;IACnB,0CAA0C;IAG1C,mBAAmB;IACnB,0CAA0C;IAC1C,kBAAkB;IAClB,yCAAyC;IACzC,kBAAkB;IAClB,sCAAsC;IAGtC,mBAAmB;IACnB,yCAAyC;IACzC,gBAAgB;IAChB,0BAA0B;IAW1B,6BAA6B;IAE7B,yBAAyB;IACzB,yBAAyB;IACzB,2BAA2B;IAC3B,uBAAuB;IAKvB,0BAA0B;IAG1B,wBAAwB;IAGxB,qBAAqB;IAGrB,wBAAwB;IAIxB,oBAAoB;IACpB,qBAAqB;IACrB,mBAAmB;IAEnB,kBAAkB;IAClB,oBAAoB;IAoBpB,6CAA6C;IAG7C,gDAAgD;IAchD,qCAAqC;IACrC,sCAAsC;IACtC,2CAA2C;IAE3C,uCAAuC;IAsDvC,oCAAoC;IACpC,kEAAkE;IAClE;2DAAoD;IASpD;+CAAyD;EA5c5C;AADJ;AAmeb;EAOE;IAKE,sBAAsB;IACtB,SAAS;IACT,UAAU;IACV,eAAe;EAJM;EAiBvB;IAEE,gBAAgB;IAChB,8BAA8B;IAC9B,WAAW;IACX,2JASC;IACD,mEAGC;IACD,uEAGC;IACD,wCAAwC;EAtBpC;EA+BN;IACE,SAAS;IACT,cAAc;IACd,qBAAqB;EAHpB;EAUH;IACE,yCAAyC;IACzC,iCAAiC;EAFf;EASpB;IAME,kBAAkB;IAClB,oBAAoB;EAFnB;EASH;IACE,cAAc;IACd,gCAAgC;IAChC,wBAAwB;EAHxB;EAUF;IAEE,mBAAmB;EADd;EAWP;IAIE,gJAUC;IACD,wEAGC;IACD,4EAGC;IACD,cAAc;EApBZ;EA2BJ;IACE,cAAc;EADV;EAQN;IAEE,cAAc;IACd,cAAc;IACd,kBAAkB;IAClB,wBAAwB;EAJtB;EAOJ;IACE,eAAe;EADb;EAIJ;IACE,WAAW;EADT;EAUJ;IACE,cAAc;IACd,qBAAqB;IACrB,yBAAyB;EAHrB;EAUN;IACE,aAAa;EADC;EAQhB;IACE,wBAAwB;EADjB;EAQT;IACE,kBAAkB;EADZ;EAQR;IAGE,gBAAgB;EADb;EAUL;IAQE,cAAc;IACd,sBAAsB;EAFjB;EASP;IAEE,eAAe;IACf,YAAY;EAFR;EAYN;IAME,aAAa;IACb,8BAA8B;IAC9B,gCAAgC;IAChC,uBAAuB;IACvB,cAAc;IACd,gBAAgB;IAChB,6BAA6B;IAC7B,UAAU;EARW;EAevB;IACE,mBAAmB;EAD0B;EAQ/C;IACE,0BAA0B;EAD0B;EAQtD;IACE,sBAAsB;EADD;EAQvB;IACE,UAAU;EADE;EASd;IAEE;MACE,mBAAyD;MAAzD;QAAA,yDAAyD;MAAA;IAD7C;EADiC;EAUjD;IACE,gBAAgB;EADT;EAQT;IACE,wBAAwB;EADE;EAS5B;IACE,eAAe;IACf,mBAAmB;EAFS;EAS9B;IACE,oBAAoB;EADE;EAQxB;IACE,UAAU;EAD2B;EAIvC;IASE,gBAAgB;EADqB;EAQvC;IACE,cAAc;EADoB;EAQpC;IACE,gBAAgB;EADD;EAQjB;IAGE,kBAAkB;EADG;EAQvB;IAEE,YAAY;EADc;EAQ5B;IACE,wBAAwB;EADmB;AAnZnC;AAwZZ;EACE;IAAA,oBAAmB;EAAA;EAAnB;IAAA,oBAAmB;EAAA;EAAnB;IAAA,kBAAmB;EAAA;EAAnB;IAAA,mBAAmB;EAAA;EAAnB;IAAA,kBAAmB;IAAnB,UAAmB;IAAnB,WAAmB;IAAnB,UAAmB;IAAnB,YAAmB;IAAnB,gBAAmB;IAAnB,qBAAmB;IAAnB,mBAAmB;IAAnB,eAAmB;EAAA;EAAnB;IAAA,gBAAmB;IAAnB,WAAmB;IAAnB,YAAmB;IAAnB,UAAmB;IAAnB,SAAmB;IAAnB,iBAAmB;IAAnB,eAAmB;IAAnB,mBAAmB;EAAA;EAAnB;IAAA,kBAAmB;EAAA;EAAnB;IAAA,eAAmB;EAAA;EAAnB;IAAA,kBAAmB;EAAA;EAAnB;IAAA,gBAAmB;EAAA;EAAnB;IAAA,gBAAmB;EAAA;EAAnB;IAAA,gCAAmB;EAAA;EAAnB;IAAA,+BAAmB;EAAA;EAAnB;IAAA,+BAAmB;EAAA;EAAnB;IAAA,sCAAmB;EAAA;EAAnB;IAAA,sCAAmB;EAAA;EAAnB;IAAA,sCAAmB;EAAA;EAAnB;IAAA,6BAAmB;EAAA;EAAnB;IAAA,qBAAmB;EAAA;EAAnB;IAAA,6BAAmB;EAAA;EAAnB;IAAA,6BAAmB;EAAA;EAAnB;IAAA,+BAAmB;EAAA;EAAnB;IAAA,+BAAmB;EAAA;EAAnB;IAAA,+BAAmB;EAAA;EAAnB;IAAA,gCAAmB;EAAA;EAAnB;IAAA,gCAAmB;EAAA;EAAnB;IAAA,gCAAmB;EAAA;EAAnB;IAAA,gCAAmB;EAAA;EAAnB;IAAA,iCAAmB;EAAA;EAAnB;IAAA,iCAAmB;EAAA;EAAnB;IAAA,+BAAmB;EAAA;EAAnB;IAAA,8BAAmB;EAAA;EAAnB;IAAA,sBAAmB;EAAA;EAAnB;IAAA,8BAAmB;EAAA;EAAnB;IAAA,8BAAmB;EAAA;EAAnB;IAAA,kBAAmB;EAAA;EAAnB;IAAA,eAAmB;EAAA;EAAnB;IAAA,WAAmB;EAAA;EAAnB;IAAA,WAAmB;EAAA;EAAnB;IAAA,WAAmB;EAAA;EAAnB;IAAA,WAAmB;EAAA;EAAnB;IAAA,WAAmB;EAAA;EAAnB;IAAA,4BAAmB;EAAA;EAAnB;IAAA,oBAAmB;EAAA;EAAnB;IAAA,oBAAmB;EAAA;EAAnB;IAAA,yBAAmB;EAAA;EAAnB;IAAA,iBAAmB;EAAA;EAAnB;IAAA,iBAAmB;EAAA;EAAnB;IAAA,sBAAmB;IAAnB;MAAA,2BAAmB;IAAA;IAAnB;MAAA,2BAAmB;IAAA;IAAnB;MAAA,2BAAmB;IAAA;IAAnB;MAAA,2BAAmB;IAAA;IAAnB;MAAA,2BAAmB;IAAA;EAAA;EAAnB;IAAA,WAAmB;IAAnB;MAAA,gBAAmB;IAAA;IAAnB;MAAA,gBAAmB;IAAA;IAAnB;MAAA,gBAAmB;IAAA;IAAnB;MAAA,gBAAmB;IAAA;IAAnB;MAAA,gBAAmB;IAAA;EAAA;EAAnB;IAAA,gCAAmB;EAAA;EAAnB;IAAA,wCAAmB;EAAA;EAAnB;IAAA,uCAAmB;EAAA;EAAnB;IAAA,mBAAmB;EAAA;EAAnB;IAAA,sCAAmB;EAAA;EAAnB;IAAA,sCAAmB;EAAA;EAAnB;IAAA,oCAAmB;EAAA;EAAnB;IAAA,oCAAmB;EAAA;EAAnB;IAAA,oCAAmB;EAAA;EAAnB;IAAA,qCAAmB;EAAA;EAAnB;IAAA,qCAAmB;EAAA;EAAnB;IAAA,kBAAmB;EAAA;EAAnB;IAAA,kBAAmB;EAAA;EAAnB;IAAA,uCAAmB;EAAA;EAAnB;IAAA,uCAAmB;EAAA;EAAnB;IAAA,uCAAmB;EAAA;EAAnB;IAAA,uCAAmB;EAAA;EAAnB;IAAA,iBAAmB;EAAA;EAAnB;IAAA,gBAAmB;IAAnB,oBAAmB;IAAnB,4BAAmB;IAAnB,qBAAmB;EAAA;EAAnB;IAAA,wBAAmB;EAAA;EAAnB;IAAA,cAAmB;EAAA;EAAnB;IAAA,iBAAmB;EAAA;EAAnB;IAAA,aAAmB;EAAA;EAAnB;IAAA,kBAAmB;EAAA;EAAnB;IAAA,aAAmB;EAAA;EAAnB;IAAA,aAAmB;EAAA;EAAnB;IAAA,eAAmB;EAAA;EAAnB;IAAA,qBAAmB;EAAA;EAAnB;IAAA,oBAAmB;EAAA;EAAnB;IAAA,oBAAmB;EAAA;EAAnB;IAAA,qBAAmB;EAAA;EAAnB;IAAA,kBAAmB;EAAA;EAAnB;IAAA,cAAmB;EAAA;EAAnB;IAAA,sBAAmB;EAAA;EAAnB;IAAA,mBAAmB;EAAA;EAAnB;IAAA,qBAAmB;EAAA;EAAnB;IAAA,2BAAmB;EAAA;EAAnB;IAAA,2BAAmB;EAAA;EAAnB;IAAA,2BAAmB;EAAA;EAAnB;IAAA,kBAAmB;EAAA;EAAnB;IAAA,wBAAmB;EAAA;EAAnB;IAAA,mBAAmB;EAAA;EAAnB;IAAA,iCAAmB;IAAnB,kCAAmB;EAAA;EAAnB;IAAA,+BAAmB;IAAnB,gCAAmB;EAAA;EAAnB;IAAA,+BAAmB;IAAnB,gCAAmB;EAAA;EAAnB;IAAA,+BAAmB;IAAnB,gCAAmB;EAAA;EAAnB;IAAA,+BAAmB;IAAnB,gCAAmB;EAAA;EAAnB;IAAA,gCAAmB;IAAnB,iCAAmB;EAAA;EAAnB;IAAA,gCAAmB;IAAnB,iCAAmB;EAAA;EAAnB;IAAA,gCAAmB;IAAnB,iCAAmB;EAAA;EAAnB;IAAA,WAAmB;IAAnB,YAAmB;EAAA;EAAnB;IAAA,gCAAmB;EAAA;EAAnB;IAAA,gCAAmB;EAAA;EAAnB;IAAA,gCAAmB;EAAA;EAAnB;IAAA,gCAAmB;EAAA;EAAnB;IAAA,gCAAmB;EAAA;EAAnB;IAAA,gCAAmB;EAAA;EAAnB;IAAA,iCAAmB;EAAA;EAAnB;IAAA,iCAAmB;EAAA;EAAnB;IAAA,iCAAmB;EAAA;EAAnB;IAAA,YAAmB;EAAA;EAAnB;IAAA,YAAmB;EAAA;EAAnB;IAAA,aAAmB;EAAA;EAAnB;IAAA,0CAAmB;EAAA;EAAnB;IAAA,YAAmB;EAAA;EAAnB;IAAA,YAAmB;EAAA;EAAnB;IAAA,WAAmB;EAAA;EAAnB;IAAA,aAAmB;EAAA;EAAnB;IAAA,cAAmB;EAAA;EAAnB;IAAA,wDAAmB;EAAA;EAAnB;IAAA,sCAAmB;EAAA;EAAnB;IAAA,oCAAmB;EAAA;EAAnB;IAAA,oCAAmB;EAAA;EAAnB;IAAA,iBAAmB;EAAA;EAAnB;IAAA,kBAAmB;EAAA;EAAnB;IAAA,iCAAmB;EAAA;EAAnB;IAAA,iCAAmB;EAAA;EAAnB;IAAA,+BAAmB;EAAA;EAAnB;IAAA,+BAAmB;EAAA;EAAnB;IAAA,+BAAmB;EAAA;EAAnB;IAAA,gCAAmB;EAAA;EAAnB;IAAA,gCAAmB;EAAA;EAAnB;IAAA,WAAmB;EAAA;EAAnB;IAAA,WAAmB;EAAA;EAAnB;IAAA,YAAmB;EAAA;EAAnB;IAAA,WAAmB;EAAA;EAAnB;IAAA,kBAAmB;EAAA;EAAnB;IAAA,WAAmB;EAAA;EAAnB;IAAA,UAAmB;EAAA;EAAnB;IAAA,+BAAmB;EAAA;EAAnB;IAAA,+BAAmB;EAAA;EAAnB;IAAA,2BAAmB;EAAA;EAAnB;IAAA,+BAAmB;EAAA;EAAnB;IAAA,oCAAmB;EAAA;EAAnB;IAAA,eAAmB;EAAA;EAAnB;IAAA,eAAmB;EAAA;EAAnB;IAAA,4CAAmB;EAAA;EAAnB;IAAA,OAAmB;EAAA;EAAnB;IAAA,cAAmB;EAAA;EAAnB;IAAA,cAAmB;EAAA;EAAnB;IAAA,cAAmB;EAAA;EAAnB;IAAA,cAAmB;EAAA;EAAnB;IAAA,YAAmB;EAAA;EAAnB;IAAA,YAAmB;EAAA;EAAnB;IAAA,yBAAmB;EAAA;EAAnB;IAAA,8DAAmB;EAAA;EAAnB;IAAA,wBAAmB;EAAA;EAAnB;IAAA,6CAAmB;IAAnB,sDAAmB;EAAA;EAAnB;IAAA,uBAAmB;IAAnB,sDAAmB;EAAA;EAAnB;IAAA,0CAAmB;IAAnB,sDAAmB;EAAA;EAAnB;IAAA,6CAAmB;IAAnB,sDAAmB;EAAA;EAAnB;IAAA,uBAAmB;IAAnB,sDAAmB;EAAA;EAAnB;IAAA,2CAAmB;IAAnB,sDAAmB;EAAA;EAAnB;IAAA,eAAmB;EAAA;EAAnB;IAAA,kBAAmB;IAAnB,kBAAmB;IAAnB,kBAAmB;IAAnB,0CAAmB;EAAA;EAAnB;IAAA,4DAAmB;EAAA;EAAnB;IAAA,0GAAmB;EAAA;EAAnB;IAAA,8BAAmB;EAAA;EAAnB;IAAA,eAAmB;EAAA;EAAnB;IAAA,eAAmB;EAAA;EAAnB;IAAA,2BAAmB;IAAnB,qEAAmB;EAAA;EAAnB;IAAA,YAAmB;EAAA;EAAnB;IAAA,6CAAmB;EAAA;EAAnB;IAAA,gDAAmB;EAAA;EAAnB;IAAA,gDAAmB;EAAA;EAAnB;IAAA,4BAAmB;EAAA;EAAnB;IAAA,8BAAmB;EAAA;EAAnB;IAAA,6CAAmB;EAAA;EAAnB;IAAA,iCAAmB;EAAA;EAAnB;IAAA,sBAAmB;EAAA;EAAnB;IAAA,mBAAmB;EAAA;EAAnB;IAAA,2BAAmB;EAAA;EAAnB;IAAA,eAAmB;EAAA;EAAnB;IAAA,qBAAmB;EAAA;EAAnB;IAAA,kBAAmB;EAAA;EAAnB;IAAA,mBAAmB;EAAA;EAAnB;IAAA,mBAAmB;EAAA;EAAnB;IAAA,qBAAmB;EAAA;EAAnB;IAAA,uBAAmB;EAAA;EAAnB;IAAA,8BAAmB;EAAA;EAAnB;IAAA,uBAAmB;EAAA;EAAnB;IAAA,yBAAmB;EAAA;EAAnB;IAAA,oBAAmB;EAAA;EAAnB;IAAA,6BAAmB;EAAA;EAAnB;IAAA,+BAAmB;EAAA;EAAnB;IAAA,6BAAmB;EAAA;EAAnB;IAAA,+BAAmB;EAAA;EAAnB;IAAA,6BAAmB;EAAA;EAAnB;IAAA,6BAAmB;EAAA;EAAnB;IAAA,6BAAmB;EAAA;EAAnB;IAAA,6BAAmB;EAAA;EAAnB;IAAA;MAAA,uBAAmB;MAAnB,8EAAmB;MAAnB,sFAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,uBAAmB;MAAnB,8EAAmB;MAAnB,sFAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,uBAAmB;MAAnB,8EAAmB;MAAnB,sFAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,uBAAmB;MAAnB,8EAAmB;MAAnB,sFAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,uBAAmB;MAAnB,8EAAmB;MAAnB,sFAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,uBAAmB;MAAnB,8EAAmB;MAAnB,sFAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,uBAAmB;MAAnB,+EAAmB;MAAnB,uFAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,uBAAmB;IAAA;EAAA;EAAnB;IAAA,oCAAmB;EAAA;EAAnB;IAAA;MAAA,uBAAmB;IAAA;EAAA;EAAnB;IAAA,mCAAmB;EAAA;EAAnB;IAAA;MAAA,wBAAmB;MAAnB,2CAAmB;MAAnB,iEAAmB;MAAnB,yEAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,wBAAmB;MAAnB,2CAAmB;MAAnB,wCAAmB;MAAnB,wDAAmB;MAAnB,qEAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,wBAAmB;IAAA;EAAA;EAAnB;IAAA,kBAAmB;EAAA;EAAnB;IAAA,sBAAmB;EAAA;EAAnB;IAAA,sBAAmB;EAAA;EAAnB;IAAA,wBAAmB;EAAA;EAAnB;IAAA,gBAAmB;IAAnB,uBAAmB;IAAnB,mBAAmB;EAAA;EAAnB;IAAA,cAAmB;EAAA;EAAnB;IAAA,gBAAmB;EAAA;EAAnB;IAAA,kBAAmB;EAAA;EAAnB;IAAA,gBAAmB;EAAA;EAAnB;IAAA,kBAAmB;EAAA;EAAnB;IAAA,uBAAmB;EAAA;EAAnB;IAAA,sBAAmB;EAAA;EAAnB;IAAA,gCAAmB;EAAA;EAAnB;IAAA,gCAAmB;EAAA;EAAnB;IAAA,mBAAmB;EAAA;EAAnB;IAAA,mBAAmB;EAAA;EAAnB;IAAA,mBAAmB;EAAA;EAAnB;IAAA,mBAAmB;EAAA;EAAnB;IAAA,mCAAmB;EAAA;EAAnB;IAAA,+BAAmB;EAAA;EAAnB;IAAA,+BAAmB;EAAA;EAAnB;IAAA,+BAAmB;EAAA;EAAnB;IAAA,kCAAmB;IAAnB,gCAAmB;EAAA;EAAnB;IAAA,kCAAmB;EAAA;EAAnB;IAAA,gCAAmB;IAAnB,8BAAmB;EAAA;EAAnB;IAAA,gCAAmB;EAAA;EAAnB;IAAA,8BAAmB;EAAA;EAAnB;IAAA,gCAAmB;EAAA;EAAnB;IAAA,+BAAmB;IAAnB,gCAAmB;EAAA;EAAnB;IAAA,+BAAmB;IAAnB,kCAAmB;EAAA;EAAnB;IAAA,yBAAmB;IAAnB,4BAAmB;EAAA;EAAnB;IAAA,+BAAmB;EAAA;EAAnB;IAAA,gCAAmB;IAAnB,mCAAmB;EAAA;EAAnB;IAAA,gCAAmB;EAAA;EAAnB;IAAA,mCAAmB;IAAnB,kCAAmB;EAAA;EAAnB;IAAA,mCAAmB;EAAA;EAAnB;IAAA,kCAAmB;EAAA;EAAnB;IAAA,oCAAmB;IAAnB,iBAAmB;EAAA;EAAnB;IAAA,2CAAmB;IAAnB,wBAAmB;EAAA;EAAnB;IAAA,0CAAmB;IAAnB,uBAAmB;EAAA;EAAnB;IAAA,iDAAmB;IAAnB,8BAAmB;EAAA;EAAnB;IAAA,+CAAmB;IAAnB,4BAAmB;EAAA;EAAnB;IAAA,wCAAmB;IAAnB,qBAAmB;EAAA;EAAnB;IAAA,0CAAmB;IAAnB,uBAAmB;EAAA;EAAnB;IAAA,2CAAmB;IAAnB,wBAAmB;EAAA;EAAnB;IAAA,yCAAmB;IAAnB,sBAAmB;EAAA;EAAnB;IAAA,uBAAmB;IAAnB,kBAAmB;EAAA;EAAnB;IAAA,wBAAmB;IAAnB,mBAAmB;EAAA;EAAnB;IAAA,mCAAmB;EAAA;EAAnB;IAAA,gCAAmB;IAAnB;MAAA,sEAAmB;IAAA;EAAA;EAAnB;IAAA,0BAAmB;EAAA;EAAnB;IAAA,0BAAmB;IAAnB;MAAA,gEAAmB;IAAA;EAAA;EAAnB;IAAA,yBAAmB;EAAA;EAAnB;IAAA,mCAAmB;EAAA;EAAnB;IAAA,+BAAmB;EAAA;EAAnB;IAAA,mCAAmB;EAAA;EAAnB;IAAA,oCAAmB;EAAA;EAAnB;IAAA,2DAAmB;IAAnB;MAAA,0EAAmB;IAAA;EAAA;EAAnB;IAAA,sCAAmB;EAAA;EAAnB;IAAA,iFAAmB;IAAnB;MAAA,6EAAmB;IAAA;EAAA;EAAnB;IAAA,+BAAmB;EAAA;EAAnB;IAAA,6BAAmB;EAAA;EAAnB;IAAA,oCAAmB;EAAA;EAAnB;IAAA,oCAAmB;IAAnB;MAAA,0EAAmB;IAAA;EAAA;EAAnB;IAAA,mCAAmB;IAAnB;MAAA,yEAAmB;IAAA;EAAA;EAAnB;IAAA,uCAAmB;EAAA;EAAnB;IAAA,8BAAmB;EAAA;EAAnB;IAAA,8BAAmB;IAAnB;MAAA,oEAAmB;IAAA;EAAA;EAAnB;IAAA,gCAAmB;EAAA;EAAnB;IAAA,gCAAmB;EAAA;EAAnB;IAAA,6BAAmB;EAAA;EAAnB;IAAA,oCAAmB;EAAA;EAAnB;IAAA,uCAAmB;EAAA;EAAnB;IAAA,+EAAmB;IAAnB;MAAA,6EAAmB;IAAA;EAAA;EAAnB;IAAA,uCAAmB;EAAA;EAAnB;IAAA,iCAAmB;IAAnB;MAAA,0CAAmB;IAAA;IAAnB,2DAAmB;EAAA;EAAnB;IAAA,8BAAmB;IAAnB;MAAA,uCAAmB;IAAA;IAAnB,2DAAmB;EAAA;EAAnB;IAAA,qIAAmB;EAAA;EAAnB;IAAA,qCAAmB;IAAnB,8LAAmB;EAAA;EAAnB;IAAA,6BAAmB;IAAnB,8LAAmB;EAAA;EAAnB;IAAA,0GAAmB;EAAA;EAAnB;IAAA,gCAAmB;EAAA;EAAnB;IAAA,yBAAmB;EAAA;EAAnB;IAAA,kBAAmB;EAAA;EAAnB;IAAA,mBAAmB;EAAA;EAAnB;IAAA,iBAAmB;EAAA;EAAnB;IAAA,mCAAmB;EAAA;EAAnB;IAAA,iCAAmB;EAAA;EAAnB;IAAA,iCAAmB;EAAA;EAAnB;IAAA,iCAAmB;EAAA;EAAnB;IAAA,iCAAmB;EAAA;EAAnB;IAAA,iCAAmB;EAAA;EAAnB;IAAA,iCAAmB;EAAA;EAAnB;IAAA,0CAAmB;EAAA;EAAnB;IAAA,wCAAmB;EAAA;EAAnB;IAAA,wCAAmB;EAAA;EAAnB;IAAA,wCAAmB;EAAA;EAAnB;IAAA,wCAAmB;EAAA;EAAnB;IAAA,wCAAmB;EAAA;EAAnB;IAAA,uCAAmB;EAAA;EAAnB;IAAA,yCAAmB;EAAA;EAAnB;IAAA,uCAAmB;EAAA;EAAnB;IAAA,uCAAmB;EAAA;EAAnB;IAAA,qCAAmB;EAAA;EAAnB;IAAA,sCAAmB;EAAA;EAAnB;IAAA,sCAAmB;EAAA;EAAnB;IAAA,yCAAmB;EAAA;EAAnB;IAAA,uCAAmB;EAAA;EAAnB;IAAA,uCAAmB;EAAA;EAAnB;IAAA,wCAAmB;EAAA;EAAnB;IAAA,wCAAmB;EAAA;EAAnB;IAAA,qBAAmB;EAAA;EAAnB;IAAA,sCAAmB;EAAA;EAAnB;IAAA,wCAAmB;EAAA;EAAnB;IAAA,sCAAmB;EAAA;EAAnB;IAAA,sCAAmB;EAAA;EAAnB;IAAA,kBAAmB;EAAA;EAAnB;IAAA,gBAAmB;EAAA;EAAnB;IAAA,iBAAmB;EAAA;EAAnB;IAAA;+CAAmB;EAAA;EAAnB;IAAA;2DAAmB;EAAA;EAAnB;IAAA,0BAAmB;IAAnB,4DAAmB;EAAA;EAAnB;IAAA,0BAAmB;IAAnB,4DAAmB;EAAA;EAAnB;IAAA,0BAAmB;IAAnB,4DAAmB;EAAA;EAAnB;IAAA,yBAAmB;IAAnB,2DAAmB;EAAA;EAAnB;IAAA,yBAAmB;IAAnB,2DAAmB;EAAA;EAAnB;IAAA,yBAAmB;IAAnB,2DAAmB;EAAA;EAAnB;IAAA,yBAAmB;IAAnB,2DAAmB;EAAA;EAAnB;IAAA,sCAAmB;IAAnB,qCAAmB;EAAA;EAAnB;IAAA,sCAAmB;IAAnB,qCAAmB;EAAA;EAAnB;IAAA,kCAAmB;IAAnB,iCAAmB;EAAA;EAAnB;IAAA,yCAAmB;IAAnB,oCAAmB;EAAA;EAAnB;IAAA,+CAAmB;IAAnB,0CAAmB;EAAA;EAAnB;IAAA,2CAAmB;IAAnB,sCAAmB;EAAA;EAAnB;IAAA,2CAAmB;IAAnB,sCAAmB;EAAA;EAAnB;IAAA,6CAAmB;IAAnB,wCAAmB;EAAA;EAAnB;IAAA,oCAAmB;IAAnB,qCAAmB;EAAA;EAAnB;IAAA,oCAAmB;IAAnB,qCAAmB;EAAA;EAAnB;IAAA,kBAAmB;EAAA;EAAnB;IAAA,iBAAmB;EAAA;EAAnB;IAAA,eAAmB;EAAA;EAAnB;IAAA,mBAAmB;EAAA;EAAnB;IAAA,uBAAmB;EAAA;EAAnB;IAAA,mBAAmB;EAAA;EAAnB;IAAA,2BAAmB;EAAA;EAAnB;IAAA,4BAAmB;EAAA;EAAnB;IAAA,4BAAmB;EAAA;EAAnB;IAAA,4BAAmB;EAAA;EAAnB;IAAA,4BAAmB;EAAA;EAAnB;IAAA,6BAAmB;EAAA;EAAnB;IAAA,yBAAmB;EAAA;EAAnB;IAAA,wBAAmB;EAAA;EAAnB;IAAA,4BAAmB;EAAA;EAAnB;IAAA,8BAAmB;EAAA;EAAnB;IAAA,gCAAmB;EAAA;EAAnB;IAAA,qBAAmB;EAAA;EAAnB;IAAA,gCAAmB;EAAA;EAAnB;IAAA,kCAAmB;EAAA;EAAnB;IAAA,kBAAmB;EAAA;EAAnB;IAAA,2BAAmB;EAAA;EAAnB;IAAA,4BAAmB;EAAA;EAAnB;IAAA,4BAAmB;EAAA;EAAnB;IAAA,4BAAmB;EAAA;EAAnB;IAAA,4BAAmB;EAAA;EAAnB;IAAA,0BAAmB;EAAA;EAAnB;IAAA,yBAAmB;EAAA;EAAnB;IAAA,oBAAmB;EAAA;EAAnB;IAAA,yBAAmB;EAAA;EAAnB;IAAA,kBAAmB;EAAA;EAAnB;IAAA,kBAAmB;EAAA;EAAnB;IAAA,yCAAmB;IAAnB,iJAAmB;EAAA;EAAnB;IAAA,gCAAmB;IAAnB,iJAAmB;EAAA;EAAnB;IAAA,kCAAmB;IAAnB,iJAAmB;EAAA;EAAnB;IAAA,qBAAmB;IAAnB,iJAAmB;EAAA;EAAnB;IAAA,uCAAmB;IAAnB,iJAAmB;EAAA;EAAnB;IAAA,+BAAmB;IAAnB,iJAAmB;EAAA;EAAnB;IAAA,wCAAmB;IAAnB,iJAAmB;EAAA;EAAnB;IAAA,kCAAmB;IAAnB,iJAAmB;EAAA;EAAnB;IAAA,4BAAmB;EAAA;EAAnB;IAAA,kCAAmB;EAAA;EAAnB;IAAA,0BAAmB;EAAA;EAAnB;IAAA,8BAAmB;EAAA;EAAnB;IAAA,+BAAmB;EAAA;EAAnB;IAAA,0BAAmB;EAAA;EAAnB;IAAA,0BAAmB;EAAA;EAAnB;IAAA,mCAAmB;IAAnB,kCAAmB;EAAA;EAAnB;IAAA,4BAAmB;IAAnB,6BAAmB;EAAA;EAAnB;IAAA,WAAmB;EAAA;EAAnB;IAAA,YAAmB;EAAA;EAAnB;IAAA,aAAmB;EAAA;EAAnB;IAAA,0HAAmB;IAAnB,sIAAmB;EAAA;EAAnB;IAAA,kEAAmB;IAAnB,sIAAmB;EAAA;EAAnB;IAAA,wHAAmB;IAAnB,sIAAmB;EAAA;EAAnB;IAAA,gFAAmB;IAAnB,sIAAmB;EAAA;EAAnB;IAAA,wBAAmB;IAAnB,mBAAmB;IAAnB;MAAA,8BAAmB;MAAnB,mBAAmB;IAAA;EAAA;EAAnB;IAAA,sCAAmB;IAAnB,kBAAmB;EAAA;EAAnB;IAAA,oBAAmB;IAAnB,0LAAmB;EAAA;EAAnB;IAAA,0BAAmB;IAAnB,mHAAmB;IAAnB,4CAAmB;IAAnB,0LAAmB;EAAA;EAAnB;IAAA,2BAAmB;IAAnB,oHAAmB;IAAnB,4CAAmB;IAAnB,0LAAmB;EAAA;EAAnB;IAAA,2BAAmB;IAAnB,oHAAmB;IAAnB,4CAAmB;IAAnB,0LAAmB;EAAA;EAAnB;IAAA,0BAAmB;IAAnB,mHAAmB;IAAnB,4CAAmB;IAAnB,0LAAmB;EAAA;EAAnB;IAAA,0BAAmB;IAAnB,kHAAmB;IAAnB,4CAAmB;IAAnB,0LAAmB;EAAA;EAAnB;IAAA,2BAAmB;IAAnB,mHAAmB;IAAnB,4CAAmB;IAAnB,0LAAmB;EAAA;EAAnB;IAAA,iKAAmB;IAAnB,mGAAmB;IAAnB,0LAAmB;EAAA;EAAnB;IAAA,8FAAmB;IAAnB,qDAAmB;IAAnB,0LAAmB;EAAA;EAAnB;IAAA,4FAAmB;IAAnB,oDAAmB;IAAnB,0LAAmB;EAAA;EAAnB;IAAA,+BAAmB;IAAnB,0LAAmB;EAAA;EAAnB;IAAA,yBAAmB;IAAnB,0LAAmB;EAAA;EAAnB;IAAA,uBAAmB;IAAnB,0LAAmB;EAAA;EAAnB;IAAA,0LAAmB;EAAA;EAAnB;IAAA,6BAAmB;IAAnB,wRAAmB;IAAnB,gRAAmB;EAAA;EAAnB;IAAA,wCAAmB;IAAnB,wRAAmB;IAAnB,gRAAmB;EAAA;EAAnB;IAAA,kCAAmB;IAAnB,wRAAmB;IAAnB,gRAAmB;EAAA;EAAnB;IAAA,gCAAmB;IAAnB,wRAAmB;IAAnB,gRAAmB;EAAA;EAAnB;IAAA,wRAAmB;IAAnB,gRAAmB;EAAA;EAAnB;IAAA,yUAAmB;IAAnB,qFAAmB;IAAnB,2EAAmB;EAAA;EAAnB;IAAA,uCAAmB;IAAnB,qFAAmB;IAAnB,2EAAmB;EAAA;EAAnB;IAAA,kDAAmB;IAAnB,qFAAmB;IAAnB,2EAAmB;EAAA;EAAnB;IAAA,sDAAmB;IAAnB,qFAAmB;IAAnB,2EAAmB;EAAA;EAAnB;IAAA,2BAAmB;IAAnB,qFAAmB;IAAnB,2EAAmB;EAAA;EAAnB;IAAA,0BAAmB;IAAnB,qFAAmB;IAAnB,2EAAmB;EAAA;EAAnB;IAAA,wBAAmB;IAAnB,qFAAmB;IAAnB,2EAAmB;EAAA;EAAnB;IAAA,uKAAmB;IAAnB,qFAAmB;IAAnB,2EAAmB;EAAA;EAAnB;IAAA,4BAAmB;IAAnB,qFAAmB;IAAnB,2EAAmB;EAAA;EAAnB;IAAA,wDAAmB;IAAnB,qFAAmB;IAAnB,2EAAmB;EAAA;EAAnB;IAAA,uBAAmB;EAAA;EAAnB;IAAA,uBAAmB;EAAA;EAAnB;IAAA,oBAAmB;IAAnB,0BAAmB;EAAA;EAAnB;IAAA,oBAAmB;IAAnB,0BAAmB;EAAA;EAAnB;IAAA,oBAAmB;IAAnB,0BAAmB;EAAA;EAAnB;IAAA,oBAAmB;IAAnB,0BAAmB;EAAA;EAAnB;IAAA,yBAAmB;IAAnB,0CAAmB;EAAA;EAAnB;IAAA,6BAAmB;IAAnB,8CAAmB;EAAA;EAAnB;IAAA,iBAAmB;IAAnB,kCAAmB;EAAA;EAAnB;IAAA,0BAAmB;IAAnB,2CAAmB;EAAA;EAAnB;IC93BmtL,8BAA0C;IAAE,qBAAsE;IAAE,mCAA+C;IAAE,0BAA2E;ED83Bh7L;EAAnB;IC93BmtL,8BAA0C;IAAE,oBAAsE;IAAE,mCAA+C;IAAE,yBAA2E;ED83Bh7L;EAAnB;IAAA,wBAAmB;IAAnB,mBAAmB;EAAA;EAAnB;IAAA,yBAAmB;IAAnB,iBAAmB;EAAA;EAAnB;IAAA;MAAA,wBAAmB;IAAA;EAAA;EAAnB;IC93BkgN,4BAA4B;ED83B3gN;EAAnB;IAAA,sBAAmB;EAAA;EAAnB;IC93Bm9M,6BAA6B;ED83B79M;EAAnB;IC93BusO,mBAAmB;ED83BvsO;EAAnB;IC93B+hP,kBAAkB;ED83B9hP;EAAnB;IAAA;MAAA;QAAA,0CAAmB;QAAnB,sDAAmB;MAAA;IAAA;EAAA;EAAnB;IAAA;MAAA;QAAA,0CAAmB;QAAnB,sDAAmB;MAAA;IAAA;EAAA;EAAnB;IAAA;MAAA;QAAA,aAAmB;MAAA;IAAA;EAAA;EAAnB;IAAA;MAAA,oCAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,mCAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,oCAAmB;MAAnB;QAAA,0EAAmB;MAAA;IAAA;EAAA;EAAnB;IAAA;MAAA,yBAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA;QAAA,kBAAmB;QAAnB,kBAAmB;QAAnB,kBAAmB;QAAnB,0CAAmB;MAAA;IAAA;EAAA;EAAnB;IAAA;MAAA;QAAA,kBAAmB;QAAnB,kBAAmB;QAAnB,kBAAmB;QAAnB,0CAAmB;MAAA;IAAA;EAAA;EAAnB;IAAA;MAAA;QAAA,mCAAmB;MAAA;IAAA;EAAA;EAAnB;IAAA;MAAA;QAAA,+BAAmB;MAAA;IAAA;EAAA;EAAnB;IAAA;MAAA;QAAA,oCAAmB;QAAnB;UAAA,0EAAmB;QAAA;MAAA;IAAA;EAAA;EAAnB;IAAA;MAAA;QAAA,mCAAmB;QAAnB;UAAA,yEAAmB;QAAA;MAAA;IAAA;EAAA;EAAnB;IAAA;MAAA;QAAA,mCAAmB;QAAnB;UAAA,yEAAmB;QAAA;MAAA;IAAA;EAAA;EAAnB;IAAA;MAAA;QAAA,8BAAmB;MAAA;IAAA;EAAA;EAAnB;IAAA;MAAA;QAAA,gCAAmB;QAAnB;UAAA,sEAAmB;QAAA;MAAA;IAAA;EAAA;EAAnB;IAAA;MAAA;QAAA,uCAAmB;MAAA;IAAA;EAAA;EAAnB;IAAA;MAAA;QAAA,uCAAmB;MAAA;IAAA;EAAA;EAAnB;IAAA;MAAA;QAAA,+BAAmB;MAAA;IAAA;EAAA;EAAnB;IAAA;MAAA;QAAA,wBAAmB;MAAA;IAAA;EAAA;EAAnB;IAAA;MAAA;QAAA,8BAAmB;MAAA;IAAA;EAAA;EAAnB;IAAA;MAAA;QAAA,4BAAmB;MAAA;IAAA;EAAA;EAAnB;IAAA;MAAA;QAAA,+BAAmB;MAAA;IAAA;EAAA;EAAnB;IAAA;MAAA;QAAA;UAAA,wBAAmB;QAAA;MAAA;IAAA;EAAA;EAAnB;IAAA;MAAA,kBAAmB;MAAnB,kBAAmB;MAAnB,kBAAmB;MAAnB,0CAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,+BAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,oCAAmB;MAAnB;QAAA,0EAAmB;MAAA;IAAA;EAAA;EAAnB;IAAA;MAAA,mCAAmB;MAAnB;QAAA,yEAAmB;MAAA;IAAA;EAAA;EAAnB;IAAA;MAAA,8BAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,gCAAmB;MAAnB;QAAA,sEAAmB;MAAA;IAAA;EAAA;EAAnB;IAAA;MAAA,+BAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,wBAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,wBAAmB;MAAnB,mBAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA;QAAA,yBAAmB;MAAA;IAAA;EAAA;EAAnB;IAAA;MAAA,yBAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,wHAAmB;MAAnB,sIAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,mCAAmB;MAAnB;QAAA,yEAAmB;MAAA;IAAA;EAAA;EAAnB;IAAA;MAAA,4BAAmB;MAAnB;QAAA,kEAAmB;MAAA;IAAA;EAAA;EAAnB;IAAA;MAAA,oBAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,mBAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,YAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,aAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,WAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,0BAAmB;MAAnB,6BAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,0CAAmB;MAAnB,uBAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,uCAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,mDAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,oCAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,0CAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,wCAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,wCAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,cAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,0BAAmB;MAAnB,6BAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,uCAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,sCAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,gCAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,mCAAmB;MAAnB;QAAA,yEAAmB;MAAA;IAAA;EAAA;EAAnB;IAAA;MAAA,8BAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,oBAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,YAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,mCAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,8BAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,8BAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,0CAAmB;MAAnB,sDAAmB;IAAA;EAAA;EAAnB;IAAA;MC93BiuR,mDAAsD;ID83BpwR;EAAA;EAAnB;IAAA;MAAA,2CAAmB;MAAnB,sDAAmB;IAAA;EAAA;EAAnB;IAAA;MC93BqxT,gDAAmD;ID83BrzT;EAAA;EAAnB;IAAA;MAAA,0CAAmB;MAAnB,sDAAmB;IAAA;EAAA;EAAnB;IAAA;MC93B06S,mDAAsD;ID83B78S;EAAA;EAAnB;IAAA;MAAA,2CAAmB;MAAnB,sDAAmB;IAAA;EAAA;EAAnB;IAAA;MC93B8kS,gDAAmD;ID83B9mS;EAAA;EAAnB;IAAA;MAAA,gCAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,gCAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA;QAAA,yBAAmB;QAAnB;UAAA,+DAAmB;QAAA;MAAA;IAAA;EAAA;EAAnB;IAAA;MAAA;QAAA,gBAAmB;QAAnB,oBAAmB;QAAnB,4BAAmB;QAAnB,qBAAmB;MAAA;IAAA;EAAA;EAAnB;IAAA;MAAA;QAAA,aAAmB;MAAA;IAAA;EAAA;EAAnB;IAAA;MAAA;QAAA,mBAAmB;MAAA;IAAA;EAAA;EAAnB;IAAA;MAAA;QAAA,6BAAmB;MAAA;IAAA;EAAA;EAAnB;IAAA;MAAA,8NAAmB;IAAA;EAAA;EAAnB;IAAA;MC93BwlO,8BAA4C;MAAE,oBAA8C;ID83BjqO;EAAA;EAAnB;IAAA;MC93BukP,4BAAyC;MAAyC,oBAA4C;ID83BlrP;EAAA;EAAnB;IAAA;MAAA,+BAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,iFAAmB;MAAnB;QAAA,6EAAmB;MAAA;IAAA;EAAA;EAAnB;IAAA;MAAA,8BAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,+BAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,4BAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA;QAAA;UAAA,iFAAmB;UAAnB;YAAA,6EAAmB;UAAA;QAAA;MAAA;IAAA;EAAA;EAAnB;IAAA;MAAA;QAAA;UAAA,mCAAmB;UAAnB;YAAA,yEAAmB;UAAA;QAAA;MAAA;IAAA;EAAA;EAAnB;IAAA;MAAA,+NAAmB;IAAA;EAAA;EAAnB;IAAA;MC93B47N,+BAA6C;MAAE,qBAA+C;ID83BvgO;EAAA;EAAnB;IAAA;MC93B+uO,6BAA0C;MAA0C,qBAA6C;ID83B71O;EAAA;EAAnB;IAAA;MAAA,uCAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,8BAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,iCAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,UAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,oCAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,cAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,aAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,aAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,eAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,gCAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,YAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,0CAAmB;MAAnB,sDAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,0BAAmB;MAAnB,6BAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,0CAAmB;MAAnB,uBAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,wCAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,wCAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,uCAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,yCAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,qBAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,yBAAmB;MAAnB,2DAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,cAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,aAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,0BAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,0BAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,8BAAmB;MAAnB;QAAA,oEAAmB;MAAA;IAAA;EAAA;EAAnB;IAAA;MAAA;QAAA;UAAA,+BAAmB;UAAnB;YAAA,qEAAmB;UAAA;QAAA;MAAA;IAAA;EAAA;EAAnB;IAAA;MAAA;QAAA;UAAA,8BAAmB;UAAnB;YAAA,oEAAmB;UAAA;QAAA;MAAA;IAAA;EAAA;EAAnB;IAAA;MAAA;QAAA,mCAAmB;QAAnB;UAAA,yEAAmB;QAAA;MAAA;IAAA;EAAA;EAAnB;IAAA;MAAA;QAAA,mCAAmB;QAAnB;UAAA,yEAAmB;QAAA;MAAA;IAAA;EAAA;EAAnB;IAAA;MAAA;QAAA,4BAAmB;MAAA;IAAA;EAAA;EAAnB;IAAA;MAAA,oCAAmB;MAAnB,mCAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,oBAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,cAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,+BAAmB;MAAnB,gCAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,8BAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,iCAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,kBAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,uBAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,iCAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,kBAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,2CAAmB;MAAnB,sCAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA;QAAA;UAAA,aAAmB;QAAA;MAAA;IAAA;EAAA;EAAnB;IAAA;MAAA;QAAA;UAAA,mBAAmB;QAAA;MAAA;IAAA;EAAA;EAAnB;IAAA;MAAA;QAAA;UAAA,6BAAmB;QAAA;MAAA;IAAA;EAAA;EAAnB;IAAA;MAAA,8BAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,+BAAmB;MAAnB,gCAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,4CAAmB;MAAnB,sDAAmB;IAAA;EAAA;EAAnB;IAAA;MAAA,mBAAmB;IAAA;EAAA;AADJ;AC73BjB;EAA+B,WAAU;EAAC,eAAc;EAAC,iBAAgB;AAA3C;AAA4C;EAAmC,WAAU;EAAC,eAAc;EAAC,qBAAoB;AAA/C;AAAgD;EAAkC,WAAU;EAAC,eAAc;AAA1B;AAA2B;EAAmC,WAAU;EAAC,eAAc;EAAC,mBAAkB;AAA7C;AAA8C;EAAyC,WAAU;EAAC,eAAc;EAAC,gBAAe;AAA1C;AAA2C;EAA0B,WAAU;EAAC,eAAc;EAAC,gBAAe;AAA1C;AAA2C;EAA6B,WAAU;EAAC,eAAc;EAAC,gBAAe;AAA1C;AAA2C;EAA4B,WAAU;EAAC,eAAc;EAAC,gBAAe;AAA1C;AAA2C;EAA2B,WAAU;EAAC,eAAc;EAAC,gBAAe;AAA1C;AAA2C;EAAiC,WAAU;EAAC,eAAc;EAAC,gBAAe;AAA1C;AAA2C;EAAiC,WAAU;EAAC,eAAc;EAAC,gBAAe;AAA1C;AAA2C;EAAyB,WAAU;EAAC,eAAc;EAAC,gBAAe;AAA1C;AAA2C;EAA4B,WAAU;EAAC,eAAc;EAAC,gBAAe;AAA1C;AAA2C;EAA2B,WAAU;EAAC,eAAc;EAAC,gBAAe;AAA1C;AAA2C;EAA0B,WAAU;EAAC,eAAc;EAAC,gBAAe;AAA1C;AAA2C;EAAgC,WAAU;EAAC,eAAc;EAAC,gBAAe;AAA1C;AAA2C;EAAgC,WAAU;EAAC,eAAc;EAAC,gBAAe;AAA1C;ACKlqC;EACE,kBAAmB;EACnB,0BAA2B;EAC3B,8BAA+B;EAC/B,oBAAqB;EACrB,mCAAoC;EACpC,uBAAwB;EACxB,sCAAuC;EACvC,2BAA4B;EAC5B,sCAAuC;EACvC,4BAA6B;EAC7B,wCAAyC;EACzC,wBAAyB;EACzB,oCAAqC;EACrC,yBAA0B;EAC1B,qCAAsC;EACtC,wCAAyC;EACzC,0BAA2B;EAC3B,yBAA0B;EAC1B,wBAAyB;EACzB,oCAAqC;EACrC,mCAAoC;EACpC,oCAAqC;EACrC,oCAAqC;EACrC,mCAAoC;EACpC,2BAA4B;EAC5B,sCAAuC;EACvC,mCAAoC;EACpC,8CAA+C;EAC/C,iCAAkC;EAClC,6CAA8C;EAC9C,kCAAmC;EACnC,gCAAiC;AAClC;AAED;EACE,8BAA+B;EAC/B,8BAA+B;EAC/B,wBAAyB;EACzB,mCAAoC;EACpC,2BAA4B;EAC5B,sCAAuC;EACvC,2BAA4B;EAC5B,sCAAuC;EACvC,6BAA8B;EAC9B,wCAAyC;EACzC,yBAA0B;EAC1B,oCAAqC;EACrC,0BAA2B;EAC3B,qCAAsC;EACtC,wCAAyC;EACzC,4BAA6B;EAC7B,2BAA4B;EAC5B,wBAAyB;EACzB,qCAAsC;EACtC,mCAAoC;EACpC,mCAAoC;EACpC,mCAAoC;EACpC,oCAAqC;EACrC,2BAA4B;EAC5B,sCAAuC;EACvC,6CAA8C;EAC9C,8CAA+C;EAC/C,kCAAmC;EACnC,6CAA8C;EAC9C,oCAAqC;EACrC,gCAAiC;AAClC;AA2CD;EACE;IACS,+BAAoB;IAApB;MAAA,qEAAoB;IAAA;IAAC,0BAAe;IAAf;MAAA,gEAAe;IAAA;EAC5C;EACD;IACS,mCAAa;IAAC,wBAAe;EACrC;AACF;AAED;EACE;IACE,qBAAsB;IACtB,sBAAuB;IACvB,mCAAoC;IACpC,4BAA6B;IAC7B;;;;;;;;OAQI;IACJ;;;;;;;OAOI;IACJ,4BAA6B;IAC7B,yBAA0B;IAC1B,qBAAsB;EACvB;EAED;IACE;MACE,4BAA6B;IAC9B;IACD;MACE,2BAA4B;IAC7B;EACF;AACF;AF8tBC;EAAA,WAAmB;EAAnB,eAAmB;EAAnB,gBAAmB;AAAA;AAAnB;EAAA,WAAmB;EAAnB,eAAmB;EAAnB,gBAAmB;AAAA;AAAnB;EAAA,WAAmB;EAAnB,eAAmB;EAAnB,gBAAmB;AAAA;AAAnB;EAAA,WAAmB;EAAnB,eAAmB;EAAnB,gBAAmB;AAAA;AAAnB;EAAA,WAAmB;EAAnB,eAAmB;EAAnB,gBAAmB;AAAA;AAAnB;EAAA,WAAmB;EAAnB,eAAmB;EAAnB,gBAAmB;AAAA;AAAnB;EAAA,WAAmB;EAAnB,eAAmB;AAAA;AAAnB;EAAA,WAAmB;EAAnB,eAAmB;AAAA;AAAnB;EAAA,WAAmB;EAAnB,eAAmB;AAAA;AAAnB;EAAA,WAAmB;EAAnB,eAAmB;AAAA;AAAnB;EAAA,WAAmB;EAAnB,eAAmB;AAAA;AAAnB;EAAA,WAAmB;EAAnB,eAAmB;AAAA;AAAnB;EAAA,WAAmB;EAAnB,eAAmB;AAAA;AAAnB;EAAA,WAAmB;EAAnB,eAAmB;AAAA;AAAnB;EAAA,WAAmB;EAAnB,eAAmB;EAAnB,gBAAmB;AAAA;AAAnB;EAAA,WAAmB;EAAnB,eAAmB;EAAnB,gBAAmB;AAAA;AAAnB;EAAA,WAAmB;EAAnB,eAAmB;EAAnB,gBAAmB;AAAA;AAAnB;EAAA,WAAmB;EAAnB,eAAmB;EAAnB,oBAAmB;AAAA;AAAnB;EAAA,WAAmB;EAAnB,eAAmB;EAAnB,gBAAmB;AAAA;AAAnB;EAAA,WAAmB;EAAnB,eAAmB;AAAA;AAAnB;EAAA,iBAAmB;EAAnB,eAAmB;EAAnB,oBAAmB;AAAA;AAAnB;EAAA,iBAAmB;EAAnB,eAAmB;EAAnB,oBAAmB;AAAA;AAAnB;EAAA,iBAAmB;EAAnB,eAAmB;EAAnB,oBAAmB;AAAA;AAAnB;EAAA,WAAmB;EAAnB,eAAmB;AAAA;AAAnB;EAAA,WAAmB;EAAnB,eAAmB;AAAA;AAAnB;EAAA,6BAAmB;EAAnB,eAAmB;EAAnB,iBAAmB;AAAA;AAAnB;EAAA,6BAAmB;EAAnB,eAAmB;EAAnB,kBAAmB;AAAA;AAAnB;EAAA,6BAAmB;EAAnB,eAAmB;EAAnB,mBAAmB;AAAA;AAAnB;EAAA,WAAmB;EAAnB,eAAmB;AAAA;AAAnB;EAAA,WAAmB;EAAnB,eAAmB;AAAA;AAAnB;EAAA,WAAmB;EAAnB,eAAmB;AAAA;AAAnB;EAAA,WAAmB;EAAnB,eAAmB;AAAA;AAAnB;EAAA,WAAmB;EAAnB,eAAmB;AAAA;AAAnB;EAAA,WAAmB;EAAnB,eAAmB;AAAA;AAAnB;EAAA,WAAmB;EAAnB,eAAmB;AAAA;AAAnB;EAAA,WAAmB;EAAnB,eAAmB;AAAA;AAAnB;EAAA,WAAmB;EAAnB,eAAmB;EAAnB,wBAAmB;AAAA;AAAnB;EAAA,WAAmB;EAAnB,eAAmB;AAAA;AAAnB;EAAA,sBAAmB;EAAnB,eAAmB;EAAnB,mBAAmB;AAAA;AAAnB;EAAA,WAAmB;EAAnB,eAAmB;EAAnB,wBAAmB;AAAA;AAAnB;EAAA,WAAmB;EAAnB,eAAmB;AAAA;AAAnB;EAAA,sBAAmB;EAAnB,eAAmB;EAAnB,mBAAmB;AAAA;AAAnB;EAAA,WAAmB;EAAnB,eAAmB;AAAA;AAAnB;EAAA,WAAmB;EAAnB,eAAmB;EAAnB,wBAAmB;AAAA;AAAnB;EAAA,WAAmB;EAAnB,eAAmB;AAAA;AAAnB;EAAA,WAAmB;EAAnB,eAAmB;EAAnB,wBAAmB;AAAA;AAAnB;EAAA,WAAmB;EAAnB,eAAmB;AAAA;AAAnB;EAAA,kBAAmB;EAAnB,eAAmB;EAAnB,kBAAmB;AAAA;AAAnB;EAAA,WAAmB;EAAnB,eAAmB;EAAnB,mBAAmB;AAAA;AAAnB;EAAA,WAAmB;EAAnB,eAAmB;EAAnB,wBAAmB;AAAA;AAAnB;EAAA,WAAmB;EAAnB,eAAmB;EAAnB,oBAAmB;AAAA;AAAnB;EAAA,WAAmB;EAAnB,eAAmB;AAAA;AAAnB;EAAA,WAAmB;EAAnB,eAAmB;AAAA;AAAnB;EAAA,WAAmB;EAAnB,eAAmB;AAAA;AAAnB;EAAA,WAAmB;EAAnB,eAAmB;AAAA;AAAnB;EAAA,WAAmB;EAAnB,eAAmB;AAAA;AAAnB;EAAA,WAAmB;EAAnB,eAAmB;AAAA;AAAnB;EAAA,WAAmB;EAAnB,eAAmB;AAAA;AAAnB;EAAA,WAAmB;EAAnB,eAAmB;AAAA;AAAnB;EAAA,WAAmB;EAAnB,eAAmB;AAAA;AAAnB;EAAA,WAAmB;EAAnB,eAAmB;AAAA;AAAnB;EAAA,WAAmB;EAAnB,eAAmB;AAAA;AAAnB;EAAA,sBAAmB;EAAnB,eAAmB;EAAnB,mBAAmB;AAAA;AAAnB;EAAA,WAAmB;EAAnB,eAAmB;AAAA;AAAnB;EAAA,WAAmB;EAAnB,eAAmB;AAAA;AAAnB;EAAA,WAAmB;EAAnB,eAAmB;AAAA;AAAnB;EAAA,WAAmB;EAAnB,eAAmB;AAAA;AAAnB;EAAA,WAAmB;EAAnB,eAAmB;AAAA;AAAnB;EAAA,WAAmB;EAAnB,eAAmB;AAAA;AAAnB;EAAA,WAAmB;EAAnB,eAAmB;AAAA;AAAnB;EAAA,WAAmB;EAAnB,eAAmB;AAAA;AAAnB;EAAA,WAAmB;EAAnB,eAAmB;AAAA;AAAnB;EAAA,WAAmB;EAAnB,eAAmB;AAAA;AAAnB;EAAA,WAAmB;EAAnB,eAAmB;AAAA;AAAnB;EAAA,WAAmB;EAAnB,eAAmB;AAAA;AA3ejB;EACE;IACE,yBAAyB;EADxB;AADW;ACnZkxF;EAAmB;IAAO,kCAAkC;IAAE,qMAAqM;IAAE,oCAAoC;EAAjR;AAAP;AAA4R;EAAkB;IAAK,iCAAiC;IAAE,+LAA+L;IAAE,mCAAmC;EAAzQ;AAAL;AD83BjmG;EAAA;IAAA;MAAA,mBAAmB;MAAnB,mBAAmB;MAAnB,mBAAmB;MAAnB,eAAmB;MAAnB,eAAmB;MAAnB,eAAmB;MAAnB,sBAAmB;MAAnB,sBAAmB;MAAnB,sBAAmB;MAAnB,oBAAmB;MAAnB,oBAAmB;MAAnB,mBAAmB;MAAnB,mBAAmB;MAAnB,wBAAmB;MAAnB,uBAAmB;MAAnB,uBAAmB;MAAnB,wBAAmB;MAAnB,wBAAmB;MAAnB,wBAAmB;MAAnB,+BAAmB;MAAnB,yBAAmB;MAAnB,wBAAmB;MAAnB,uBAAmB;MAAnB,4BAAmB;MAAnB,gCAAmB;MAAnB,+BAAmB;MAAnB,+BAAmB;MAAnB,+BAAmB;MAAnB,qBAAmB;MAAnB,yBAAmB;MAAnB,sBAAmB;MAAnB,qBAAmB;MAAnB,0BAAmB;MAAnB,4BAAmB;MAAnB,6BAAmB;MAAnB,8BAAmB;MAAnB,sBAAmB;MAAnB,0BAAmB;MAAnB,uBAAmB;MAAnB,4BAAmB;MAAnB,gCAAmB;MAAnB,6BAAmB;MAAnB,wBAAmB;MAAnB,2BAAmB;MAAnB,8BAAmB;MAAnB,iCAAmB;MAAnB,wBAAmB;MAAnB,2BAAmB;MAAnB,4BAAmB;MAAnB,kCAAmB;MAAnB,yBAAmB;MAAnB,kBAAmB;MAAnB,wBAAmB;MAAnB,sBAAmB;MAAnB,uBAAmB;MAAnB,wBAAmB;MAAnB,oBAAmB;MAAnB,qBAAmB;MAAnB,sBAAmB;MAAnB,mBAAmB;MAAnB,yBAAmB;MAAnB,+BAAmB;MAAnB,4BAAmB;MAAnB,8BAAmB;MAAnB,2BAAmB;MAAnB,iCAAmB;MAAnB,+BAAmB;MAAnB,gCAAmB;MAAnB,iCAAmB;MAAnB,6BAAmB;MAAnB,8BAAmB;MAAnB,+BAAmB;MAAnB,4BAAmB;MAAnB,sBAAmB;MAAnB,kBAAmB;MC93BrB,wBAA8B;MAA4C,gCAAkC;MAAgD,gCAAiC;MAA2B,8BAAkC;MAA8C,iCAAwC;MAA2C,kBAAyB;MAA2C,qBAA4B;MAA2C,oBAA2B;MAA2C,mBAA0B;MAA2C,yBAAgC;MAA2C,yBAAgC;MAA2C,iBAAwB;MAA2C,oBAA2B;MAA2C,mBAA0B;MAA2C,kBAAyB;MAA2C,wBAA+B;MAA2C,wBAA+B;ID83B7oC;EAAA;AAAA',
          sourcesContent: [
            null,
            '@layer theme, base, components, utilities;\n\n@layer theme {\n  @theme default {\n    --font-sans:\n      ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji",\n      "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";\n    --font-serif: ui-serif, Georgia, Cambria, "Times New Roman", Times, serif;\n    --font-mono:\n      ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono",\n      "Courier New", monospace;\n\n    --color-red-50: oklch(97.1% 0.013 17.38);\n    --color-red-100: oklch(93.6% 0.032 17.717);\n    --color-red-200: oklch(88.5% 0.062 18.334);\n    --color-red-300: oklch(80.8% 0.114 19.571);\n    --color-red-400: oklch(70.4% 0.191 22.216);\n    --color-red-500: oklch(63.7% 0.237 25.331);\n    --color-red-600: oklch(57.7% 0.245 27.325);\n    --color-red-700: oklch(50.5% 0.213 27.518);\n    --color-red-800: oklch(44.4% 0.177 26.899);\n    --color-red-900: oklch(39.6% 0.141 25.723);\n    --color-red-950: oklch(25.8% 0.092 26.042);\n\n    --color-orange-50: oklch(98% 0.016 73.684);\n    --color-orange-100: oklch(95.4% 0.038 75.164);\n    --color-orange-200: oklch(90.1% 0.076 70.697);\n    --color-orange-300: oklch(83.7% 0.128 66.29);\n    --color-orange-400: oklch(75% 0.183 55.934);\n    --color-orange-500: oklch(70.5% 0.213 47.604);\n    --color-orange-600: oklch(64.6% 0.222 41.116);\n    --color-orange-700: oklch(55.3% 0.195 38.402);\n    --color-orange-800: oklch(47% 0.157 37.304);\n    --color-orange-900: oklch(40.8% 0.123 38.172);\n    --color-orange-950: oklch(26.6% 0.079 36.259);\n\n    --color-amber-50: oklch(98.7% 0.022 95.277);\n    --color-amber-100: oklch(96.2% 0.059 95.617);\n    --color-amber-200: oklch(92.4% 0.12 95.746);\n    --color-amber-300: oklch(87.9% 0.169 91.605);\n    --color-amber-400: oklch(82.8% 0.189 84.429);\n    --color-amber-500: oklch(76.9% 0.188 70.08);\n    --color-amber-600: oklch(66.6% 0.179 58.318);\n    --color-amber-700: oklch(55.5% 0.163 48.998);\n    --color-amber-800: oklch(47.3% 0.137 46.201);\n    --color-amber-900: oklch(41.4% 0.112 45.904);\n    --color-amber-950: oklch(27.9% 0.077 45.635);\n\n    --color-yellow-50: oklch(98.7% 0.026 102.212);\n    --color-yellow-100: oklch(97.3% 0.071 103.193);\n    --color-yellow-200: oklch(94.5% 0.129 101.54);\n    --color-yellow-300: oklch(90.5% 0.182 98.111);\n    --color-yellow-400: oklch(85.2% 0.199 91.936);\n    --color-yellow-500: oklch(79.5% 0.184 86.047);\n    --color-yellow-600: oklch(68.1% 0.162 75.834);\n    --color-yellow-700: oklch(55.4% 0.135 66.442);\n    --color-yellow-800: oklch(47.6% 0.114 61.907);\n    --color-yellow-900: oklch(42.1% 0.095 57.708);\n    --color-yellow-950: oklch(28.6% 0.066 53.813);\n\n    --color-lime-50: oklch(98.6% 0.031 120.757);\n    --color-lime-100: oklch(96.7% 0.067 122.328);\n    --color-lime-200: oklch(93.8% 0.127 124.321);\n    --color-lime-300: oklch(89.7% 0.196 126.665);\n    --color-lime-400: oklch(84.1% 0.238 128.85);\n    --color-lime-500: oklch(76.8% 0.233 130.85);\n    --color-lime-600: oklch(64.8% 0.2 131.684);\n    --color-lime-700: oklch(53.2% 0.157 131.589);\n    --color-lime-800: oklch(45.3% 0.124 130.933);\n    --color-lime-900: oklch(40.5% 0.101 131.063);\n    --color-lime-950: oklch(27.4% 0.072 132.109);\n\n    --color-green-50: oklch(98.2% 0.018 155.826);\n    --color-green-100: oklch(96.2% 0.044 156.743);\n    --color-green-200: oklch(92.5% 0.084 155.995);\n    --color-green-300: oklch(87.1% 0.15 154.449);\n    --color-green-400: oklch(79.2% 0.209 151.711);\n    --color-green-500: oklch(72.3% 0.219 149.579);\n    --color-green-600: oklch(62.7% 0.194 149.214);\n    --color-green-700: oklch(52.7% 0.154 150.069);\n    --color-green-800: oklch(44.8% 0.119 151.328);\n    --color-green-900: oklch(39.3% 0.095 152.535);\n    --color-green-950: oklch(26.6% 0.065 152.934);\n\n    --color-emerald-50: oklch(97.9% 0.021 166.113);\n    --color-emerald-100: oklch(95% 0.052 163.051);\n    --color-emerald-200: oklch(90.5% 0.093 164.15);\n    --color-emerald-300: oklch(84.5% 0.143 164.978);\n    --color-emerald-400: oklch(76.5% 0.177 163.223);\n    --color-emerald-500: oklch(69.6% 0.17 162.48);\n    --color-emerald-600: oklch(59.6% 0.145 163.225);\n    --color-emerald-700: oklch(50.8% 0.118 165.612);\n    --color-emerald-800: oklch(43.2% 0.095 166.913);\n    --color-emerald-900: oklch(37.8% 0.077 168.94);\n    --color-emerald-950: oklch(26.2% 0.051 172.552);\n\n    --color-teal-50: oklch(98.4% 0.014 180.72);\n    --color-teal-100: oklch(95.3% 0.051 180.801);\n    --color-teal-200: oklch(91% 0.096 180.426);\n    --color-teal-300: oklch(85.5% 0.138 181.071);\n    --color-teal-400: oklch(77.7% 0.152 181.912);\n    --color-teal-500: oklch(70.4% 0.14 182.503);\n    --color-teal-600: oklch(60% 0.118 184.704);\n    --color-teal-700: oklch(51.1% 0.096 186.391);\n    --color-teal-800: oklch(43.7% 0.078 188.216);\n    --color-teal-900: oklch(38.6% 0.063 188.416);\n    --color-teal-950: oklch(27.7% 0.046 192.524);\n\n    --color-cyan-50: oklch(98.4% 0.019 200.873);\n    --color-cyan-100: oklch(95.6% 0.045 203.388);\n    --color-cyan-200: oklch(91.7% 0.08 205.041);\n    --color-cyan-300: oklch(86.5% 0.127 207.078);\n    --color-cyan-400: oklch(78.9% 0.154 211.53);\n    --color-cyan-500: oklch(71.5% 0.143 215.221);\n    --color-cyan-600: oklch(60.9% 0.126 221.723);\n    --color-cyan-700: oklch(52% 0.105 223.128);\n    --color-cyan-800: oklch(45% 0.085 224.283);\n    --color-cyan-900: oklch(39.8% 0.07 227.392);\n    --color-cyan-950: oklch(30.2% 0.056 229.695);\n\n    --color-sky-50: oklch(97.7% 0.013 236.62);\n    --color-sky-100: oklch(95.1% 0.026 236.824);\n    --color-sky-200: oklch(90.1% 0.058 230.902);\n    --color-sky-300: oklch(82.8% 0.111 230.318);\n    --color-sky-400: oklch(74.6% 0.16 232.661);\n    --color-sky-500: oklch(68.5% 0.169 237.323);\n    --color-sky-600: oklch(58.8% 0.158 241.966);\n    --color-sky-700: oklch(50% 0.134 242.749);\n    --color-sky-800: oklch(44.3% 0.11 240.79);\n    --color-sky-900: oklch(39.1% 0.09 240.876);\n    --color-sky-950: oklch(29.3% 0.066 243.157);\n\n    --color-blue-50: oklch(97% 0.014 254.604);\n    --color-blue-100: oklch(93.2% 0.032 255.585);\n    --color-blue-200: oklch(88.2% 0.059 254.128);\n    --color-blue-300: oklch(80.9% 0.105 251.813);\n    --color-blue-400: oklch(70.7% 0.165 254.624);\n    --color-blue-500: oklch(62.3% 0.214 259.815);\n    --color-blue-600: oklch(54.6% 0.245 262.881);\n    --color-blue-700: oklch(48.8% 0.243 264.376);\n    --color-blue-800: oklch(42.4% 0.199 265.638);\n    --color-blue-900: oklch(37.9% 0.146 265.522);\n    --color-blue-950: oklch(28.2% 0.091 267.935);\n\n    --color-indigo-50: oklch(96.2% 0.018 272.314);\n    --color-indigo-100: oklch(93% 0.034 272.788);\n    --color-indigo-200: oklch(87% 0.065 274.039);\n    --color-indigo-300: oklch(78.5% 0.115 274.713);\n    --color-indigo-400: oklch(67.3% 0.182 276.935);\n    --color-indigo-500: oklch(58.5% 0.233 277.117);\n    --color-indigo-600: oklch(51.1% 0.262 276.966);\n    --color-indigo-700: oklch(45.7% 0.24 277.023);\n    --color-indigo-800: oklch(39.8% 0.195 277.366);\n    --color-indigo-900: oklch(35.9% 0.144 278.697);\n    --color-indigo-950: oklch(25.7% 0.09 281.288);\n\n    --color-violet-50: oklch(96.9% 0.016 293.756);\n    --color-violet-100: oklch(94.3% 0.029 294.588);\n    --color-violet-200: oklch(89.4% 0.057 293.283);\n    --color-violet-300: oklch(81.1% 0.111 293.571);\n    --color-violet-400: oklch(70.2% 0.183 293.541);\n    --color-violet-500: oklch(60.6% 0.25 292.717);\n    --color-violet-600: oklch(54.1% 0.281 293.009);\n    --color-violet-700: oklch(49.1% 0.27 292.581);\n    --color-violet-800: oklch(43.2% 0.232 292.759);\n    --color-violet-900: oklch(38% 0.189 293.745);\n    --color-violet-950: oklch(28.3% 0.141 291.089);\n\n    --color-purple-50: oklch(97.7% 0.014 308.299);\n    --color-purple-100: oklch(94.6% 0.033 307.174);\n    --color-purple-200: oklch(90.2% 0.063 306.703);\n    --color-purple-300: oklch(82.7% 0.119 306.383);\n    --color-purple-400: oklch(71.4% 0.203 305.504);\n    --color-purple-500: oklch(62.7% 0.265 303.9);\n    --color-purple-600: oklch(55.8% 0.288 302.321);\n    --color-purple-700: oklch(49.6% 0.265 301.924);\n    --color-purple-800: oklch(43.8% 0.218 303.724);\n    --color-purple-900: oklch(38.1% 0.176 304.987);\n    --color-purple-950: oklch(29.1% 0.149 302.717);\n\n    --color-fuchsia-50: oklch(97.7% 0.017 320.058);\n    --color-fuchsia-100: oklch(95.2% 0.037 318.852);\n    --color-fuchsia-200: oklch(90.3% 0.076 319.62);\n    --color-fuchsia-300: oklch(83.3% 0.145 321.434);\n    --color-fuchsia-400: oklch(74% 0.238 322.16);\n    --color-fuchsia-500: oklch(66.7% 0.295 322.15);\n    --color-fuchsia-600: oklch(59.1% 0.293 322.896);\n    --color-fuchsia-700: oklch(51.8% 0.253 323.949);\n    --color-fuchsia-800: oklch(45.2% 0.211 324.591);\n    --color-fuchsia-900: oklch(40.1% 0.17 325.612);\n    --color-fuchsia-950: oklch(29.3% 0.136 325.661);\n\n    --color-pink-50: oklch(97.1% 0.014 343.198);\n    --color-pink-100: oklch(94.8% 0.028 342.258);\n    --color-pink-200: oklch(89.9% 0.061 343.231);\n    --color-pink-300: oklch(82.3% 0.12 346.018);\n    --color-pink-400: oklch(71.8% 0.202 349.761);\n    --color-pink-500: oklch(65.6% 0.241 354.308);\n    --color-pink-600: oklch(59.2% 0.249 0.584);\n    --color-pink-700: oklch(52.5% 0.223 3.958);\n    --color-pink-800: oklch(45.9% 0.187 3.815);\n    --color-pink-900: oklch(40.8% 0.153 2.432);\n    --color-pink-950: oklch(28.4% 0.109 3.907);\n\n    --color-rose-50: oklch(96.9% 0.015 12.422);\n    --color-rose-100: oklch(94.1% 0.03 12.58);\n    --color-rose-200: oklch(89.2% 0.058 10.001);\n    --color-rose-300: oklch(81% 0.117 11.638);\n    --color-rose-400: oklch(71.2% 0.194 13.428);\n    --color-rose-500: oklch(64.5% 0.246 16.439);\n    --color-rose-600: oklch(58.6% 0.253 17.585);\n    --color-rose-700: oklch(51.4% 0.222 16.935);\n    --color-rose-800: oklch(45.5% 0.188 13.697);\n    --color-rose-900: oklch(41% 0.159 10.272);\n    --color-rose-950: oklch(27.1% 0.105 12.094);\n\n    --color-slate-50: oklch(98.4% 0.003 247.858);\n    --color-slate-100: oklch(96.8% 0.007 247.896);\n    --color-slate-200: oklch(92.9% 0.013 255.508);\n    --color-slate-300: oklch(86.9% 0.022 252.894);\n    --color-slate-400: oklch(70.4% 0.04 256.788);\n    --color-slate-500: oklch(55.4% 0.046 257.417);\n    --color-slate-600: oklch(44.6% 0.043 257.281);\n    --color-slate-700: oklch(37.2% 0.044 257.287);\n    --color-slate-800: oklch(27.9% 0.041 260.031);\n    --color-slate-900: oklch(20.8% 0.042 265.755);\n    --color-slate-950: oklch(12.9% 0.042 264.695);\n\n    --color-gray-50: oklch(98.5% 0.002 247.839);\n    --color-gray-100: oklch(96.7% 0.003 264.542);\n    --color-gray-200: oklch(92.8% 0.006 264.531);\n    --color-gray-300: oklch(87.2% 0.01 258.338);\n    --color-gray-400: oklch(70.7% 0.022 261.325);\n    --color-gray-500: oklch(55.1% 0.027 264.364);\n    --color-gray-600: oklch(44.6% 0.03 256.802);\n    --color-gray-700: oklch(37.3% 0.034 259.733);\n    --color-gray-800: oklch(27.8% 0.033 256.848);\n    --color-gray-900: oklch(21% 0.034 264.665);\n    --color-gray-950: oklch(13% 0.028 261.692);\n\n    --color-zinc-50: oklch(98.5% 0 0);\n    --color-zinc-100: oklch(96.7% 0.001 286.375);\n    --color-zinc-200: oklch(92% 0.004 286.32);\n    --color-zinc-300: oklch(87.1% 0.006 286.286);\n    --color-zinc-400: oklch(70.5% 0.015 286.067);\n    --color-zinc-500: oklch(55.2% 0.016 285.938);\n    --color-zinc-600: oklch(44.2% 0.017 285.786);\n    --color-zinc-700: oklch(37% 0.013 285.805);\n    --color-zinc-800: oklch(27.4% 0.006 286.033);\n    --color-zinc-900: oklch(21% 0.006 285.885);\n    --color-zinc-950: oklch(14.1% 0.005 285.823);\n\n    --color-neutral-50: oklch(98.5% 0 0);\n    --color-neutral-100: oklch(97% 0 0);\n    --color-neutral-200: oklch(92.2% 0 0);\n    --color-neutral-300: oklch(87% 0 0);\n    --color-neutral-400: oklch(70.8% 0 0);\n    --color-neutral-500: oklch(55.6% 0 0);\n    --color-neutral-600: oklch(43.9% 0 0);\n    --color-neutral-700: oklch(37.1% 0 0);\n    --color-neutral-800: oklch(26.9% 0 0);\n    --color-neutral-900: oklch(20.5% 0 0);\n    --color-neutral-950: oklch(14.5% 0 0);\n\n    --color-stone-50: oklch(98.5% 0.001 106.423);\n    --color-stone-100: oklch(97% 0.001 106.424);\n    --color-stone-200: oklch(92.3% 0.003 48.717);\n    --color-stone-300: oklch(86.9% 0.005 56.366);\n    --color-stone-400: oklch(70.9% 0.01 56.259);\n    --color-stone-500: oklch(55.3% 0.013 58.071);\n    --color-stone-600: oklch(44.4% 0.011 73.639);\n    --color-stone-700: oklch(37.4% 0.01 67.558);\n    --color-stone-800: oklch(26.8% 0.007 34.298);\n    --color-stone-900: oklch(21.6% 0.006 56.043);\n    --color-stone-950: oklch(14.7% 0.004 49.25);\n\n    --color-black: #000;\n    --color-white: #fff;\n\n    --spacing: 0.25rem;\n\n    --breakpoint-sm: 40rem;\n    --breakpoint-md: 48rem;\n    --breakpoint-lg: 64rem;\n    --breakpoint-xl: 80rem;\n    --breakpoint-2xl: 96rem;\n\n    --container-3xs: 16rem;\n    --container-2xs: 18rem;\n    --container-xs: 20rem;\n    --container-sm: 24rem;\n    --container-md: 28rem;\n    --container-lg: 32rem;\n    --container-xl: 36rem;\n    --container-2xl: 42rem;\n    --container-3xl: 48rem;\n    --container-4xl: 56rem;\n    --container-5xl: 64rem;\n    --container-6xl: 72rem;\n    --container-7xl: 80rem;\n\n    --text-xs: 0.75rem;\n    --text-xs--line-height: calc(1 / 0.75);\n    --text-sm: 0.875rem;\n    --text-sm--line-height: calc(1.25 / 0.875);\n    --text-base: 1rem;\n    --text-base--line-height: calc(1.5 / 1);\n    --text-lg: 1.125rem;\n    --text-lg--line-height: calc(1.75 / 1.125);\n    --text-xl: 1.25rem;\n    --text-xl--line-height: calc(1.75 / 1.25);\n    --text-2xl: 1.5rem;\n    --text-2xl--line-height: calc(2 / 1.5);\n    --text-3xl: 1.875rem;\n    --text-3xl--line-height: calc(2.25 / 1.875);\n    --text-4xl: 2.25rem;\n    --text-4xl--line-height: calc(2.5 / 2.25);\n    --text-5xl: 3rem;\n    --text-5xl--line-height: 1;\n    --text-6xl: 3.75rem;\n    --text-6xl--line-height: 1;\n    --text-7xl: 4.5rem;\n    --text-7xl--line-height: 1;\n    --text-8xl: 6rem;\n    --text-8xl--line-height: 1;\n    --text-9xl: 8rem;\n    --text-9xl--line-height: 1;\n\n    --font-weight-thin: 100;\n    --font-weight-extralight: 200;\n    --font-weight-light: 300;\n    --font-weight-normal: 400;\n    --font-weight-medium: 500;\n    --font-weight-semibold: 600;\n    --font-weight-bold: 700;\n    --font-weight-extrabold: 800;\n    --font-weight-black: 900;\n\n    --tracking-tighter: -0.05em;\n    --tracking-tight: -0.025em;\n    --tracking-normal: 0em;\n    --tracking-wide: 0.025em;\n    --tracking-wider: 0.05em;\n    --tracking-widest: 0.1em;\n\n    --leading-tight: 1.25;\n    --leading-snug: 1.375;\n    --leading-normal: 1.5;\n    --leading-relaxed: 1.625;\n    --leading-loose: 2;\n\n    --radius-xs: 0.125rem;\n    --radius-sm: 0.25rem;\n    --radius-md: 0.375rem;\n    --radius-lg: 0.5rem;\n    --radius-xl: 0.75rem;\n    --radius-2xl: 1rem;\n    --radius-3xl: 1.5rem;\n    --radius-4xl: 2rem;\n\n    --shadow-2xs: 0 1px rgb(0 0 0 / 0.05);\n    --shadow-xs: 0 1px 2px 0 rgb(0 0 0 / 0.05);\n    --shadow-sm: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);\n    --shadow-md:\n      0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);\n    --shadow-lg:\n      0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);\n    --shadow-xl:\n      0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);\n    --shadow-2xl: 0 25px 50px -12px rgb(0 0 0 / 0.25);\n\n    --inset-shadow-2xs: inset 0 1px rgb(0 0 0 / 0.05);\n    --inset-shadow-xs: inset 0 1px 1px rgb(0 0 0 / 0.05);\n    --inset-shadow-sm: inset 0 2px 4px rgb(0 0 0 / 0.05);\n\n    --drop-shadow-xs: 0 1px 1px rgb(0 0 0 / 0.05);\n    --drop-shadow-sm: 0 1px 2px rgb(0 0 0 / 0.15);\n    --drop-shadow-md: 0 3px 3px rgb(0 0 0 / 0.12);\n    --drop-shadow-lg: 0 4px 4px rgb(0 0 0 / 0.15);\n    --drop-shadow-xl: 0 9px 7px rgb(0 0 0 / 0.1);\n    --drop-shadow-2xl: 0 25px 25px rgb(0 0 0 / 0.15);\n\n    --text-shadow-2xs: 0px 1px 0px rgb(0 0 0 / 0.15);\n    --text-shadow-xs: 0px 1px 1px rgb(0 0 0 / 0.2);\n    --text-shadow-sm:\n      0px 1px 0px rgb(0 0 0 / 0.075), 0px 1px 1px rgb(0 0 0 / 0.075),\n      0px 2px 2px rgb(0 0 0 / 0.075);\n    --text-shadow-md:\n      0px 1px 1px rgb(0 0 0 / 0.1), 0px 1px 2px rgb(0 0 0 / 0.1),\n      0px 2px 4px rgb(0 0 0 / 0.1);\n    --text-shadow-lg:\n      0px 1px 2px rgb(0 0 0 / 0.1), 0px 3px 2px rgb(0 0 0 / 0.1),\n      0px 4px 8px rgb(0 0 0 / 0.1);\n\n    --ease-in: cubic-bezier(0.4, 0, 1, 1);\n    --ease-out: cubic-bezier(0, 0, 0.2, 1);\n    --ease-in-out: cubic-bezier(0.4, 0, 0.2, 1);\n\n    --animate-spin: spin 1s linear infinite;\n    --animate-ping: ping 1s cubic-bezier(0, 0, 0.2, 1) infinite;\n    --animate-pulse: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;\n    --animate-bounce: bounce 1s infinite;\n\n    @keyframes spin {\n      to {\n        transform: rotate(360deg);\n      }\n    }\n\n    @keyframes ping {\n      75%,\n      100% {\n        transform: scale(2);\n        opacity: 0;\n      }\n    }\n\n    @keyframes pulse {\n      50% {\n        opacity: 0.5;\n      }\n    }\n\n    @keyframes bounce {\n      0%,\n      100% {\n        transform: translateY(-25%);\n        animation-timing-function: cubic-bezier(0.8, 0, 1, 1);\n      }\n\n      50% {\n        transform: none;\n        animation-timing-function: cubic-bezier(0, 0, 0.2, 1);\n      }\n    }\n\n    --blur-xs: 4px;\n    --blur-sm: 8px;\n    --blur-md: 12px;\n    --blur-lg: 16px;\n    --blur-xl: 24px;\n    --blur-2xl: 40px;\n    --blur-3xl: 64px;\n\n    --perspective-dramatic: 100px;\n    --perspective-near: 300px;\n    --perspective-normal: 500px;\n    --perspective-midrange: 800px;\n    --perspective-distant: 1200px;\n\n    --aspect-video: 16 / 9;\n\n    --default-transition-duration: 150ms;\n    --default-transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n    --default-font-family: --theme(--font-sans, initial);\n    --default-font-feature-settings: --theme(\n      --font-sans--font-feature-settings,\n      initial\n    );\n    --default-font-variation-settings: --theme(\n      --font-sans--font-variation-settings,\n      initial\n    );\n    --default-mono-font-family: --theme(--font-mono, initial);\n    --default-mono-font-feature-settings: --theme(\n      --font-mono--font-feature-settings,\n      initial\n    );\n    --default-mono-font-variation-settings: --theme(\n      --font-mono--font-variation-settings,\n      initial\n    );\n  }\n\n  /* Deprecated */\n  @theme default inline reference {\n    --blur: 8px;\n    --shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);\n    --shadow-inner: inset 0 2px 4px 0 rgb(0 0 0 / 0.05);\n    --drop-shadow: 0 1px 2px rgb(0 0 0 / 0.1), 0 1px 1px rgb(0 0 0 / 0.06);\n    --radius: 0.25rem;\n    --max-width-prose: 65ch;\n  }\n}\n\n@layer base {\n  /*\n  1. Prevent padding and border from affecting element width. (https://github.com/mozdevs/cssremedy/issues/4)\n  2. Remove default margins and padding\n  3. Reset all borders.\n*/\n\n  *,\n  ::after,\n  ::before,\n  ::backdrop,\n  ::file-selector-button {\n    box-sizing: border-box; /* 1 */\n    margin: 0; /* 2 */\n    padding: 0; /* 2 */\n    border: 0 solid; /* 3 */\n  }\n\n  /*\n  1. Use a consistent sensible line-height in all browsers.\n  2. Prevent adjustments of font size after orientation changes in iOS.\n  3. Use a more readable tab size.\n  4. Use the user\'s configured `sans` font-family by default.\n  5. Use the user\'s configured `sans` font-feature-settings by default.\n  6. Use the user\'s configured `sans` font-variation-settings by default.\n  7. Disable tap highlights on iOS.\n*/\n\n  html,\n  :host {\n    line-height: 1.5; /* 1 */\n    -webkit-text-size-adjust: 100%; /* 2 */\n    tab-size: 4; /* 3 */\n    font-family: --theme(\n      --default-font-family,\n      ui-sans-serif,\n      system-ui,\n      sans-serif,\n      "Apple Color Emoji",\n      "Segoe UI Emoji",\n      "Segoe UI Symbol",\n      "Noto Color Emoji"\n    ); /* 4 */\n    font-feature-settings: --theme(\n      --default-font-feature-settings,\n      normal\n    ); /* 5 */\n    font-variation-settings: --theme(\n      --default-font-variation-settings,\n      normal\n    ); /* 6 */\n    -webkit-tap-highlight-color: transparent; /* 7 */\n  }\n\n  /*\n  1. Add the correct height in Firefox.\n  2. Correct the inheritance of border color in Firefox. (https://bugzilla.mozilla.org/show_bug.cgi?id=190655)\n  3. Reset the default border style to a 1px solid border.\n*/\n\n  hr {\n    height: 0; /* 1 */\n    color: inherit; /* 2 */\n    border-top-width: 1px; /* 3 */\n  }\n\n  /*\n  Add the correct text decoration in Chrome, Edge, and Safari.\n*/\n\n  abbr:where([title]) {\n    -webkit-text-decoration: underline dotted;\n    text-decoration: underline dotted;\n  }\n\n  /*\n  Remove the default font size and weight for headings.\n*/\n\n  h1,\n  h2,\n  h3,\n  h4,\n  h5,\n  h6 {\n    font-size: inherit;\n    font-weight: inherit;\n  }\n\n  /*\n  Reset links to optimize for opt-in styling instead of opt-out.\n*/\n\n  a {\n    color: inherit;\n    -webkit-text-decoration: inherit;\n    text-decoration: inherit;\n  }\n\n  /*\n  Add the correct font weight in Edge and Safari.\n*/\n\n  b,\n  strong {\n    font-weight: bolder;\n  }\n\n  /*\n  1. Use the user\'s configured `mono` font-family by default.\n  2. Use the user\'s configured `mono` font-feature-settings by default.\n  3. Use the user\'s configured `mono` font-variation-settings by default.\n  4. Correct the odd `em` font sizing in all browsers.\n*/\n\n  code,\n  kbd,\n  samp,\n  pre {\n    font-family: --theme(\n      --default-mono-font-family,\n      ui-monospace,\n      SFMono-Regular,\n      Menlo,\n      Monaco,\n      Consolas,\n      "Liberation Mono",\n      "Courier New",\n      monospace\n    ); /* 1 */\n    font-feature-settings: --theme(\n      --default-mono-font-feature-settings,\n      normal\n    ); /* 2 */\n    font-variation-settings: --theme(\n      --default-mono-font-variation-settings,\n      normal\n    ); /* 3 */\n    font-size: 1em; /* 4 */\n  }\n\n  /*\n  Add the correct font size in all browsers.\n*/\n\n  small {\n    font-size: 80%;\n  }\n\n  /*\n  Prevent `sub` and `sup` elements from affecting the line height in all browsers.\n*/\n\n  sub,\n  sup {\n    font-size: 75%;\n    line-height: 0;\n    position: relative;\n    vertical-align: baseline;\n  }\n\n  sub {\n    bottom: -0.25em;\n  }\n\n  sup {\n    top: -0.5em;\n  }\n\n  /*\n  1. Remove text indentation from table contents in Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=999088, https://bugs.webkit.org/show_bug.cgi?id=201297)\n  2. Correct table border color inheritance in all Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=935729, https://bugs.webkit.org/show_bug.cgi?id=195016)\n  3. Remove gaps between table borders by default.\n*/\n\n  table {\n    text-indent: 0; /* 1 */\n    border-color: inherit; /* 2 */\n    border-collapse: collapse; /* 3 */\n  }\n\n  /*\n  Use the modern Firefox focus style for all focusable elements.\n*/\n\n  :-moz-focusring {\n    outline: auto;\n  }\n\n  /*\n  Add the correct vertical alignment in Chrome and Firefox.\n*/\n\n  progress {\n    vertical-align: baseline;\n  }\n\n  /*\n  Add the correct display in Chrome and Safari.\n*/\n\n  summary {\n    display: list-item;\n  }\n\n  /*\n  Make lists unstyled by default.\n*/\n\n  ol,\n  ul,\n  menu {\n    list-style: none;\n  }\n\n  /*\n  1. Make replaced elements `display: block` by default. (https://github.com/mozdevs/cssremedy/issues/14)\n  2. Add `vertical-align: middle` to align replaced elements more sensibly by default. (https://github.com/jensimmons/cssremedy/issues/14#issuecomment-634934210)\n      This can trigger a poorly considered lint error in some tools but is included by design.\n*/\n\n  img,\n  svg,\n  video,\n  canvas,\n  audio,\n  iframe,\n  embed,\n  object {\n    display: block; /* 1 */\n    vertical-align: middle; /* 2 */\n  }\n\n  /*\n  Constrain images and videos to the parent width and preserve their intrinsic aspect ratio. (https://github.com/mozdevs/cssremedy/issues/14)\n*/\n\n  img,\n  video {\n    max-width: 100%;\n    height: auto;\n  }\n\n  /*\n  1. Inherit font styles in all browsers.\n  2. Remove border radius in all browsers.\n  3. Remove background color in all browsers.\n  4. Ensure consistent opacity for disabled states in all browsers.\n*/\n\n  button,\n  input,\n  select,\n  optgroup,\n  textarea,\n  ::file-selector-button {\n    font: inherit; /* 1 */\n    font-feature-settings: inherit; /* 1 */\n    font-variation-settings: inherit; /* 1 */\n    letter-spacing: inherit; /* 1 */\n    color: inherit; /* 1 */\n    border-radius: 0; /* 2 */\n    background-color: transparent; /* 3 */\n    opacity: 1; /* 4 */\n  }\n\n  /*\n  Restore default font weight.\n*/\n\n  :where(select:is([multiple], [size])) optgroup {\n    font-weight: bolder;\n  }\n\n  /*\n  Restore indentation.\n*/\n\n  :where(select:is([multiple], [size])) optgroup option {\n    padding-inline-start: 20px;\n  }\n\n  /*\n  Restore space after button.\n*/\n\n  ::file-selector-button {\n    margin-inline-end: 4px;\n  }\n\n  /*\n  Reset the default placeholder opacity in Firefox. (https://github.com/tailwindlabs/tailwindcss/issues/3300)\n*/\n\n  ::placeholder {\n    opacity: 1;\n  }\n\n  /*\n  Set the default placeholder color to a semi-transparent version of the current text color in browsers that do not\n  crash when using `color-mix()` with `currentcolor`. (https://github.com/tailwindlabs/tailwindcss/issues/17194)\n*/\n\n  @supports (not (-webkit-appearance: -apple-pay-button)) /* Not Safari */ or\n    (contain-intrinsic-size: 1px) /* Safari 17+ */ {\n    ::placeholder {\n      color: color-mix(in oklab, currentcolor 50%, transparent);\n    }\n  }\n\n  /*\n  Prevent resizing textareas horizontally by default.\n*/\n\n  textarea {\n    resize: vertical;\n  }\n\n  /*\n  Remove the inner padding in Chrome and Safari on macOS.\n*/\n\n  ::-webkit-search-decoration {\n    -webkit-appearance: none;\n  }\n\n  /*\n  1. Ensure date/time inputs have the same height when empty in iOS Safari.\n  2. Ensure text alignment can be changed on date/time inputs in iOS Safari.\n*/\n\n  ::-webkit-date-and-time-value {\n    min-height: 1lh; /* 1 */\n    text-align: inherit; /* 2 */\n  }\n\n  /*\n  Prevent height from changing on date/time inputs in macOS Safari when the input is set to `display: block`.\n*/\n\n  ::-webkit-datetime-edit {\n    display: inline-flex;\n  }\n\n  /*\n  Remove excess padding from pseudo-elements in date/time inputs to ensure consistent height across browsers.\n*/\n\n  ::-webkit-datetime-edit-fields-wrapper {\n    padding: 0;\n  }\n\n  ::-webkit-datetime-edit,\n  ::-webkit-datetime-edit-year-field,\n  ::-webkit-datetime-edit-month-field,\n  ::-webkit-datetime-edit-day-field,\n  ::-webkit-datetime-edit-hour-field,\n  ::-webkit-datetime-edit-minute-field,\n  ::-webkit-datetime-edit-second-field,\n  ::-webkit-datetime-edit-millisecond-field,\n  ::-webkit-datetime-edit-meridiem-field {\n    padding-block: 0;\n  }\n\n  /*\n  Center dropdown marker shown on inputs with paired `<datalist>`s in Chrome. (https://github.com/tailwindlabs/tailwindcss/issues/18499)\n*/\n\n  ::-webkit-calendar-picker-indicator {\n    line-height: 1;\n  }\n\n  /*\n  Remove the additional `:invalid` styles in Firefox. (https://github.com/mozilla/gecko-dev/blob/2f9eacd9d3d995c937b4251a5557d95d494c9be1/layout/style/res/forms.css#L728-L737)\n*/\n\n  :-moz-ui-invalid {\n    box-shadow: none;\n  }\n\n  /*\n  Correct the inability to style the border radius in iOS Safari.\n*/\n\n  button,\n  input:where([type="button"], [type="reset"], [type="submit"]),\n  ::file-selector-button {\n    appearance: button;\n  }\n\n  /*\n  Correct the cursor style of increment and decrement buttons in Safari.\n*/\n\n  ::-webkit-inner-spin-button,\n  ::-webkit-outer-spin-button {\n    height: auto;\n  }\n\n  /*\n  Make elements with the HTML hidden attribute stay hidden by default.\n*/\n\n  [hidden]:where(:not([hidden="until-found"])) {\n    display: none !important;\n  }\n}\n\n@layer utilities {\n  @tailwind utilities;\n}\n',
            '@property --tw-animation-delay{syntax:"*";inherits:false;initial-value:0s}@property --tw-animation-direction{syntax:"*";inherits:false;initial-value:normal}@property --tw-animation-duration{syntax:"*";inherits:false}@property --tw-animation-fill-mode{syntax:"*";inherits:false;initial-value:none}@property --tw-animation-iteration-count{syntax:"*";inherits:false;initial-value:1}@property --tw-enter-blur{syntax:"*";inherits:false;initial-value:0}@property --tw-enter-opacity{syntax:"*";inherits:false;initial-value:1}@property --tw-enter-rotate{syntax:"*";inherits:false;initial-value:0}@property --tw-enter-scale{syntax:"*";inherits:false;initial-value:1}@property --tw-enter-translate-x{syntax:"*";inherits:false;initial-value:0}@property --tw-enter-translate-y{syntax:"*";inherits:false;initial-value:0}@property --tw-exit-blur{syntax:"*";inherits:false;initial-value:0}@property --tw-exit-opacity{syntax:"*";inherits:false;initial-value:1}@property --tw-exit-rotate{syntax:"*";inherits:false;initial-value:0}@property --tw-exit-scale{syntax:"*";inherits:false;initial-value:1}@property --tw-exit-translate-x{syntax:"*";inherits:false;initial-value:0}@property --tw-exit-translate-y{syntax:"*";inherits:false;initial-value:0}@theme inline{--animation-delay-0: 0s; --animation-delay-75: 75ms; --animation-delay-100: .1s; --animation-delay-150: .15s; --animation-delay-200: .2s; --animation-delay-300: .3s; --animation-delay-500: .5s; --animation-delay-700: .7s; --animation-delay-1000: 1s; --animation-repeat-0: 0; --animation-repeat-1: 1; --animation-repeat-infinite: infinite; --animation-direction-normal: normal; --animation-direction-reverse: reverse; --animation-direction-alternate: alternate; --animation-direction-alternate-reverse: alternate-reverse; --animation-fill-mode-none: none; --animation-fill-mode-forwards: forwards; --animation-fill-mode-backwards: backwards; --animation-fill-mode-both: both; --percentage-0: 0; --percentage-5: .05; --percentage-10: .1; --percentage-15: .15; --percentage-20: .2; --percentage-25: .25; --percentage-30: .3; --percentage-35: .35; --percentage-40: .4; --percentage-45: .45; --percentage-50: .5; --percentage-55: .55; --percentage-60: .6; --percentage-65: .65; --percentage-70: .7; --percentage-75: .75; --percentage-80: .8; --percentage-85: .85; --percentage-90: .9; --percentage-95: .95; --percentage-100: 1; --percentage-translate-full: 1; --animate-in: enter var(--tw-animation-duration,var(--tw-duration,.15s))var(--tw-ease,ease)var(--tw-animation-delay,0s)var(--tw-animation-iteration-count,1)var(--tw-animation-direction,normal)var(--tw-animation-fill-mode,none); --animate-out: exit var(--tw-animation-duration,var(--tw-duration,.15s))var(--tw-ease,ease)var(--tw-animation-delay,0s)var(--tw-animation-iteration-count,1)var(--tw-animation-direction,normal)var(--tw-animation-fill-mode,none); @keyframes enter { from { opacity: var(--tw-enter-opacity,1); transform: translate3d(var(--tw-enter-translate-x,0),var(--tw-enter-translate-y,0),0)scale3d(var(--tw-enter-scale,1),var(--tw-enter-scale,1),var(--tw-enter-scale,1))rotate(var(--tw-enter-rotate,0)); filter: blur(var(--tw-enter-blur,0)); }}@keyframes exit { to { opacity: var(--tw-exit-opacity,1); transform: translate3d(var(--tw-exit-translate-x,0),var(--tw-exit-translate-y,0),0)scale3d(var(--tw-exit-scale,1),var(--tw-exit-scale,1),var(--tw-exit-scale,1))rotate(var(--tw-exit-rotate,0)); filter: blur(var(--tw-exit-blur,0)); }}--animate-accordion-down: accordion-down var(--tw-animation-duration,var(--tw-duration,.2s))var(--tw-ease,ease-out)var(--tw-animation-delay,0s)var(--tw-animation-iteration-count,1)var(--tw-animation-direction,normal)var(--tw-animation-fill-mode,none); --animate-accordion-up: accordion-up var(--tw-animation-duration,var(--tw-duration,.2s))var(--tw-ease,ease-out)var(--tw-animation-delay,0s)var(--tw-animation-iteration-count,1)var(--tw-animation-direction,normal)var(--tw-animation-fill-mode,none); --animate-collapsible-down: collapsible-down var(--tw-animation-duration,var(--tw-duration,.2s))var(--tw-ease,ease-out)var(--tw-animation-delay,0s)var(--tw-animation-iteration-count,1)var(--tw-animation-direction,normal)var(--tw-animation-fill-mode,none); --animate-collapsible-up: collapsible-up var(--tw-animation-duration,var(--tw-duration,.2s))var(--tw-ease,ease-out)var(--tw-animation-delay,0s)var(--tw-animation-iteration-count,1)var(--tw-animation-direction,normal)var(--tw-animation-fill-mode,none); @keyframes accordion-down { from { height: 0; }to { height: var(--radix-accordion-content-height,var(--bits-accordion-content-height,var(--reka-accordion-content-height,var(--kb-accordion-content-height,var(--ngp-accordion-content-height,auto))))); }}@keyframes accordion-up { from { height: var(--radix-accordion-content-height,var(--bits-accordion-content-height,var(--reka-accordion-content-height,var(--kb-accordion-content-height,var(--ngp-accordion-content-height,auto))))); }to { height: 0; }}@keyframes collapsible-down { from { height: 0; }to { height: var(--radix-collapsible-content-height,var(--bits-collapsible-content-height,var(--reka-collapsible-content-height,var(--kb-collapsible-content-height,auto)))); }}@keyframes collapsible-up { from { height: var(--radix-collapsible-content-height,var(--bits-collapsible-content-height,var(--reka-collapsible-content-height,var(--kb-collapsible-content-height,auto)))); }to { height: 0; }}--animate-caret-blink: caret-blink 1.25s ease-out infinite; @keyframes caret-blink { 0%,70%,100% { opacity: 1; }20%,50% { opacity: 0; }}}@utility animation-duration-*{--tw-animation-duration: calc(--value(number)*1ms); --tw-animation-duration: --value(--animation-duration-*,[duration],"initial",[*]); animation-duration: calc(--value(number)*1ms); animation-duration: --value(--animation-duration-*,[duration],"initial",[*]);}@utility delay-*{animation-delay: calc(--value(number)*1ms); animation-delay: --value(--animation-delay-*,[duration],"initial",[*]); --tw-animation-delay: calc(--value(number)*1ms); --tw-animation-delay: --value(--animation-delay-*,[duration],"initial",[*]);}@utility repeat-*{animation-iteration-count: --value(--animation-repeat-*,number,"initial",[*]); --tw-animation-iteration-count: --value(--animation-repeat-*,number,"initial",[*]);}@utility direction-*{animation-direction: --value(--animation-direction-*,"initial",[*]); --tw-animation-direction: --value(--animation-direction-*,"initial",[*]);}@utility fill-mode-*{animation-fill-mode: --value(--animation-fill-mode-*,"initial",[*]); --tw-animation-fill-mode: --value(--animation-fill-mode-*,"initial",[*]);}@utility running{animation-play-state: running;}@utility paused{animation-play-state: paused;}@utility play-state-*{animation-play-state: --value("initial",[*]);}@utility blur-in{--tw-enter-blur: 20px;}@utility blur-in-*{--tw-enter-blur: calc(--value(number)*1px); --tw-enter-blur: --value(--blur-*,[*]);}@utility blur-out{--tw-exit-blur: 20px;}@utility blur-out-*{--tw-exit-blur: calc(--value(number)*1px); --tw-exit-blur: --value(--blur-*,[*]);}@utility fade-in{--tw-enter-opacity: 0;}@utility fade-in-*{--tw-enter-opacity: calc(--value(number)/100); --tw-enter-opacity: --value(--percentage-*,[*]);}@utility fade-out{--tw-exit-opacity: 0;}@utility fade-out-*{--tw-exit-opacity: calc(--value(number)/100); --tw-exit-opacity: --value(--percentage-*,[*]);}@utility zoom-in{--tw-enter-scale: 0;}@utility zoom-in-*{--tw-enter-scale: calc(--value(number)*1%); --tw-enter-scale: calc(--value(ratio)); --tw-enter-scale: --value(--percentage-*,[*]);}@utility -zoom-in-*{--tw-enter-scale: calc(--value(number)*-1%); --tw-enter-scale: calc(--value(ratio)*-1); --tw-enter-scale: --value(--percentage-*,[*]);}@utility zoom-out{--tw-exit-scale: 0;}@utility zoom-out-*{--tw-exit-scale: calc(--value(number)*1%); --tw-exit-scale: calc(--value(ratio)); --tw-exit-scale: --value(--percentage-*,[*]);}@utility -zoom-out-*{--tw-exit-scale: calc(--value(number)*-1%); --tw-exit-scale: calc(--value(ratio)*-1); --tw-exit-scale: --value(--percentage-*,[*]);}@utility spin-in{--tw-enter-rotate: 30deg;}@utility spin-in-*{--tw-enter-rotate: calc(--value(number)*1deg); --tw-enter-rotate: calc(--value(ratio)*360deg); --tw-enter-rotate: --value(--rotate-*,[*]);}@utility -spin-in{--tw-enter-rotate: -30deg;}@utility -spin-in-*{--tw-enter-rotate: calc(--value(number)*-1deg); --tw-enter-rotate: calc(--value(ratio)*-360deg); --tw-enter-rotate: --value(--rotate-*,[*]);}@utility spin-out{--tw-exit-rotate: 30deg;}@utility spin-out-*{--tw-exit-rotate: calc(--value(number)*1deg); --tw-exit-rotate: calc(--value(ratio)*360deg); --tw-exit-rotate: --value(--rotate-*,[*]);}@utility -spin-out{--tw-exit-rotate: -30deg;}@utility -spin-out-*{--tw-exit-rotate: calc(--value(number)*-1deg); --tw-exit-rotate: calc(--value(ratio)*-360deg); --tw-exit-rotate: --value(--rotate-*,[*]);}@utility slide-in-from-top{--tw-enter-translate-y: -100%;}@utility slide-in-from-top-*{--tw-enter-translate-y: --spacing(--value(integer)*-1); --tw-enter-translate-y: calc(--value(--percentage-*,--percentage-translate-*)*-100%); --tw-enter-translate-y: calc(--value(ratio)*-100%); --tw-enter-translate-y: calc(--value(--translate-*,[percentage],[length])*-1);}@utility slide-in-from-bottom{--tw-enter-translate-y: 100%;}@utility slide-in-from-bottom-*{--tw-enter-translate-y: --spacing(--value(integer)); --tw-enter-translate-y: calc(--value(--percentage-*,--percentage-translate-*)*100%); --tw-enter-translate-y: calc(--value(ratio)*100%); --tw-enter-translate-y: --value(--translate-*,[percentage],[length]);}@utility slide-in-from-left{--tw-enter-translate-x: -100%;}@utility slide-in-from-left-*{--tw-enter-translate-x: --spacing(--value(integer)*-1); --tw-enter-translate-x: calc(--value(--percentage-*,--percentage-translate-*)*-100%); --tw-enter-translate-x: calc(--value(ratio)*-100%); --tw-enter-translate-x: calc(--value(--translate-*,[percentage],[length])*-1);}@utility slide-in-from-right{--tw-enter-translate-x: 100%;}@utility slide-in-from-right-*{--tw-enter-translate-x: --spacing(--value(integer)); --tw-enter-translate-x: calc(--value(--percentage-*,--percentage-translate-*)*100%); --tw-enter-translate-x: calc(--value(ratio)*100%); --tw-enter-translate-x: --value(--translate-*,[percentage],[length]);}@utility slide-in-from-start{&:dir(ltr){ --tw-enter-translate-x: -100%; }&:dir(rtl){ --tw-enter-translate-x: 100%; }}@utility slide-in-from-start-*{&:where(:dir(ltr),[dir="ltr"],[dir="ltr"]*){ --tw-enter-translate-x: --spacing(--value(integer)*-1); --tw-enter-translate-x: calc(--value(--percentage-*,--percentage-translate-*)*-100%); --tw-enter-translate-x: calc(--value(ratio)*-100%); --tw-enter-translate-x: calc(--value(--translate-*,[percentage],[length])*-1); }&:where(:dir(rtl),[dir="rtl"],[dir="rtl"]*){ --tw-enter-translate-x: --spacing(--value(integer)); --tw-enter-translate-x: calc(--value(--percentage-*,--percentage-translate-*)*100%); --tw-enter-translate-x: calc(--value(ratio)*100%); --tw-enter-translate-x: --value(--translate-*,[percentage],[length]); }}@utility slide-in-from-end{&:dir(ltr){ --tw-enter-translate-x: 100%; }&:dir(rtl){ --tw-enter-translate-x: -100%; }}@utility slide-in-from-end-*{&:where(:dir(ltr),[dir="ltr"],[dir="ltr"]*){ --tw-enter-translate-x: --spacing(--value(integer)); --tw-enter-translate-x: calc(--value(--percentage-*,--percentage-translate-*)*100%); --tw-enter-translate-x: calc(--value(ratio)*100%); --tw-enter-translate-x: --value(--translate-*,[percentage],[length]); }&:where(:dir(rtl),[dir="rtl"],[dir="rtl"]*){ --tw-enter-translate-x: --spacing(--value(integer)*-1); --tw-enter-translate-x: calc(--value(--percentage-*,--percentage-translate-*)*-100%); --tw-enter-translate-x: calc(--value(ratio)*-100%); --tw-enter-translate-x: calc(--value(--translate-*,[percentage],[length])*-1); }}@utility slide-out-to-top{--tw-exit-translate-y: -100%;}@utility slide-out-to-top-*{--tw-exit-translate-y: --spacing(--value(integer)*-1); --tw-exit-translate-y: calc(--value(--percentage-*,--percentage-translate-*)*-100%); --tw-exit-translate-y: calc(--value(ratio)*-100%); --tw-exit-translate-y: calc(--value(--translate-*,[percentage],[length])*-1);}@utility slide-out-to-bottom{--tw-exit-translate-y: 100%;}@utility slide-out-to-bottom-*{--tw-exit-translate-y: --spacing(--value(integer)); --tw-exit-translate-y: calc(--value(--percentage-*,--percentage-translate-*)*100%); --tw-exit-translate-y: calc(--value(ratio)*100%); --tw-exit-translate-y: --value(--translate-*,[percentage],[length]);}@utility slide-out-to-left{--tw-exit-translate-x: -100%;}@utility slide-out-to-left-*{--tw-exit-translate-x: --spacing(--value(integer)*-1); --tw-exit-translate-x: calc(--value(--percentage-*,--percentage-translate-*)*-100%); --tw-exit-translate-x: calc(--value(ratio)*-100%); --tw-exit-translate-x: calc(--value(--translate-*,[percentage],[length])*-1);}@utility slide-out-to-right{--tw-exit-translate-x: 100%;}@utility slide-out-to-right-*{--tw-exit-translate-x: --spacing(--value(integer)); --tw-exit-translate-x: calc(--value(--percentage-*,--percentage-translate-*)*100%); --tw-exit-translate-x: calc(--value(ratio)*100%); --tw-exit-translate-x: --value(--translate-*,[percentage],[length]);}@utility slide-out-to-start{&:dir(ltr){ --tw-exit-translate-x: -100%; }&:dir(rtl){ --tw-exit-translate-x: 100%; }}@utility slide-out-to-start-*{&:where(:dir(ltr),[dir="ltr"],[dir="ltr"]*){ --tw-exit-translate-x: --spacing(--value(integer)*-1); --tw-exit-translate-x: calc(--value(--percentage-*,--percentage-translate-*)*-100%); --tw-exit-translate-x: calc(--value(ratio)*-100%); --tw-exit-translate-x: calc(--value(--translate-*,[percentage],[length])*-1); }&:where(:dir(rtl),[dir="rtl"],[dir="rtl"]*){ --tw-exit-translate-x: --spacing(--value(integer)); --tw-exit-translate-x: calc(--value(--percentage-*,--percentage-translate-*)*100%); --tw-exit-translate-x: calc(--value(ratio)*100%); --tw-exit-translate-x: --value(--translate-*,[percentage],[length]); }}@utility slide-out-to-end{&:dir(ltr){ --tw-exit-translate-x: 100%; }&:dir(rtl){ --tw-exit-translate-x: -100%; }}@utility slide-out-to-end-*{&:where(:dir(ltr),[dir="ltr"],[dir="ltr"]*){ --tw-exit-translate-x: --spacing(--value(integer)); --tw-exit-translate-x: calc(--value(--percentage-*,--percentage-translate-*)*100%); --tw-exit-translate-x: calc(--value(ratio)*100%); --tw-exit-translate-x: --value(--translate-*,[percentage],[length]); }&:where(:dir(rtl),[dir="rtl"],[dir="rtl"]*){ --tw-exit-translate-x: --spacing(--value(integer)*-1); --tw-exit-translate-x: calc(--value(--percentage-*,--percentage-translate-*)*-100%); --tw-exit-translate-x: calc(--value(ratio)*-100%); --tw-exit-translate-x: calc(--value(--translate-*,[percentage],[length])*-1); }}',
            "@import 'tailwindcss';\n@import 'tw-animate-css';\n\n@custom-variant dark (&:is(.dark *));\n\n:root {\n  --radius: 0.625rem;\n  --background: oklch(1 0 0);\n  --foreground: oklch(0.145 0 0);\n  --card: oklch(1 0 0);\n  --card-foreground: oklch(0.145 0 0);\n  --popover: oklch(1 0 0);\n  --popover-foreground: oklch(0.145 0 0);\n  --primary: oklch(0.205 0 0);\n  --primary-foreground: oklch(0.985 0 0);\n  --secondary: oklch(0.97 0 0);\n  --secondary-foreground: oklch(0.205 0 0);\n  --muted: oklch(0.97 0 0);\n  --muted-foreground: oklch(0.556 0 0);\n  --accent: oklch(0.97 0 0);\n  --accent-foreground: oklch(0.205 0 0);\n  --destructive: oklch(0.577 0.245 27.325);\n  --border: oklch(0.922 0 0);\n  --input: oklch(0.922 0 0);\n  --ring: oklch(0.708 0 0);\n  --chart-1: oklch(0.646 0.222 41.116);\n  --chart-2: oklch(0.6 0.118 184.704);\n  --chart-3: oklch(0.398 0.07 227.392);\n  --chart-4: oklch(0.828 0.189 84.429);\n  --chart-5: oklch(0.769 0.188 70.08);\n  --sidebar: oklch(0.985 0 0);\n  --sidebar-foreground: oklch(0.145 0 0);\n  --sidebar-primary: oklch(0.205 0 0);\n  --sidebar-primary-foreground: oklch(0.985 0 0);\n  --sidebar-accent: oklch(0.97 0 0);\n  --sidebar-accent-foreground: oklch(0.205 0 0);\n  --sidebar-border: oklch(0.922 0 0);\n  --sidebar-ring: oklch(0.708 0 0);\n}\n\n.dark {\n  --background: oklch(0.145 0 0);\n  --foreground: oklch(0.985 0 0);\n  --card: oklch(0.205 0 0);\n  --card-foreground: oklch(0.985 0 0);\n  --popover: oklch(0.269 0 0);\n  --popover-foreground: oklch(0.985 0 0);\n  --primary: oklch(0.922 0 0);\n  --primary-foreground: oklch(0.205 0 0);\n  --secondary: oklch(0.269 0 0);\n  --secondary-foreground: oklch(0.985 0 0);\n  --muted: oklch(0.269 0 0);\n  --muted-foreground: oklch(0.708 0 0);\n  --accent: oklch(0.371 0 0);\n  --accent-foreground: oklch(0.985 0 0);\n  --destructive: oklch(0.704 0.191 22.216);\n  --border: oklch(1 0 0 / 10%);\n  --input: oklch(1 0 0 / 15%);\n  --ring: oklch(0.556 0 0);\n  --chart-1: oklch(0.488 0.243 264.376);\n  --chart-2: oklch(0.696 0.17 162.48);\n  --chart-3: oklch(0.769 0.188 70.08);\n  --chart-4: oklch(0.627 0.265 303.9);\n  --chart-5: oklch(0.645 0.246 16.439);\n  --sidebar: oklch(0.205 0 0);\n  --sidebar-foreground: oklch(0.985 0 0);\n  --sidebar-primary: oklch(0.488 0.243 264.376);\n  --sidebar-primary-foreground: oklch(0.985 0 0);\n  --sidebar-accent: oklch(0.269 0 0);\n  --sidebar-accent-foreground: oklch(0.985 0 0);\n  --sidebar-border: oklch(1 0 0 / 10%);\n  --sidebar-ring: oklch(0.439 0 0);\n}\n\n@theme inline {\n  --font-sans:\n    var(--font-public-sans), ui-sans-serif, system-ui, sans-serif, 'Apple Color Emoji',\n    'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';\n  --font-mono:\n    var(--font-commit-mono), ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,\n    'Liberation Mono', 'Courier New', monospace;\n\n  --color-background: var(--background);\n  --color-foreground: var(--foreground);\n  --color-card: var(--card);\n  --color-card-foreground: var(--card-foreground);\n  --color-popover: var(--popover);\n  --color-popover-foreground: var(--popover-foreground);\n  --color-primary: var(--primary);\n  --color-primary-foreground: var(--primary-foreground);\n  --color-secondary: var(--secondary);\n  --color-secondary-foreground: var(--secondary-foreground);\n  --color-muted: var(--muted);\n  --color-muted-foreground: var(--muted-foreground);\n  --color-accent: var(--accent);\n  --color-accent-foreground: var(--accent-foreground);\n  --color-destructive: var(--destructive);\n  --color-border: var(--border);\n  --color-input: var(--input);\n  --color-ring: var(--ring);\n  --color-chart-1: var(--chart-1);\n  --color-chart-2: var(--chart-2);\n  --color-chart-3: var(--chart-3);\n  --color-chart-4: var(--chart-4);\n  --color-chart-5: var(--chart-5);\n  --color-sidebar: var(--sidebar);\n  --color-sidebar-foreground: var(--sidebar-foreground);\n  --color-sidebar-primary: var(--sidebar-primary);\n  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);\n  --color-sidebar-accent: var(--sidebar-accent);\n  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);\n  --color-sidebar-border: var(--sidebar-border);\n  --color-sidebar-ring: var(--sidebar-ring);\n}\n\n@layer base {\n  * {\n    @apply border-foreground/20 outline-ring/50;\n  }\n  body {\n    @apply bg-background text-foreground;\n  }\n}\n\n@layer utils {\n  .animate-text-shimmer {\n    animation-delay: 0.5s;\n    animation-duration: 3s;\n    animation-iteration-count: infinite;\n    animation-name: text-shimmer;\n    background: var(--muted-foreground)\n      gradient(\n        linear,\n        100% 0,\n        0 0,\n        from(var(--muted-foreground)),\n        color-stop(0.5, var(--secondary-foreground)),\n        to(var(--muted-foreground))\n      );\n    background: var(--muted-foreground) -webkit-gradient(\n        linear,\n        100% 0,\n        0 0,\n        from(var(--muted-foreground)),\n        color-stop(0.5, var(--secondary-foreground)),\n        to(var(--muted-foreground))\n      );\n    background-repeat: no-repeat;\n    background-size: 50% 200%;\n    display: inline-block;\n  }\n\n  @keyframes text-shimmer {\n    0% {\n      background-position: -100% 0;\n    }\n    100% {\n      background-position: 250% 0;\n    }\n  }\n}\n",
          ],
          sourceRoot: '',
        },
      ]);
      // Exports
      /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ =
        ___CSS_LOADER_EXPORT___.toString();

      /***/
    },

    /***/ 646: /***/ (__unused_webpack_module, exports) => {
      /**
       * @license React
       * react.production.js
       *
       * Copyright (c) Meta Platforms, Inc. and affiliates.
       *
       * This source code is licensed under the MIT license found in the
       * LICENSE file in the root directory of this source tree.
       */

      var REACT_ELEMENT_TYPE = Symbol.for('react.transitional.element'),
        REACT_PORTAL_TYPE = Symbol.for('react.portal'),
        REACT_FRAGMENT_TYPE = Symbol.for('react.fragment'),
        REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode'),
        REACT_PROFILER_TYPE = Symbol.for('react.profiler'),
        REACT_CONSUMER_TYPE = Symbol.for('react.consumer'),
        REACT_CONTEXT_TYPE = Symbol.for('react.context'),
        REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref'),
        REACT_SUSPENSE_TYPE = Symbol.for('react.suspense'),
        REACT_MEMO_TYPE = Symbol.for('react.memo'),
        REACT_LAZY_TYPE = Symbol.for('react.lazy'),
        MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
      function getIteratorFn(maybeIterable) {
        if (null === maybeIterable || 'object' !== typeof maybeIterable) return null;
        maybeIterable =
          (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
          maybeIterable['@@iterator'];
        return 'function' === typeof maybeIterable ? maybeIterable : null;
      }
      var ReactNoopUpdateQueue = {
          isMounted: function () {
            return !1;
          },
          enqueueForceUpdate: function () {},
          enqueueReplaceState: function () {},
          enqueueSetState: function () {},
        },
        assign = Object.assign,
        emptyObject = {};
      function Component(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
      }
      Component.prototype.isReactComponent = {};
      Component.prototype.setState = function (partialState, callback) {
        if (
          'object' !== typeof partialState &&
          'function' !== typeof partialState &&
          null != partialState
        )
          throw Error(
            'takes an object of state variables to update or a function which returns an object of state variables.'
          );
        this.updater.enqueueSetState(this, partialState, callback, 'setState');
      };
      Component.prototype.forceUpdate = function (callback) {
        this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
      };
      function ComponentDummy() {}
      ComponentDummy.prototype = Component.prototype;
      function PureComponent(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
      }
      var pureComponentPrototype = (PureComponent.prototype = new ComponentDummy());
      pureComponentPrototype.constructor = PureComponent;
      assign(pureComponentPrototype, Component.prototype);
      pureComponentPrototype.isPureReactComponent = !0;
      var isArrayImpl = Array.isArray,
        ReactSharedInternals = { H: null, A: null, T: null, S: null, V: null },
        hasOwnProperty = Object.prototype.hasOwnProperty;
      function ReactElement(type, key, self, source, owner, props) {
        self = props.ref;
        return {
          $$typeof: REACT_ELEMENT_TYPE,
          type: type,
          key: key,
          ref: void 0 !== self ? self : null,
          props: props,
        };
      }
      function cloneAndReplaceKey(oldElement, newKey) {
        return ReactElement(oldElement.type, newKey, void 0, void 0, void 0, oldElement.props);
      }
      function isValidElement(object) {
        return (
          'object' === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE
        );
      }
      function escape(key) {
        var escaperLookup = { '=': '=0', ':': '=2' };
        return (
          '$' +
          key.replace(/[=:]/g, function (match) {
            return escaperLookup[match];
          })
        );
      }
      var userProvidedKeyEscapeRegex = /\/+/g;
      function getElementKey(element, index) {
        return 'object' === typeof element && null !== element && null != element.key
          ? escape('' + element.key)
          : index.toString(36);
      }
      function noop$1() {}
      function resolveThenable(thenable) {
        switch (thenable.status) {
          case 'fulfilled':
            return thenable.value;
          case 'rejected':
            throw thenable.reason;
          default:
            switch (
              ('string' === typeof thenable.status
                ? thenable.then(noop$1, noop$1)
                : ((thenable.status = 'pending'),
                  thenable.then(
                    function (fulfilledValue) {
                      'pending' === thenable.status &&
                        ((thenable.status = 'fulfilled'), (thenable.value = fulfilledValue));
                    },
                    function (error) {
                      'pending' === thenable.status &&
                        ((thenable.status = 'rejected'), (thenable.reason = error));
                    }
                  )),
              thenable.status)
            ) {
              case 'fulfilled':
                return thenable.value;
              case 'rejected':
                throw thenable.reason;
            }
        }
        throw thenable;
      }
      function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
        var type = typeof children;
        if ('undefined' === type || 'boolean' === type) children = null;
        var invokeCallback = !1;
        if (null === children) invokeCallback = !0;
        else
          switch (type) {
            case 'bigint':
            case 'string':
            case 'number':
              invokeCallback = !0;
              break;
            case 'object':
              switch (children.$$typeof) {
                case REACT_ELEMENT_TYPE:
                case REACT_PORTAL_TYPE:
                  invokeCallback = !0;
                  break;
                case REACT_LAZY_TYPE:
                  return (
                    (invokeCallback = children._init),
                    mapIntoArray(
                      invokeCallback(children._payload),
                      array,
                      escapedPrefix,
                      nameSoFar,
                      callback
                    )
                  );
              }
          }
        if (invokeCallback)
          return (
            (callback = callback(children)),
            (invokeCallback = '' === nameSoFar ? '.' + getElementKey(children, 0) : nameSoFar),
            isArrayImpl(callback)
              ? ((escapedPrefix = ''),
                null != invokeCallback &&
                  (escapedPrefix = invokeCallback.replace(userProvidedKeyEscapeRegex, '$&/') + '/'),
                mapIntoArray(callback, array, escapedPrefix, '', function (c) {
                  return c;
                }))
              : null != callback &&
                (isValidElement(callback) &&
                  (callback = cloneAndReplaceKey(
                    callback,
                    escapedPrefix +
                      (null == callback.key || (children && children.key === callback.key)
                        ? ''
                        : ('' + callback.key).replace(userProvidedKeyEscapeRegex, '$&/') + '/') +
                      invokeCallback
                  )),
                array.push(callback)),
            1
          );
        invokeCallback = 0;
        var nextNamePrefix = '' === nameSoFar ? '.' : nameSoFar + ':';
        if (isArrayImpl(children))
          for (var i = 0; i < children.length; i++)
            ((nameSoFar = children[i]),
              (type = nextNamePrefix + getElementKey(nameSoFar, i)),
              (invokeCallback += mapIntoArray(nameSoFar, array, escapedPrefix, type, callback)));
        else if (((i = getIteratorFn(children)), 'function' === typeof i))
          for (children = i.call(children), i = 0; !(nameSoFar = children.next()).done; )
            ((nameSoFar = nameSoFar.value),
              (type = nextNamePrefix + getElementKey(nameSoFar, i++)),
              (invokeCallback += mapIntoArray(nameSoFar, array, escapedPrefix, type, callback)));
        else if ('object' === type) {
          if ('function' === typeof children.then)
            return mapIntoArray(
              resolveThenable(children),
              array,
              escapedPrefix,
              nameSoFar,
              callback
            );
          array = String(children);
          throw Error(
            'Objects are not valid as a React child (found: ' +
              ('[object Object]' === array
                ? 'object with keys {' + Object.keys(children).join(', ') + '}'
                : array) +
              '). If you meant to render a collection of children, use an array instead.'
          );
        }
        return invokeCallback;
      }
      function mapChildren(children, func, context) {
        if (null == children) return children;
        var result = [],
          count = 0;
        mapIntoArray(children, result, '', '', function (child) {
          return func.call(context, child, count++);
        });
        return result;
      }
      function lazyInitializer(payload) {
        if (-1 === payload._status) {
          var ctor = payload._result;
          ctor = ctor();
          ctor.then(
            function (moduleObject) {
              if (0 === payload._status || -1 === payload._status)
                ((payload._status = 1), (payload._result = moduleObject));
            },
            function (error) {
              if (0 === payload._status || -1 === payload._status)
                ((payload._status = 2), (payload._result = error));
            }
          );
          -1 === payload._status && ((payload._status = 0), (payload._result = ctor));
        }
        if (1 === payload._status) return payload._result.default;
        throw payload._result;
      }
      var reportGlobalError =
        'function' === typeof reportError
          ? reportError
          : function (error) {
              if ('object' === typeof window && 'function' === typeof window.ErrorEvent) {
                var event = new window.ErrorEvent('error', {
                  bubbles: !0,
                  cancelable: !0,
                  message:
                    'object' === typeof error && null !== error && 'string' === typeof error.message
                      ? String(error.message)
                      : String(error),
                  error: error,
                });
                if (!window.dispatchEvent(event)) return;
              } else if ('object' === typeof process && 'function' === typeof process.emit) {
                process.emit('uncaughtException', error);
                return;
              }
              console.error(error);
            };
      function noop() {}
      exports.Children = {
        map: mapChildren,
        forEach: function (children, forEachFunc, forEachContext) {
          mapChildren(
            children,
            function () {
              forEachFunc.apply(this, arguments);
            },
            forEachContext
          );
        },
        count: function (children) {
          var n = 0;
          mapChildren(children, function () {
            n++;
          });
          return n;
        },
        toArray: function (children) {
          return (
            mapChildren(children, function (child) {
              return child;
            }) || []
          );
        },
        only: function (children) {
          if (!isValidElement(children))
            throw Error('React.Children.only expected to receive a single React element child.');
          return children;
        },
      };
      exports.Component = Component;
      exports.Fragment = REACT_FRAGMENT_TYPE;
      exports.Profiler = REACT_PROFILER_TYPE;
      exports.PureComponent = PureComponent;
      exports.StrictMode = REACT_STRICT_MODE_TYPE;
      exports.Suspense = REACT_SUSPENSE_TYPE;
      exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE =
        ReactSharedInternals;
      exports.__COMPILER_RUNTIME = {
        __proto__: null,
        c: function (size) {
          return ReactSharedInternals.H.useMemoCache(size);
        },
      };
      exports.cache = function (fn) {
        return function () {
          return fn.apply(null, arguments);
        };
      };
      exports.cloneElement = function (element, config, children) {
        if (null === element || void 0 === element)
          throw Error('The argument must be a React element, but you passed ' + element + '.');
        var props = assign({}, element.props),
          key = element.key,
          owner = void 0;
        if (null != config)
          for (propName in (void 0 !== config.ref && (owner = void 0),
          void 0 !== config.key && (key = '' + config.key),
          config))
            !hasOwnProperty.call(config, propName) ||
              'key' === propName ||
              '__self' === propName ||
              '__source' === propName ||
              ('ref' === propName && void 0 === config.ref) ||
              (props[propName] = config[propName]);
        var propName = arguments.length - 2;
        if (1 === propName) props.children = children;
        else if (1 < propName) {
          for (var childArray = Array(propName), i = 0; i < propName; i++)
            childArray[i] = arguments[i + 2];
          props.children = childArray;
        }
        return ReactElement(element.type, key, void 0, void 0, owner, props);
      };
      exports.createContext = function (defaultValue) {
        defaultValue = {
          $$typeof: REACT_CONTEXT_TYPE,
          _currentValue: defaultValue,
          _currentValue2: defaultValue,
          _threadCount: 0,
          Provider: null,
          Consumer: null,
        };
        defaultValue.Provider = defaultValue;
        defaultValue.Consumer = {
          $$typeof: REACT_CONSUMER_TYPE,
          _context: defaultValue,
        };
        return defaultValue;
      };
      exports.createElement = function (type, config, children) {
        var propName,
          props = {},
          key = null;
        if (null != config)
          for (propName in (void 0 !== config.key && (key = '' + config.key), config))
            hasOwnProperty.call(config, propName) &&
              'key' !== propName &&
              '__self' !== propName &&
              '__source' !== propName &&
              (props[propName] = config[propName]);
        var childrenLength = arguments.length - 2;
        if (1 === childrenLength) props.children = children;
        else if (1 < childrenLength) {
          for (var childArray = Array(childrenLength), i = 0; i < childrenLength; i++)
            childArray[i] = arguments[i + 2];
          props.children = childArray;
        }
        if (type && type.defaultProps)
          for (propName in ((childrenLength = type.defaultProps), childrenLength))
            void 0 === props[propName] && (props[propName] = childrenLength[propName]);
        return ReactElement(type, key, void 0, void 0, null, props);
      };
      exports.createRef = function () {
        return { current: null };
      };
      exports.forwardRef = function (render) {
        return { $$typeof: REACT_FORWARD_REF_TYPE, render: render };
      };
      exports.isValidElement = isValidElement;
      exports.lazy = function (ctor) {
        return {
          $$typeof: REACT_LAZY_TYPE,
          _payload: { _status: -1, _result: ctor },
          _init: lazyInitializer,
        };
      };
      exports.memo = function (type, compare) {
        return {
          $$typeof: REACT_MEMO_TYPE,
          type: type,
          compare: void 0 === compare ? null : compare,
        };
      };
      exports.startTransition = function (scope) {
        var prevTransition = ReactSharedInternals.T,
          currentTransition = {};
        ReactSharedInternals.T = currentTransition;
        try {
          var returnValue = scope(),
            onStartTransitionFinish = ReactSharedInternals.S;
          null !== onStartTransitionFinish &&
            onStartTransitionFinish(currentTransition, returnValue);
          'object' === typeof returnValue &&
            null !== returnValue &&
            'function' === typeof returnValue.then &&
            returnValue.then(noop, reportGlobalError);
        } catch (error) {
          reportGlobalError(error);
        } finally {
          ReactSharedInternals.T = prevTransition;
        }
      };
      exports.unstable_useCacheRefresh = function () {
        return ReactSharedInternals.H.useCacheRefresh();
      };
      exports.use = function (usable) {
        return ReactSharedInternals.H.use(usable);
      };
      exports.useActionState = function (action, initialState, permalink) {
        return ReactSharedInternals.H.useActionState(action, initialState, permalink);
      };
      exports.useCallback = function (callback, deps) {
        return ReactSharedInternals.H.useCallback(callback, deps);
      };
      exports.useContext = function (Context) {
        return ReactSharedInternals.H.useContext(Context);
      };
      exports.useDebugValue = function () {};
      exports.useDeferredValue = function (value, initialValue) {
        return ReactSharedInternals.H.useDeferredValue(value, initialValue);
      };
      exports.useEffect = function (create, createDeps, update) {
        var dispatcher = ReactSharedInternals.H;
        if ('function' === typeof update)
          throw Error('useEffect CRUD overload is not enabled in this build of React.');
        return dispatcher.useEffect(create, createDeps);
      };
      exports.useId = function () {
        return ReactSharedInternals.H.useId();
      };
      exports.useImperativeHandle = function (ref, create, deps) {
        return ReactSharedInternals.H.useImperativeHandle(ref, create, deps);
      };
      exports.useInsertionEffect = function (create, deps) {
        return ReactSharedInternals.H.useInsertionEffect(create, deps);
      };
      exports.useLayoutEffect = function (create, deps) {
        return ReactSharedInternals.H.useLayoutEffect(create, deps);
      };
      exports.useMemo = function (create, deps) {
        return ReactSharedInternals.H.useMemo(create, deps);
      };
      exports.useOptimistic = function (passthrough, reducer) {
        return ReactSharedInternals.H.useOptimistic(passthrough, reducer);
      };
      exports.useReducer = function (reducer, initialArg, init) {
        return ReactSharedInternals.H.useReducer(reducer, initialArg, init);
      };
      exports.useRef = function (initialValue) {
        return ReactSharedInternals.H.useRef(initialValue);
      };
      exports.useState = function (initialState) {
        return ReactSharedInternals.H.useState(initialState);
      };
      exports.useSyncExternalStore = function (subscribe, getSnapshot, getServerSnapshot) {
        return ReactSharedInternals.H.useSyncExternalStore(
          subscribe,
          getSnapshot,
          getServerSnapshot
        );
      };
      exports.useTransition = function () {
        return ReactSharedInternals.H.useTransition();
      };
      exports.version = '19.1.1';

      /***/
    },

    /***/ 690: /***/ (__unused_webpack_module, exports) => {
      /**
       * @license React
       * scheduler.production.js
       *
       * Copyright (c) Meta Platforms, Inc. and affiliates.
       *
       * This source code is licensed under the MIT license found in the
       * LICENSE file in the root directory of this source tree.
       */

      function push(heap, node) {
        var index = heap.length;
        heap.push(node);
        a: for (; 0 < index; ) {
          var parentIndex = (index - 1) >>> 1,
            parent = heap[parentIndex];
          if (0 < compare(parent, node))
            ((heap[parentIndex] = node), (heap[index] = parent), (index = parentIndex));
          else break a;
        }
      }
      function peek(heap) {
        return 0 === heap.length ? null : heap[0];
      }
      function pop(heap) {
        if (0 === heap.length) return null;
        var first = heap[0],
          last = heap.pop();
        if (last !== first) {
          heap[0] = last;
          a: for (
            var index = 0, length = heap.length, halfLength = length >>> 1;
            index < halfLength;

          ) {
            var leftIndex = 2 * (index + 1) - 1,
              left = heap[leftIndex],
              rightIndex = leftIndex + 1,
              right = heap[rightIndex];
            if (0 > compare(left, last))
              rightIndex < length && 0 > compare(right, left)
                ? ((heap[index] = right), (heap[rightIndex] = last), (index = rightIndex))
                : ((heap[index] = left), (heap[leftIndex] = last), (index = leftIndex));
            else if (rightIndex < length && 0 > compare(right, last))
              ((heap[index] = right), (heap[rightIndex] = last), (index = rightIndex));
            else break a;
          }
        }
        return first;
      }
      function compare(a, b) {
        var diff = a.sortIndex - b.sortIndex;
        return 0 !== diff ? diff : a.id - b.id;
      }
      exports.unstable_now = void 0;
      if ('object' === typeof performance && 'function' === typeof performance.now) {
        var localPerformance = performance;
        exports.unstable_now = function () {
          return localPerformance.now();
        };
      } else {
        var localDate = Date,
          initialTime = localDate.now();
        exports.unstable_now = function () {
          return localDate.now() - initialTime;
        };
      }
      var taskQueue = [],
        timerQueue = [],
        taskIdCounter = 1,
        currentTask = null,
        currentPriorityLevel = 3,
        isPerformingWork = !1,
        isHostCallbackScheduled = !1,
        isHostTimeoutScheduled = !1,
        needsPaint = !1,
        localSetTimeout = 'function' === typeof setTimeout ? setTimeout : null,
        localClearTimeout = 'function' === typeof clearTimeout ? clearTimeout : null,
        localSetImmediate = 'undefined' !== typeof setImmediate ? setImmediate : null;
      function advanceTimers(currentTime) {
        for (var timer = peek(timerQueue); null !== timer; ) {
          if (null === timer.callback) pop(timerQueue);
          else if (timer.startTime <= currentTime)
            (pop(timerQueue), (timer.sortIndex = timer.expirationTime), push(taskQueue, timer));
          else break;
          timer = peek(timerQueue);
        }
      }
      function handleTimeout(currentTime) {
        isHostTimeoutScheduled = !1;
        advanceTimers(currentTime);
        if (!isHostCallbackScheduled)
          if (null !== peek(taskQueue))
            ((isHostCallbackScheduled = !0),
              isMessageLoopRunning ||
                ((isMessageLoopRunning = !0), schedulePerformWorkUntilDeadline()));
          else {
            var firstTimer = peek(timerQueue);
            null !== firstTimer &&
              requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
          }
      }
      var isMessageLoopRunning = !1,
        taskTimeoutID = -1,
        frameInterval = 5,
        startTime = -1;
      function shouldYieldToHost() {
        return needsPaint ? !0 : exports.unstable_now() - startTime < frameInterval ? !1 : !0;
      }
      function performWorkUntilDeadline() {
        needsPaint = !1;
        if (isMessageLoopRunning) {
          var currentTime = exports.unstable_now();
          startTime = currentTime;
          var hasMoreWork = !0;
          try {
            a: {
              isHostCallbackScheduled = !1;
              isHostTimeoutScheduled &&
                ((isHostTimeoutScheduled = !1),
                localClearTimeout(taskTimeoutID),
                (taskTimeoutID = -1));
              isPerformingWork = !0;
              var previousPriorityLevel = currentPriorityLevel;
              try {
                b: {
                  advanceTimers(currentTime);
                  for (
                    currentTask = peek(taskQueue);
                    null !== currentTask &&
                    !(currentTask.expirationTime > currentTime && shouldYieldToHost());

                  ) {
                    var callback = currentTask.callback;
                    if ('function' === typeof callback) {
                      currentTask.callback = null;
                      currentPriorityLevel = currentTask.priorityLevel;
                      var continuationCallback = callback(
                        currentTask.expirationTime <= currentTime
                      );
                      currentTime = exports.unstable_now();
                      if ('function' === typeof continuationCallback) {
                        currentTask.callback = continuationCallback;
                        advanceTimers(currentTime);
                        hasMoreWork = !0;
                        break b;
                      }
                      currentTask === peek(taskQueue) && pop(taskQueue);
                      advanceTimers(currentTime);
                    } else pop(taskQueue);
                    currentTask = peek(taskQueue);
                  }
                  if (null !== currentTask) hasMoreWork = !0;
                  else {
                    var firstTimer = peek(timerQueue);
                    null !== firstTimer &&
                      requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
                    hasMoreWork = !1;
                  }
                }
                break a;
              } finally {
                ((currentTask = null),
                  (currentPriorityLevel = previousPriorityLevel),
                  (isPerformingWork = !1));
              }
              hasMoreWork = void 0;
            }
          } finally {
            hasMoreWork ? schedulePerformWorkUntilDeadline() : (isMessageLoopRunning = !1);
          }
        }
      }
      var schedulePerformWorkUntilDeadline;
      if ('function' === typeof localSetImmediate)
        schedulePerformWorkUntilDeadline = function () {
          localSetImmediate(performWorkUntilDeadline);
        };
      else if ('undefined' !== typeof MessageChannel) {
        var channel = new MessageChannel(),
          port = channel.port2;
        channel.port1.onmessage = performWorkUntilDeadline;
        schedulePerformWorkUntilDeadline = function () {
          port.postMessage(null);
        };
      } else
        schedulePerformWorkUntilDeadline = function () {
          localSetTimeout(performWorkUntilDeadline, 0);
        };
      function requestHostTimeout(callback, ms) {
        taskTimeoutID = localSetTimeout(function () {
          callback(exports.unstable_now());
        }, ms);
      }
      exports.unstable_IdlePriority = 5;
      exports.unstable_ImmediatePriority = 1;
      exports.unstable_LowPriority = 4;
      exports.unstable_NormalPriority = 3;
      exports.unstable_Profiling = null;
      exports.unstable_UserBlockingPriority = 2;
      exports.unstable_cancelCallback = function (task) {
        task.callback = null;
      };
      exports.unstable_forceFrameRate = function (fps) {
        0 > fps || 125 < fps
          ? console.error(
              'forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported'
            )
          : (frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5);
      };
      exports.unstable_getCurrentPriorityLevel = function () {
        return currentPriorityLevel;
      };
      exports.unstable_next = function (eventHandler) {
        switch (currentPriorityLevel) {
          case 1:
          case 2:
          case 3:
            var priorityLevel = 3;
            break;
          default:
            priorityLevel = currentPriorityLevel;
        }
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = priorityLevel;
        try {
          return eventHandler();
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      };
      exports.unstable_requestPaint = function () {
        needsPaint = !0;
      };
      exports.unstable_runWithPriority = function (priorityLevel, eventHandler) {
        switch (priorityLevel) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            priorityLevel = 3;
        }
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = priorityLevel;
        try {
          return eventHandler();
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      };
      exports.unstable_scheduleCallback = function (priorityLevel, callback, options) {
        var currentTime = exports.unstable_now();
        'object' === typeof options && null !== options
          ? ((options = options.delay),
            (options =
              'number' === typeof options && 0 < options ? currentTime + options : currentTime))
          : (options = currentTime);
        switch (priorityLevel) {
          case 1:
            var timeout = -1;
            break;
          case 2:
            timeout = 250;
            break;
          case 5:
            timeout = 1073741823;
            break;
          case 4:
            timeout = 1e4;
            break;
          default:
            timeout = 5e3;
        }
        timeout = options + timeout;
        priorityLevel = {
          id: taskIdCounter++,
          callback: callback,
          priorityLevel: priorityLevel,
          startTime: options,
          expirationTime: timeout,
          sortIndex: -1,
        };
        options > currentTime
          ? ((priorityLevel.sortIndex = options),
            push(timerQueue, priorityLevel),
            null === peek(taskQueue) &&
              priorityLevel === peek(timerQueue) &&
              (isHostTimeoutScheduled
                ? (localClearTimeout(taskTimeoutID), (taskTimeoutID = -1))
                : (isHostTimeoutScheduled = !0),
              requestHostTimeout(handleTimeout, options - currentTime)))
          : ((priorityLevel.sortIndex = timeout),
            push(taskQueue, priorityLevel),
            isHostCallbackScheduled ||
              isPerformingWork ||
              ((isHostCallbackScheduled = !0),
              isMessageLoopRunning ||
                ((isMessageLoopRunning = !0), schedulePerformWorkUntilDeadline())));
        return priorityLevel;
      };
      exports.unstable_shouldYield = shouldYieldToHost;
      exports.unstable_wrapCallback = function (callback) {
        var parentPriorityLevel = currentPriorityLevel;
        return function () {
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = parentPriorityLevel;
          try {
            return callback.apply(this, arguments);
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        };
      };

      /***/
    },

    /***/ 701: /***/ (__unused_webpack_module, exports) => {
      /**
       * @license React
       * react-jsx-runtime.production.js
       *
       * Copyright (c) Meta Platforms, Inc. and affiliates.
       *
       * This source code is licensed under the MIT license found in the
       * LICENSE file in the root directory of this source tree.
       */

      var REACT_ELEMENT_TYPE = Symbol.for('react.transitional.element'),
        REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
      function jsxProd(type, config, maybeKey) {
        var key = null;
        void 0 !== maybeKey && (key = '' + maybeKey);
        void 0 !== config.key && (key = '' + config.key);
        if ('key' in config) {
          maybeKey = {};
          for (var propName in config)
            'key' !== propName && (maybeKey[propName] = config[propName]);
        } else maybeKey = config;
        config = maybeKey.ref;
        return {
          $$typeof: REACT_ELEMENT_TYPE,
          type: type,
          key: key,
          ref: void 0 !== config ? config : null,
          props: maybeKey,
        };
      }
      exports.Fragment = REACT_FRAGMENT_TYPE;
      exports.jsx = jsxProd;
      exports.jsxs = jsxProd;

      /***/
    },

    /***/ 729: /***/ (module, __unused_webpack_exports, __webpack_require__) => {
      if (true) {
        module.exports = __webpack_require__(646);
      } // removed by dead control flow
      else {
      }

      /***/
    },

    /***/ 759: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
      /**
       * @license React
       * react-dom-client.production.js
       *
       * Copyright (c) Meta Platforms, Inc. and affiliates.
       *
       * This source code is licensed under the MIT license found in the
       * LICENSE file in the root directory of this source tree.
       */

      /*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/

      var Scheduler = __webpack_require__(123),
        React = __webpack_require__(729),
        ReactDOM = __webpack_require__(937);
      function formatProdErrorMessage(code) {
        var url = 'https://react.dev/errors/' + code;
        if (1 < arguments.length) {
          url += '?args[]=' + encodeURIComponent(arguments[1]);
          for (var i = 2; i < arguments.length; i++)
            url += '&args[]=' + encodeURIComponent(arguments[i]);
        }
        return (
          'Minified React error #' +
          code +
          '; visit ' +
          url +
          ' for the full message or use the non-minified dev environment for full errors and additional helpful warnings.'
        );
      }
      function isValidContainer(node) {
        return !(!node || (1 !== node.nodeType && 9 !== node.nodeType && 11 !== node.nodeType));
      }
      function getNearestMountedFiber(fiber) {
        var node = fiber,
          nearestMounted = fiber;
        if (fiber.alternate) for (; node.return; ) node = node.return;
        else {
          fiber = node;
          do
            ((node = fiber),
              0 !== (node.flags & 4098) && (nearestMounted = node.return),
              (fiber = node.return));
          while (fiber);
        }
        return 3 === node.tag ? nearestMounted : null;
      }
      function getSuspenseInstanceFromFiber(fiber) {
        if (13 === fiber.tag) {
          var suspenseState = fiber.memoizedState;
          null === suspenseState &&
            ((fiber = fiber.alternate), null !== fiber && (suspenseState = fiber.memoizedState));
          if (null !== suspenseState) return suspenseState.dehydrated;
        }
        return null;
      }
      function assertIsMounted(fiber) {
        if (getNearestMountedFiber(fiber) !== fiber) throw Error(formatProdErrorMessage(188));
      }
      function findCurrentFiberUsingSlowPath(fiber) {
        var alternate = fiber.alternate;
        if (!alternate) {
          alternate = getNearestMountedFiber(fiber);
          if (null === alternate) throw Error(formatProdErrorMessage(188));
          return alternate !== fiber ? null : fiber;
        }
        for (var a = fiber, b = alternate; ; ) {
          var parentA = a.return;
          if (null === parentA) break;
          var parentB = parentA.alternate;
          if (null === parentB) {
            b = parentA.return;
            if (null !== b) {
              a = b;
              continue;
            }
            break;
          }
          if (parentA.child === parentB.child) {
            for (parentB = parentA.child; parentB; ) {
              if (parentB === a) return (assertIsMounted(parentA), fiber);
              if (parentB === b) return (assertIsMounted(parentA), alternate);
              parentB = parentB.sibling;
            }
            throw Error(formatProdErrorMessage(188));
          }
          if (a.return !== b.return) ((a = parentA), (b = parentB));
          else {
            for (var didFindChild = !1, child$0 = parentA.child; child$0; ) {
              if (child$0 === a) {
                didFindChild = !0;
                a = parentA;
                b = parentB;
                break;
              }
              if (child$0 === b) {
                didFindChild = !0;
                b = parentA;
                a = parentB;
                break;
              }
              child$0 = child$0.sibling;
            }
            if (!didFindChild) {
              for (child$0 = parentB.child; child$0; ) {
                if (child$0 === a) {
                  didFindChild = !0;
                  a = parentB;
                  b = parentA;
                  break;
                }
                if (child$0 === b) {
                  didFindChild = !0;
                  b = parentB;
                  a = parentA;
                  break;
                }
                child$0 = child$0.sibling;
              }
              if (!didFindChild) throw Error(formatProdErrorMessage(189));
            }
          }
          if (a.alternate !== b) throw Error(formatProdErrorMessage(190));
        }
        if (3 !== a.tag) throw Error(formatProdErrorMessage(188));
        return a.stateNode.current === a ? fiber : alternate;
      }
      function findCurrentHostFiberImpl(node) {
        var tag = node.tag;
        if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;
        for (node = node.child; null !== node; ) {
          tag = findCurrentHostFiberImpl(node);
          if (null !== tag) return tag;
          node = node.sibling;
        }
        return null;
      }
      var assign = Object.assign,
        REACT_LEGACY_ELEMENT_TYPE = Symbol.for('react.element'),
        REACT_ELEMENT_TYPE = Symbol.for('react.transitional.element'),
        REACT_PORTAL_TYPE = Symbol.for('react.portal'),
        REACT_FRAGMENT_TYPE = Symbol.for('react.fragment'),
        REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode'),
        REACT_PROFILER_TYPE = Symbol.for('react.profiler'),
        REACT_PROVIDER_TYPE = Symbol.for('react.provider'),
        REACT_CONSUMER_TYPE = Symbol.for('react.consumer'),
        REACT_CONTEXT_TYPE = Symbol.for('react.context'),
        REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref'),
        REACT_SUSPENSE_TYPE = Symbol.for('react.suspense'),
        REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list'),
        REACT_MEMO_TYPE = Symbol.for('react.memo'),
        REACT_LAZY_TYPE = Symbol.for('react.lazy');
      Symbol.for('react.scope');
      var REACT_ACTIVITY_TYPE = Symbol.for('react.activity');
      Symbol.for('react.legacy_hidden');
      Symbol.for('react.tracing_marker');
      var REACT_MEMO_CACHE_SENTINEL = Symbol.for('react.memo_cache_sentinel');
      Symbol.for('react.view_transition');
      var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
      function getIteratorFn(maybeIterable) {
        if (null === maybeIterable || 'object' !== typeof maybeIterable) return null;
        maybeIterable =
          (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
          maybeIterable['@@iterator'];
        return 'function' === typeof maybeIterable ? maybeIterable : null;
      }
      var REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');
      function getComponentNameFromType(type) {
        if (null == type) return null;
        if ('function' === typeof type)
          return type.$$typeof === REACT_CLIENT_REFERENCE
            ? null
            : type.displayName || type.name || null;
        if ('string' === typeof type) return type;
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return 'Fragment';
          case REACT_PROFILER_TYPE:
            return 'Profiler';
          case REACT_STRICT_MODE_TYPE:
            return 'StrictMode';
          case REACT_SUSPENSE_TYPE:
            return 'Suspense';
          case REACT_SUSPENSE_LIST_TYPE:
            return 'SuspenseList';
          case REACT_ACTIVITY_TYPE:
            return 'Activity';
        }
        if ('object' === typeof type)
          switch (type.$$typeof) {
            case REACT_PORTAL_TYPE:
              return 'Portal';
            case REACT_CONTEXT_TYPE:
              return (type.displayName || 'Context') + '.Provider';
            case REACT_CONSUMER_TYPE:
              return (type._context.displayName || 'Context') + '.Consumer';
            case REACT_FORWARD_REF_TYPE:
              var innerType = type.render;
              type = type.displayName;
              type ||
                ((type = innerType.displayName || innerType.name || ''),
                (type = '' !== type ? 'ForwardRef(' + type + ')' : 'ForwardRef'));
              return type;
            case REACT_MEMO_TYPE:
              return (
                (innerType = type.displayName || null),
                null !== innerType ? innerType : getComponentNameFromType(type.type) || 'Memo'
              );
            case REACT_LAZY_TYPE:
              innerType = type._payload;
              type = type._init;
              try {
                return getComponentNameFromType(type(innerType));
              } catch (x) {}
          }
        return null;
      }
      var isArrayImpl = Array.isArray,
        ReactSharedInternals =
          React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
        ReactDOMSharedInternals =
          ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
        sharedNotPendingObject = {
          pending: !1,
          data: null,
          method: null,
          action: null,
        },
        valueStack = [],
        index = -1;
      function createCursor(defaultValue) {
        return { current: defaultValue };
      }
      function pop(cursor) {
        0 > index || ((cursor.current = valueStack[index]), (valueStack[index] = null), index--);
      }
      function push(cursor, value) {
        index++;
        valueStack[index] = cursor.current;
        cursor.current = value;
      }
      var contextStackCursor = createCursor(null),
        contextFiberStackCursor = createCursor(null),
        rootInstanceStackCursor = createCursor(null),
        hostTransitionProviderCursor = createCursor(null);
      function pushHostContainer(fiber, nextRootInstance) {
        push(rootInstanceStackCursor, nextRootInstance);
        push(contextFiberStackCursor, fiber);
        push(contextStackCursor, null);
        switch (nextRootInstance.nodeType) {
          case 9:
          case 11:
            fiber = (fiber = nextRootInstance.documentElement)
              ? (fiber = fiber.namespaceURI)
                ? getOwnHostContext(fiber)
                : 0
              : 0;
            break;
          default:
            if (
              ((fiber = nextRootInstance.tagName),
              (nextRootInstance = nextRootInstance.namespaceURI))
            )
              ((nextRootInstance = getOwnHostContext(nextRootInstance)),
                (fiber = getChildHostContextProd(nextRootInstance, fiber)));
            else
              switch (fiber) {
                case 'svg':
                  fiber = 1;
                  break;
                case 'math':
                  fiber = 2;
                  break;
                default:
                  fiber = 0;
              }
        }
        pop(contextStackCursor);
        push(contextStackCursor, fiber);
      }
      function popHostContainer() {
        pop(contextStackCursor);
        pop(contextFiberStackCursor);
        pop(rootInstanceStackCursor);
      }
      function pushHostContext(fiber) {
        null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber);
        var context = contextStackCursor.current;
        var JSCompiler_inline_result = getChildHostContextProd(context, fiber.type);
        context !== JSCompiler_inline_result &&
          (push(contextFiberStackCursor, fiber),
          push(contextStackCursor, JSCompiler_inline_result));
      }
      function popHostContext(fiber) {
        contextFiberStackCursor.current === fiber &&
          (pop(contextStackCursor), pop(contextFiberStackCursor));
        hostTransitionProviderCursor.current === fiber &&
          (pop(hostTransitionProviderCursor),
          (HostTransitionContext._currentValue = sharedNotPendingObject));
      }
      var hasOwnProperty = Object.prototype.hasOwnProperty,
        scheduleCallback$3 = Scheduler.unstable_scheduleCallback,
        cancelCallback$1 = Scheduler.unstable_cancelCallback,
        shouldYield = Scheduler.unstable_shouldYield,
        requestPaint = Scheduler.unstable_requestPaint,
        now = Scheduler.unstable_now,
        getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel,
        ImmediatePriority = Scheduler.unstable_ImmediatePriority,
        UserBlockingPriority = Scheduler.unstable_UserBlockingPriority,
        NormalPriority$1 = Scheduler.unstable_NormalPriority,
        LowPriority = Scheduler.unstable_LowPriority,
        IdlePriority = Scheduler.unstable_IdlePriority,
        log$1 = Scheduler.log,
        unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue,
        rendererID = null,
        injectedHook = null;
      function setIsStrictModeForDevtools(newIsStrictMode) {
        'function' === typeof log$1 && unstable_setDisableYieldValue(newIsStrictMode);
        if (injectedHook && 'function' === typeof injectedHook.setStrictMode)
          try {
            injectedHook.setStrictMode(rendererID, newIsStrictMode);
          } catch (err) {}
      }
      var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback,
        log = Math.log,
        LN2 = Math.LN2;
      function clz32Fallback(x) {
        x >>>= 0;
        return 0 === x ? 32 : (31 - ((log(x) / LN2) | 0)) | 0;
      }
      var nextTransitionLane = 256,
        nextRetryLane = 4194304;
      function getHighestPriorityLanes(lanes) {
        var pendingSyncLanes = lanes & 42;
        if (0 !== pendingSyncLanes) return pendingSyncLanes;
        switch (lanes & -lanes) {
          case 1:
            return 1;
          case 2:
            return 2;
          case 4:
            return 4;
          case 8:
            return 8;
          case 16:
            return 16;
          case 32:
            return 32;
          case 64:
            return 64;
          case 128:
            return 128;
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return lanes & 4194048;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
            return lanes & 62914560;
          case 67108864:
            return 67108864;
          case 134217728:
            return 134217728;
          case 268435456:
            return 268435456;
          case 536870912:
            return 536870912;
          case 1073741824:
            return 0;
          default:
            return lanes;
        }
      }
      function getNextLanes(root, wipLanes, rootHasPendingCommit) {
        var pendingLanes = root.pendingLanes;
        if (0 === pendingLanes) return 0;
        var nextLanes = 0,
          suspendedLanes = root.suspendedLanes,
          pingedLanes = root.pingedLanes;
        root = root.warmLanes;
        var nonIdlePendingLanes = pendingLanes & 134217727;
        0 !== nonIdlePendingLanes
          ? ((pendingLanes = nonIdlePendingLanes & ~suspendedLanes),
            0 !== pendingLanes
              ? (nextLanes = getHighestPriorityLanes(pendingLanes))
              : ((pingedLanes &= nonIdlePendingLanes),
                0 !== pingedLanes
                  ? (nextLanes = getHighestPriorityLanes(pingedLanes))
                  : rootHasPendingCommit ||
                    ((rootHasPendingCommit = nonIdlePendingLanes & ~root),
                    0 !== rootHasPendingCommit &&
                      (nextLanes = getHighestPriorityLanes(rootHasPendingCommit)))))
          : ((nonIdlePendingLanes = pendingLanes & ~suspendedLanes),
            0 !== nonIdlePendingLanes
              ? (nextLanes = getHighestPriorityLanes(nonIdlePendingLanes))
              : 0 !== pingedLanes
                ? (nextLanes = getHighestPriorityLanes(pingedLanes))
                : rootHasPendingCommit ||
                  ((rootHasPendingCommit = pendingLanes & ~root),
                  0 !== rootHasPendingCommit &&
                    (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))));
        return 0 === nextLanes
          ? 0
          : 0 !== wipLanes &&
              wipLanes !== nextLanes &&
              0 === (wipLanes & suspendedLanes) &&
              ((suspendedLanes = nextLanes & -nextLanes),
              (rootHasPendingCommit = wipLanes & -wipLanes),
              suspendedLanes >= rootHasPendingCommit ||
                (32 === suspendedLanes && 0 !== (rootHasPendingCommit & 4194048)))
            ? wipLanes
            : nextLanes;
      }
      function checkIfRootIsPrerendering(root, renderLanes) {
        return 0 === (root.pendingLanes & ~(root.suspendedLanes & ~root.pingedLanes) & renderLanes);
      }
      function computeExpirationTime(lane, currentTime) {
        switch (lane) {
          case 1:
          case 2:
          case 4:
          case 8:
          case 64:
            return currentTime + 250;
          case 16:
          case 32:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return currentTime + 5e3;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
            return -1;
          case 67108864:
          case 134217728:
          case 268435456:
          case 536870912:
          case 1073741824:
            return -1;
          default:
            return -1;
        }
      }
      function claimNextTransitionLane() {
        var lane = nextTransitionLane;
        nextTransitionLane <<= 1;
        0 === (nextTransitionLane & 4194048) && (nextTransitionLane = 256);
        return lane;
      }
      function claimNextRetryLane() {
        var lane = nextRetryLane;
        nextRetryLane <<= 1;
        0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
        return lane;
      }
      function createLaneMap(initial) {
        for (var laneMap = [], i = 0; 31 > i; i++) laneMap.push(initial);
        return laneMap;
      }
      function markRootUpdated$1(root, updateLane) {
        root.pendingLanes |= updateLane;
        268435456 !== updateLane &&
          ((root.suspendedLanes = 0), (root.pingedLanes = 0), (root.warmLanes = 0));
      }
      function markRootFinished(
        root,
        finishedLanes,
        remainingLanes,
        spawnedLane,
        updatedLanes,
        suspendedRetryLanes
      ) {
        var previouslyPendingLanes = root.pendingLanes;
        root.pendingLanes = remainingLanes;
        root.suspendedLanes = 0;
        root.pingedLanes = 0;
        root.warmLanes = 0;
        root.expiredLanes &= remainingLanes;
        root.entangledLanes &= remainingLanes;
        root.errorRecoveryDisabledLanes &= remainingLanes;
        root.shellSuspendCounter = 0;
        var entanglements = root.entanglements,
          expirationTimes = root.expirationTimes,
          hiddenUpdates = root.hiddenUpdates;
        for (remainingLanes = previouslyPendingLanes & ~remainingLanes; 0 < remainingLanes; ) {
          var index$5 = 31 - clz32(remainingLanes),
            lane = 1 << index$5;
          entanglements[index$5] = 0;
          expirationTimes[index$5] = -1;
          var hiddenUpdatesForLane = hiddenUpdates[index$5];
          if (null !== hiddenUpdatesForLane)
            for (
              hiddenUpdates[index$5] = null, index$5 = 0;
              index$5 < hiddenUpdatesForLane.length;
              index$5++
            ) {
              var update = hiddenUpdatesForLane[index$5];
              null !== update && (update.lane &= -536870913);
            }
          remainingLanes &= ~lane;
        }
        0 !== spawnedLane && markSpawnedDeferredLane(root, spawnedLane, 0);
        0 !== suspendedRetryLanes &&
          0 === updatedLanes &&
          0 !== root.tag &&
          (root.suspendedLanes |= suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
      }
      function markSpawnedDeferredLane(root, spawnedLane, entangledLanes) {
        root.pendingLanes |= spawnedLane;
        root.suspendedLanes &= ~spawnedLane;
        var spawnedLaneIndex = 31 - clz32(spawnedLane);
        root.entangledLanes |= spawnedLane;
        root.entanglements[spawnedLaneIndex] =
          root.entanglements[spawnedLaneIndex] | 1073741824 | (entangledLanes & 4194090);
      }
      function markRootEntangled(root, entangledLanes) {
        var rootEntangledLanes = (root.entangledLanes |= entangledLanes);
        for (root = root.entanglements; rootEntangledLanes; ) {
          var index$6 = 31 - clz32(rootEntangledLanes),
            lane = 1 << index$6;
          (lane & entangledLanes) | (root[index$6] & entangledLanes) &&
            (root[index$6] |= entangledLanes);
          rootEntangledLanes &= ~lane;
        }
      }
      function getBumpedLaneForHydrationByLane(lane) {
        switch (lane) {
          case 2:
            lane = 1;
            break;
          case 8:
            lane = 4;
            break;
          case 32:
            lane = 16;
            break;
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
            lane = 128;
            break;
          case 268435456:
            lane = 134217728;
            break;
          default:
            lane = 0;
        }
        return lane;
      }
      function lanesToEventPriority(lanes) {
        lanes &= -lanes;
        return 2 < lanes ? (8 < lanes ? (0 !== (lanes & 134217727) ? 32 : 268435456) : 8) : 2;
      }
      function resolveUpdatePriority() {
        var updatePriority = ReactDOMSharedInternals.p;
        if (0 !== updatePriority) return updatePriority;
        updatePriority = window.event;
        return void 0 === updatePriority ? 32 : getEventPriority(updatePriority.type);
      }
      function runWithPriority(priority, fn) {
        var previousPriority = ReactDOMSharedInternals.p;
        try {
          return ((ReactDOMSharedInternals.p = priority), fn());
        } finally {
          ReactDOMSharedInternals.p = previousPriority;
        }
      }
      var randomKey = Math.random().toString(36).slice(2),
        internalInstanceKey = '__reactFiber$' + randomKey,
        internalPropsKey = '__reactProps$' + randomKey,
        internalContainerInstanceKey = '__reactContainer$' + randomKey,
        internalEventHandlersKey = '__reactEvents$' + randomKey,
        internalEventHandlerListenersKey = '__reactListeners$' + randomKey,
        internalEventHandlesSetKey = '__reactHandles$' + randomKey,
        internalRootNodeResourcesKey = '__reactResources$' + randomKey,
        internalHoistableMarker = '__reactMarker$' + randomKey;
      function detachDeletedInstance(node) {
        delete node[internalInstanceKey];
        delete node[internalPropsKey];
        delete node[internalEventHandlersKey];
        delete node[internalEventHandlerListenersKey];
        delete node[internalEventHandlesSetKey];
      }
      function getClosestInstanceFromNode(targetNode) {
        var targetInst = targetNode[internalInstanceKey];
        if (targetInst) return targetInst;
        for (var parentNode = targetNode.parentNode; parentNode; ) {
          if (
            (targetInst =
              parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey])
          ) {
            parentNode = targetInst.alternate;
            if (null !== targetInst.child || (null !== parentNode && null !== parentNode.child))
              for (targetNode = getParentSuspenseInstance(targetNode); null !== targetNode; ) {
                if ((parentNode = targetNode[internalInstanceKey])) return parentNode;
                targetNode = getParentSuspenseInstance(targetNode);
              }
            return targetInst;
          }
          targetNode = parentNode;
          parentNode = targetNode.parentNode;
        }
        return null;
      }
      function getInstanceFromNode(node) {
        if ((node = node[internalInstanceKey] || node[internalContainerInstanceKey])) {
          var tag = node.tag;
          if (5 === tag || 6 === tag || 13 === tag || 26 === tag || 27 === tag || 3 === tag)
            return node;
        }
        return null;
      }
      function getNodeFromInstance(inst) {
        var tag = inst.tag;
        if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return inst.stateNode;
        throw Error(formatProdErrorMessage(33));
      }
      function getResourcesFromRoot(root) {
        var resources = root[internalRootNodeResourcesKey];
        resources ||
          (resources = root[internalRootNodeResourcesKey] =
            { hoistableStyles: new Map(), hoistableScripts: new Map() });
        return resources;
      }
      function markNodeAsHoistable(node) {
        node[internalHoistableMarker] = !0;
      }
      var allNativeEvents = new Set(),
        registrationNameDependencies = {};
      function registerTwoPhaseEvent(registrationName, dependencies) {
        registerDirectEvent(registrationName, dependencies);
        registerDirectEvent(registrationName + 'Capture', dependencies);
      }
      function registerDirectEvent(registrationName, dependencies) {
        registrationNameDependencies[registrationName] = dependencies;
        for (registrationName = 0; registrationName < dependencies.length; registrationName++)
          allNativeEvents.add(dependencies[registrationName]);
      }
      var VALID_ATTRIBUTE_NAME_REGEX = RegExp(
          '^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'
        ),
        illegalAttributeNameCache = {},
        validatedAttributeNameCache = {};
      function isAttributeNameSafe(attributeName) {
        if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) return !0;
        if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) return !1;
        if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
          return (validatedAttributeNameCache[attributeName] = !0);
        illegalAttributeNameCache[attributeName] = !0;
        return !1;
      }
      function setValueForAttribute(node, name, value) {
        if (isAttributeNameSafe(name))
          if (null === value) node.removeAttribute(name);
          else {
            switch (typeof value) {
              case 'undefined':
              case 'function':
              case 'symbol':
                node.removeAttribute(name);
                return;
              case 'boolean':
                var prefix$8 = name.toLowerCase().slice(0, 5);
                if ('data-' !== prefix$8 && 'aria-' !== prefix$8) {
                  node.removeAttribute(name);
                  return;
                }
            }
            node.setAttribute(name, '' + value);
          }
      }
      function setValueForKnownAttribute(node, name, value) {
        if (null === value) node.removeAttribute(name);
        else {
          switch (typeof value) {
            case 'undefined':
            case 'function':
            case 'symbol':
            case 'boolean':
              node.removeAttribute(name);
              return;
          }
          node.setAttribute(name, '' + value);
        }
      }
      function setValueForNamespacedAttribute(node, namespace, name, value) {
        if (null === value) node.removeAttribute(name);
        else {
          switch (typeof value) {
            case 'undefined':
            case 'function':
            case 'symbol':
            case 'boolean':
              node.removeAttribute(name);
              return;
          }
          node.setAttributeNS(namespace, name, '' + value);
        }
      }
      var prefix, suffix;
      function describeBuiltInComponentFrame(name) {
        if (void 0 === prefix)
          try {
            throw Error();
          } catch (x) {
            var match = x.stack.trim().match(/\n( *(at )?)/);
            prefix = (match && match[1]) || '';
            suffix =
              -1 < x.stack.indexOf('\n    at')
                ? ' (<anonymous>)'
                : -1 < x.stack.indexOf('@')
                  ? '@unknown:0:0'
                  : '';
          }
        return '\n' + prefix + name + suffix;
      }
      var reentry = !1;
      function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry) return '';
        reentry = !0;
        var previousPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
          var RunInRootFrame = {
            DetermineComponentFrameRoot: function () {
              try {
                if (construct) {
                  var Fake = function () {
                    throw Error();
                  };
                  Object.defineProperty(Fake.prototype, 'props', {
                    set: function () {
                      throw Error();
                    },
                  });
                  if ('object' === typeof Reflect && Reflect.construct) {
                    try {
                      Reflect.construct(Fake, []);
                    } catch (x) {
                      var control = x;
                    }
                    Reflect.construct(fn, [], Fake);
                  } else {
                    try {
                      Fake.call();
                    } catch (x$9) {
                      control = x$9;
                    }
                    fn.call(Fake.prototype);
                  }
                } else {
                  try {
                    throw Error();
                  } catch (x$10) {
                    control = x$10;
                  }
                  (Fake = fn()) && 'function' === typeof Fake.catch && Fake.catch(function () {});
                }
              } catch (sample) {
                if (sample && control && 'string' === typeof sample.stack)
                  return [sample.stack, control.stack];
              }
              return [null, null];
            },
          };
          RunInRootFrame.DetermineComponentFrameRoot.displayName = 'DetermineComponentFrameRoot';
          var namePropDescriptor = Object.getOwnPropertyDescriptor(
            RunInRootFrame.DetermineComponentFrameRoot,
            'name'
          );
          namePropDescriptor &&
            namePropDescriptor.configurable &&
            Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, 'name', {
              value: 'DetermineComponentFrameRoot',
            });
          var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(),
            sampleStack = _RunInRootFrame$Deter[0],
            controlStack = _RunInRootFrame$Deter[1];
          if (sampleStack && controlStack) {
            var sampleLines = sampleStack.split('\n'),
              controlLines = controlStack.split('\n');
            for (
              namePropDescriptor = RunInRootFrame = 0;
              RunInRootFrame < sampleLines.length &&
              !sampleLines[RunInRootFrame].includes('DetermineComponentFrameRoot');

            )
              RunInRootFrame++;
            for (
              ;
              namePropDescriptor < controlLines.length &&
              !controlLines[namePropDescriptor].includes('DetermineComponentFrameRoot');

            )
              namePropDescriptor++;
            if (RunInRootFrame === sampleLines.length || namePropDescriptor === controlLines.length)
              for (
                RunInRootFrame = sampleLines.length - 1,
                  namePropDescriptor = controlLines.length - 1;
                1 <= RunInRootFrame &&
                0 <= namePropDescriptor &&
                sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor];

              )
                namePropDescriptor--;
            for (
              ;
              1 <= RunInRootFrame && 0 <= namePropDescriptor;
              RunInRootFrame--, namePropDescriptor--
            )
              if (sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
                if (1 !== RunInRootFrame || 1 !== namePropDescriptor) {
                  do
                    if (
                      (RunInRootFrame--,
                      namePropDescriptor--,
                      0 > namePropDescriptor ||
                        sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor])
                    ) {
                      var frame = '\n' + sampleLines[RunInRootFrame].replace(' at new ', ' at ');
                      fn.displayName &&
                        frame.includes('<anonymous>') &&
                        (frame = frame.replace('<anonymous>', fn.displayName));
                      return frame;
                    }
                  while (1 <= RunInRootFrame && 0 <= namePropDescriptor);
                }
                break;
              }
          }
        } finally {
          ((reentry = !1), (Error.prepareStackTrace = previousPrepareStackTrace));
        }
        return (previousPrepareStackTrace = fn ? fn.displayName || fn.name : '')
          ? describeBuiltInComponentFrame(previousPrepareStackTrace)
          : '';
      }
      function describeFiber(fiber) {
        switch (fiber.tag) {
          case 26:
          case 27:
          case 5:
            return describeBuiltInComponentFrame(fiber.type);
          case 16:
            return describeBuiltInComponentFrame('Lazy');
          case 13:
            return describeBuiltInComponentFrame('Suspense');
          case 19:
            return describeBuiltInComponentFrame('SuspenseList');
          case 0:
          case 15:
            return describeNativeComponentFrame(fiber.type, !1);
          case 11:
            return describeNativeComponentFrame(fiber.type.render, !1);
          case 1:
            return describeNativeComponentFrame(fiber.type, !0);
          case 31:
            return describeBuiltInComponentFrame('Activity');
          default:
            return '';
        }
      }
      function getStackByFiberInDevAndProd(workInProgress) {
        try {
          var info = '';
          do ((info += describeFiber(workInProgress)), (workInProgress = workInProgress.return));
          while (workInProgress);
          return info;
        } catch (x) {
          return '\nError generating stack: ' + x.message + '\n' + x.stack;
        }
      }
      function getToStringValue(value) {
        switch (typeof value) {
          case 'bigint':
          case 'boolean':
          case 'number':
          case 'string':
          case 'undefined':
            return value;
          case 'object':
            return value;
          default:
            return '';
        }
      }
      function isCheckable(elem) {
        var type = elem.type;
        return (
          (elem = elem.nodeName) &&
          'input' === elem.toLowerCase() &&
          ('checkbox' === type || 'radio' === type)
        );
      }
      function trackValueOnNode(node) {
        var valueField = isCheckable(node) ? 'checked' : 'value',
          descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField),
          currentValue = '' + node[valueField];
        if (
          !node.hasOwnProperty(valueField) &&
          'undefined' !== typeof descriptor &&
          'function' === typeof descriptor.get &&
          'function' === typeof descriptor.set
        ) {
          var get = descriptor.get,
            set = descriptor.set;
          Object.defineProperty(node, valueField, {
            configurable: !0,
            get: function () {
              return get.call(this);
            },
            set: function (value) {
              currentValue = '' + value;
              set.call(this, value);
            },
          });
          Object.defineProperty(node, valueField, {
            enumerable: descriptor.enumerable,
          });
          return {
            getValue: function () {
              return currentValue;
            },
            setValue: function (value) {
              currentValue = '' + value;
            },
            stopTracking: function () {
              node._valueTracker = null;
              delete node[valueField];
            },
          };
        }
      }
      function track(node) {
        node._valueTracker || (node._valueTracker = trackValueOnNode(node));
      }
      function updateValueIfChanged(node) {
        if (!node) return !1;
        var tracker = node._valueTracker;
        if (!tracker) return !0;
        var lastValue = tracker.getValue();
        var value = '';
        node && (value = isCheckable(node) ? (node.checked ? 'true' : 'false') : node.value);
        node = value;
        return node !== lastValue ? (tracker.setValue(node), !0) : !1;
      }
      function getActiveElement(doc) {
        doc = doc || ('undefined' !== typeof document ? document : void 0);
        if ('undefined' === typeof doc) return null;
        try {
          return doc.activeElement || doc.body;
        } catch (e) {
          return doc.body;
        }
      }
      var escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g;
      function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
        return value.replace(escapeSelectorAttributeValueInsideDoubleQuotesRegex, function (ch) {
          return '\\' + ch.charCodeAt(0).toString(16) + ' ';
        });
      }
      function updateInput(
        element,
        value,
        defaultValue,
        lastDefaultValue,
        checked,
        defaultChecked,
        type,
        name
      ) {
        element.name = '';
        null != type &&
        'function' !== typeof type &&
        'symbol' !== typeof type &&
        'boolean' !== typeof type
          ? (element.type = type)
          : element.removeAttribute('type');
        if (null != value)
          if ('number' === type) {
            if ((0 === value && '' === element.value) || element.value != value)
              element.value = '' + getToStringValue(value);
          } else
            element.value !== '' + getToStringValue(value) &&
              (element.value = '' + getToStringValue(value));
        else ('submit' !== type && 'reset' !== type) || element.removeAttribute('value');
        null != value
          ? setDefaultValue(element, type, getToStringValue(value))
          : null != defaultValue
            ? setDefaultValue(element, type, getToStringValue(defaultValue))
            : null != lastDefaultValue && element.removeAttribute('value');
        null == checked && null != defaultChecked && (element.defaultChecked = !!defaultChecked);
        null != checked &&
          (element.checked =
            checked && 'function' !== typeof checked && 'symbol' !== typeof checked);
        null != name &&
        'function' !== typeof name &&
        'symbol' !== typeof name &&
        'boolean' !== typeof name
          ? (element.name = '' + getToStringValue(name))
          : element.removeAttribute('name');
      }
      function initInput(
        element,
        value,
        defaultValue,
        checked,
        defaultChecked,
        type,
        name,
        isHydrating
      ) {
        null != type &&
          'function' !== typeof type &&
          'symbol' !== typeof type &&
          'boolean' !== typeof type &&
          (element.type = type);
        if (null != value || null != defaultValue) {
          if (!(('submit' !== type && 'reset' !== type) || (void 0 !== value && null !== value)))
            return;
          defaultValue = null != defaultValue ? '' + getToStringValue(defaultValue) : '';
          value = null != value ? '' + getToStringValue(value) : defaultValue;
          isHydrating || value === element.value || (element.value = value);
          element.defaultValue = value;
        }
        checked = null != checked ? checked : defaultChecked;
        checked = 'function' !== typeof checked && 'symbol' !== typeof checked && !!checked;
        element.checked = isHydrating ? element.checked : !!checked;
        element.defaultChecked = !!checked;
        null != name &&
          'function' !== typeof name &&
          'symbol' !== typeof name &&
          'boolean' !== typeof name &&
          (element.name = name);
      }
      function setDefaultValue(node, type, value) {
        ('number' === type && getActiveElement(node.ownerDocument) === node) ||
          node.defaultValue === '' + value ||
          (node.defaultValue = '' + value);
      }
      function updateOptions(node, multiple, propValue, setDefaultSelected) {
        node = node.options;
        if (multiple) {
          multiple = {};
          for (var i = 0; i < propValue.length; i++) multiple['$' + propValue[i]] = !0;
          for (propValue = 0; propValue < node.length; propValue++)
            ((i = multiple.hasOwnProperty('$' + node[propValue].value)),
              node[propValue].selected !== i && (node[propValue].selected = i),
              i && setDefaultSelected && (node[propValue].defaultSelected = !0));
        } else {
          propValue = '' + getToStringValue(propValue);
          multiple = null;
          for (i = 0; i < node.length; i++) {
            if (node[i].value === propValue) {
              node[i].selected = !0;
              setDefaultSelected && (node[i].defaultSelected = !0);
              return;
            }
            null !== multiple || node[i].disabled || (multiple = node[i]);
          }
          null !== multiple && (multiple.selected = !0);
        }
      }
      function updateTextarea(element, value, defaultValue) {
        if (
          null != value &&
          ((value = '' + getToStringValue(value)),
          value !== element.value && (element.value = value),
          null == defaultValue)
        ) {
          element.defaultValue !== value && (element.defaultValue = value);
          return;
        }
        element.defaultValue = null != defaultValue ? '' + getToStringValue(defaultValue) : '';
      }
      function initTextarea(element, value, defaultValue, children) {
        if (null == value) {
          if (null != children) {
            if (null != defaultValue) throw Error(formatProdErrorMessage(92));
            if (isArrayImpl(children)) {
              if (1 < children.length) throw Error(formatProdErrorMessage(93));
              children = children[0];
            }
            defaultValue = children;
          }
          null == defaultValue && (defaultValue = '');
          value = defaultValue;
        }
        defaultValue = getToStringValue(value);
        element.defaultValue = defaultValue;
        children = element.textContent;
        children === defaultValue &&
          '' !== children &&
          null !== children &&
          (element.value = children);
      }
      function setTextContent(node, text) {
        if (text) {
          var firstChild = node.firstChild;
          if (firstChild && firstChild === node.lastChild && 3 === firstChild.nodeType) {
            firstChild.nodeValue = text;
            return;
          }
        }
        node.textContent = text;
      }
      var unitlessNumbers = new Set(
        'animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp'.split(
          ' '
        )
      );
      function setValueForStyle(style, styleName, value) {
        var isCustomProperty = 0 === styleName.indexOf('--');
        null == value || 'boolean' === typeof value || '' === value
          ? isCustomProperty
            ? style.setProperty(styleName, '')
            : 'float' === styleName
              ? (style.cssFloat = '')
              : (style[styleName] = '')
          : isCustomProperty
            ? style.setProperty(styleName, value)
            : 'number' !== typeof value || 0 === value || unitlessNumbers.has(styleName)
              ? 'float' === styleName
                ? (style.cssFloat = value)
                : (style[styleName] = ('' + value).trim())
              : (style[styleName] = value + 'px');
      }
      function setValueForStyles(node, styles, prevStyles) {
        if (null != styles && 'object' !== typeof styles) throw Error(formatProdErrorMessage(62));
        node = node.style;
        if (null != prevStyles) {
          for (var styleName in prevStyles)
            !prevStyles.hasOwnProperty(styleName) ||
              (null != styles && styles.hasOwnProperty(styleName)) ||
              (0 === styleName.indexOf('--')
                ? node.setProperty(styleName, '')
                : 'float' === styleName
                  ? (node.cssFloat = '')
                  : (node[styleName] = ''));
          for (var styleName$16 in styles)
            ((styleName = styles[styleName$16]),
              styles.hasOwnProperty(styleName$16) &&
                prevStyles[styleName$16] !== styleName &&
                setValueForStyle(node, styleName$16, styleName));
        } else
          for (var styleName$17 in styles)
            styles.hasOwnProperty(styleName$17) &&
              setValueForStyle(node, styleName$17, styles[styleName$17]);
      }
      function isCustomElement(tagName) {
        if (-1 === tagName.indexOf('-')) return !1;
        switch (tagName) {
          case 'annotation-xml':
          case 'color-profile':
          case 'font-face':
          case 'font-face-src':
          case 'font-face-uri':
          case 'font-face-format':
          case 'font-face-name':
          case 'missing-glyph':
            return !1;
          default:
            return !0;
        }
      }
      var aliases = new Map([
          ['acceptCharset', 'accept-charset'],
          ['htmlFor', 'for'],
          ['httpEquiv', 'http-equiv'],
          ['crossOrigin', 'crossorigin'],
          ['accentHeight', 'accent-height'],
          ['alignmentBaseline', 'alignment-baseline'],
          ['arabicForm', 'arabic-form'],
          ['baselineShift', 'baseline-shift'],
          ['capHeight', 'cap-height'],
          ['clipPath', 'clip-path'],
          ['clipRule', 'clip-rule'],
          ['colorInterpolation', 'color-interpolation'],
          ['colorInterpolationFilters', 'color-interpolation-filters'],
          ['colorProfile', 'color-profile'],
          ['colorRendering', 'color-rendering'],
          ['dominantBaseline', 'dominant-baseline'],
          ['enableBackground', 'enable-background'],
          ['fillOpacity', 'fill-opacity'],
          ['fillRule', 'fill-rule'],
          ['floodColor', 'flood-color'],
          ['floodOpacity', 'flood-opacity'],
          ['fontFamily', 'font-family'],
          ['fontSize', 'font-size'],
          ['fontSizeAdjust', 'font-size-adjust'],
          ['fontStretch', 'font-stretch'],
          ['fontStyle', 'font-style'],
          ['fontVariant', 'font-variant'],
          ['fontWeight', 'font-weight'],
          ['glyphName', 'glyph-name'],
          ['glyphOrientationHorizontal', 'glyph-orientation-horizontal'],
          ['glyphOrientationVertical', 'glyph-orientation-vertical'],
          ['horizAdvX', 'horiz-adv-x'],
          ['horizOriginX', 'horiz-origin-x'],
          ['imageRendering', 'image-rendering'],
          ['letterSpacing', 'letter-spacing'],
          ['lightingColor', 'lighting-color'],
          ['markerEnd', 'marker-end'],
          ['markerMid', 'marker-mid'],
          ['markerStart', 'marker-start'],
          ['overlinePosition', 'overline-position'],
          ['overlineThickness', 'overline-thickness'],
          ['paintOrder', 'paint-order'],
          ['panose-1', 'panose-1'],
          ['pointerEvents', 'pointer-events'],
          ['renderingIntent', 'rendering-intent'],
          ['shapeRendering', 'shape-rendering'],
          ['stopColor', 'stop-color'],
          ['stopOpacity', 'stop-opacity'],
          ['strikethroughPosition', 'strikethrough-position'],
          ['strikethroughThickness', 'strikethrough-thickness'],
          ['strokeDasharray', 'stroke-dasharray'],
          ['strokeDashoffset', 'stroke-dashoffset'],
          ['strokeLinecap', 'stroke-linecap'],
          ['strokeLinejoin', 'stroke-linejoin'],
          ['strokeMiterlimit', 'stroke-miterlimit'],
          ['strokeOpacity', 'stroke-opacity'],
          ['strokeWidth', 'stroke-width'],
          ['textAnchor', 'text-anchor'],
          ['textDecoration', 'text-decoration'],
          ['textRendering', 'text-rendering'],
          ['transformOrigin', 'transform-origin'],
          ['underlinePosition', 'underline-position'],
          ['underlineThickness', 'underline-thickness'],
          ['unicodeBidi', 'unicode-bidi'],
          ['unicodeRange', 'unicode-range'],
          ['unitsPerEm', 'units-per-em'],
          ['vAlphabetic', 'v-alphabetic'],
          ['vHanging', 'v-hanging'],
          ['vIdeographic', 'v-ideographic'],
          ['vMathematical', 'v-mathematical'],
          ['vectorEffect', 'vector-effect'],
          ['vertAdvY', 'vert-adv-y'],
          ['vertOriginX', 'vert-origin-x'],
          ['vertOriginY', 'vert-origin-y'],
          ['wordSpacing', 'word-spacing'],
          ['writingMode', 'writing-mode'],
          ['xmlnsXlink', 'xmlns:xlink'],
          ['xHeight', 'x-height'],
        ]),
        isJavaScriptProtocol =
          /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
      function sanitizeURL(url) {
        return isJavaScriptProtocol.test('' + url)
          ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')"
          : url;
      }
      var currentReplayingEvent = null;
      function getEventTarget(nativeEvent) {
        nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;
        nativeEvent.correspondingUseElement && (nativeEvent = nativeEvent.correspondingUseElement);
        return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;
      }
      var restoreTarget = null,
        restoreQueue = null;
      function restoreStateOfTarget(target) {
        var internalInstance = getInstanceFromNode(target);
        if (internalInstance && (target = internalInstance.stateNode)) {
          var props = target[internalPropsKey] || null;
          a: switch (((target = internalInstance.stateNode), internalInstance.type)) {
            case 'input':
              updateInput(
                target,
                props.value,
                props.defaultValue,
                props.defaultValue,
                props.checked,
                props.defaultChecked,
                props.type,
                props.name
              );
              internalInstance = props.name;
              if ('radio' === props.type && null != internalInstance) {
                for (props = target; props.parentNode; ) props = props.parentNode;
                props = props.querySelectorAll(
                  'input[name="' +
                    escapeSelectorAttributeValueInsideDoubleQuotes('' + internalInstance) +
                    '"][type="radio"]'
                );
                for (internalInstance = 0; internalInstance < props.length; internalInstance++) {
                  var otherNode = props[internalInstance];
                  if (otherNode !== target && otherNode.form === target.form) {
                    var otherProps = otherNode[internalPropsKey] || null;
                    if (!otherProps) throw Error(formatProdErrorMessage(90));
                    updateInput(
                      otherNode,
                      otherProps.value,
                      otherProps.defaultValue,
                      otherProps.defaultValue,
                      otherProps.checked,
                      otherProps.defaultChecked,
                      otherProps.type,
                      otherProps.name
                    );
                  }
                }
                for (internalInstance = 0; internalInstance < props.length; internalInstance++)
                  ((otherNode = props[internalInstance]),
                    otherNode.form === target.form && updateValueIfChanged(otherNode));
              }
              break a;
            case 'textarea':
              updateTextarea(target, props.value, props.defaultValue);
              break a;
            case 'select':
              ((internalInstance = props.value),
                null != internalInstance &&
                  updateOptions(target, !!props.multiple, internalInstance, !1));
          }
        }
      }
      var isInsideEventHandler = !1;
      function batchedUpdates$1(fn, a, b) {
        if (isInsideEventHandler) return fn(a, b);
        isInsideEventHandler = !0;
        try {
          var JSCompiler_inline_result = fn(a);
          return JSCompiler_inline_result;
        } finally {
          if (((isInsideEventHandler = !1), null !== restoreTarget || null !== restoreQueue))
            if (
              (flushSyncWork$1(),
              restoreTarget &&
                ((a = restoreTarget),
                (fn = restoreQueue),
                (restoreQueue = restoreTarget = null),
                restoreStateOfTarget(a),
                fn))
            )
              for (a = 0; a < fn.length; a++) restoreStateOfTarget(fn[a]);
        }
      }
      function getListener(inst, registrationName) {
        var stateNode = inst.stateNode;
        if (null === stateNode) return null;
        var props = stateNode[internalPropsKey] || null;
        if (null === props) return null;
        stateNode = props[registrationName];
        a: switch (registrationName) {
          case 'onClick':
          case 'onClickCapture':
          case 'onDoubleClick':
          case 'onDoubleClickCapture':
          case 'onMouseDown':
          case 'onMouseDownCapture':
          case 'onMouseMove':
          case 'onMouseMoveCapture':
          case 'onMouseUp':
          case 'onMouseUpCapture':
          case 'onMouseEnter':
            (props = !props.disabled) ||
              ((inst = inst.type),
              (props = !(
                'button' === inst ||
                'input' === inst ||
                'select' === inst ||
                'textarea' === inst
              )));
            inst = !props;
            break a;
          default:
            inst = !1;
        }
        if (inst) return null;
        if (stateNode && 'function' !== typeof stateNode)
          throw Error(formatProdErrorMessage(231, registrationName, typeof stateNode));
        return stateNode;
      }
      var canUseDOM = !(
          'undefined' === typeof window ||
          'undefined' === typeof window.document ||
          'undefined' === typeof window.document.createElement
        ),
        passiveBrowserEventsSupported = !1;
      if (canUseDOM)
        try {
          var options = {};
          Object.defineProperty(options, 'passive', {
            get: function () {
              passiveBrowserEventsSupported = !0;
            },
          });
          window.addEventListener('test', options, options);
          window.removeEventListener('test', options, options);
        } catch (e) {
          passiveBrowserEventsSupported = !1;
        }
      var root = null,
        startText = null,
        fallbackText = null;
      function getData() {
        if (fallbackText) return fallbackText;
        var start,
          startValue = startText,
          startLength = startValue.length,
          end,
          endValue = 'value' in root ? root.value : root.textContent,
          endLength = endValue.length;
        for (start = 0; start < startLength && startValue[start] === endValue[start]; start++);
        var minEnd = startLength - start;
        for (
          end = 1;
          end <= minEnd && startValue[startLength - end] === endValue[endLength - end];
          end++
        );
        return (fallbackText = endValue.slice(start, 1 < end ? 1 - end : void 0));
      }
      function getEventCharCode(nativeEvent) {
        var keyCode = nativeEvent.keyCode;
        'charCode' in nativeEvent
          ? ((nativeEvent = nativeEvent.charCode),
            0 === nativeEvent && 13 === keyCode && (nativeEvent = 13))
          : (nativeEvent = keyCode);
        10 === nativeEvent && (nativeEvent = 13);
        return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;
      }
      function functionThatReturnsTrue() {
        return !0;
      }
      function functionThatReturnsFalse() {
        return !1;
      }
      function createSyntheticEvent(Interface) {
        function SyntheticBaseEvent(
          reactName,
          reactEventType,
          targetInst,
          nativeEvent,
          nativeEventTarget
        ) {
          this._reactName = reactName;
          this._targetInst = targetInst;
          this.type = reactEventType;
          this.nativeEvent = nativeEvent;
          this.target = nativeEventTarget;
          this.currentTarget = null;
          for (var propName in Interface)
            Interface.hasOwnProperty(propName) &&
              ((reactName = Interface[propName]),
              (this[propName] = reactName ? reactName(nativeEvent) : nativeEvent[propName]));
          this.isDefaultPrevented = (
            null != nativeEvent.defaultPrevented
              ? nativeEvent.defaultPrevented
              : !1 === nativeEvent.returnValue
          )
            ? functionThatReturnsTrue
            : functionThatReturnsFalse;
          this.isPropagationStopped = functionThatReturnsFalse;
          return this;
        }
        assign(SyntheticBaseEvent.prototype, {
          preventDefault: function () {
            this.defaultPrevented = !0;
            var event = this.nativeEvent;
            event &&
              (event.preventDefault
                ? event.preventDefault()
                : 'unknown' !== typeof event.returnValue && (event.returnValue = !1),
              (this.isDefaultPrevented = functionThatReturnsTrue));
          },
          stopPropagation: function () {
            var event = this.nativeEvent;
            event &&
              (event.stopPropagation
                ? event.stopPropagation()
                : 'unknown' !== typeof event.cancelBubble && (event.cancelBubble = !0),
              (this.isPropagationStopped = functionThatReturnsTrue));
          },
          persist: function () {},
          isPersistent: functionThatReturnsTrue,
        });
        return SyntheticBaseEvent;
      }
      var EventInterface = {
          eventPhase: 0,
          bubbles: 0,
          cancelable: 0,
          timeStamp: function (event) {
            return event.timeStamp || Date.now();
          },
          defaultPrevented: 0,
          isTrusted: 0,
        },
        SyntheticEvent = createSyntheticEvent(EventInterface),
        UIEventInterface = assign({}, EventInterface, { view: 0, detail: 0 }),
        SyntheticUIEvent = createSyntheticEvent(UIEventInterface),
        lastMovementX,
        lastMovementY,
        lastMouseEvent,
        MouseEventInterface = assign({}, UIEventInterface, {
          screenX: 0,
          screenY: 0,
          clientX: 0,
          clientY: 0,
          pageX: 0,
          pageY: 0,
          ctrlKey: 0,
          shiftKey: 0,
          altKey: 0,
          metaKey: 0,
          getModifierState: getEventModifierState,
          button: 0,
          buttons: 0,
          relatedTarget: function (event) {
            return void 0 === event.relatedTarget
              ? event.fromElement === event.srcElement
                ? event.toElement
                : event.fromElement
              : event.relatedTarget;
          },
          movementX: function (event) {
            if ('movementX' in event) return event.movementX;
            event !== lastMouseEvent &&
              (lastMouseEvent && 'mousemove' === event.type
                ? ((lastMovementX = event.screenX - lastMouseEvent.screenX),
                  (lastMovementY = event.screenY - lastMouseEvent.screenY))
                : (lastMovementY = lastMovementX = 0),
              (lastMouseEvent = event));
            return lastMovementX;
          },
          movementY: function (event) {
            return 'movementY' in event ? event.movementY : lastMovementY;
          },
        }),
        SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface),
        DragEventInterface = assign({}, MouseEventInterface, { dataTransfer: 0 }),
        SyntheticDragEvent = createSyntheticEvent(DragEventInterface),
        FocusEventInterface = assign({}, UIEventInterface, { relatedTarget: 0 }),
        SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface),
        AnimationEventInterface = assign({}, EventInterface, {
          animationName: 0,
          elapsedTime: 0,
          pseudoElement: 0,
        }),
        SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface),
        ClipboardEventInterface = assign({}, EventInterface, {
          clipboardData: function (event) {
            return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
          },
        }),
        SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface),
        CompositionEventInterface = assign({}, EventInterface, { data: 0 }),
        SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface),
        normalizeKey = {
          Esc: 'Escape',
          Spacebar: ' ',
          Left: 'ArrowLeft',
          Up: 'ArrowUp',
          Right: 'ArrowRight',
          Down: 'ArrowDown',
          Del: 'Delete',
          Win: 'OS',
          Menu: 'ContextMenu',
          Apps: 'ContextMenu',
          Scroll: 'ScrollLock',
          MozPrintableKey: 'Unidentified',
        },
        translateToKey = {
          8: 'Backspace',
          9: 'Tab',
          12: 'Clear',
          13: 'Enter',
          16: 'Shift',
          17: 'Control',
          18: 'Alt',
          19: 'Pause',
          20: 'CapsLock',
          27: 'Escape',
          32: ' ',
          33: 'PageUp',
          34: 'PageDown',
          35: 'End',
          36: 'Home',
          37: 'ArrowLeft',
          38: 'ArrowUp',
          39: 'ArrowRight',
          40: 'ArrowDown',
          45: 'Insert',
          46: 'Delete',
          112: 'F1',
          113: 'F2',
          114: 'F3',
          115: 'F4',
          116: 'F5',
          117: 'F6',
          118: 'F7',
          119: 'F8',
          120: 'F9',
          121: 'F10',
          122: 'F11',
          123: 'F12',
          144: 'NumLock',
          145: 'ScrollLock',
          224: 'Meta',
        },
        modifierKeyToProp = {
          Alt: 'altKey',
          Control: 'ctrlKey',
          Meta: 'metaKey',
          Shift: 'shiftKey',
        };
      function modifierStateGetter(keyArg) {
        var nativeEvent = this.nativeEvent;
        return nativeEvent.getModifierState
          ? nativeEvent.getModifierState(keyArg)
          : (keyArg = modifierKeyToProp[keyArg])
            ? !!nativeEvent[keyArg]
            : !1;
      }
      function getEventModifierState() {
        return modifierStateGetter;
      }
      var KeyboardEventInterface = assign({}, UIEventInterface, {
          key: function (nativeEvent) {
            if (nativeEvent.key) {
              var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
              if ('Unidentified' !== key) return key;
            }
            return 'keypress' === nativeEvent.type
              ? ((nativeEvent = getEventCharCode(nativeEvent)),
                13 === nativeEvent ? 'Enter' : String.fromCharCode(nativeEvent))
              : 'keydown' === nativeEvent.type || 'keyup' === nativeEvent.type
                ? translateToKey[nativeEvent.keyCode] || 'Unidentified'
                : '';
          },
          code: 0,
          location: 0,
          ctrlKey: 0,
          shiftKey: 0,
          altKey: 0,
          metaKey: 0,
          repeat: 0,
          locale: 0,
          getModifierState: getEventModifierState,
          charCode: function (event) {
            return 'keypress' === event.type ? getEventCharCode(event) : 0;
          },
          keyCode: function (event) {
            return 'keydown' === event.type || 'keyup' === event.type ? event.keyCode : 0;
          },
          which: function (event) {
            return 'keypress' === event.type
              ? getEventCharCode(event)
              : 'keydown' === event.type || 'keyup' === event.type
                ? event.keyCode
                : 0;
          },
        }),
        SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface),
        PointerEventInterface = assign({}, MouseEventInterface, {
          pointerId: 0,
          width: 0,
          height: 0,
          pressure: 0,
          tangentialPressure: 0,
          tiltX: 0,
          tiltY: 0,
          twist: 0,
          pointerType: 0,
          isPrimary: 0,
        }),
        SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface),
        TouchEventInterface = assign({}, UIEventInterface, {
          touches: 0,
          targetTouches: 0,
          changedTouches: 0,
          altKey: 0,
          metaKey: 0,
          ctrlKey: 0,
          shiftKey: 0,
          getModifierState: getEventModifierState,
        }),
        SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface),
        TransitionEventInterface = assign({}, EventInterface, {
          propertyName: 0,
          elapsedTime: 0,
          pseudoElement: 0,
        }),
        SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface),
        WheelEventInterface = assign({}, MouseEventInterface, {
          deltaX: function (event) {
            return 'deltaX' in event
              ? event.deltaX
              : 'wheelDeltaX' in event
                ? -event.wheelDeltaX
                : 0;
          },
          deltaY: function (event) {
            return 'deltaY' in event
              ? event.deltaY
              : 'wheelDeltaY' in event
                ? -event.wheelDeltaY
                : 'wheelDelta' in event
                  ? -event.wheelDelta
                  : 0;
          },
          deltaZ: 0,
          deltaMode: 0,
        }),
        SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface),
        ToggleEventInterface = assign({}, EventInterface, {
          newState: 0,
          oldState: 0,
        }),
        SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface),
        END_KEYCODES = [9, 13, 27, 32],
        canUseCompositionEvent = canUseDOM && 'CompositionEvent' in window,
        documentMode = null;
      canUseDOM && 'documentMode' in document && (documentMode = document.documentMode);
      var canUseTextInputEvent = canUseDOM && 'TextEvent' in window && !documentMode,
        useFallbackCompositionData =
          canUseDOM &&
          (!canUseCompositionEvent || (documentMode && 8 < documentMode && 11 >= documentMode)),
        SPACEBAR_CHAR = String.fromCharCode(32),
        hasSpaceKeypress = !1;
      function isFallbackCompositionEnd(domEventName, nativeEvent) {
        switch (domEventName) {
          case 'keyup':
            return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);
          case 'keydown':
            return 229 !== nativeEvent.keyCode;
          case 'keypress':
          case 'mousedown':
          case 'focusout':
            return !0;
          default:
            return !1;
        }
      }
      function getDataFromCustomEvent(nativeEvent) {
        nativeEvent = nativeEvent.detail;
        return 'object' === typeof nativeEvent && 'data' in nativeEvent ? nativeEvent.data : null;
      }
      var isComposing = !1;
      function getNativeBeforeInputChars(domEventName, nativeEvent) {
        switch (domEventName) {
          case 'compositionend':
            return getDataFromCustomEvent(nativeEvent);
          case 'keypress':
            if (32 !== nativeEvent.which) return null;
            hasSpaceKeypress = !0;
            return SPACEBAR_CHAR;
          case 'textInput':
            return (
              (domEventName = nativeEvent.data),
              domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName
            );
          default:
            return null;
        }
      }
      function getFallbackBeforeInputChars(domEventName, nativeEvent) {
        if (isComposing)
          return 'compositionend' === domEventName ||
            (!canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent))
            ? ((domEventName = getData()),
              (fallbackText = startText = root = null),
              (isComposing = !1),
              domEventName)
            : null;
        switch (domEventName) {
          case 'paste':
            return null;
          case 'keypress':
            if (
              !(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) ||
              (nativeEvent.ctrlKey && nativeEvent.altKey)
            ) {
              if (nativeEvent.char && 1 < nativeEvent.char.length) return nativeEvent.char;
              if (nativeEvent.which) return String.fromCharCode(nativeEvent.which);
            }
            return null;
          case 'compositionend':
            return useFallbackCompositionData && 'ko' !== nativeEvent.locale
              ? null
              : nativeEvent.data;
          default:
            return null;
        }
      }
      var supportedInputTypes = {
        color: !0,
        date: !0,
        datetime: !0,
        'datetime-local': !0,
        email: !0,
        month: !0,
        number: !0,
        password: !0,
        range: !0,
        search: !0,
        tel: !0,
        text: !0,
        time: !0,
        url: !0,
        week: !0,
      };
      function isTextInputElement(elem) {
        var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
        return 'input' === nodeName
          ? !!supportedInputTypes[elem.type]
          : 'textarea' === nodeName
            ? !0
            : !1;
      }
      function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
        restoreTarget
          ? restoreQueue
            ? restoreQueue.push(target)
            : (restoreQueue = [target])
          : (restoreTarget = target);
        inst = accumulateTwoPhaseListeners(inst, 'onChange');
        0 < inst.length &&
          ((nativeEvent = new SyntheticEvent('onChange', 'change', null, nativeEvent, target)),
          dispatchQueue.push({ event: nativeEvent, listeners: inst }));
      }
      var activeElement$1 = null,
        activeElementInst$1 = null;
      function runEventInBatch(dispatchQueue) {
        processDispatchQueue(dispatchQueue, 0);
      }
      function getInstIfValueChanged(targetInst) {
        var targetNode = getNodeFromInstance(targetInst);
        if (updateValueIfChanged(targetNode)) return targetInst;
      }
      function getTargetInstForChangeEvent(domEventName, targetInst) {
        if ('change' === domEventName) return targetInst;
      }
      var isInputEventSupported = !1;
      if (canUseDOM) {
        var JSCompiler_inline_result$jscomp$282;
        if (canUseDOM) {
          var isSupported$jscomp$inline_417 = 'oninput' in document;
          if (!isSupported$jscomp$inline_417) {
            var element$jscomp$inline_418 = document.createElement('div');
            element$jscomp$inline_418.setAttribute('oninput', 'return;');
            isSupported$jscomp$inline_417 = 'function' === typeof element$jscomp$inline_418.oninput;
          }
          JSCompiler_inline_result$jscomp$282 = isSupported$jscomp$inline_417;
        } else JSCompiler_inline_result$jscomp$282 = !1;
        isInputEventSupported =
          JSCompiler_inline_result$jscomp$282 &&
          (!document.documentMode || 9 < document.documentMode);
      }
      function stopWatchingForValueChange() {
        activeElement$1 &&
          (activeElement$1.detachEvent('onpropertychange', handlePropertyChange),
          (activeElementInst$1 = activeElement$1 = null));
      }
      function handlePropertyChange(nativeEvent) {
        if ('value' === nativeEvent.propertyName && getInstIfValueChanged(activeElementInst$1)) {
          var dispatchQueue = [];
          createAndAccumulateChangeEvent(
            dispatchQueue,
            activeElementInst$1,
            nativeEvent,
            getEventTarget(nativeEvent)
          );
          batchedUpdates$1(runEventInBatch, dispatchQueue);
        }
      }
      function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
        'focusin' === domEventName
          ? (stopWatchingForValueChange(),
            (activeElement$1 = target),
            (activeElementInst$1 = targetInst),
            activeElement$1.attachEvent('onpropertychange', handlePropertyChange))
          : 'focusout' === domEventName && stopWatchingForValueChange();
      }
      function getTargetInstForInputEventPolyfill(domEventName) {
        if (
          'selectionchange' === domEventName ||
          'keyup' === domEventName ||
          'keydown' === domEventName
        )
          return getInstIfValueChanged(activeElementInst$1);
      }
      function getTargetInstForClickEvent(domEventName, targetInst) {
        if ('click' === domEventName) return getInstIfValueChanged(targetInst);
      }
      function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
        if ('input' === domEventName || 'change' === domEventName)
          return getInstIfValueChanged(targetInst);
      }
      function is(x, y) {
        return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);
      }
      var objectIs = 'function' === typeof Object.is ? Object.is : is;
      function shallowEqual(objA, objB) {
        if (objectIs(objA, objB)) return !0;
        if ('object' !== typeof objA || null === objA || 'object' !== typeof objB || null === objB)
          return !1;
        var keysA = Object.keys(objA),
          keysB = Object.keys(objB);
        if (keysA.length !== keysB.length) return !1;
        for (keysB = 0; keysB < keysA.length; keysB++) {
          var currentKey = keysA[keysB];
          if (
            !hasOwnProperty.call(objB, currentKey) ||
            !objectIs(objA[currentKey], objB[currentKey])
          )
            return !1;
        }
        return !0;
      }
      function getLeafNode(node) {
        for (; node && node.firstChild; ) node = node.firstChild;
        return node;
      }
      function getNodeForCharacterOffset(root, offset) {
        var node = getLeafNode(root);
        root = 0;
        for (var nodeEnd; node; ) {
          if (3 === node.nodeType) {
            nodeEnd = root + node.textContent.length;
            if (root <= offset && nodeEnd >= offset) return { node: node, offset: offset - root };
            root = nodeEnd;
          }
          a: {
            for (; node; ) {
              if (node.nextSibling) {
                node = node.nextSibling;
                break a;
              }
              node = node.parentNode;
            }
            node = void 0;
          }
          node = getLeafNode(node);
        }
      }
      function containsNode(outerNode, innerNode) {
        return outerNode && innerNode
          ? outerNode === innerNode
            ? !0
            : outerNode && 3 === outerNode.nodeType
              ? !1
              : innerNode && 3 === innerNode.nodeType
                ? containsNode(outerNode, innerNode.parentNode)
                : 'contains' in outerNode
                  ? outerNode.contains(innerNode)
                  : outerNode.compareDocumentPosition
                    ? !!(outerNode.compareDocumentPosition(innerNode) & 16)
                    : !1
          : !1;
      }
      function getActiveElementDeep(containerInfo) {
        containerInfo =
          null != containerInfo &&
          null != containerInfo.ownerDocument &&
          null != containerInfo.ownerDocument.defaultView
            ? containerInfo.ownerDocument.defaultView
            : window;
        for (
          var element = getActiveElement(containerInfo.document);
          element instanceof containerInfo.HTMLIFrameElement;

        ) {
          try {
            var JSCompiler_inline_result = 'string' === typeof element.contentWindow.location.href;
          } catch (err) {
            JSCompiler_inline_result = !1;
          }
          if (JSCompiler_inline_result) containerInfo = element.contentWindow;
          else break;
          element = getActiveElement(containerInfo.document);
        }
        return element;
      }
      function hasSelectionCapabilities(elem) {
        var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
        return (
          nodeName &&
          (('input' === nodeName &&
            ('text' === elem.type ||
              'search' === elem.type ||
              'tel' === elem.type ||
              'url' === elem.type ||
              'password' === elem.type)) ||
            'textarea' === nodeName ||
            'true' === elem.contentEditable)
        );
      }
      var skipSelectionChangeEvent =
          canUseDOM && 'documentMode' in document && 11 >= document.documentMode,
        activeElement = null,
        activeElementInst = null,
        lastSelection = null,
        mouseDown = !1;
      function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
        var doc =
          nativeEventTarget.window === nativeEventTarget
            ? nativeEventTarget.document
            : 9 === nativeEventTarget.nodeType
              ? nativeEventTarget
              : nativeEventTarget.ownerDocument;
        mouseDown ||
          null == activeElement ||
          activeElement !== getActiveElement(doc) ||
          ((doc = activeElement),
          'selectionStart' in doc && hasSelectionCapabilities(doc)
            ? (doc = { start: doc.selectionStart, end: doc.selectionEnd })
            : ((doc = (
                (doc.ownerDocument && doc.ownerDocument.defaultView) ||
                window
              ).getSelection()),
              (doc = {
                anchorNode: doc.anchorNode,
                anchorOffset: doc.anchorOffset,
                focusNode: doc.focusNode,
                focusOffset: doc.focusOffset,
              })),
          (lastSelection && shallowEqual(lastSelection, doc)) ||
            ((lastSelection = doc),
            (doc = accumulateTwoPhaseListeners(activeElementInst, 'onSelect')),
            0 < doc.length &&
              ((nativeEvent = new SyntheticEvent(
                'onSelect',
                'select',
                null,
                nativeEvent,
                nativeEventTarget
              )),
              dispatchQueue.push({ event: nativeEvent, listeners: doc }),
              (nativeEvent.target = activeElement))));
      }
      function makePrefixMap(styleProp, eventName) {
        var prefixes = {};
        prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
        prefixes['Webkit' + styleProp] = 'webkit' + eventName;
        prefixes['Moz' + styleProp] = 'moz' + eventName;
        return prefixes;
      }
      var vendorPrefixes = {
          animationend: makePrefixMap('Animation', 'AnimationEnd'),
          animationiteration: makePrefixMap('Animation', 'AnimationIteration'),
          animationstart: makePrefixMap('Animation', 'AnimationStart'),
          transitionrun: makePrefixMap('Transition', 'TransitionRun'),
          transitionstart: makePrefixMap('Transition', 'TransitionStart'),
          transitioncancel: makePrefixMap('Transition', 'TransitionCancel'),
          transitionend: makePrefixMap('Transition', 'TransitionEnd'),
        },
        prefixedEventNames = {},
        style = {};
      canUseDOM &&
        ((style = document.createElement('div').style),
        'AnimationEvent' in window ||
          (delete vendorPrefixes.animationend.animation,
          delete vendorPrefixes.animationiteration.animation,
          delete vendorPrefixes.animationstart.animation),
        'TransitionEvent' in window || delete vendorPrefixes.transitionend.transition);
      function getVendorPrefixedEventName(eventName) {
        if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];
        if (!vendorPrefixes[eventName]) return eventName;
        var prefixMap = vendorPrefixes[eventName],
          styleProp;
        for (styleProp in prefixMap)
          if (prefixMap.hasOwnProperty(styleProp) && styleProp in style)
            return (prefixedEventNames[eventName] = prefixMap[styleProp]);
        return eventName;
      }
      var ANIMATION_END = getVendorPrefixedEventName('animationend'),
        ANIMATION_ITERATION = getVendorPrefixedEventName('animationiteration'),
        ANIMATION_START = getVendorPrefixedEventName('animationstart'),
        TRANSITION_RUN = getVendorPrefixedEventName('transitionrun'),
        TRANSITION_START = getVendorPrefixedEventName('transitionstart'),
        TRANSITION_CANCEL = getVendorPrefixedEventName('transitioncancel'),
        TRANSITION_END = getVendorPrefixedEventName('transitionend'),
        topLevelEventsToReactNames = new Map(),
        simpleEventPluginEvents =
          'abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel'.split(
            ' '
          );
      simpleEventPluginEvents.push('scrollEnd');
      function registerSimpleEvent(domEventName, reactName) {
        topLevelEventsToReactNames.set(domEventName, reactName);
        registerTwoPhaseEvent(reactName, [domEventName]);
      }
      var CapturedStacks = new WeakMap();
      function createCapturedValueAtFiber(value, source) {
        if ('object' === typeof value && null !== value) {
          var existing = CapturedStacks.get(value);
          if (void 0 !== existing) return existing;
          source = {
            value: value,
            source: source,
            stack: getStackByFiberInDevAndProd(source),
          };
          CapturedStacks.set(value, source);
          return source;
        }
        return {
          value: value,
          source: source,
          stack: getStackByFiberInDevAndProd(source),
        };
      }
      var concurrentQueues = [],
        concurrentQueuesIndex = 0,
        concurrentlyUpdatedLanes = 0;
      function finishQueueingConcurrentUpdates() {
        for (
          var endIndex = concurrentQueuesIndex,
            i = (concurrentlyUpdatedLanes = concurrentQueuesIndex = 0);
          i < endIndex;

        ) {
          var fiber = concurrentQueues[i];
          concurrentQueues[i++] = null;
          var queue = concurrentQueues[i];
          concurrentQueues[i++] = null;
          var update = concurrentQueues[i];
          concurrentQueues[i++] = null;
          var lane = concurrentQueues[i];
          concurrentQueues[i++] = null;
          if (null !== queue && null !== update) {
            var pending = queue.pending;
            null === pending
              ? (update.next = update)
              : ((update.next = pending.next), (pending.next = update));
            queue.pending = update;
          }
          0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);
        }
      }
      function enqueueUpdate$1(fiber, queue, update, lane) {
        concurrentQueues[concurrentQueuesIndex++] = fiber;
        concurrentQueues[concurrentQueuesIndex++] = queue;
        concurrentQueues[concurrentQueuesIndex++] = update;
        concurrentQueues[concurrentQueuesIndex++] = lane;
        concurrentlyUpdatedLanes |= lane;
        fiber.lanes |= lane;
        fiber = fiber.alternate;
        null !== fiber && (fiber.lanes |= lane);
      }
      function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
        enqueueUpdate$1(fiber, queue, update, lane);
        return getRootForUpdatedFiber(fiber);
      }
      function enqueueConcurrentRenderForLane(fiber, lane) {
        enqueueUpdate$1(fiber, null, null, lane);
        return getRootForUpdatedFiber(fiber);
      }
      function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
        sourceFiber.lanes |= lane;
        var alternate = sourceFiber.alternate;
        null !== alternate && (alternate.lanes |= lane);
        for (var isHidden = !1, parent = sourceFiber.return; null !== parent; )
          ((parent.childLanes |= lane),
            (alternate = parent.alternate),
            null !== alternate && (alternate.childLanes |= lane),
            22 === parent.tag &&
              ((sourceFiber = parent.stateNode),
              null === sourceFiber || sourceFiber._visibility & 1 || (isHidden = !0)),
            (sourceFiber = parent),
            (parent = parent.return));
        return 3 === sourceFiber.tag
          ? ((parent = sourceFiber.stateNode),
            isHidden &&
              null !== update &&
              ((isHidden = 31 - clz32(lane)),
              (sourceFiber = parent.hiddenUpdates),
              (alternate = sourceFiber[isHidden]),
              null === alternate ? (sourceFiber[isHidden] = [update]) : alternate.push(update),
              (update.lane = lane | 536870912)),
            parent)
          : null;
      }
      function getRootForUpdatedFiber(sourceFiber) {
        if (50 < nestedUpdateCount)
          throw (
            (nestedUpdateCount = 0),
            (rootWithNestedUpdates = null),
            Error(formatProdErrorMessage(185))
          );
        for (var parent = sourceFiber.return; null !== parent; )
          ((sourceFiber = parent), (parent = sourceFiber.return));
        return 3 === sourceFiber.tag ? sourceFiber.stateNode : null;
      }
      var emptyContextObject = {};
      function FiberNode(tag, pendingProps, key, mode) {
        this.tag = tag;
        this.key = key;
        this.sibling =
          this.child =
          this.return =
          this.stateNode =
          this.type =
          this.elementType =
            null;
        this.index = 0;
        this.refCleanup = this.ref = null;
        this.pendingProps = pendingProps;
        this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
        this.mode = mode;
        this.subtreeFlags = this.flags = 0;
        this.deletions = null;
        this.childLanes = this.lanes = 0;
        this.alternate = null;
      }
      function createFiberImplClass(tag, pendingProps, key, mode) {
        return new FiberNode(tag, pendingProps, key, mode);
      }
      function shouldConstruct(Component) {
        Component = Component.prototype;
        return !(!Component || !Component.isReactComponent);
      }
      function createWorkInProgress(current, pendingProps) {
        var workInProgress = current.alternate;
        null === workInProgress
          ? ((workInProgress = createFiberImplClass(
              current.tag,
              pendingProps,
              current.key,
              current.mode
            )),
            (workInProgress.elementType = current.elementType),
            (workInProgress.type = current.type),
            (workInProgress.stateNode = current.stateNode),
            (workInProgress.alternate = current),
            (current.alternate = workInProgress))
          : ((workInProgress.pendingProps = pendingProps),
            (workInProgress.type = current.type),
            (workInProgress.flags = 0),
            (workInProgress.subtreeFlags = 0),
            (workInProgress.deletions = null));
        workInProgress.flags = current.flags & 65011712;
        workInProgress.childLanes = current.childLanes;
        workInProgress.lanes = current.lanes;
        workInProgress.child = current.child;
        workInProgress.memoizedProps = current.memoizedProps;
        workInProgress.memoizedState = current.memoizedState;
        workInProgress.updateQueue = current.updateQueue;
        pendingProps = current.dependencies;
        workInProgress.dependencies =
          null === pendingProps
            ? null
            : { lanes: pendingProps.lanes, firstContext: pendingProps.firstContext };
        workInProgress.sibling = current.sibling;
        workInProgress.index = current.index;
        workInProgress.ref = current.ref;
        workInProgress.refCleanup = current.refCleanup;
        return workInProgress;
      }
      function resetWorkInProgress(workInProgress, renderLanes) {
        workInProgress.flags &= 65011714;
        var current = workInProgress.alternate;
        null === current
          ? ((workInProgress.childLanes = 0),
            (workInProgress.lanes = renderLanes),
            (workInProgress.child = null),
            (workInProgress.subtreeFlags = 0),
            (workInProgress.memoizedProps = null),
            (workInProgress.memoizedState = null),
            (workInProgress.updateQueue = null),
            (workInProgress.dependencies = null),
            (workInProgress.stateNode = null))
          : ((workInProgress.childLanes = current.childLanes),
            (workInProgress.lanes = current.lanes),
            (workInProgress.child = current.child),
            (workInProgress.subtreeFlags = 0),
            (workInProgress.deletions = null),
            (workInProgress.memoizedProps = current.memoizedProps),
            (workInProgress.memoizedState = current.memoizedState),
            (workInProgress.updateQueue = current.updateQueue),
            (workInProgress.type = current.type),
            (renderLanes = current.dependencies),
            (workInProgress.dependencies =
              null === renderLanes
                ? null
                : {
                    lanes: renderLanes.lanes,
                    firstContext: renderLanes.firstContext,
                  }));
        return workInProgress;
      }
      function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
        var fiberTag = 0;
        owner = type;
        if ('function' === typeof type) shouldConstruct(type) && (fiberTag = 1);
        else if ('string' === typeof type)
          fiberTag = isHostHoistableType(type, pendingProps, contextStackCursor.current)
            ? 26
            : 'html' === type || 'head' === type || 'body' === type
              ? 27
              : 5;
        else
          a: switch (type) {
            case REACT_ACTIVITY_TYPE:
              return (
                (type = createFiberImplClass(31, pendingProps, key, mode)),
                (type.elementType = REACT_ACTIVITY_TYPE),
                (type.lanes = lanes),
                type
              );
            case REACT_FRAGMENT_TYPE:
              return createFiberFromFragment(pendingProps.children, mode, lanes, key);
            case REACT_STRICT_MODE_TYPE:
              fiberTag = 8;
              mode |= 24;
              break;
            case REACT_PROFILER_TYPE:
              return (
                (type = createFiberImplClass(12, pendingProps, key, mode | 2)),
                (type.elementType = REACT_PROFILER_TYPE),
                (type.lanes = lanes),
                type
              );
            case REACT_SUSPENSE_TYPE:
              return (
                (type = createFiberImplClass(13, pendingProps, key, mode)),
                (type.elementType = REACT_SUSPENSE_TYPE),
                (type.lanes = lanes),
                type
              );
            case REACT_SUSPENSE_LIST_TYPE:
              return (
                (type = createFiberImplClass(19, pendingProps, key, mode)),
                (type.elementType = REACT_SUSPENSE_LIST_TYPE),
                (type.lanes = lanes),
                type
              );
            default:
              if ('object' === typeof type && null !== type)
                switch (type.$$typeof) {
                  case REACT_PROVIDER_TYPE:
                  case REACT_CONTEXT_TYPE:
                    fiberTag = 10;
                    break a;
                  case REACT_CONSUMER_TYPE:
                    fiberTag = 9;
                    break a;
                  case REACT_FORWARD_REF_TYPE:
                    fiberTag = 11;
                    break a;
                  case REACT_MEMO_TYPE:
                    fiberTag = 14;
                    break a;
                  case REACT_LAZY_TYPE:
                    fiberTag = 16;
                    owner = null;
                    break a;
                }
              fiberTag = 29;
              pendingProps = Error(
                formatProdErrorMessage(130, null === type ? 'null' : typeof type, '')
              );
              owner = null;
          }
        key = createFiberImplClass(fiberTag, pendingProps, key, mode);
        key.elementType = type;
        key.type = owner;
        key.lanes = lanes;
        return key;
      }
      function createFiberFromFragment(elements, mode, lanes, key) {
        elements = createFiberImplClass(7, elements, key, mode);
        elements.lanes = lanes;
        return elements;
      }
      function createFiberFromText(content, mode, lanes) {
        content = createFiberImplClass(6, content, null, mode);
        content.lanes = lanes;
        return content;
      }
      function createFiberFromPortal(portal, mode, lanes) {
        mode = createFiberImplClass(
          4,
          null !== portal.children ? portal.children : [],
          portal.key,
          mode
        );
        mode.lanes = lanes;
        mode.stateNode = {
          containerInfo: portal.containerInfo,
          pendingChildren: null,
          implementation: portal.implementation,
        };
        return mode;
      }
      var forkStack = [],
        forkStackIndex = 0,
        treeForkProvider = null,
        treeForkCount = 0,
        idStack = [],
        idStackIndex = 0,
        treeContextProvider = null,
        treeContextId = 1,
        treeContextOverflow = '';
      function pushTreeFork(workInProgress, totalChildren) {
        forkStack[forkStackIndex++] = treeForkCount;
        forkStack[forkStackIndex++] = treeForkProvider;
        treeForkProvider = workInProgress;
        treeForkCount = totalChildren;
      }
      function pushTreeId(workInProgress, totalChildren, index) {
        idStack[idStackIndex++] = treeContextId;
        idStack[idStackIndex++] = treeContextOverflow;
        idStack[idStackIndex++] = treeContextProvider;
        treeContextProvider = workInProgress;
        var baseIdWithLeadingBit = treeContextId;
        workInProgress = treeContextOverflow;
        var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
        baseIdWithLeadingBit &= ~(1 << baseLength);
        index += 1;
        var length = 32 - clz32(totalChildren) + baseLength;
        if (30 < length) {
          var numberOfOverflowBits = baseLength - (baseLength % 5);
          length = (baseIdWithLeadingBit & ((1 << numberOfOverflowBits) - 1)).toString(32);
          baseIdWithLeadingBit >>= numberOfOverflowBits;
          baseLength -= numberOfOverflowBits;
          treeContextId =
            (1 << (32 - clz32(totalChildren) + baseLength)) |
            (index << baseLength) |
            baseIdWithLeadingBit;
          treeContextOverflow = length + workInProgress;
        } else
          ((treeContextId = (1 << length) | (index << baseLength) | baseIdWithLeadingBit),
            (treeContextOverflow = workInProgress));
      }
      function pushMaterializedTreeId(workInProgress) {
        null !== workInProgress.return &&
          (pushTreeFork(workInProgress, 1), pushTreeId(workInProgress, 1, 0));
      }
      function popTreeContext(workInProgress) {
        for (; workInProgress === treeForkProvider; )
          ((treeForkProvider = forkStack[--forkStackIndex]),
            (forkStack[forkStackIndex] = null),
            (treeForkCount = forkStack[--forkStackIndex]),
            (forkStack[forkStackIndex] = null));
        for (; workInProgress === treeContextProvider; )
          ((treeContextProvider = idStack[--idStackIndex]),
            (idStack[idStackIndex] = null),
            (treeContextOverflow = idStack[--idStackIndex]),
            (idStack[idStackIndex] = null),
            (treeContextId = idStack[--idStackIndex]),
            (idStack[idStackIndex] = null));
      }
      var hydrationParentFiber = null,
        nextHydratableInstance = null,
        isHydrating = !1,
        hydrationErrors = null,
        rootOrSingletonContext = !1,
        HydrationMismatchException = Error(formatProdErrorMessage(519));
      function throwOnHydrationMismatch(fiber) {
        var error = Error(formatProdErrorMessage(418, ''));
        queueHydrationError(createCapturedValueAtFiber(error, fiber));
        throw HydrationMismatchException;
      }
      function prepareToHydrateHostInstance(fiber) {
        var instance = fiber.stateNode,
          type = fiber.type,
          props = fiber.memoizedProps;
        instance[internalInstanceKey] = fiber;
        instance[internalPropsKey] = props;
        switch (type) {
          case 'dialog':
            listenToNonDelegatedEvent('cancel', instance);
            listenToNonDelegatedEvent('close', instance);
            break;
          case 'iframe':
          case 'object':
          case 'embed':
            listenToNonDelegatedEvent('load', instance);
            break;
          case 'video':
          case 'audio':
            for (type = 0; type < mediaEventTypes.length; type++)
              listenToNonDelegatedEvent(mediaEventTypes[type], instance);
            break;
          case 'source':
            listenToNonDelegatedEvent('error', instance);
            break;
          case 'img':
          case 'image':
          case 'link':
            listenToNonDelegatedEvent('error', instance);
            listenToNonDelegatedEvent('load', instance);
            break;
          case 'details':
            listenToNonDelegatedEvent('toggle', instance);
            break;
          case 'input':
            listenToNonDelegatedEvent('invalid', instance);
            initInput(
              instance,
              props.value,
              props.defaultValue,
              props.checked,
              props.defaultChecked,
              props.type,
              props.name,
              !0
            );
            track(instance);
            break;
          case 'select':
            listenToNonDelegatedEvent('invalid', instance);
            break;
          case 'textarea':
            (listenToNonDelegatedEvent('invalid', instance),
              initTextarea(instance, props.value, props.defaultValue, props.children),
              track(instance));
        }
        type = props.children;
        ('string' !== typeof type && 'number' !== typeof type && 'bigint' !== typeof type) ||
        instance.textContent === '' + type ||
        !0 === props.suppressHydrationWarning ||
        checkForUnmatchedText(instance.textContent, type)
          ? (null != props.popover &&
              (listenToNonDelegatedEvent('beforetoggle', instance),
              listenToNonDelegatedEvent('toggle', instance)),
            null != props.onScroll && listenToNonDelegatedEvent('scroll', instance),
            null != props.onScrollEnd && listenToNonDelegatedEvent('scrollend', instance),
            null != props.onClick && (instance.onclick = noop$1),
            (instance = !0))
          : (instance = !1);
        instance || throwOnHydrationMismatch(fiber);
      }
      function popToNextHostParent(fiber) {
        for (hydrationParentFiber = fiber.return; hydrationParentFiber; )
          switch (hydrationParentFiber.tag) {
            case 5:
            case 13:
              rootOrSingletonContext = !1;
              return;
            case 27:
            case 3:
              rootOrSingletonContext = !0;
              return;
            default:
              hydrationParentFiber = hydrationParentFiber.return;
          }
      }
      function popHydrationState(fiber) {
        if (fiber !== hydrationParentFiber) return !1;
        if (!isHydrating) return (popToNextHostParent(fiber), (isHydrating = !0), !1);
        var tag = fiber.tag,
          JSCompiler_temp;
        if ((JSCompiler_temp = 3 !== tag && 27 !== tag)) {
          if ((JSCompiler_temp = 5 === tag))
            ((JSCompiler_temp = fiber.type),
              (JSCompiler_temp =
                !('form' !== JSCompiler_temp && 'button' !== JSCompiler_temp) ||
                shouldSetTextContent(fiber.type, fiber.memoizedProps)));
          JSCompiler_temp = !JSCompiler_temp;
        }
        JSCompiler_temp && nextHydratableInstance && throwOnHydrationMismatch(fiber);
        popToNextHostParent(fiber);
        if (13 === tag) {
          fiber = fiber.memoizedState;
          fiber = null !== fiber ? fiber.dehydrated : null;
          if (!fiber) throw Error(formatProdErrorMessage(317));
          a: {
            fiber = fiber.nextSibling;
            for (tag = 0; fiber; ) {
              if (8 === fiber.nodeType)
                if (((JSCompiler_temp = fiber.data), '/$' === JSCompiler_temp)) {
                  if (0 === tag) {
                    nextHydratableInstance = getNextHydratable(fiber.nextSibling);
                    break a;
                  }
                  tag--;
                } else
                  ('$' !== JSCompiler_temp &&
                    '$!' !== JSCompiler_temp &&
                    '$?' !== JSCompiler_temp) ||
                    tag++;
              fiber = fiber.nextSibling;
            }
            nextHydratableInstance = null;
          }
        } else
          27 === tag
            ? ((tag = nextHydratableInstance),
              isSingletonScope(fiber.type)
                ? ((fiber = previousHydratableOnEnteringScopedSingleton),
                  (previousHydratableOnEnteringScopedSingleton = null),
                  (nextHydratableInstance = fiber))
                : (nextHydratableInstance = tag))
            : (nextHydratableInstance = hydrationParentFiber
                ? getNextHydratable(fiber.stateNode.nextSibling)
                : null);
        return !0;
      }
      function resetHydrationState() {
        nextHydratableInstance = hydrationParentFiber = null;
        isHydrating = !1;
      }
      function upgradeHydrationErrorsToRecoverable() {
        var queuedErrors = hydrationErrors;
        null !== queuedErrors &&
          (null === workInProgressRootRecoverableErrors
            ? (workInProgressRootRecoverableErrors = queuedErrors)
            : workInProgressRootRecoverableErrors.push.apply(
                workInProgressRootRecoverableErrors,
                queuedErrors
              ),
          (hydrationErrors = null));
        return queuedErrors;
      }
      function queueHydrationError(error) {
        null === hydrationErrors ? (hydrationErrors = [error]) : hydrationErrors.push(error);
      }
      var valueCursor = createCursor(null),
        currentlyRenderingFiber$1 = null,
        lastContextDependency = null;
      function pushProvider(providerFiber, context, nextValue) {
        push(valueCursor, context._currentValue);
        context._currentValue = nextValue;
      }
      function popProvider(context) {
        context._currentValue = valueCursor.current;
        pop(valueCursor);
      }
      function scheduleContextWorkOnParentPath(parent, renderLanes, propagationRoot) {
        for (; null !== parent; ) {
          var alternate = parent.alternate;
          (parent.childLanes & renderLanes) !== renderLanes
            ? ((parent.childLanes |= renderLanes),
              null !== alternate && (alternate.childLanes |= renderLanes))
            : null !== alternate &&
              (alternate.childLanes & renderLanes) !== renderLanes &&
              (alternate.childLanes |= renderLanes);
          if (parent === propagationRoot) break;
          parent = parent.return;
        }
      }
      function propagateContextChanges(
        workInProgress,
        contexts,
        renderLanes,
        forcePropagateEntireTree
      ) {
        var fiber = workInProgress.child;
        null !== fiber && (fiber.return = workInProgress);
        for (; null !== fiber; ) {
          var list = fiber.dependencies;
          if (null !== list) {
            var nextFiber = fiber.child;
            list = list.firstContext;
            a: for (; null !== list; ) {
              var dependency = list;
              list = fiber;
              for (var i = 0; i < contexts.length; i++)
                if (dependency.context === contexts[i]) {
                  list.lanes |= renderLanes;
                  dependency = list.alternate;
                  null !== dependency && (dependency.lanes |= renderLanes);
                  scheduleContextWorkOnParentPath(list.return, renderLanes, workInProgress);
                  forcePropagateEntireTree || (nextFiber = null);
                  break a;
                }
              list = dependency.next;
            }
          } else if (18 === fiber.tag) {
            nextFiber = fiber.return;
            if (null === nextFiber) throw Error(formatProdErrorMessage(341));
            nextFiber.lanes |= renderLanes;
            list = nextFiber.alternate;
            null !== list && (list.lanes |= renderLanes);
            scheduleContextWorkOnParentPath(nextFiber, renderLanes, workInProgress);
            nextFiber = null;
          } else nextFiber = fiber.child;
          if (null !== nextFiber) nextFiber.return = fiber;
          else
            for (nextFiber = fiber; null !== nextFiber; ) {
              if (nextFiber === workInProgress) {
                nextFiber = null;
                break;
              }
              fiber = nextFiber.sibling;
              if (null !== fiber) {
                fiber.return = nextFiber.return;
                nextFiber = fiber;
                break;
              }
              nextFiber = nextFiber.return;
            }
          fiber = nextFiber;
        }
      }
      function propagateParentContextChanges(
        current,
        workInProgress,
        renderLanes,
        forcePropagateEntireTree
      ) {
        current = null;
        for (var parent = workInProgress, isInsidePropagationBailout = !1; null !== parent; ) {
          if (!isInsidePropagationBailout)
            if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = !0;
            else if (0 !== (parent.flags & 262144)) break;
          if (10 === parent.tag) {
            var currentParent = parent.alternate;
            if (null === currentParent) throw Error(formatProdErrorMessage(387));
            currentParent = currentParent.memoizedProps;
            if (null !== currentParent) {
              var context = parent.type;
              objectIs(parent.pendingProps.value, currentParent.value) ||
                (null !== current ? current.push(context) : (current = [context]));
            }
          } else if (parent === hostTransitionProviderCursor.current) {
            currentParent = parent.alternate;
            if (null === currentParent) throw Error(formatProdErrorMessage(387));
            currentParent.memoizedState.memoizedState !== parent.memoizedState.memoizedState &&
              (null !== current
                ? current.push(HostTransitionContext)
                : (current = [HostTransitionContext]));
          }
          parent = parent.return;
        }
        null !== current &&
          propagateContextChanges(workInProgress, current, renderLanes, forcePropagateEntireTree);
        workInProgress.flags |= 262144;
      }
      function checkIfContextChanged(currentDependencies) {
        for (
          currentDependencies = currentDependencies.firstContext;
          null !== currentDependencies;

        ) {
          if (
            !objectIs(currentDependencies.context._currentValue, currentDependencies.memoizedValue)
          )
            return !0;
          currentDependencies = currentDependencies.next;
        }
        return !1;
      }
      function prepareToReadContext(workInProgress) {
        currentlyRenderingFiber$1 = workInProgress;
        lastContextDependency = null;
        workInProgress = workInProgress.dependencies;
        null !== workInProgress && (workInProgress.firstContext = null);
      }
      function readContext(context) {
        return readContextForConsumer(currentlyRenderingFiber$1, context);
      }
      function readContextDuringReconciliation(consumer, context) {
        null === currentlyRenderingFiber$1 && prepareToReadContext(consumer);
        return readContextForConsumer(consumer, context);
      }
      function readContextForConsumer(consumer, context) {
        var value = context._currentValue;
        context = { context: context, memoizedValue: value, next: null };
        if (null === lastContextDependency) {
          if (null === consumer) throw Error(formatProdErrorMessage(308));
          lastContextDependency = context;
          consumer.dependencies = { lanes: 0, firstContext: context };
          consumer.flags |= 524288;
        } else lastContextDependency = lastContextDependency.next = context;
        return value;
      }
      var AbortControllerLocal =
          'undefined' !== typeof AbortController
            ? AbortController
            : function () {
                var listeners = [],
                  signal = (this.signal = {
                    aborted: !1,
                    addEventListener: function (type, listener) {
                      listeners.push(listener);
                    },
                  });
                this.abort = function () {
                  signal.aborted = !0;
                  listeners.forEach(function (listener) {
                    return listener();
                  });
                };
              },
        scheduleCallback$2 = Scheduler.unstable_scheduleCallback,
        NormalPriority = Scheduler.unstable_NormalPriority,
        CacheContext = {
          $$typeof: REACT_CONTEXT_TYPE,
          Consumer: null,
          Provider: null,
          _currentValue: null,
          _currentValue2: null,
          _threadCount: 0,
        };
      function createCache() {
        return {
          controller: new AbortControllerLocal(),
          data: new Map(),
          refCount: 0,
        };
      }
      function releaseCache(cache) {
        cache.refCount--;
        0 === cache.refCount &&
          scheduleCallback$2(NormalPriority, function () {
            cache.controller.abort();
          });
      }
      var currentEntangledListeners = null,
        currentEntangledPendingCount = 0,
        currentEntangledLane = 0,
        currentEntangledActionThenable = null;
      function entangleAsyncAction(transition, thenable) {
        if (null === currentEntangledListeners) {
          var entangledListeners = (currentEntangledListeners = []);
          currentEntangledPendingCount = 0;
          currentEntangledLane = requestTransitionLane();
          currentEntangledActionThenable = {
            status: 'pending',
            value: void 0,
            then: function (resolve) {
              entangledListeners.push(resolve);
            },
          };
        }
        currentEntangledPendingCount++;
        thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
        return thenable;
      }
      function pingEngtangledActionScope() {
        if (0 === --currentEntangledPendingCount && null !== currentEntangledListeners) {
          null !== currentEntangledActionThenable &&
            (currentEntangledActionThenable.status = 'fulfilled');
          var listeners = currentEntangledListeners;
          currentEntangledListeners = null;
          currentEntangledLane = 0;
          currentEntangledActionThenable = null;
          for (var i = 0; i < listeners.length; i++) (0, listeners[i])();
        }
      }
      function chainThenableValue(thenable, result) {
        var listeners = [],
          thenableWithOverride = {
            status: 'pending',
            value: null,
            reason: null,
            then: function (resolve) {
              listeners.push(resolve);
            },
          };
        thenable.then(
          function () {
            thenableWithOverride.status = 'fulfilled';
            thenableWithOverride.value = result;
            for (var i = 0; i < listeners.length; i++) (0, listeners[i])(result);
          },
          function (error) {
            thenableWithOverride.status = 'rejected';
            thenableWithOverride.reason = error;
            for (error = 0; error < listeners.length; error++) (0, listeners[error])(void 0);
          }
        );
        return thenableWithOverride;
      }
      var prevOnStartTransitionFinish = ReactSharedInternals.S;
      ReactSharedInternals.S = function (transition, returnValue) {
        'object' === typeof returnValue &&
          null !== returnValue &&
          'function' === typeof returnValue.then &&
          entangleAsyncAction(transition, returnValue);
        null !== prevOnStartTransitionFinish &&
          prevOnStartTransitionFinish(transition, returnValue);
      };
      var resumedCache = createCursor(null);
      function peekCacheFromPool() {
        var cacheResumedFromPreviousRender = resumedCache.current;
        return null !== cacheResumedFromPreviousRender
          ? cacheResumedFromPreviousRender
          : workInProgressRoot.pooledCache;
      }
      function pushTransition(offscreenWorkInProgress, prevCachePool) {
        null === prevCachePool
          ? push(resumedCache, resumedCache.current)
          : push(resumedCache, prevCachePool.pool);
      }
      function getSuspendedCache() {
        var cacheFromPool = peekCacheFromPool();
        return null === cacheFromPool
          ? null
          : { parent: CacheContext._currentValue, pool: cacheFromPool };
      }
      var SuspenseException = Error(formatProdErrorMessage(460)),
        SuspenseyCommitException = Error(formatProdErrorMessage(474)),
        SuspenseActionException = Error(formatProdErrorMessage(542)),
        noopSuspenseyCommitThenable = { then: function () {} };
      function isThenableResolved(thenable) {
        thenable = thenable.status;
        return 'fulfilled' === thenable || 'rejected' === thenable;
      }
      function noop$3() {}
      function trackUsedThenable(thenableState, thenable, index) {
        index = thenableState[index];
        void 0 === index
          ? thenableState.push(thenable)
          : index !== thenable && (thenable.then(noop$3, noop$3), (thenable = index));
        switch (thenable.status) {
          case 'fulfilled':
            return thenable.value;
          case 'rejected':
            throw (
              (thenableState = thenable.reason),
              checkIfUseWrappedInAsyncCatch(thenableState),
              thenableState
            );
          default:
            if ('string' === typeof thenable.status) thenable.then(noop$3, noop$3);
            else {
              thenableState = workInProgressRoot;
              if (null !== thenableState && 100 < thenableState.shellSuspendCounter)
                throw Error(formatProdErrorMessage(482));
              thenableState = thenable;
              thenableState.status = 'pending';
              thenableState.then(
                function (fulfilledValue) {
                  if ('pending' === thenable.status) {
                    var fulfilledThenable = thenable;
                    fulfilledThenable.status = 'fulfilled';
                    fulfilledThenable.value = fulfilledValue;
                  }
                },
                function (error) {
                  if ('pending' === thenable.status) {
                    var rejectedThenable = thenable;
                    rejectedThenable.status = 'rejected';
                    rejectedThenable.reason = error;
                  }
                }
              );
            }
            switch (thenable.status) {
              case 'fulfilled':
                return thenable.value;
              case 'rejected':
                throw (
                  (thenableState = thenable.reason),
                  checkIfUseWrappedInAsyncCatch(thenableState),
                  thenableState
                );
            }
            suspendedThenable = thenable;
            throw SuspenseException;
        }
      }
      var suspendedThenable = null;
      function getSuspendedThenable() {
        if (null === suspendedThenable) throw Error(formatProdErrorMessage(459));
        var thenable = suspendedThenable;
        suspendedThenable = null;
        return thenable;
      }
      function checkIfUseWrappedInAsyncCatch(rejectedReason) {
        if (rejectedReason === SuspenseException || rejectedReason === SuspenseActionException)
          throw Error(formatProdErrorMessage(483));
      }
      var hasForceUpdate = !1;
      function initializeUpdateQueue(fiber) {
        fiber.updateQueue = {
          baseState: fiber.memoizedState,
          firstBaseUpdate: null,
          lastBaseUpdate: null,
          shared: { pending: null, lanes: 0, hiddenCallbacks: null },
          callbacks: null,
        };
      }
      function cloneUpdateQueue(current, workInProgress) {
        current = current.updateQueue;
        workInProgress.updateQueue === current &&
          (workInProgress.updateQueue = {
            baseState: current.baseState,
            firstBaseUpdate: current.firstBaseUpdate,
            lastBaseUpdate: current.lastBaseUpdate,
            shared: current.shared,
            callbacks: null,
          });
      }
      function createUpdate(lane) {
        return { lane: lane, tag: 0, payload: null, callback: null, next: null };
      }
      function enqueueUpdate(fiber, update, lane) {
        var updateQueue = fiber.updateQueue;
        if (null === updateQueue) return null;
        updateQueue = updateQueue.shared;
        if (0 !== (executionContext & 2)) {
          var pending = updateQueue.pending;
          null === pending
            ? (update.next = update)
            : ((update.next = pending.next), (pending.next = update));
          updateQueue.pending = update;
          update = getRootForUpdatedFiber(fiber);
          markUpdateLaneFromFiberToRoot(fiber, null, lane);
          return update;
        }
        enqueueUpdate$1(fiber, updateQueue, update, lane);
        return getRootForUpdatedFiber(fiber);
      }
      function entangleTransitions(root, fiber, lane) {
        fiber = fiber.updateQueue;
        if (null !== fiber && ((fiber = fiber.shared), 0 !== (lane & 4194048))) {
          var queueLanes = fiber.lanes;
          queueLanes &= root.pendingLanes;
          lane |= queueLanes;
          fiber.lanes = lane;
          markRootEntangled(root, lane);
        }
      }
      function enqueueCapturedUpdate(workInProgress, capturedUpdate) {
        var queue = workInProgress.updateQueue,
          current = workInProgress.alternate;
        if (null !== current && ((current = current.updateQueue), queue === current)) {
          var newFirst = null,
            newLast = null;
          queue = queue.firstBaseUpdate;
          if (null !== queue) {
            do {
              var clone = {
                lane: queue.lane,
                tag: queue.tag,
                payload: queue.payload,
                callback: null,
                next: null,
              };
              null === newLast ? (newFirst = newLast = clone) : (newLast = newLast.next = clone);
              queue = queue.next;
            } while (null !== queue);
            null === newLast
              ? (newFirst = newLast = capturedUpdate)
              : (newLast = newLast.next = capturedUpdate);
          } else newFirst = newLast = capturedUpdate;
          queue = {
            baseState: current.baseState,
            firstBaseUpdate: newFirst,
            lastBaseUpdate: newLast,
            shared: current.shared,
            callbacks: current.callbacks,
          };
          workInProgress.updateQueue = queue;
          return;
        }
        workInProgress = queue.lastBaseUpdate;
        null === workInProgress
          ? (queue.firstBaseUpdate = capturedUpdate)
          : (workInProgress.next = capturedUpdate);
        queue.lastBaseUpdate = capturedUpdate;
      }
      var didReadFromEntangledAsyncAction = !1;
      function suspendIfUpdateReadFromEntangledAsyncAction() {
        if (didReadFromEntangledAsyncAction) {
          var entangledActionThenable = currentEntangledActionThenable;
          if (null !== entangledActionThenable) throw entangledActionThenable;
        }
      }
      function processUpdateQueue(workInProgress$jscomp$0, props, instance$jscomp$0, renderLanes) {
        didReadFromEntangledAsyncAction = !1;
        var queue = workInProgress$jscomp$0.updateQueue;
        hasForceUpdate = !1;
        var firstBaseUpdate = queue.firstBaseUpdate,
          lastBaseUpdate = queue.lastBaseUpdate,
          pendingQueue = queue.shared.pending;
        if (null !== pendingQueue) {
          queue.shared.pending = null;
          var lastPendingUpdate = pendingQueue,
            firstPendingUpdate = lastPendingUpdate.next;
          lastPendingUpdate.next = null;
          null === lastBaseUpdate
            ? (firstBaseUpdate = firstPendingUpdate)
            : (lastBaseUpdate.next = firstPendingUpdate);
          lastBaseUpdate = lastPendingUpdate;
          var current = workInProgress$jscomp$0.alternate;
          null !== current &&
            ((current = current.updateQueue),
            (pendingQueue = current.lastBaseUpdate),
            pendingQueue !== lastBaseUpdate &&
              (null === pendingQueue
                ? (current.firstBaseUpdate = firstPendingUpdate)
                : (pendingQueue.next = firstPendingUpdate),
              (current.lastBaseUpdate = lastPendingUpdate)));
        }
        if (null !== firstBaseUpdate) {
          var newState = queue.baseState;
          lastBaseUpdate = 0;
          current = firstPendingUpdate = lastPendingUpdate = null;
          pendingQueue = firstBaseUpdate;
          do {
            var updateLane = pendingQueue.lane & -536870913,
              isHiddenUpdate = updateLane !== pendingQueue.lane;
            if (
              isHiddenUpdate
                ? (workInProgressRootRenderLanes & updateLane) === updateLane
                : (renderLanes & updateLane) === updateLane
            ) {
              0 !== updateLane &&
                updateLane === currentEntangledLane &&
                (didReadFromEntangledAsyncAction = !0);
              null !== current &&
                (current = current.next =
                  {
                    lane: 0,
                    tag: pendingQueue.tag,
                    payload: pendingQueue.payload,
                    callback: null,
                    next: null,
                  });
              a: {
                var workInProgress = workInProgress$jscomp$0,
                  update = pendingQueue;
                updateLane = props;
                var instance = instance$jscomp$0;
                switch (update.tag) {
                  case 1:
                    workInProgress = update.payload;
                    if ('function' === typeof workInProgress) {
                      newState = workInProgress.call(instance, newState, updateLane);
                      break a;
                    }
                    newState = workInProgress;
                    break a;
                  case 3:
                    workInProgress.flags = (workInProgress.flags & -65537) | 128;
                  case 0:
                    workInProgress = update.payload;
                    updateLane =
                      'function' === typeof workInProgress
                        ? workInProgress.call(instance, newState, updateLane)
                        : workInProgress;
                    if (null === updateLane || void 0 === updateLane) break a;
                    newState = assign({}, newState, updateLane);
                    break a;
                  case 2:
                    hasForceUpdate = !0;
                }
              }
              updateLane = pendingQueue.callback;
              null !== updateLane &&
                ((workInProgress$jscomp$0.flags |= 64),
                isHiddenUpdate && (workInProgress$jscomp$0.flags |= 8192),
                (isHiddenUpdate = queue.callbacks),
                null === isHiddenUpdate
                  ? (queue.callbacks = [updateLane])
                  : isHiddenUpdate.push(updateLane));
            } else
              ((isHiddenUpdate = {
                lane: updateLane,
                tag: pendingQueue.tag,
                payload: pendingQueue.payload,
                callback: pendingQueue.callback,
                next: null,
              }),
                null === current
                  ? ((firstPendingUpdate = current = isHiddenUpdate),
                    (lastPendingUpdate = newState))
                  : (current = current.next = isHiddenUpdate),
                (lastBaseUpdate |= updateLane));
            pendingQueue = pendingQueue.next;
            if (null === pendingQueue)
              if (((pendingQueue = queue.shared.pending), null === pendingQueue)) break;
              else
                ((isHiddenUpdate = pendingQueue),
                  (pendingQueue = isHiddenUpdate.next),
                  (isHiddenUpdate.next = null),
                  (queue.lastBaseUpdate = isHiddenUpdate),
                  (queue.shared.pending = null));
          } while (1);
          null === current && (lastPendingUpdate = newState);
          queue.baseState = lastPendingUpdate;
          queue.firstBaseUpdate = firstPendingUpdate;
          queue.lastBaseUpdate = current;
          null === firstBaseUpdate && (queue.shared.lanes = 0);
          workInProgressRootSkippedLanes |= lastBaseUpdate;
          workInProgress$jscomp$0.lanes = lastBaseUpdate;
          workInProgress$jscomp$0.memoizedState = newState;
        }
      }
      function callCallback(callback, context) {
        if ('function' !== typeof callback) throw Error(formatProdErrorMessage(191, callback));
        callback.call(context);
      }
      function commitCallbacks(updateQueue, context) {
        var callbacks = updateQueue.callbacks;
        if (null !== callbacks)
          for (
            updateQueue.callbacks = null, updateQueue = 0;
            updateQueue < callbacks.length;
            updateQueue++
          )
            callCallback(callbacks[updateQueue], context);
      }
      var currentTreeHiddenStackCursor = createCursor(null),
        prevEntangledRenderLanesCursor = createCursor(0);
      function pushHiddenContext(fiber, context) {
        fiber = entangledRenderLanes;
        push(prevEntangledRenderLanesCursor, fiber);
        push(currentTreeHiddenStackCursor, context);
        entangledRenderLanes = fiber | context.baseLanes;
      }
      function reuseHiddenContextOnStack() {
        push(prevEntangledRenderLanesCursor, entangledRenderLanes);
        push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current);
      }
      function popHiddenContext() {
        entangledRenderLanes = prevEntangledRenderLanesCursor.current;
        pop(currentTreeHiddenStackCursor);
        pop(prevEntangledRenderLanesCursor);
      }
      var renderLanes = 0,
        currentlyRenderingFiber = null,
        currentHook = null,
        workInProgressHook = null,
        didScheduleRenderPhaseUpdate = !1,
        didScheduleRenderPhaseUpdateDuringThisPass = !1,
        shouldDoubleInvokeUserFnsInHooksDEV = !1,
        localIdCounter = 0,
        thenableIndexCounter$1 = 0,
        thenableState$1 = null,
        globalClientIdCounter = 0;
      function throwInvalidHookError() {
        throw Error(formatProdErrorMessage(321));
      }
      function areHookInputsEqual(nextDeps, prevDeps) {
        if (null === prevDeps) return !1;
        for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++)
          if (!objectIs(nextDeps[i], prevDeps[i])) return !1;
        return !0;
      }
      function renderWithHooks(
        current,
        workInProgress,
        Component,
        props,
        secondArg,
        nextRenderLanes
      ) {
        renderLanes = nextRenderLanes;
        currentlyRenderingFiber = workInProgress;
        workInProgress.memoizedState = null;
        workInProgress.updateQueue = null;
        workInProgress.lanes = 0;
        ReactSharedInternals.H =
          null === current || null === current.memoizedState
            ? HooksDispatcherOnMount
            : HooksDispatcherOnUpdate;
        shouldDoubleInvokeUserFnsInHooksDEV = !1;
        nextRenderLanes = Component(props, secondArg);
        shouldDoubleInvokeUserFnsInHooksDEV = !1;
        didScheduleRenderPhaseUpdateDuringThisPass &&
          (nextRenderLanes = renderWithHooksAgain(workInProgress, Component, props, secondArg));
        finishRenderingHooks(current);
        return nextRenderLanes;
      }
      function finishRenderingHooks(current) {
        ReactSharedInternals.H = ContextOnlyDispatcher;
        var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;
        renderLanes = 0;
        workInProgressHook = currentHook = currentlyRenderingFiber = null;
        didScheduleRenderPhaseUpdate = !1;
        thenableIndexCounter$1 = 0;
        thenableState$1 = null;
        if (didRenderTooFewHooks) throw Error(formatProdErrorMessage(300));
        null === current ||
          didReceiveUpdate ||
          ((current = current.dependencies),
          null !== current && checkIfContextChanged(current) && (didReceiveUpdate = !0));
      }
      function renderWithHooksAgain(workInProgress, Component, props, secondArg) {
        currentlyRenderingFiber = workInProgress;
        var numberOfReRenders = 0;
        do {
          didScheduleRenderPhaseUpdateDuringThisPass && (thenableState$1 = null);
          thenableIndexCounter$1 = 0;
          didScheduleRenderPhaseUpdateDuringThisPass = !1;
          if (25 <= numberOfReRenders) throw Error(formatProdErrorMessage(301));
          numberOfReRenders += 1;
          workInProgressHook = currentHook = null;
          if (null != workInProgress.updateQueue) {
            var children = workInProgress.updateQueue;
            children.lastEffect = null;
            children.events = null;
            children.stores = null;
            null != children.memoCache && (children.memoCache.index = 0);
          }
          ReactSharedInternals.H = HooksDispatcherOnRerender;
          children = Component(props, secondArg);
        } while (didScheduleRenderPhaseUpdateDuringThisPass);
        return children;
      }
      function TransitionAwareHostComponent() {
        var dispatcher = ReactSharedInternals.H,
          maybeThenable = dispatcher.useState()[0];
        maybeThenable =
          'function' === typeof maybeThenable.then ? useThenable(maybeThenable) : maybeThenable;
        dispatcher = dispatcher.useState()[0];
        (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher &&
          (currentlyRenderingFiber.flags |= 1024);
        return maybeThenable;
      }
      function checkDidRenderIdHook() {
        var didRenderIdHook = 0 !== localIdCounter;
        localIdCounter = 0;
        return didRenderIdHook;
      }
      function bailoutHooks(current, workInProgress, lanes) {
        workInProgress.updateQueue = current.updateQueue;
        workInProgress.flags &= -2053;
        current.lanes &= ~lanes;
      }
      function resetHooksOnUnwind(workInProgress) {
        if (didScheduleRenderPhaseUpdate) {
          for (workInProgress = workInProgress.memoizedState; null !== workInProgress; ) {
            var queue = workInProgress.queue;
            null !== queue && (queue.pending = null);
            workInProgress = workInProgress.next;
          }
          didScheduleRenderPhaseUpdate = !1;
        }
        renderLanes = 0;
        workInProgressHook = currentHook = currentlyRenderingFiber = null;
        didScheduleRenderPhaseUpdateDuringThisPass = !1;
        thenableIndexCounter$1 = localIdCounter = 0;
        thenableState$1 = null;
      }
      function mountWorkInProgressHook() {
        var hook = {
          memoizedState: null,
          baseState: null,
          baseQueue: null,
          queue: null,
          next: null,
        };
        null === workInProgressHook
          ? (currentlyRenderingFiber.memoizedState = workInProgressHook = hook)
          : (workInProgressHook = workInProgressHook.next = hook);
        return workInProgressHook;
      }
      function updateWorkInProgressHook() {
        if (null === currentHook) {
          var nextCurrentHook = currentlyRenderingFiber.alternate;
          nextCurrentHook = null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
        } else nextCurrentHook = currentHook.next;
        var nextWorkInProgressHook =
          null === workInProgressHook
            ? currentlyRenderingFiber.memoizedState
            : workInProgressHook.next;
        if (null !== nextWorkInProgressHook)
          ((workInProgressHook = nextWorkInProgressHook), (currentHook = nextCurrentHook));
        else {
          if (null === nextCurrentHook) {
            if (null === currentlyRenderingFiber.alternate)
              throw Error(formatProdErrorMessage(467));
            throw Error(formatProdErrorMessage(310));
          }
          currentHook = nextCurrentHook;
          nextCurrentHook = {
            memoizedState: currentHook.memoizedState,
            baseState: currentHook.baseState,
            baseQueue: currentHook.baseQueue,
            queue: currentHook.queue,
            next: null,
          };
          null === workInProgressHook
            ? (currentlyRenderingFiber.memoizedState = workInProgressHook = nextCurrentHook)
            : (workInProgressHook = workInProgressHook.next = nextCurrentHook);
        }
        return workInProgressHook;
      }
      function createFunctionComponentUpdateQueue() {
        return { lastEffect: null, events: null, stores: null, memoCache: null };
      }
      function useThenable(thenable) {
        var index = thenableIndexCounter$1;
        thenableIndexCounter$1 += 1;
        null === thenableState$1 && (thenableState$1 = []);
        thenable = trackUsedThenable(thenableState$1, thenable, index);
        index = currentlyRenderingFiber;
        null === (null === workInProgressHook ? index.memoizedState : workInProgressHook.next) &&
          ((index = index.alternate),
          (ReactSharedInternals.H =
            null === index || null === index.memoizedState
              ? HooksDispatcherOnMount
              : HooksDispatcherOnUpdate));
        return thenable;
      }
      function use(usable) {
        if (null !== usable && 'object' === typeof usable) {
          if ('function' === typeof usable.then) return useThenable(usable);
          if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);
        }
        throw Error(formatProdErrorMessage(438, String(usable)));
      }
      function useMemoCache(size) {
        var memoCache = null,
          updateQueue = currentlyRenderingFiber.updateQueue;
        null !== updateQueue && (memoCache = updateQueue.memoCache);
        if (null == memoCache) {
          var current = currentlyRenderingFiber.alternate;
          null !== current &&
            ((current = current.updateQueue),
            null !== current &&
              ((current = current.memoCache),
              null != current &&
                (memoCache = {
                  data: current.data.map(function (array) {
                    return array.slice();
                  }),
                  index: 0,
                })));
        }
        null == memoCache && (memoCache = { data: [], index: 0 });
        null === updateQueue &&
          ((updateQueue = createFunctionComponentUpdateQueue()),
          (currentlyRenderingFiber.updateQueue = updateQueue));
        updateQueue.memoCache = memoCache;
        updateQueue = memoCache.data[memoCache.index];
        if (void 0 === updateQueue)
          for (
            updateQueue = memoCache.data[memoCache.index] = Array(size), current = 0;
            current < size;
            current++
          )
            updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;
        memoCache.index++;
        return updateQueue;
      }
      function basicStateReducer(state, action) {
        return 'function' === typeof action ? action(state) : action;
      }
      function updateReducer(reducer) {
        var hook = updateWorkInProgressHook();
        return updateReducerImpl(hook, currentHook, reducer);
      }
      function updateReducerImpl(hook, current, reducer) {
        var queue = hook.queue;
        if (null === queue) throw Error(formatProdErrorMessage(311));
        queue.lastRenderedReducer = reducer;
        var baseQueue = hook.baseQueue,
          pendingQueue = queue.pending;
        if (null !== pendingQueue) {
          if (null !== baseQueue) {
            var baseFirst = baseQueue.next;
            baseQueue.next = pendingQueue.next;
            pendingQueue.next = baseFirst;
          }
          current.baseQueue = baseQueue = pendingQueue;
          queue.pending = null;
        }
        pendingQueue = hook.baseState;
        if (null === baseQueue) hook.memoizedState = pendingQueue;
        else {
          current = baseQueue.next;
          var newBaseQueueFirst = (baseFirst = null),
            newBaseQueueLast = null,
            update = current,
            didReadFromEntangledAsyncAction$32 = !1;
          do {
            var updateLane = update.lane & -536870913;
            if (
              updateLane !== update.lane
                ? (workInProgressRootRenderLanes & updateLane) === updateLane
                : (renderLanes & updateLane) === updateLane
            ) {
              var revertLane = update.revertLane;
              if (0 === revertLane)
                (null !== newBaseQueueLast &&
                  (newBaseQueueLast = newBaseQueueLast.next =
                    {
                      lane: 0,
                      revertLane: 0,
                      action: update.action,
                      hasEagerState: update.hasEagerState,
                      eagerState: update.eagerState,
                      next: null,
                    }),
                  updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction$32 = !0));
              else if ((renderLanes & revertLane) === revertLane) {
                update = update.next;
                revertLane === currentEntangledLane && (didReadFromEntangledAsyncAction$32 = !0);
                continue;
              } else
                ((updateLane = {
                  lane: 0,
                  revertLane: update.revertLane,
                  action: update.action,
                  hasEagerState: update.hasEagerState,
                  eagerState: update.eagerState,
                  next: null,
                }),
                  null === newBaseQueueLast
                    ? ((newBaseQueueFirst = newBaseQueueLast = updateLane),
                      (baseFirst = pendingQueue))
                    : (newBaseQueueLast = newBaseQueueLast.next = updateLane),
                  (currentlyRenderingFiber.lanes |= revertLane),
                  (workInProgressRootSkippedLanes |= revertLane));
              updateLane = update.action;
              shouldDoubleInvokeUserFnsInHooksDEV && reducer(pendingQueue, updateLane);
              pendingQueue = update.hasEagerState
                ? update.eagerState
                : reducer(pendingQueue, updateLane);
            } else
              ((revertLane = {
                lane: updateLane,
                revertLane: update.revertLane,
                action: update.action,
                hasEagerState: update.hasEagerState,
                eagerState: update.eagerState,
                next: null,
              }),
                null === newBaseQueueLast
                  ? ((newBaseQueueFirst = newBaseQueueLast = revertLane),
                    (baseFirst = pendingQueue))
                  : (newBaseQueueLast = newBaseQueueLast.next = revertLane),
                (currentlyRenderingFiber.lanes |= updateLane),
                (workInProgressRootSkippedLanes |= updateLane));
            update = update.next;
          } while (null !== update && update !== current);
          null === newBaseQueueLast
            ? (baseFirst = pendingQueue)
            : (newBaseQueueLast.next = newBaseQueueFirst);
          if (
            !objectIs(pendingQueue, hook.memoizedState) &&
            ((didReceiveUpdate = !0),
            didReadFromEntangledAsyncAction$32 &&
              ((reducer = currentEntangledActionThenable), null !== reducer))
          )
            throw reducer;
          hook.memoizedState = pendingQueue;
          hook.baseState = baseFirst;
          hook.baseQueue = newBaseQueueLast;
          queue.lastRenderedState = pendingQueue;
        }
        null === baseQueue && (queue.lanes = 0);
        return [hook.memoizedState, queue.dispatch];
      }
      function rerenderReducer(reducer) {
        var hook = updateWorkInProgressHook(),
          queue = hook.queue;
        if (null === queue) throw Error(formatProdErrorMessage(311));
        queue.lastRenderedReducer = reducer;
        var dispatch = queue.dispatch,
          lastRenderPhaseUpdate = queue.pending,
          newState = hook.memoizedState;
        if (null !== lastRenderPhaseUpdate) {
          queue.pending = null;
          var update = (lastRenderPhaseUpdate = lastRenderPhaseUpdate.next);
          do ((newState = reducer(newState, update.action)), (update = update.next));
          while (update !== lastRenderPhaseUpdate);
          objectIs(newState, hook.memoizedState) || (didReceiveUpdate = !0);
          hook.memoizedState = newState;
          null === hook.baseQueue && (hook.baseState = newState);
          queue.lastRenderedState = newState;
        }
        return [newState, dispatch];
      }
      function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
        var fiber = currentlyRenderingFiber,
          hook = updateWorkInProgressHook(),
          isHydrating$jscomp$0 = isHydrating;
        if (isHydrating$jscomp$0) {
          if (void 0 === getServerSnapshot) throw Error(formatProdErrorMessage(407));
          getServerSnapshot = getServerSnapshot();
        } else getServerSnapshot = getSnapshot();
        var snapshotChanged = !objectIs((currentHook || hook).memoizedState, getServerSnapshot);
        snapshotChanged && ((hook.memoizedState = getServerSnapshot), (didReceiveUpdate = !0));
        hook = hook.queue;
        var create = subscribeToStore.bind(null, fiber, hook, subscribe);
        updateEffectImpl(2048, 8, create, [subscribe]);
        if (
          hook.getSnapshot !== getSnapshot ||
          snapshotChanged ||
          (null !== workInProgressHook && workInProgressHook.memoizedState.tag & 1)
        ) {
          fiber.flags |= 2048;
          pushSimpleEffect(
            9,
            createEffectInstance(),
            updateStoreInstance.bind(null, fiber, hook, getServerSnapshot, getSnapshot),
            null
          );
          if (null === workInProgressRoot) throw Error(formatProdErrorMessage(349));
          isHydrating$jscomp$0 ||
            0 !== (renderLanes & 124) ||
            pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
        }
        return getServerSnapshot;
      }
      function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
        fiber.flags |= 16384;
        fiber = { getSnapshot: getSnapshot, value: renderedSnapshot };
        getSnapshot = currentlyRenderingFiber.updateQueue;
        null === getSnapshot
          ? ((getSnapshot = createFunctionComponentUpdateQueue()),
            (currentlyRenderingFiber.updateQueue = getSnapshot),
            (getSnapshot.stores = [fiber]))
          : ((renderedSnapshot = getSnapshot.stores),
            null === renderedSnapshot
              ? (getSnapshot.stores = [fiber])
              : renderedSnapshot.push(fiber));
      }
      function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
        inst.value = nextSnapshot;
        inst.getSnapshot = getSnapshot;
        checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
      }
      function subscribeToStore(fiber, inst, subscribe) {
        return subscribe(function () {
          checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
        });
      }
      function checkIfSnapshotChanged(inst) {
        var latestGetSnapshot = inst.getSnapshot;
        inst = inst.value;
        try {
          var nextValue = latestGetSnapshot();
          return !objectIs(inst, nextValue);
        } catch (error) {
          return !0;
        }
      }
      function forceStoreRerender(fiber) {
        var root = enqueueConcurrentRenderForLane(fiber, 2);
        null !== root && scheduleUpdateOnFiber(root, fiber, 2);
      }
      function mountStateImpl(initialState) {
        var hook = mountWorkInProgressHook();
        if ('function' === typeof initialState) {
          var initialStateInitializer = initialState;
          initialState = initialStateInitializer();
          if (shouldDoubleInvokeUserFnsInHooksDEV) {
            setIsStrictModeForDevtools(!0);
            try {
              initialStateInitializer();
            } finally {
              setIsStrictModeForDevtools(!1);
            }
          }
        }
        hook.memoizedState = hook.baseState = initialState;
        hook.queue = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: basicStateReducer,
          lastRenderedState: initialState,
        };
        return hook;
      }
      function updateOptimisticImpl(hook, current, passthrough, reducer) {
        hook.baseState = passthrough;
        return updateReducerImpl(
          hook,
          currentHook,
          'function' === typeof reducer ? reducer : basicStateReducer
        );
      }
      function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {
        if (isRenderPhaseUpdate(fiber)) throw Error(formatProdErrorMessage(485));
        fiber = actionQueue.action;
        if (null !== fiber) {
          var actionNode = {
            payload: payload,
            action: fiber,
            next: null,
            isTransition: !0,
            status: 'pending',
            value: null,
            reason: null,
            listeners: [],
            then: function (listener) {
              actionNode.listeners.push(listener);
            },
          };
          null !== ReactSharedInternals.T ? setPendingState(!0) : (actionNode.isTransition = !1);
          setState(actionNode);
          setPendingState = actionQueue.pending;
          null === setPendingState
            ? ((actionNode.next = actionQueue.pending = actionNode),
              runActionStateAction(actionQueue, actionNode))
            : ((actionNode.next = setPendingState.next),
              (actionQueue.pending = setPendingState.next = actionNode));
        }
      }
      function runActionStateAction(actionQueue, node) {
        var action = node.action,
          payload = node.payload,
          prevState = actionQueue.state;
        if (node.isTransition) {
          var prevTransition = ReactSharedInternals.T,
            currentTransition = {};
          ReactSharedInternals.T = currentTransition;
          try {
            var returnValue = action(prevState, payload),
              onStartTransitionFinish = ReactSharedInternals.S;
            null !== onStartTransitionFinish &&
              onStartTransitionFinish(currentTransition, returnValue);
            handleActionReturnValue(actionQueue, node, returnValue);
          } catch (error) {
            onActionError(actionQueue, node, error);
          } finally {
            ReactSharedInternals.T = prevTransition;
          }
        } else
          try {
            ((prevTransition = action(prevState, payload)),
              handleActionReturnValue(actionQueue, node, prevTransition));
          } catch (error$38) {
            onActionError(actionQueue, node, error$38);
          }
      }
      function handleActionReturnValue(actionQueue, node, returnValue) {
        null !== returnValue &&
        'object' === typeof returnValue &&
        'function' === typeof returnValue.then
          ? returnValue.then(
              function (nextState) {
                onActionSuccess(actionQueue, node, nextState);
              },
              function (error) {
                return onActionError(actionQueue, node, error);
              }
            )
          : onActionSuccess(actionQueue, node, returnValue);
      }
      function onActionSuccess(actionQueue, actionNode, nextState) {
        actionNode.status = 'fulfilled';
        actionNode.value = nextState;
        notifyActionListeners(actionNode);
        actionQueue.state = nextState;
        actionNode = actionQueue.pending;
        null !== actionNode &&
          ((nextState = actionNode.next),
          nextState === actionNode
            ? (actionQueue.pending = null)
            : ((nextState = nextState.next),
              (actionNode.next = nextState),
              runActionStateAction(actionQueue, nextState)));
      }
      function onActionError(actionQueue, actionNode, error) {
        var last = actionQueue.pending;
        actionQueue.pending = null;
        if (null !== last) {
          last = last.next;
          do
            ((actionNode.status = 'rejected'),
              (actionNode.reason = error),
              notifyActionListeners(actionNode),
              (actionNode = actionNode.next));
          while (actionNode !== last);
        }
        actionQueue.action = null;
      }
      function notifyActionListeners(actionNode) {
        actionNode = actionNode.listeners;
        for (var i = 0; i < actionNode.length; i++) (0, actionNode[i])();
      }
      function actionStateReducer(oldState, newState) {
        return newState;
      }
      function mountActionState(action, initialStateProp) {
        if (isHydrating) {
          var ssrFormState = workInProgressRoot.formState;
          if (null !== ssrFormState) {
            a: {
              var JSCompiler_inline_result = currentlyRenderingFiber;
              if (isHydrating) {
                if (nextHydratableInstance) {
                  b: {
                    var JSCompiler_inline_result$jscomp$0 = nextHydratableInstance;
                    for (
                      var inRootOrSingleton = rootOrSingletonContext;
                      8 !== JSCompiler_inline_result$jscomp$0.nodeType;

                    ) {
                      if (!inRootOrSingleton) {
                        JSCompiler_inline_result$jscomp$0 = null;
                        break b;
                      }
                      JSCompiler_inline_result$jscomp$0 = getNextHydratable(
                        JSCompiler_inline_result$jscomp$0.nextSibling
                      );
                      if (null === JSCompiler_inline_result$jscomp$0) {
                        JSCompiler_inline_result$jscomp$0 = null;
                        break b;
                      }
                    }
                    inRootOrSingleton = JSCompiler_inline_result$jscomp$0.data;
                    JSCompiler_inline_result$jscomp$0 =
                      'F!' === inRootOrSingleton || 'F' === inRootOrSingleton
                        ? JSCompiler_inline_result$jscomp$0
                        : null;
                  }
                  if (JSCompiler_inline_result$jscomp$0) {
                    nextHydratableInstance = getNextHydratable(
                      JSCompiler_inline_result$jscomp$0.nextSibling
                    );
                    JSCompiler_inline_result = 'F!' === JSCompiler_inline_result$jscomp$0.data;
                    break a;
                  }
                }
                throwOnHydrationMismatch(JSCompiler_inline_result);
              }
              JSCompiler_inline_result = !1;
            }
            JSCompiler_inline_result && (initialStateProp = ssrFormState[0]);
          }
        }
        ssrFormState = mountWorkInProgressHook();
        ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
        JSCompiler_inline_result = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: actionStateReducer,
          lastRenderedState: initialStateProp,
        };
        ssrFormState.queue = JSCompiler_inline_result;
        ssrFormState = dispatchSetState.bind(
          null,
          currentlyRenderingFiber,
          JSCompiler_inline_result
        );
        JSCompiler_inline_result.dispatch = ssrFormState;
        JSCompiler_inline_result = mountStateImpl(!1);
        inRootOrSingleton = dispatchOptimisticSetState.bind(
          null,
          currentlyRenderingFiber,
          !1,
          JSCompiler_inline_result.queue
        );
        JSCompiler_inline_result = mountWorkInProgressHook();
        JSCompiler_inline_result$jscomp$0 = {
          state: initialStateProp,
          dispatch: null,
          action: action,
          pending: null,
        };
        JSCompiler_inline_result.queue = JSCompiler_inline_result$jscomp$0;
        ssrFormState = dispatchActionState.bind(
          null,
          currentlyRenderingFiber,
          JSCompiler_inline_result$jscomp$0,
          inRootOrSingleton,
          ssrFormState
        );
        JSCompiler_inline_result$jscomp$0.dispatch = ssrFormState;
        JSCompiler_inline_result.memoizedState = action;
        return [initialStateProp, ssrFormState, !1];
      }
      function updateActionState(action) {
        var stateHook = updateWorkInProgressHook();
        return updateActionStateImpl(stateHook, currentHook, action);
      }
      function updateActionStateImpl(stateHook, currentStateHook, action) {
        currentStateHook = updateReducerImpl(stateHook, currentStateHook, actionStateReducer)[0];
        stateHook = updateReducer(basicStateReducer)[0];
        if (
          'object' === typeof currentStateHook &&
          null !== currentStateHook &&
          'function' === typeof currentStateHook.then
        )
          try {
            var state = useThenable(currentStateHook);
          } catch (x) {
            if (x === SuspenseException) throw SuspenseActionException;
            throw x;
          }
        else state = currentStateHook;
        currentStateHook = updateWorkInProgressHook();
        var actionQueue = currentStateHook.queue,
          dispatch = actionQueue.dispatch;
        action !== currentStateHook.memoizedState &&
          ((currentlyRenderingFiber.flags |= 2048),
          pushSimpleEffect(
            9,
            createEffectInstance(),
            actionStateActionEffect.bind(null, actionQueue, action),
            null
          ));
        return [state, dispatch, stateHook];
      }
      function actionStateActionEffect(actionQueue, action) {
        actionQueue.action = action;
      }
      function rerenderActionState(action) {
        var stateHook = updateWorkInProgressHook(),
          currentStateHook = currentHook;
        if (null !== currentStateHook)
          return updateActionStateImpl(stateHook, currentStateHook, action);
        updateWorkInProgressHook();
        stateHook = stateHook.memoizedState;
        currentStateHook = updateWorkInProgressHook();
        var dispatch = currentStateHook.queue.dispatch;
        currentStateHook.memoizedState = action;
        return [stateHook, dispatch, !1];
      }
      function pushSimpleEffect(tag, inst, create, createDeps) {
        tag = { tag: tag, create: create, deps: createDeps, inst: inst, next: null };
        inst = currentlyRenderingFiber.updateQueue;
        null === inst &&
          ((inst = createFunctionComponentUpdateQueue()),
          (currentlyRenderingFiber.updateQueue = inst));
        create = inst.lastEffect;
        null === create
          ? (inst.lastEffect = tag.next = tag)
          : ((createDeps = create.next),
            (create.next = tag),
            (tag.next = createDeps),
            (inst.lastEffect = tag));
        return tag;
      }
      function createEffectInstance() {
        return { destroy: void 0, resource: void 0 };
      }
      function updateRef() {
        return updateWorkInProgressHook().memoizedState;
      }
      function mountEffectImpl(fiberFlags, hookFlags, create, createDeps) {
        var hook = mountWorkInProgressHook();
        createDeps = void 0 === createDeps ? null : createDeps;
        currentlyRenderingFiber.flags |= fiberFlags;
        hook.memoizedState = pushSimpleEffect(
          1 | hookFlags,
          createEffectInstance(),
          create,
          createDeps
        );
      }
      function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
        var hook = updateWorkInProgressHook();
        deps = void 0 === deps ? null : deps;
        var inst = hook.memoizedState.inst;
        null !== currentHook &&
        null !== deps &&
        areHookInputsEqual(deps, currentHook.memoizedState.deps)
          ? (hook.memoizedState = pushSimpleEffect(hookFlags, inst, create, deps))
          : ((currentlyRenderingFiber.flags |= fiberFlags),
            (hook.memoizedState = pushSimpleEffect(1 | hookFlags, inst, create, deps)));
      }
      function mountEffect(create, createDeps) {
        mountEffectImpl(8390656, 8, create, createDeps);
      }
      function updateEffect(create, createDeps) {
        updateEffectImpl(2048, 8, create, createDeps);
      }
      function updateInsertionEffect(create, deps) {
        return updateEffectImpl(4, 2, create, deps);
      }
      function updateLayoutEffect(create, deps) {
        return updateEffectImpl(4, 4, create, deps);
      }
      function imperativeHandleEffect(create, ref) {
        if ('function' === typeof ref) {
          create = create();
          var refCleanup = ref(create);
          return function () {
            'function' === typeof refCleanup ? refCleanup() : ref(null);
          };
        }
        if (null !== ref && void 0 !== ref)
          return (
            (create = create()),
            (ref.current = create),
            function () {
              ref.current = null;
            }
          );
      }
      function updateImperativeHandle(ref, create, deps) {
        deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
        updateEffectImpl(4, 4, imperativeHandleEffect.bind(null, create, ref), deps);
      }
      function mountDebugValue() {}
      function updateCallback(callback, deps) {
        var hook = updateWorkInProgressHook();
        deps = void 0 === deps ? null : deps;
        var prevState = hook.memoizedState;
        if (null !== deps && areHookInputsEqual(deps, prevState[1])) return prevState[0];
        hook.memoizedState = [callback, deps];
        return callback;
      }
      function updateMemo(nextCreate, deps) {
        var hook = updateWorkInProgressHook();
        deps = void 0 === deps ? null : deps;
        var prevState = hook.memoizedState;
        if (null !== deps && areHookInputsEqual(deps, prevState[1])) return prevState[0];
        prevState = nextCreate();
        if (shouldDoubleInvokeUserFnsInHooksDEV) {
          setIsStrictModeForDevtools(!0);
          try {
            nextCreate();
          } finally {
            setIsStrictModeForDevtools(!1);
          }
        }
        hook.memoizedState = [prevState, deps];
        return prevState;
      }
      function mountDeferredValueImpl(hook, value, initialValue) {
        if (void 0 === initialValue || 0 !== (renderLanes & 1073741824))
          return (hook.memoizedState = value);
        hook.memoizedState = initialValue;
        hook = requestDeferredLane();
        currentlyRenderingFiber.lanes |= hook;
        workInProgressRootSkippedLanes |= hook;
        return initialValue;
      }
      function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
        if (objectIs(value, prevValue)) return value;
        if (null !== currentTreeHiddenStackCursor.current)
          return (
            (hook = mountDeferredValueImpl(hook, value, initialValue)),
            objectIs(hook, prevValue) || (didReceiveUpdate = !0),
            hook
          );
        if (0 === (renderLanes & 42))
          return ((didReceiveUpdate = !0), (hook.memoizedState = value));
        hook = requestDeferredLane();
        currentlyRenderingFiber.lanes |= hook;
        workInProgressRootSkippedLanes |= hook;
        return prevValue;
      }
      function startTransition(fiber, queue, pendingState, finishedState, callback) {
        var previousPriority = ReactDOMSharedInternals.p;
        ReactDOMSharedInternals.p =
          0 !== previousPriority && 8 > previousPriority ? previousPriority : 8;
        var prevTransition = ReactSharedInternals.T,
          currentTransition = {};
        ReactSharedInternals.T = currentTransition;
        dispatchOptimisticSetState(fiber, !1, queue, pendingState);
        try {
          var returnValue = callback(),
            onStartTransitionFinish = ReactSharedInternals.S;
          null !== onStartTransitionFinish &&
            onStartTransitionFinish(currentTransition, returnValue);
          if (
            null !== returnValue &&
            'object' === typeof returnValue &&
            'function' === typeof returnValue.then
          ) {
            var thenableForFinishedState = chainThenableValue(returnValue, finishedState);
            dispatchSetStateInternal(
              fiber,
              queue,
              thenableForFinishedState,
              requestUpdateLane(fiber)
            );
          } else dispatchSetStateInternal(fiber, queue, finishedState, requestUpdateLane(fiber));
        } catch (error) {
          dispatchSetStateInternal(
            fiber,
            queue,
            { then: function () {}, status: 'rejected', reason: error },
            requestUpdateLane()
          );
        } finally {
          ((ReactDOMSharedInternals.p = previousPriority),
            (ReactSharedInternals.T = prevTransition));
        }
      }
      function noop$2() {}
      function startHostTransition(formFiber, pendingState, action, formData) {
        if (5 !== formFiber.tag) throw Error(formatProdErrorMessage(476));
        var queue = ensureFormComponentIsStateful(formFiber).queue;
        startTransition(
          formFiber,
          queue,
          pendingState,
          sharedNotPendingObject,
          null === action
            ? noop$2
            : function () {
                requestFormReset$1(formFiber);
                return action(formData);
              }
        );
      }
      function ensureFormComponentIsStateful(formFiber) {
        var existingStateHook = formFiber.memoizedState;
        if (null !== existingStateHook) return existingStateHook;
        existingStateHook = {
          memoizedState: sharedNotPendingObject,
          baseState: sharedNotPendingObject,
          baseQueue: null,
          queue: {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: basicStateReducer,
            lastRenderedState: sharedNotPendingObject,
          },
          next: null,
        };
        var initialResetState = {};
        existingStateHook.next = {
          memoizedState: initialResetState,
          baseState: initialResetState,
          baseQueue: null,
          queue: {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: basicStateReducer,
            lastRenderedState: initialResetState,
          },
          next: null,
        };
        formFiber.memoizedState = existingStateHook;
        formFiber = formFiber.alternate;
        null !== formFiber && (formFiber.memoizedState = existingStateHook);
        return existingStateHook;
      }
      function requestFormReset$1(formFiber) {
        var resetStateQueue = ensureFormComponentIsStateful(formFiber).next.queue;
        dispatchSetStateInternal(formFiber, resetStateQueue, {}, requestUpdateLane());
      }
      function useHostTransitionStatus() {
        return readContext(HostTransitionContext);
      }
      function updateId() {
        return updateWorkInProgressHook().memoizedState;
      }
      function updateRefresh() {
        return updateWorkInProgressHook().memoizedState;
      }
      function refreshCache(fiber) {
        for (var provider = fiber.return; null !== provider; ) {
          switch (provider.tag) {
            case 24:
            case 3:
              var lane = requestUpdateLane();
              fiber = createUpdate(lane);
              var root$41 = enqueueUpdate(provider, fiber, lane);
              null !== root$41 &&
                (scheduleUpdateOnFiber(root$41, provider, lane),
                entangleTransitions(root$41, provider, lane));
              provider = { cache: createCache() };
              fiber.payload = provider;
              return;
          }
          provider = provider.return;
        }
      }
      function dispatchReducerAction(fiber, queue, action) {
        var lane = requestUpdateLane();
        action = {
          lane: lane,
          revertLane: 0,
          action: action,
          hasEagerState: !1,
          eagerState: null,
          next: null,
        };
        isRenderPhaseUpdate(fiber)
          ? enqueueRenderPhaseUpdate(queue, action)
          : ((action = enqueueConcurrentHookUpdate(fiber, queue, action, lane)),
            null !== action &&
              (scheduleUpdateOnFiber(action, fiber, lane),
              entangleTransitionUpdate(action, queue, lane)));
      }
      function dispatchSetState(fiber, queue, action) {
        var lane = requestUpdateLane();
        dispatchSetStateInternal(fiber, queue, action, lane);
      }
      function dispatchSetStateInternal(fiber, queue, action, lane) {
        var update = {
          lane: lane,
          revertLane: 0,
          action: action,
          hasEagerState: !1,
          eagerState: null,
          next: null,
        };
        if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);
        else {
          var alternate = fiber.alternate;
          if (
            0 === fiber.lanes &&
            (null === alternate || 0 === alternate.lanes) &&
            ((alternate = queue.lastRenderedReducer), null !== alternate)
          )
            try {
              var currentState = queue.lastRenderedState,
                eagerState = alternate(currentState, action);
              update.hasEagerState = !0;
              update.eagerState = eagerState;
              if (objectIs(eagerState, currentState))
                return (
                  enqueueUpdate$1(fiber, queue, update, 0),
                  null === workInProgressRoot && finishQueueingConcurrentUpdates(),
                  !1
                );
            } catch (error) {
            } finally {
            }
          action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
          if (null !== action)
            return (
              scheduleUpdateOnFiber(action, fiber, lane),
              entangleTransitionUpdate(action, queue, lane),
              !0
            );
        }
        return !1;
      }
      function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
        action = {
          lane: 2,
          revertLane: requestTransitionLane(),
          action: action,
          hasEagerState: !1,
          eagerState: null,
          next: null,
        };
        if (isRenderPhaseUpdate(fiber)) {
          if (throwIfDuringRender) throw Error(formatProdErrorMessage(479));
        } else
          ((throwIfDuringRender = enqueueConcurrentHookUpdate(fiber, queue, action, 2)),
            null !== throwIfDuringRender && scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2));
      }
      function isRenderPhaseUpdate(fiber) {
        var alternate = fiber.alternate;
        return (
          fiber === currentlyRenderingFiber ||
          (null !== alternate && alternate === currentlyRenderingFiber)
        );
      }
      function enqueueRenderPhaseUpdate(queue, update) {
        didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = !0;
        var pending = queue.pending;
        null === pending
          ? (update.next = update)
          : ((update.next = pending.next), (pending.next = update));
        queue.pending = update;
      }
      function entangleTransitionUpdate(root, queue, lane) {
        if (0 !== (lane & 4194048)) {
          var queueLanes = queue.lanes;
          queueLanes &= root.pendingLanes;
          lane |= queueLanes;
          queue.lanes = lane;
          markRootEntangled(root, lane);
        }
      }
      var ContextOnlyDispatcher = {
          readContext: readContext,
          use: use,
          useCallback: throwInvalidHookError,
          useContext: throwInvalidHookError,
          useEffect: throwInvalidHookError,
          useImperativeHandle: throwInvalidHookError,
          useLayoutEffect: throwInvalidHookError,
          useInsertionEffect: throwInvalidHookError,
          useMemo: throwInvalidHookError,
          useReducer: throwInvalidHookError,
          useRef: throwInvalidHookError,
          useState: throwInvalidHookError,
          useDebugValue: throwInvalidHookError,
          useDeferredValue: throwInvalidHookError,
          useTransition: throwInvalidHookError,
          useSyncExternalStore: throwInvalidHookError,
          useId: throwInvalidHookError,
          useHostTransitionStatus: throwInvalidHookError,
          useFormState: throwInvalidHookError,
          useActionState: throwInvalidHookError,
          useOptimistic: throwInvalidHookError,
          useMemoCache: throwInvalidHookError,
          useCacheRefresh: throwInvalidHookError,
        },
        HooksDispatcherOnMount = {
          readContext: readContext,
          use: use,
          useCallback: function (callback, deps) {
            mountWorkInProgressHook().memoizedState = [callback, void 0 === deps ? null : deps];
            return callback;
          },
          useContext: readContext,
          useEffect: mountEffect,
          useImperativeHandle: function (ref, create, deps) {
            deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
            mountEffectImpl(4194308, 4, imperativeHandleEffect.bind(null, create, ref), deps);
          },
          useLayoutEffect: function (create, deps) {
            return mountEffectImpl(4194308, 4, create, deps);
          },
          useInsertionEffect: function (create, deps) {
            mountEffectImpl(4, 2, create, deps);
          },
          useMemo: function (nextCreate, deps) {
            var hook = mountWorkInProgressHook();
            deps = void 0 === deps ? null : deps;
            var nextValue = nextCreate();
            if (shouldDoubleInvokeUserFnsInHooksDEV) {
              setIsStrictModeForDevtools(!0);
              try {
                nextCreate();
              } finally {
                setIsStrictModeForDevtools(!1);
              }
            }
            hook.memoizedState = [nextValue, deps];
            return nextValue;
          },
          useReducer: function (reducer, initialArg, init) {
            var hook = mountWorkInProgressHook();
            if (void 0 !== init) {
              var initialState = init(initialArg);
              if (shouldDoubleInvokeUserFnsInHooksDEV) {
                setIsStrictModeForDevtools(!0);
                try {
                  init(initialArg);
                } finally {
                  setIsStrictModeForDevtools(!1);
                }
              }
            } else initialState = initialArg;
            hook.memoizedState = hook.baseState = initialState;
            reducer = {
              pending: null,
              lanes: 0,
              dispatch: null,
              lastRenderedReducer: reducer,
              lastRenderedState: initialState,
            };
            hook.queue = reducer;
            reducer = reducer.dispatch = dispatchReducerAction.bind(
              null,
              currentlyRenderingFiber,
              reducer
            );
            return [hook.memoizedState, reducer];
          },
          useRef: function (initialValue) {
            var hook = mountWorkInProgressHook();
            initialValue = { current: initialValue };
            return (hook.memoizedState = initialValue);
          },
          useState: function (initialState) {
            initialState = mountStateImpl(initialState);
            var queue = initialState.queue,
              dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
            queue.dispatch = dispatch;
            return [initialState.memoizedState, dispatch];
          },
          useDebugValue: mountDebugValue,
          useDeferredValue: function (value, initialValue) {
            var hook = mountWorkInProgressHook();
            return mountDeferredValueImpl(hook, value, initialValue);
          },
          useTransition: function () {
            var stateHook = mountStateImpl(!1);
            stateHook = startTransition.bind(
              null,
              currentlyRenderingFiber,
              stateHook.queue,
              !0,
              !1
            );
            mountWorkInProgressHook().memoizedState = stateHook;
            return [!1, stateHook];
          },
          useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {
            var fiber = currentlyRenderingFiber,
              hook = mountWorkInProgressHook();
            if (isHydrating) {
              if (void 0 === getServerSnapshot) throw Error(formatProdErrorMessage(407));
              getServerSnapshot = getServerSnapshot();
            } else {
              getServerSnapshot = getSnapshot();
              if (null === workInProgressRoot) throw Error(formatProdErrorMessage(349));
              0 !== (workInProgressRootRenderLanes & 124) ||
                pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
            }
            hook.memoizedState = getServerSnapshot;
            var inst = { value: getServerSnapshot, getSnapshot: getSnapshot };
            hook.queue = inst;
            mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]);
            fiber.flags |= 2048;
            pushSimpleEffect(
              9,
              createEffectInstance(),
              updateStoreInstance.bind(null, fiber, inst, getServerSnapshot, getSnapshot),
              null
            );
            return getServerSnapshot;
          },
          useId: function () {
            var hook = mountWorkInProgressHook(),
              identifierPrefix = workInProgressRoot.identifierPrefix;
            if (isHydrating) {
              var JSCompiler_inline_result = treeContextOverflow;
              var idWithLeadingBit = treeContextId;
              JSCompiler_inline_result =
                (idWithLeadingBit & ~(1 << (32 - clz32(idWithLeadingBit) - 1))).toString(32) +
                JSCompiler_inline_result;
              identifierPrefix = '\u00ab' + identifierPrefix + 'R' + JSCompiler_inline_result;
              JSCompiler_inline_result = localIdCounter++;
              0 < JSCompiler_inline_result &&
                (identifierPrefix += 'H' + JSCompiler_inline_result.toString(32));
              identifierPrefix += '\u00bb';
            } else
              ((JSCompiler_inline_result = globalClientIdCounter++),
                (identifierPrefix =
                  '\u00ab' +
                  identifierPrefix +
                  'r' +
                  JSCompiler_inline_result.toString(32) +
                  '\u00bb'));
            return (hook.memoizedState = identifierPrefix);
          },
          useHostTransitionStatus: useHostTransitionStatus,
          useFormState: mountActionState,
          useActionState: mountActionState,
          useOptimistic: function (passthrough) {
            var hook = mountWorkInProgressHook();
            hook.memoizedState = hook.baseState = passthrough;
            var queue = {
              pending: null,
              lanes: 0,
              dispatch: null,
              lastRenderedReducer: null,
              lastRenderedState: null,
            };
            hook.queue = queue;
            hook = dispatchOptimisticSetState.bind(null, currentlyRenderingFiber, !0, queue);
            queue.dispatch = hook;
            return [passthrough, hook];
          },
          useMemoCache: useMemoCache,
          useCacheRefresh: function () {
            return (mountWorkInProgressHook().memoizedState = refreshCache.bind(
              null,
              currentlyRenderingFiber
            ));
          },
        },
        HooksDispatcherOnUpdate = {
          readContext: readContext,
          use: use,
          useCallback: updateCallback,
          useContext: readContext,
          useEffect: updateEffect,
          useImperativeHandle: updateImperativeHandle,
          useInsertionEffect: updateInsertionEffect,
          useLayoutEffect: updateLayoutEffect,
          useMemo: updateMemo,
          useReducer: updateReducer,
          useRef: updateRef,
          useState: function () {
            return updateReducer(basicStateReducer);
          },
          useDebugValue: mountDebugValue,
          useDeferredValue: function (value, initialValue) {
            var hook = updateWorkInProgressHook();
            return updateDeferredValueImpl(hook, currentHook.memoizedState, value, initialValue);
          },
          useTransition: function () {
            var booleanOrThenable = updateReducer(basicStateReducer)[0],
              start = updateWorkInProgressHook().memoizedState;
            return [
              'boolean' === typeof booleanOrThenable
                ? booleanOrThenable
                : useThenable(booleanOrThenable),
              start,
            ];
          },
          useSyncExternalStore: updateSyncExternalStore,
          useId: updateId,
          useHostTransitionStatus: useHostTransitionStatus,
          useFormState: updateActionState,
          useActionState: updateActionState,
          useOptimistic: function (passthrough, reducer) {
            var hook = updateWorkInProgressHook();
            return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
          },
          useMemoCache: useMemoCache,
          useCacheRefresh: updateRefresh,
        },
        HooksDispatcherOnRerender = {
          readContext: readContext,
          use: use,
          useCallback: updateCallback,
          useContext: readContext,
          useEffect: updateEffect,
          useImperativeHandle: updateImperativeHandle,
          useInsertionEffect: updateInsertionEffect,
          useLayoutEffect: updateLayoutEffect,
          useMemo: updateMemo,
          useReducer: rerenderReducer,
          useRef: updateRef,
          useState: function () {
            return rerenderReducer(basicStateReducer);
          },
          useDebugValue: mountDebugValue,
          useDeferredValue: function (value, initialValue) {
            var hook = updateWorkInProgressHook();
            return null === currentHook
              ? mountDeferredValueImpl(hook, value, initialValue)
              : updateDeferredValueImpl(hook, currentHook.memoizedState, value, initialValue);
          },
          useTransition: function () {
            var booleanOrThenable = rerenderReducer(basicStateReducer)[0],
              start = updateWorkInProgressHook().memoizedState;
            return [
              'boolean' === typeof booleanOrThenable
                ? booleanOrThenable
                : useThenable(booleanOrThenable),
              start,
            ];
          },
          useSyncExternalStore: updateSyncExternalStore,
          useId: updateId,
          useHostTransitionStatus: useHostTransitionStatus,
          useFormState: rerenderActionState,
          useActionState: rerenderActionState,
          useOptimistic: function (passthrough, reducer) {
            var hook = updateWorkInProgressHook();
            if (null !== currentHook)
              return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
            hook.baseState = passthrough;
            return [passthrough, hook.queue.dispatch];
          },
          useMemoCache: useMemoCache,
          useCacheRefresh: updateRefresh,
        },
        thenableState = null,
        thenableIndexCounter = 0;
      function unwrapThenable(thenable) {
        var index = thenableIndexCounter;
        thenableIndexCounter += 1;
        null === thenableState && (thenableState = []);
        return trackUsedThenable(thenableState, thenable, index);
      }
      function coerceRef(workInProgress, element) {
        element = element.props.ref;
        workInProgress.ref = void 0 !== element ? element : null;
      }
      function throwOnInvalidObjectType(returnFiber, newChild) {
        if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)
          throw Error(formatProdErrorMessage(525));
        returnFiber = Object.prototype.toString.call(newChild);
        throw Error(
          formatProdErrorMessage(
            31,
            '[object Object]' === returnFiber
              ? 'object with keys {' + Object.keys(newChild).join(', ') + '}'
              : returnFiber
          )
        );
      }
      function resolveLazy(lazyType) {
        var init = lazyType._init;
        return init(lazyType._payload);
      }
      function createChildReconciler(shouldTrackSideEffects) {
        function deleteChild(returnFiber, childToDelete) {
          if (shouldTrackSideEffects) {
            var deletions = returnFiber.deletions;
            null === deletions
              ? ((returnFiber.deletions = [childToDelete]), (returnFiber.flags |= 16))
              : deletions.push(childToDelete);
          }
        }
        function deleteRemainingChildren(returnFiber, currentFirstChild) {
          if (!shouldTrackSideEffects) return null;
          for (; null !== currentFirstChild; )
            (deleteChild(returnFiber, currentFirstChild),
              (currentFirstChild = currentFirstChild.sibling));
          return null;
        }
        function mapRemainingChildren(currentFirstChild) {
          for (var existingChildren = new Map(); null !== currentFirstChild; )
            (null !== currentFirstChild.key
              ? existingChildren.set(currentFirstChild.key, currentFirstChild)
              : existingChildren.set(currentFirstChild.index, currentFirstChild),
              (currentFirstChild = currentFirstChild.sibling));
          return existingChildren;
        }
        function useFiber(fiber, pendingProps) {
          fiber = createWorkInProgress(fiber, pendingProps);
          fiber.index = 0;
          fiber.sibling = null;
          return fiber;
        }
        function placeChild(newFiber, lastPlacedIndex, newIndex) {
          newFiber.index = newIndex;
          if (!shouldTrackSideEffects) return ((newFiber.flags |= 1048576), lastPlacedIndex);
          newIndex = newFiber.alternate;
          if (null !== newIndex)
            return (
              (newIndex = newIndex.index),
              newIndex < lastPlacedIndex
                ? ((newFiber.flags |= 67108866), lastPlacedIndex)
                : newIndex
            );
          newFiber.flags |= 67108866;
          return lastPlacedIndex;
        }
        function placeSingleChild(newFiber) {
          shouldTrackSideEffects && null === newFiber.alternate && (newFiber.flags |= 67108866);
          return newFiber;
        }
        function updateTextNode(returnFiber, current, textContent, lanes) {
          if (null === current || 6 !== current.tag)
            return (
              (current = createFiberFromText(textContent, returnFiber.mode, lanes)),
              (current.return = returnFiber),
              current
            );
          current = useFiber(current, textContent);
          current.return = returnFiber;
          return current;
        }
        function updateElement(returnFiber, current, element, lanes) {
          var elementType = element.type;
          if (elementType === REACT_FRAGMENT_TYPE)
            return updateFragment(returnFiber, current, element.props.children, lanes, element.key);
          if (
            null !== current &&
            (current.elementType === elementType ||
              ('object' === typeof elementType &&
                null !== elementType &&
                elementType.$$typeof === REACT_LAZY_TYPE &&
                resolveLazy(elementType) === current.type))
          )
            return (
              (current = useFiber(current, element.props)),
              coerceRef(current, element),
              (current.return = returnFiber),
              current
            );
          current = createFiberFromTypeAndProps(
            element.type,
            element.key,
            element.props,
            null,
            returnFiber.mode,
            lanes
          );
          coerceRef(current, element);
          current.return = returnFiber;
          return current;
        }
        function updatePortal(returnFiber, current, portal, lanes) {
          if (
            null === current ||
            4 !== current.tag ||
            current.stateNode.containerInfo !== portal.containerInfo ||
            current.stateNode.implementation !== portal.implementation
          )
            return (
              (current = createFiberFromPortal(portal, returnFiber.mode, lanes)),
              (current.return = returnFiber),
              current
            );
          current = useFiber(current, portal.children || []);
          current.return = returnFiber;
          return current;
        }
        function updateFragment(returnFiber, current, fragment, lanes, key) {
          if (null === current || 7 !== current.tag)
            return (
              (current = createFiberFromFragment(fragment, returnFiber.mode, lanes, key)),
              (current.return = returnFiber),
              current
            );
          current = useFiber(current, fragment);
          current.return = returnFiber;
          return current;
        }
        function createChild(returnFiber, newChild, lanes) {
          if (
            ('string' === typeof newChild && '' !== newChild) ||
            'number' === typeof newChild ||
            'bigint' === typeof newChild
          )
            return (
              (newChild = createFiberFromText('' + newChild, returnFiber.mode, lanes)),
              (newChild.return = returnFiber),
              newChild
            );
          if ('object' === typeof newChild && null !== newChild) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                return (
                  (lanes = createFiberFromTypeAndProps(
                    newChild.type,
                    newChild.key,
                    newChild.props,
                    null,
                    returnFiber.mode,
                    lanes
                  )),
                  coerceRef(lanes, newChild),
                  (lanes.return = returnFiber),
                  lanes
                );
              case REACT_PORTAL_TYPE:
                return (
                  (newChild = createFiberFromPortal(newChild, returnFiber.mode, lanes)),
                  (newChild.return = returnFiber),
                  newChild
                );
              case REACT_LAZY_TYPE:
                var init = newChild._init;
                newChild = init(newChild._payload);
                return createChild(returnFiber, newChild, lanes);
            }
            if (isArrayImpl(newChild) || getIteratorFn(newChild))
              return (
                (newChild = createFiberFromFragment(newChild, returnFiber.mode, lanes, null)),
                (newChild.return = returnFiber),
                newChild
              );
            if ('function' === typeof newChild.then)
              return createChild(returnFiber, unwrapThenable(newChild), lanes);
            if (newChild.$$typeof === REACT_CONTEXT_TYPE)
              return createChild(
                returnFiber,
                readContextDuringReconciliation(returnFiber, newChild),
                lanes
              );
            throwOnInvalidObjectType(returnFiber, newChild);
          }
          return null;
        }
        function updateSlot(returnFiber, oldFiber, newChild, lanes) {
          var key = null !== oldFiber ? oldFiber.key : null;
          if (
            ('string' === typeof newChild && '' !== newChild) ||
            'number' === typeof newChild ||
            'bigint' === typeof newChild
          )
            return null !== key
              ? null
              : updateTextNode(returnFiber, oldFiber, '' + newChild, lanes);
          if ('object' === typeof newChild && null !== newChild) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                return newChild.key === key
                  ? updateElement(returnFiber, oldFiber, newChild, lanes)
                  : null;
              case REACT_PORTAL_TYPE:
                return newChild.key === key
                  ? updatePortal(returnFiber, oldFiber, newChild, lanes)
                  : null;
              case REACT_LAZY_TYPE:
                return (
                  (key = newChild._init),
                  (newChild = key(newChild._payload)),
                  updateSlot(returnFiber, oldFiber, newChild, lanes)
                );
            }
            if (isArrayImpl(newChild) || getIteratorFn(newChild))
              return null !== key
                ? null
                : updateFragment(returnFiber, oldFiber, newChild, lanes, null);
            if ('function' === typeof newChild.then)
              return updateSlot(returnFiber, oldFiber, unwrapThenable(newChild), lanes);
            if (newChild.$$typeof === REACT_CONTEXT_TYPE)
              return updateSlot(
                returnFiber,
                oldFiber,
                readContextDuringReconciliation(returnFiber, newChild),
                lanes
              );
            throwOnInvalidObjectType(returnFiber, newChild);
          }
          return null;
        }
        function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
          if (
            ('string' === typeof newChild && '' !== newChild) ||
            'number' === typeof newChild ||
            'bigint' === typeof newChild
          )
            return (
              (existingChildren = existingChildren.get(newIdx) || null),
              updateTextNode(returnFiber, existingChildren, '' + newChild, lanes)
            );
          if ('object' === typeof newChild && null !== newChild) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                return (
                  (existingChildren =
                    existingChildren.get(null === newChild.key ? newIdx : newChild.key) || null),
                  updateElement(returnFiber, existingChildren, newChild, lanes)
                );
              case REACT_PORTAL_TYPE:
                return (
                  (existingChildren =
                    existingChildren.get(null === newChild.key ? newIdx : newChild.key) || null),
                  updatePortal(returnFiber, existingChildren, newChild, lanes)
                );
              case REACT_LAZY_TYPE:
                var init = newChild._init;
                newChild = init(newChild._payload);
                return updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes);
            }
            if (isArrayImpl(newChild) || getIteratorFn(newChild))
              return (
                (existingChildren = existingChildren.get(newIdx) || null),
                updateFragment(returnFiber, existingChildren, newChild, lanes, null)
              );
            if ('function' === typeof newChild.then)
              return updateFromMap(
                existingChildren,
                returnFiber,
                newIdx,
                unwrapThenable(newChild),
                lanes
              );
            if (newChild.$$typeof === REACT_CONTEXT_TYPE)
              return updateFromMap(
                existingChildren,
                returnFiber,
                newIdx,
                readContextDuringReconciliation(returnFiber, newChild),
                lanes
              );
            throwOnInvalidObjectType(returnFiber, newChild);
          }
          return null;
        }
        function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
          for (
            var resultingFirstChild = null,
              previousNewFiber = null,
              oldFiber = currentFirstChild,
              newIdx = (currentFirstChild = 0),
              nextOldFiber = null;
            null !== oldFiber && newIdx < newChildren.length;
            newIdx++
          ) {
            oldFiber.index > newIdx
              ? ((nextOldFiber = oldFiber), (oldFiber = null))
              : (nextOldFiber = oldFiber.sibling);
            var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);
            if (null === newFiber) {
              null === oldFiber && (oldFiber = nextOldFiber);
              break;
            }
            shouldTrackSideEffects &&
              oldFiber &&
              null === newFiber.alternate &&
              deleteChild(returnFiber, oldFiber);
            currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
            null === previousNewFiber
              ? (resultingFirstChild = newFiber)
              : (previousNewFiber.sibling = newFiber);
            previousNewFiber = newFiber;
            oldFiber = nextOldFiber;
          }
          if (newIdx === newChildren.length)
            return (
              deleteRemainingChildren(returnFiber, oldFiber),
              isHydrating && pushTreeFork(returnFiber, newIdx),
              resultingFirstChild
            );
          if (null === oldFiber) {
            for (; newIdx < newChildren.length; newIdx++)
              ((oldFiber = createChild(returnFiber, newChildren[newIdx], lanes)),
                null !== oldFiber &&
                  ((currentFirstChild = placeChild(oldFiber, currentFirstChild, newIdx)),
                  null === previousNewFiber
                    ? (resultingFirstChild = oldFiber)
                    : (previousNewFiber.sibling = oldFiber),
                  (previousNewFiber = oldFiber)));
            isHydrating && pushTreeFork(returnFiber, newIdx);
            return resultingFirstChild;
          }
          for (oldFiber = mapRemainingChildren(oldFiber); newIdx < newChildren.length; newIdx++)
            ((nextOldFiber = updateFromMap(
              oldFiber,
              returnFiber,
              newIdx,
              newChildren[newIdx],
              lanes
            )),
              null !== nextOldFiber &&
                (shouldTrackSideEffects &&
                  null !== nextOldFiber.alternate &&
                  oldFiber.delete(null === nextOldFiber.key ? newIdx : nextOldFiber.key),
                (currentFirstChild = placeChild(nextOldFiber, currentFirstChild, newIdx)),
                null === previousNewFiber
                  ? (resultingFirstChild = nextOldFiber)
                  : (previousNewFiber.sibling = nextOldFiber),
                (previousNewFiber = nextOldFiber)));
          shouldTrackSideEffects &&
            oldFiber.forEach(function (child) {
              return deleteChild(returnFiber, child);
            });
          isHydrating && pushTreeFork(returnFiber, newIdx);
          return resultingFirstChild;
        }
        function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes) {
          if (null == newChildren) throw Error(formatProdErrorMessage(151));
          for (
            var resultingFirstChild = null,
              previousNewFiber = null,
              oldFiber = currentFirstChild,
              newIdx = (currentFirstChild = 0),
              nextOldFiber = null,
              step = newChildren.next();
            null !== oldFiber && !step.done;
            newIdx++, step = newChildren.next()
          ) {
            oldFiber.index > newIdx
              ? ((nextOldFiber = oldFiber), (oldFiber = null))
              : (nextOldFiber = oldFiber.sibling);
            var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
            if (null === newFiber) {
              null === oldFiber && (oldFiber = nextOldFiber);
              break;
            }
            shouldTrackSideEffects &&
              oldFiber &&
              null === newFiber.alternate &&
              deleteChild(returnFiber, oldFiber);
            currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
            null === previousNewFiber
              ? (resultingFirstChild = newFiber)
              : (previousNewFiber.sibling = newFiber);
            previousNewFiber = newFiber;
            oldFiber = nextOldFiber;
          }
          if (step.done)
            return (
              deleteRemainingChildren(returnFiber, oldFiber),
              isHydrating && pushTreeFork(returnFiber, newIdx),
              resultingFirstChild
            );
          if (null === oldFiber) {
            for (; !step.done; newIdx++, step = newChildren.next())
              ((step = createChild(returnFiber, step.value, lanes)),
                null !== step &&
                  ((currentFirstChild = placeChild(step, currentFirstChild, newIdx)),
                  null === previousNewFiber
                    ? (resultingFirstChild = step)
                    : (previousNewFiber.sibling = step),
                  (previousNewFiber = step)));
            isHydrating && pushTreeFork(returnFiber, newIdx);
            return resultingFirstChild;
          }
          for (
            oldFiber = mapRemainingChildren(oldFiber);
            !step.done;
            newIdx++, step = newChildren.next()
          )
            ((step = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes)),
              null !== step &&
                (shouldTrackSideEffects &&
                  null !== step.alternate &&
                  oldFiber.delete(null === step.key ? newIdx : step.key),
                (currentFirstChild = placeChild(step, currentFirstChild, newIdx)),
                null === previousNewFiber
                  ? (resultingFirstChild = step)
                  : (previousNewFiber.sibling = step),
                (previousNewFiber = step)));
          shouldTrackSideEffects &&
            oldFiber.forEach(function (child) {
              return deleteChild(returnFiber, child);
            });
          isHydrating && pushTreeFork(returnFiber, newIdx);
          return resultingFirstChild;
        }
        function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes) {
          'object' === typeof newChild &&
            null !== newChild &&
            newChild.type === REACT_FRAGMENT_TYPE &&
            null === newChild.key &&
            (newChild = newChild.props.children);
          if ('object' === typeof newChild && null !== newChild) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                a: {
                  for (var key = newChild.key; null !== currentFirstChild; ) {
                    if (currentFirstChild.key === key) {
                      key = newChild.type;
                      if (key === REACT_FRAGMENT_TYPE) {
                        if (7 === currentFirstChild.tag) {
                          deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                          lanes = useFiber(currentFirstChild, newChild.props.children);
                          lanes.return = returnFiber;
                          returnFiber = lanes;
                          break a;
                        }
                      } else if (
                        currentFirstChild.elementType === key ||
                        ('object' === typeof key &&
                          null !== key &&
                          key.$$typeof === REACT_LAZY_TYPE &&
                          resolveLazy(key) === currentFirstChild.type)
                      ) {
                        deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                        lanes = useFiber(currentFirstChild, newChild.props);
                        coerceRef(lanes, newChild);
                        lanes.return = returnFiber;
                        returnFiber = lanes;
                        break a;
                      }
                      deleteRemainingChildren(returnFiber, currentFirstChild);
                      break;
                    } else deleteChild(returnFiber, currentFirstChild);
                    currentFirstChild = currentFirstChild.sibling;
                  }
                  newChild.type === REACT_FRAGMENT_TYPE
                    ? ((lanes = createFiberFromFragment(
                        newChild.props.children,
                        returnFiber.mode,
                        lanes,
                        newChild.key
                      )),
                      (lanes.return = returnFiber),
                      (returnFiber = lanes))
                    : ((lanes = createFiberFromTypeAndProps(
                        newChild.type,
                        newChild.key,
                        newChild.props,
                        null,
                        returnFiber.mode,
                        lanes
                      )),
                      coerceRef(lanes, newChild),
                      (lanes.return = returnFiber),
                      (returnFiber = lanes));
                }
                return placeSingleChild(returnFiber);
              case REACT_PORTAL_TYPE:
                a: {
                  for (key = newChild.key; null !== currentFirstChild; ) {
                    if (currentFirstChild.key === key)
                      if (
                        4 === currentFirstChild.tag &&
                        currentFirstChild.stateNode.containerInfo === newChild.containerInfo &&
                        currentFirstChild.stateNode.implementation === newChild.implementation
                      ) {
                        deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                        lanes = useFiber(currentFirstChild, newChild.children || []);
                        lanes.return = returnFiber;
                        returnFiber = lanes;
                        break a;
                      } else {
                        deleteRemainingChildren(returnFiber, currentFirstChild);
                        break;
                      }
                    else deleteChild(returnFiber, currentFirstChild);
                    currentFirstChild = currentFirstChild.sibling;
                  }
                  lanes = createFiberFromPortal(newChild, returnFiber.mode, lanes);
                  lanes.return = returnFiber;
                  returnFiber = lanes;
                }
                return placeSingleChild(returnFiber);
              case REACT_LAZY_TYPE:
                return (
                  (key = newChild._init),
                  (newChild = key(newChild._payload)),
                  reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes)
                );
            }
            if (isArrayImpl(newChild))
              return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes);
            if (getIteratorFn(newChild)) {
              key = getIteratorFn(newChild);
              if ('function' !== typeof key) throw Error(formatProdErrorMessage(150));
              newChild = key.call(newChild);
              return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes);
            }
            if ('function' === typeof newChild.then)
              return reconcileChildFibersImpl(
                returnFiber,
                currentFirstChild,
                unwrapThenable(newChild),
                lanes
              );
            if (newChild.$$typeof === REACT_CONTEXT_TYPE)
              return reconcileChildFibersImpl(
                returnFiber,
                currentFirstChild,
                readContextDuringReconciliation(returnFiber, newChild),
                lanes
              );
            throwOnInvalidObjectType(returnFiber, newChild);
          }
          return ('string' === typeof newChild && '' !== newChild) ||
            'number' === typeof newChild ||
            'bigint' === typeof newChild
            ? ((newChild = '' + newChild),
              null !== currentFirstChild && 6 === currentFirstChild.tag
                ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling),
                  (lanes = useFiber(currentFirstChild, newChild)),
                  (lanes.return = returnFiber),
                  (returnFiber = lanes))
                : (deleteRemainingChildren(returnFiber, currentFirstChild),
                  (lanes = createFiberFromText(newChild, returnFiber.mode, lanes)),
                  (lanes.return = returnFiber),
                  (returnFiber = lanes)),
              placeSingleChild(returnFiber))
            : deleteRemainingChildren(returnFiber, currentFirstChild);
        }
        return function (returnFiber, currentFirstChild, newChild, lanes) {
          try {
            thenableIndexCounter = 0;
            var firstChildFiber = reconcileChildFibersImpl(
              returnFiber,
              currentFirstChild,
              newChild,
              lanes
            );
            thenableState = null;
            return firstChildFiber;
          } catch (x) {
            if (x === SuspenseException || x === SuspenseActionException) throw x;
            var fiber = createFiberImplClass(29, x, null, returnFiber.mode);
            fiber.lanes = lanes;
            fiber.return = returnFiber;
            return fiber;
          } finally {
          }
        };
      }
      var reconcileChildFibers = createChildReconciler(!0),
        mountChildFibers = createChildReconciler(!1),
        suspenseHandlerStackCursor = createCursor(null),
        shellBoundary = null;
      function pushPrimaryTreeSuspenseHandler(handler) {
        var current = handler.alternate;
        push(suspenseStackCursor, suspenseStackCursor.current & 1);
        push(suspenseHandlerStackCursor, handler);
        null === shellBoundary &&
          (null === current || null !== currentTreeHiddenStackCursor.current
            ? (shellBoundary = handler)
            : null !== current.memoizedState && (shellBoundary = handler));
      }
      function pushOffscreenSuspenseHandler(fiber) {
        if (22 === fiber.tag) {
          if (
            (push(suspenseStackCursor, suspenseStackCursor.current),
            push(suspenseHandlerStackCursor, fiber),
            null === shellBoundary)
          ) {
            var current = fiber.alternate;
            null !== current && null !== current.memoizedState && (shellBoundary = fiber);
          }
        } else reuseSuspenseHandlerOnStack(fiber);
      }
      function reuseSuspenseHandlerOnStack() {
        push(suspenseStackCursor, suspenseStackCursor.current);
        push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current);
      }
      function popSuspenseHandler(fiber) {
        pop(suspenseHandlerStackCursor);
        shellBoundary === fiber && (shellBoundary = null);
        pop(suspenseStackCursor);
      }
      var suspenseStackCursor = createCursor(0);
      function findFirstSuspended(row) {
        for (var node = row; null !== node; ) {
          if (13 === node.tag) {
            var state = node.memoizedState;
            if (
              null !== state &&
              ((state = state.dehydrated),
              null === state || '$?' === state.data || isSuspenseInstanceFallback(state))
            )
              return node;
          } else if (19 === node.tag && void 0 !== node.memoizedProps.revealOrder) {
            if (0 !== (node.flags & 128)) return node;
          } else if (null !== node.child) {
            node.child.return = node;
            node = node.child;
            continue;
          }
          if (node === row) break;
          for (; null === node.sibling; ) {
            if (null === node.return || node.return === row) return null;
            node = node.return;
          }
          node.sibling.return = node.return;
          node = node.sibling;
        }
        return null;
      }
      function applyDerivedStateFromProps(
        workInProgress,
        ctor,
        getDerivedStateFromProps,
        nextProps
      ) {
        ctor = workInProgress.memoizedState;
        getDerivedStateFromProps = getDerivedStateFromProps(nextProps, ctor);
        getDerivedStateFromProps =
          null === getDerivedStateFromProps || void 0 === getDerivedStateFromProps
            ? ctor
            : assign({}, ctor, getDerivedStateFromProps);
        workInProgress.memoizedState = getDerivedStateFromProps;
        0 === workInProgress.lanes &&
          (workInProgress.updateQueue.baseState = getDerivedStateFromProps);
      }
      var classComponentUpdater = {
        enqueueSetState: function (inst, payload, callback) {
          inst = inst._reactInternals;
          var lane = requestUpdateLane(),
            update = createUpdate(lane);
          update.payload = payload;
          void 0 !== callback && null !== callback && (update.callback = callback);
          payload = enqueueUpdate(inst, update, lane);
          null !== payload &&
            (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
        },
        enqueueReplaceState: function (inst, payload, callback) {
          inst = inst._reactInternals;
          var lane = requestUpdateLane(),
            update = createUpdate(lane);
          update.tag = 1;
          update.payload = payload;
          void 0 !== callback && null !== callback && (update.callback = callback);
          payload = enqueueUpdate(inst, update, lane);
          null !== payload &&
            (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
        },
        enqueueForceUpdate: function (inst, callback) {
          inst = inst._reactInternals;
          var lane = requestUpdateLane(),
            update = createUpdate(lane);
          update.tag = 2;
          void 0 !== callback && null !== callback && (update.callback = callback);
          callback = enqueueUpdate(inst, update, lane);
          null !== callback &&
            (scheduleUpdateOnFiber(callback, inst, lane),
            entangleTransitions(callback, inst, lane));
        },
      };
      function checkShouldComponentUpdate(
        workInProgress,
        ctor,
        oldProps,
        newProps,
        oldState,
        newState,
        nextContext
      ) {
        workInProgress = workInProgress.stateNode;
        return 'function' === typeof workInProgress.shouldComponentUpdate
          ? workInProgress.shouldComponentUpdate(newProps, newState, nextContext)
          : ctor.prototype && ctor.prototype.isPureReactComponent
            ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)
            : !0;
      }
      function callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext) {
        workInProgress = instance.state;
        'function' === typeof instance.componentWillReceiveProps &&
          instance.componentWillReceiveProps(newProps, nextContext);
        'function' === typeof instance.UNSAFE_componentWillReceiveProps &&
          instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
        instance.state !== workInProgress &&
          classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
      }
      function resolveClassComponentProps(Component, baseProps) {
        var newProps = baseProps;
        if ('ref' in baseProps) {
          newProps = {};
          for (var propName in baseProps)
            'ref' !== propName && (newProps[propName] = baseProps[propName]);
        }
        if ((Component = Component.defaultProps)) {
          newProps === baseProps && (newProps = assign({}, newProps));
          for (var propName$73 in Component)
            void 0 === newProps[propName$73] && (newProps[propName$73] = Component[propName$73]);
        }
        return newProps;
      }
      var reportGlobalError =
        'function' === typeof reportError
          ? reportError
          : function (error) {
              if ('object' === typeof window && 'function' === typeof window.ErrorEvent) {
                var event = new window.ErrorEvent('error', {
                  bubbles: !0,
                  cancelable: !0,
                  message:
                    'object' === typeof error && null !== error && 'string' === typeof error.message
                      ? String(error.message)
                      : String(error),
                  error: error,
                });
                if (!window.dispatchEvent(event)) return;
              } else if ('object' === typeof process && 'function' === typeof process.emit) {
                process.emit('uncaughtException', error);
                return;
              }
              console.error(error);
            };
      function defaultOnUncaughtError(error) {
        reportGlobalError(error);
      }
      function defaultOnCaughtError(error) {
        console.error(error);
      }
      function defaultOnRecoverableError(error) {
        reportGlobalError(error);
      }
      function logUncaughtError(root, errorInfo) {
        try {
          var onUncaughtError = root.onUncaughtError;
          onUncaughtError(errorInfo.value, { componentStack: errorInfo.stack });
        } catch (e$74) {
          setTimeout(function () {
            throw e$74;
          });
        }
      }
      function logCaughtError(root, boundary, errorInfo) {
        try {
          var onCaughtError = root.onCaughtError;
          onCaughtError(errorInfo.value, {
            componentStack: errorInfo.stack,
            errorBoundary: 1 === boundary.tag ? boundary.stateNode : null,
          });
        } catch (e$75) {
          setTimeout(function () {
            throw e$75;
          });
        }
      }
      function createRootErrorUpdate(root, errorInfo, lane) {
        lane = createUpdate(lane);
        lane.tag = 3;
        lane.payload = { element: null };
        lane.callback = function () {
          logUncaughtError(root, errorInfo);
        };
        return lane;
      }
      function createClassErrorUpdate(lane) {
        lane = createUpdate(lane);
        lane.tag = 3;
        return lane;
      }
      function initializeClassErrorUpdate(update, root, fiber, errorInfo) {
        var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
        if ('function' === typeof getDerivedStateFromError) {
          var error = errorInfo.value;
          update.payload = function () {
            return getDerivedStateFromError(error);
          };
          update.callback = function () {
            logCaughtError(root, fiber, errorInfo);
          };
        }
        var inst = fiber.stateNode;
        null !== inst &&
          'function' === typeof inst.componentDidCatch &&
          (update.callback = function () {
            logCaughtError(root, fiber, errorInfo);
            'function' !== typeof getDerivedStateFromError &&
              (null === legacyErrorBoundariesThatAlreadyFailed
                ? (legacyErrorBoundariesThatAlreadyFailed = new Set([this]))
                : legacyErrorBoundariesThatAlreadyFailed.add(this));
            var stack = errorInfo.stack;
            this.componentDidCatch(errorInfo.value, {
              componentStack: null !== stack ? stack : '',
            });
          });
      }
      function throwException(root, returnFiber, sourceFiber, value, rootRenderLanes) {
        sourceFiber.flags |= 32768;
        if (null !== value && 'object' === typeof value && 'function' === typeof value.then) {
          returnFiber = sourceFiber.alternate;
          null !== returnFiber &&
            propagateParentContextChanges(returnFiber, sourceFiber, rootRenderLanes, !0);
          sourceFiber = suspenseHandlerStackCursor.current;
          if (null !== sourceFiber) {
            switch (sourceFiber.tag) {
              case 13:
                return (
                  null === shellBoundary
                    ? renderDidSuspendDelayIfPossible()
                    : null === sourceFiber.alternate &&
                      0 === workInProgressRootExitStatus &&
                      (workInProgressRootExitStatus = 3),
                  (sourceFiber.flags &= -257),
                  (sourceFiber.flags |= 65536),
                  (sourceFiber.lanes = rootRenderLanes),
                  value === noopSuspenseyCommitThenable
                    ? (sourceFiber.flags |= 16384)
                    : ((returnFiber = sourceFiber.updateQueue),
                      null === returnFiber
                        ? (sourceFiber.updateQueue = new Set([value]))
                        : returnFiber.add(value),
                      attachPingListener(root, value, rootRenderLanes)),
                  !1
                );
              case 22:
                return (
                  (sourceFiber.flags |= 65536),
                  value === noopSuspenseyCommitThenable
                    ? (sourceFiber.flags |= 16384)
                    : ((returnFiber = sourceFiber.updateQueue),
                      null === returnFiber
                        ? ((returnFiber = {
                            transitions: null,
                            markerInstances: null,
                            retryQueue: new Set([value]),
                          }),
                          (sourceFiber.updateQueue = returnFiber))
                        : ((sourceFiber = returnFiber.retryQueue),
                          null === sourceFiber
                            ? (returnFiber.retryQueue = new Set([value]))
                            : sourceFiber.add(value)),
                      attachPingListener(root, value, rootRenderLanes)),
                  !1
                );
            }
            throw Error(formatProdErrorMessage(435, sourceFiber.tag));
          }
          attachPingListener(root, value, rootRenderLanes);
          renderDidSuspendDelayIfPossible();
          return !1;
        }
        if (isHydrating)
          return (
            (returnFiber = suspenseHandlerStackCursor.current),
            null !== returnFiber
              ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256),
                (returnFiber.flags |= 65536),
                (returnFiber.lanes = rootRenderLanes),
                value !== HydrationMismatchException &&
                  ((root = Error(formatProdErrorMessage(422), { cause: value })),
                  queueHydrationError(createCapturedValueAtFiber(root, sourceFiber))))
              : (value !== HydrationMismatchException &&
                  ((returnFiber = Error(formatProdErrorMessage(423), {
                    cause: value,
                  })),
                  queueHydrationError(createCapturedValueAtFiber(returnFiber, sourceFiber))),
                (root = root.current.alternate),
                (root.flags |= 65536),
                (rootRenderLanes &= -rootRenderLanes),
                (root.lanes |= rootRenderLanes),
                (value = createCapturedValueAtFiber(value, sourceFiber)),
                (rootRenderLanes = createRootErrorUpdate(root.stateNode, value, rootRenderLanes)),
                enqueueCapturedUpdate(root, rootRenderLanes),
                4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2)),
            !1
          );
        var wrapperError = Error(formatProdErrorMessage(520), { cause: value });
        wrapperError = createCapturedValueAtFiber(wrapperError, sourceFiber);
        null === workInProgressRootConcurrentErrors
          ? (workInProgressRootConcurrentErrors = [wrapperError])
          : workInProgressRootConcurrentErrors.push(wrapperError);
        4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2);
        if (null === returnFiber) return !0;
        value = createCapturedValueAtFiber(value, sourceFiber);
        sourceFiber = returnFiber;
        do {
          switch (sourceFiber.tag) {
            case 3:
              return (
                (sourceFiber.flags |= 65536),
                (root = rootRenderLanes & -rootRenderLanes),
                (sourceFiber.lanes |= root),
                (root = createRootErrorUpdate(sourceFiber.stateNode, value, root)),
                enqueueCapturedUpdate(sourceFiber, root),
                !1
              );
            case 1:
              if (
                ((returnFiber = sourceFiber.type),
                (wrapperError = sourceFiber.stateNode),
                0 === (sourceFiber.flags & 128) &&
                  ('function' === typeof returnFiber.getDerivedStateFromError ||
                    (null !== wrapperError &&
                      'function' === typeof wrapperError.componentDidCatch &&
                      (null === legacyErrorBoundariesThatAlreadyFailed ||
                        !legacyErrorBoundariesThatAlreadyFailed.has(wrapperError)))))
              )
                return (
                  (sourceFiber.flags |= 65536),
                  (rootRenderLanes &= -rootRenderLanes),
                  (sourceFiber.lanes |= rootRenderLanes),
                  (rootRenderLanes = createClassErrorUpdate(rootRenderLanes)),
                  initializeClassErrorUpdate(rootRenderLanes, root, sourceFiber, value),
                  enqueueCapturedUpdate(sourceFiber, rootRenderLanes),
                  !1
                );
          }
          sourceFiber = sourceFiber.return;
        } while (null !== sourceFiber);
        return !1;
      }
      var SelectiveHydrationException = Error(formatProdErrorMessage(461)),
        didReceiveUpdate = !1;
      function reconcileChildren(current, workInProgress, nextChildren, renderLanes) {
        workInProgress.child =
          null === current
            ? mountChildFibers(workInProgress, null, nextChildren, renderLanes)
            : reconcileChildFibers(workInProgress, current.child, nextChildren, renderLanes);
      }
      function updateForwardRef(current, workInProgress, Component, nextProps, renderLanes) {
        Component = Component.render;
        var ref = workInProgress.ref;
        if ('ref' in nextProps) {
          var propsWithoutRef = {};
          for (var key in nextProps) 'ref' !== key && (propsWithoutRef[key] = nextProps[key]);
        } else propsWithoutRef = nextProps;
        prepareToReadContext(workInProgress);
        nextProps = renderWithHooks(
          current,
          workInProgress,
          Component,
          propsWithoutRef,
          ref,
          renderLanes
        );
        key = checkDidRenderIdHook();
        if (null !== current && !didReceiveUpdate)
          return (
            bailoutHooks(current, workInProgress, renderLanes),
            bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
          );
        isHydrating && key && pushMaterializedTreeId(workInProgress);
        workInProgress.flags |= 1;
        reconcileChildren(current, workInProgress, nextProps, renderLanes);
        return workInProgress.child;
      }
      function updateMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {
        if (null === current) {
          var type = Component.type;
          if (
            'function' === typeof type &&
            !shouldConstruct(type) &&
            void 0 === type.defaultProps &&
            null === Component.compare
          )
            return (
              (workInProgress.tag = 15),
              (workInProgress.type = type),
              updateSimpleMemoComponent(current, workInProgress, type, nextProps, renderLanes)
            );
          current = createFiberFromTypeAndProps(
            Component.type,
            null,
            nextProps,
            workInProgress,
            workInProgress.mode,
            renderLanes
          );
          current.ref = workInProgress.ref;
          current.return = workInProgress;
          return (workInProgress.child = current);
        }
        type = current.child;
        if (!checkScheduledUpdateOrContext(current, renderLanes)) {
          var prevProps = type.memoizedProps;
          Component = Component.compare;
          Component = null !== Component ? Component : shallowEqual;
          if (Component(prevProps, nextProps) && current.ref === workInProgress.ref)
            return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
        }
        workInProgress.flags |= 1;
        current = createWorkInProgress(type, nextProps);
        current.ref = workInProgress.ref;
        current.return = workInProgress;
        return (workInProgress.child = current);
      }
      function updateSimpleMemoComponent(
        current,
        workInProgress,
        Component,
        nextProps,
        renderLanes
      ) {
        if (null !== current) {
          var prevProps = current.memoizedProps;
          if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress.ref)
            if (
              ((didReceiveUpdate = !1),
              (workInProgress.pendingProps = nextProps = prevProps),
              checkScheduledUpdateOrContext(current, renderLanes))
            )
              0 !== (current.flags & 131072) && (didReceiveUpdate = !0);
            else
              return (
                (workInProgress.lanes = current.lanes),
                bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
              );
        }
        return updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes);
      }
      function updateOffscreenComponent(current, workInProgress, renderLanes) {
        var nextProps = workInProgress.pendingProps,
          nextChildren = nextProps.children,
          prevState = null !== current ? current.memoizedState : null;
        if ('hidden' === nextProps.mode) {
          if (0 !== (workInProgress.flags & 128)) {
            nextProps = null !== prevState ? prevState.baseLanes | renderLanes : renderLanes;
            if (null !== current) {
              nextChildren = workInProgress.child = current.child;
              for (prevState = 0; null !== nextChildren; )
                ((prevState = prevState | nextChildren.lanes | nextChildren.childLanes),
                  (nextChildren = nextChildren.sibling));
              workInProgress.childLanes = prevState & ~nextProps;
            } else ((workInProgress.childLanes = 0), (workInProgress.child = null));
            return deferHiddenOffscreenComponent(current, workInProgress, nextProps, renderLanes);
          }
          if (0 !== (renderLanes & 536870912))
            ((workInProgress.memoizedState = { baseLanes: 0, cachePool: null }),
              null !== current &&
                pushTransition(workInProgress, null !== prevState ? prevState.cachePool : null),
              null !== prevState
                ? pushHiddenContext(workInProgress, prevState)
                : reuseHiddenContextOnStack(),
              pushOffscreenSuspenseHandler(workInProgress));
          else
            return (
              (workInProgress.lanes = workInProgress.childLanes = 536870912),
              deferHiddenOffscreenComponent(
                current,
                workInProgress,
                null !== prevState ? prevState.baseLanes | renderLanes : renderLanes,
                renderLanes
              )
            );
        } else
          null !== prevState
            ? (pushTransition(workInProgress, prevState.cachePool),
              pushHiddenContext(workInProgress, prevState),
              reuseSuspenseHandlerOnStack(workInProgress),
              (workInProgress.memoizedState = null))
            : (null !== current && pushTransition(workInProgress, null),
              reuseHiddenContextOnStack(),
              reuseSuspenseHandlerOnStack(workInProgress));
        reconcileChildren(current, workInProgress, nextChildren, renderLanes);
        return workInProgress.child;
      }
      function deferHiddenOffscreenComponent(current, workInProgress, nextBaseLanes, renderLanes) {
        var JSCompiler_inline_result = peekCacheFromPool();
        JSCompiler_inline_result =
          null === JSCompiler_inline_result
            ? null
            : { parent: CacheContext._currentValue, pool: JSCompiler_inline_result };
        workInProgress.memoizedState = {
          baseLanes: nextBaseLanes,
          cachePool: JSCompiler_inline_result,
        };
        null !== current && pushTransition(workInProgress, null);
        reuseHiddenContextOnStack();
        pushOffscreenSuspenseHandler(workInProgress);
        null !== current && propagateParentContextChanges(current, workInProgress, renderLanes, !0);
        return null;
      }
      function markRef(current, workInProgress) {
        var ref = workInProgress.ref;
        if (null === ref)
          null !== current && null !== current.ref && (workInProgress.flags |= 4194816);
        else {
          if ('function' !== typeof ref && 'object' !== typeof ref)
            throw Error(formatProdErrorMessage(284));
          if (null === current || current.ref !== ref) workInProgress.flags |= 4194816;
        }
      }
      function updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes) {
        prepareToReadContext(workInProgress);
        Component = renderWithHooks(
          current,
          workInProgress,
          Component,
          nextProps,
          void 0,
          renderLanes
        );
        nextProps = checkDidRenderIdHook();
        if (null !== current && !didReceiveUpdate)
          return (
            bailoutHooks(current, workInProgress, renderLanes),
            bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
          );
        isHydrating && nextProps && pushMaterializedTreeId(workInProgress);
        workInProgress.flags |= 1;
        reconcileChildren(current, workInProgress, Component, renderLanes);
        return workInProgress.child;
      }
      function replayFunctionComponent(
        current,
        workInProgress,
        nextProps,
        Component,
        secondArg,
        renderLanes
      ) {
        prepareToReadContext(workInProgress);
        workInProgress.updateQueue = null;
        nextProps = renderWithHooksAgain(workInProgress, Component, nextProps, secondArg);
        finishRenderingHooks(current);
        Component = checkDidRenderIdHook();
        if (null !== current && !didReceiveUpdate)
          return (
            bailoutHooks(current, workInProgress, renderLanes),
            bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
          );
        isHydrating && Component && pushMaterializedTreeId(workInProgress);
        workInProgress.flags |= 1;
        reconcileChildren(current, workInProgress, nextProps, renderLanes);
        return workInProgress.child;
      }
      function updateClassComponent(current, workInProgress, Component, nextProps, renderLanes) {
        prepareToReadContext(workInProgress);
        if (null === workInProgress.stateNode) {
          var context = emptyContextObject,
            contextType = Component.contextType;
          'object' === typeof contextType &&
            null !== contextType &&
            (context = readContext(contextType));
          context = new Component(nextProps, context);
          workInProgress.memoizedState =
            null !== context.state && void 0 !== context.state ? context.state : null;
          context.updater = classComponentUpdater;
          workInProgress.stateNode = context;
          context._reactInternals = workInProgress;
          context = workInProgress.stateNode;
          context.props = nextProps;
          context.state = workInProgress.memoizedState;
          context.refs = {};
          initializeUpdateQueue(workInProgress);
          contextType = Component.contextType;
          context.context =
            'object' === typeof contextType && null !== contextType
              ? readContext(contextType)
              : emptyContextObject;
          context.state = workInProgress.memoizedState;
          contextType = Component.getDerivedStateFromProps;
          'function' === typeof contextType &&
            (applyDerivedStateFromProps(workInProgress, Component, contextType, nextProps),
            (context.state = workInProgress.memoizedState));
          'function' === typeof Component.getDerivedStateFromProps ||
            'function' === typeof context.getSnapshotBeforeUpdate ||
            ('function' !== typeof context.UNSAFE_componentWillMount &&
              'function' !== typeof context.componentWillMount) ||
            ((contextType = context.state),
            'function' === typeof context.componentWillMount && context.componentWillMount(),
            'function' === typeof context.UNSAFE_componentWillMount &&
              context.UNSAFE_componentWillMount(),
            contextType !== context.state &&
              classComponentUpdater.enqueueReplaceState(context, context.state, null),
            processUpdateQueue(workInProgress, nextProps, context, renderLanes),
            suspendIfUpdateReadFromEntangledAsyncAction(),
            (context.state = workInProgress.memoizedState));
          'function' === typeof context.componentDidMount && (workInProgress.flags |= 4194308);
          nextProps = !0;
        } else if (null === current) {
          context = workInProgress.stateNode;
          var unresolvedOldProps = workInProgress.memoizedProps,
            oldProps = resolveClassComponentProps(Component, unresolvedOldProps);
          context.props = oldProps;
          var oldContext = context.context,
            contextType$jscomp$0 = Component.contextType;
          contextType = emptyContextObject;
          'object' === typeof contextType$jscomp$0 &&
            null !== contextType$jscomp$0 &&
            (contextType = readContext(contextType$jscomp$0));
          var getDerivedStateFromProps = Component.getDerivedStateFromProps;
          contextType$jscomp$0 =
            'function' === typeof getDerivedStateFromProps ||
            'function' === typeof context.getSnapshotBeforeUpdate;
          unresolvedOldProps = workInProgress.pendingProps !== unresolvedOldProps;
          contextType$jscomp$0 ||
            ('function' !== typeof context.UNSAFE_componentWillReceiveProps &&
              'function' !== typeof context.componentWillReceiveProps) ||
            ((unresolvedOldProps || oldContext !== contextType) &&
              callComponentWillReceiveProps(workInProgress, context, nextProps, contextType));
          hasForceUpdate = !1;
          var oldState = workInProgress.memoizedState;
          context.state = oldState;
          processUpdateQueue(workInProgress, nextProps, context, renderLanes);
          suspendIfUpdateReadFromEntangledAsyncAction();
          oldContext = workInProgress.memoizedState;
          unresolvedOldProps || oldState !== oldContext || hasForceUpdate
            ? ('function' === typeof getDerivedStateFromProps &&
                (applyDerivedStateFromProps(
                  workInProgress,
                  Component,
                  getDerivedStateFromProps,
                  nextProps
                ),
                (oldContext = workInProgress.memoizedState)),
              (oldProps =
                hasForceUpdate ||
                checkShouldComponentUpdate(
                  workInProgress,
                  Component,
                  oldProps,
                  nextProps,
                  oldState,
                  oldContext,
                  contextType
                ))
                ? (contextType$jscomp$0 ||
                    ('function' !== typeof context.UNSAFE_componentWillMount &&
                      'function' !== typeof context.componentWillMount) ||
                    ('function' === typeof context.componentWillMount &&
                      context.componentWillMount(),
                    'function' === typeof context.UNSAFE_componentWillMount &&
                      context.UNSAFE_componentWillMount()),
                  'function' === typeof context.componentDidMount &&
                    (workInProgress.flags |= 4194308))
                : ('function' === typeof context.componentDidMount &&
                    (workInProgress.flags |= 4194308),
                  (workInProgress.memoizedProps = nextProps),
                  (workInProgress.memoizedState = oldContext)),
              (context.props = nextProps),
              (context.state = oldContext),
              (context.context = contextType),
              (nextProps = oldProps))
            : ('function' === typeof context.componentDidMount && (workInProgress.flags |= 4194308),
              (nextProps = !1));
        } else {
          context = workInProgress.stateNode;
          cloneUpdateQueue(current, workInProgress);
          contextType = workInProgress.memoizedProps;
          contextType$jscomp$0 = resolveClassComponentProps(Component, contextType);
          context.props = contextType$jscomp$0;
          getDerivedStateFromProps = workInProgress.pendingProps;
          oldState = context.context;
          oldContext = Component.contextType;
          oldProps = emptyContextObject;
          'object' === typeof oldContext &&
            null !== oldContext &&
            (oldProps = readContext(oldContext));
          unresolvedOldProps = Component.getDerivedStateFromProps;
          (oldContext =
            'function' === typeof unresolvedOldProps ||
            'function' === typeof context.getSnapshotBeforeUpdate) ||
            ('function' !== typeof context.UNSAFE_componentWillReceiveProps &&
              'function' !== typeof context.componentWillReceiveProps) ||
            ((contextType !== getDerivedStateFromProps || oldState !== oldProps) &&
              callComponentWillReceiveProps(workInProgress, context, nextProps, oldProps));
          hasForceUpdate = !1;
          oldState = workInProgress.memoizedState;
          context.state = oldState;
          processUpdateQueue(workInProgress, nextProps, context, renderLanes);
          suspendIfUpdateReadFromEntangledAsyncAction();
          var newState = workInProgress.memoizedState;
          contextType !== getDerivedStateFromProps ||
          oldState !== newState ||
          hasForceUpdate ||
          (null !== current &&
            null !== current.dependencies &&
            checkIfContextChanged(current.dependencies))
            ? ('function' === typeof unresolvedOldProps &&
                (applyDerivedStateFromProps(
                  workInProgress,
                  Component,
                  unresolvedOldProps,
                  nextProps
                ),
                (newState = workInProgress.memoizedState)),
              (contextType$jscomp$0 =
                hasForceUpdate ||
                checkShouldComponentUpdate(
                  workInProgress,
                  Component,
                  contextType$jscomp$0,
                  nextProps,
                  oldState,
                  newState,
                  oldProps
                ) ||
                (null !== current &&
                  null !== current.dependencies &&
                  checkIfContextChanged(current.dependencies)))
                ? (oldContext ||
                    ('function' !== typeof context.UNSAFE_componentWillUpdate &&
                      'function' !== typeof context.componentWillUpdate) ||
                    ('function' === typeof context.componentWillUpdate &&
                      context.componentWillUpdate(nextProps, newState, oldProps),
                    'function' === typeof context.UNSAFE_componentWillUpdate &&
                      context.UNSAFE_componentWillUpdate(nextProps, newState, oldProps)),
                  'function' === typeof context.componentDidUpdate && (workInProgress.flags |= 4),
                  'function' === typeof context.getSnapshotBeforeUpdate &&
                    (workInProgress.flags |= 1024))
                : ('function' !== typeof context.componentDidUpdate ||
                    (contextType === current.memoizedProps && oldState === current.memoizedState) ||
                    (workInProgress.flags |= 4),
                  'function' !== typeof context.getSnapshotBeforeUpdate ||
                    (contextType === current.memoizedProps && oldState === current.memoizedState) ||
                    (workInProgress.flags |= 1024),
                  (workInProgress.memoizedProps = nextProps),
                  (workInProgress.memoizedState = newState)),
              (context.props = nextProps),
              (context.state = newState),
              (context.context = oldProps),
              (nextProps = contextType$jscomp$0))
            : ('function' !== typeof context.componentDidUpdate ||
                (contextType === current.memoizedProps && oldState === current.memoizedState) ||
                (workInProgress.flags |= 4),
              'function' !== typeof context.getSnapshotBeforeUpdate ||
                (contextType === current.memoizedProps && oldState === current.memoizedState) ||
                (workInProgress.flags |= 1024),
              (nextProps = !1));
        }
        context = nextProps;
        markRef(current, workInProgress);
        nextProps = 0 !== (workInProgress.flags & 128);
        context || nextProps
          ? ((context = workInProgress.stateNode),
            (Component =
              nextProps && 'function' !== typeof Component.getDerivedStateFromError
                ? null
                : context.render()),
            (workInProgress.flags |= 1),
            null !== current && nextProps
              ? ((workInProgress.child = reconcileChildFibers(
                  workInProgress,
                  current.child,
                  null,
                  renderLanes
                )),
                (workInProgress.child = reconcileChildFibers(
                  workInProgress,
                  null,
                  Component,
                  renderLanes
                )))
              : reconcileChildren(current, workInProgress, Component, renderLanes),
            (workInProgress.memoizedState = context.state),
            (current = workInProgress.child))
          : (current = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes));
        return current;
      }
      function mountHostRootWithoutHydrating(current, workInProgress, nextChildren, renderLanes) {
        resetHydrationState();
        workInProgress.flags |= 256;
        reconcileChildren(current, workInProgress, nextChildren, renderLanes);
        return workInProgress.child;
      }
      var SUSPENDED_MARKER = {
        dehydrated: null,
        treeContext: null,
        retryLane: 0,
        hydrationErrors: null,
      };
      function mountSuspenseOffscreenState(renderLanes) {
        return { baseLanes: renderLanes, cachePool: getSuspendedCache() };
      }
      function getRemainingWorkInPrimaryTree(current, primaryTreeDidDefer, renderLanes) {
        current = null !== current ? current.childLanes & ~renderLanes : 0;
        primaryTreeDidDefer && (current |= workInProgressDeferredLane);
        return current;
      }
      function updateSuspenseComponent(current, workInProgress, renderLanes) {
        var nextProps = workInProgress.pendingProps,
          showFallback = !1,
          didSuspend = 0 !== (workInProgress.flags & 128),
          JSCompiler_temp;
        (JSCompiler_temp = didSuspend) ||
          (JSCompiler_temp =
            null !== current && null === current.memoizedState
              ? !1
              : 0 !== (suspenseStackCursor.current & 2));
        JSCompiler_temp && ((showFallback = !0), (workInProgress.flags &= -129));
        JSCompiler_temp = 0 !== (workInProgress.flags & 32);
        workInProgress.flags &= -33;
        if (null === current) {
          if (isHydrating) {
            showFallback
              ? pushPrimaryTreeSuspenseHandler(workInProgress)
              : reuseSuspenseHandlerOnStack(workInProgress);
            if (isHydrating) {
              var nextInstance = nextHydratableInstance,
                JSCompiler_temp$jscomp$0;
              if ((JSCompiler_temp$jscomp$0 = nextInstance)) {
                c: {
                  JSCompiler_temp$jscomp$0 = nextInstance;
                  for (
                    nextInstance = rootOrSingletonContext;
                    8 !== JSCompiler_temp$jscomp$0.nodeType;

                  ) {
                    if (!nextInstance) {
                      nextInstance = null;
                      break c;
                    }
                    JSCompiler_temp$jscomp$0 = getNextHydratable(
                      JSCompiler_temp$jscomp$0.nextSibling
                    );
                    if (null === JSCompiler_temp$jscomp$0) {
                      nextInstance = null;
                      break c;
                    }
                  }
                  nextInstance = JSCompiler_temp$jscomp$0;
                }
                null !== nextInstance
                  ? ((workInProgress.memoizedState = {
                      dehydrated: nextInstance,
                      treeContext:
                        null !== treeContextProvider
                          ? { id: treeContextId, overflow: treeContextOverflow }
                          : null,
                      retryLane: 536870912,
                      hydrationErrors: null,
                    }),
                    (JSCompiler_temp$jscomp$0 = createFiberImplClass(18, null, null, 0)),
                    (JSCompiler_temp$jscomp$0.stateNode = nextInstance),
                    (JSCompiler_temp$jscomp$0.return = workInProgress),
                    (workInProgress.child = JSCompiler_temp$jscomp$0),
                    (hydrationParentFiber = workInProgress),
                    (nextHydratableInstance = null),
                    (JSCompiler_temp$jscomp$0 = !0))
                  : (JSCompiler_temp$jscomp$0 = !1);
              }
              JSCompiler_temp$jscomp$0 || throwOnHydrationMismatch(workInProgress);
            }
            nextInstance = workInProgress.memoizedState;
            if (
              null !== nextInstance &&
              ((nextInstance = nextInstance.dehydrated), null !== nextInstance)
            )
              return (
                isSuspenseInstanceFallback(nextInstance)
                  ? (workInProgress.lanes = 32)
                  : (workInProgress.lanes = 536870912),
                null
              );
            popSuspenseHandler(workInProgress);
          }
          nextInstance = nextProps.children;
          nextProps = nextProps.fallback;
          if (showFallback)
            return (
              reuseSuspenseHandlerOnStack(workInProgress),
              (showFallback = workInProgress.mode),
              (nextInstance = mountWorkInProgressOffscreenFiber(
                { mode: 'hidden', children: nextInstance },
                showFallback
              )),
              (nextProps = createFiberFromFragment(nextProps, showFallback, renderLanes, null)),
              (nextInstance.return = workInProgress),
              (nextProps.return = workInProgress),
              (nextInstance.sibling = nextProps),
              (workInProgress.child = nextInstance),
              (showFallback = workInProgress.child),
              (showFallback.memoizedState = mountSuspenseOffscreenState(renderLanes)),
              (showFallback.childLanes = getRemainingWorkInPrimaryTree(
                current,
                JSCompiler_temp,
                renderLanes
              )),
              (workInProgress.memoizedState = SUSPENDED_MARKER),
              nextProps
            );
          pushPrimaryTreeSuspenseHandler(workInProgress);
          return mountSuspensePrimaryChildren(workInProgress, nextInstance);
        }
        JSCompiler_temp$jscomp$0 = current.memoizedState;
        if (
          null !== JSCompiler_temp$jscomp$0 &&
          ((nextInstance = JSCompiler_temp$jscomp$0.dehydrated), null !== nextInstance)
        ) {
          if (didSuspend)
            workInProgress.flags & 256
              ? (pushPrimaryTreeSuspenseHandler(workInProgress),
                (workInProgress.flags &= -257),
                (workInProgress = retrySuspenseComponentWithoutHydrating(
                  current,
                  workInProgress,
                  renderLanes
                )))
              : null !== workInProgress.memoizedState
                ? (reuseSuspenseHandlerOnStack(workInProgress),
                  (workInProgress.child = current.child),
                  (workInProgress.flags |= 128),
                  (workInProgress = null))
                : (reuseSuspenseHandlerOnStack(workInProgress),
                  (showFallback = nextProps.fallback),
                  (nextInstance = workInProgress.mode),
                  (nextProps = mountWorkInProgressOffscreenFiber(
                    { mode: 'visible', children: nextProps.children },
                    nextInstance
                  )),
                  (showFallback = createFiberFromFragment(
                    showFallback,
                    nextInstance,
                    renderLanes,
                    null
                  )),
                  (showFallback.flags |= 2),
                  (nextProps.return = workInProgress),
                  (showFallback.return = workInProgress),
                  (nextProps.sibling = showFallback),
                  (workInProgress.child = nextProps),
                  reconcileChildFibers(workInProgress, current.child, null, renderLanes),
                  (nextProps = workInProgress.child),
                  (nextProps.memoizedState = mountSuspenseOffscreenState(renderLanes)),
                  (nextProps.childLanes = getRemainingWorkInPrimaryTree(
                    current,
                    JSCompiler_temp,
                    renderLanes
                  )),
                  (workInProgress.memoizedState = SUSPENDED_MARKER),
                  (workInProgress = showFallback));
          else if (
            (pushPrimaryTreeSuspenseHandler(workInProgress),
            isSuspenseInstanceFallback(nextInstance))
          ) {
            JSCompiler_temp = nextInstance.nextSibling && nextInstance.nextSibling.dataset;
            if (JSCompiler_temp) var digest = JSCompiler_temp.dgst;
            JSCompiler_temp = digest;
            nextProps = Error(formatProdErrorMessage(419));
            nextProps.stack = '';
            nextProps.digest = JSCompiler_temp;
            queueHydrationError({ value: nextProps, source: null, stack: null });
            workInProgress = retrySuspenseComponentWithoutHydrating(
              current,
              workInProgress,
              renderLanes
            );
          } else if (
            (didReceiveUpdate ||
              propagateParentContextChanges(current, workInProgress, renderLanes, !1),
            (JSCompiler_temp = 0 !== (renderLanes & current.childLanes)),
            didReceiveUpdate || JSCompiler_temp)
          ) {
            JSCompiler_temp = workInProgressRoot;
            if (
              null !== JSCompiler_temp &&
              ((nextProps = renderLanes & -renderLanes),
              (nextProps = 0 !== (nextProps & 42) ? 1 : getBumpedLaneForHydrationByLane(nextProps)),
              (nextProps =
                0 !== (nextProps & (JSCompiler_temp.suspendedLanes | renderLanes)) ? 0 : nextProps),
              0 !== nextProps && nextProps !== JSCompiler_temp$jscomp$0.retryLane)
            )
              throw (
                (JSCompiler_temp$jscomp$0.retryLane = nextProps),
                enqueueConcurrentRenderForLane(current, nextProps),
                scheduleUpdateOnFiber(JSCompiler_temp, current, nextProps),
                SelectiveHydrationException
              );
            '$?' === nextInstance.data || renderDidSuspendDelayIfPossible();
            workInProgress = retrySuspenseComponentWithoutHydrating(
              current,
              workInProgress,
              renderLanes
            );
          } else
            '$?' === nextInstance.data
              ? ((workInProgress.flags |= 192),
                (workInProgress.child = current.child),
                (workInProgress = null))
              : ((current = JSCompiler_temp$jscomp$0.treeContext),
                (nextHydratableInstance = getNextHydratable(nextInstance.nextSibling)),
                (hydrationParentFiber = workInProgress),
                (isHydrating = !0),
                (hydrationErrors = null),
                (rootOrSingletonContext = !1),
                null !== current &&
                  ((idStack[idStackIndex++] = treeContextId),
                  (idStack[idStackIndex++] = treeContextOverflow),
                  (idStack[idStackIndex++] = treeContextProvider),
                  (treeContextId = current.id),
                  (treeContextOverflow = current.overflow),
                  (treeContextProvider = workInProgress)),
                (workInProgress = mountSuspensePrimaryChildren(workInProgress, nextProps.children)),
                (workInProgress.flags |= 4096));
          return workInProgress;
        }
        if (showFallback)
          return (
            reuseSuspenseHandlerOnStack(workInProgress),
            (showFallback = nextProps.fallback),
            (nextInstance = workInProgress.mode),
            (JSCompiler_temp$jscomp$0 = current.child),
            (digest = JSCompiler_temp$jscomp$0.sibling),
            (nextProps = createWorkInProgress(JSCompiler_temp$jscomp$0, {
              mode: 'hidden',
              children: nextProps.children,
            })),
            (nextProps.subtreeFlags = JSCompiler_temp$jscomp$0.subtreeFlags & 65011712),
            null !== digest
              ? (showFallback = createWorkInProgress(digest, showFallback))
              : ((showFallback = createFiberFromFragment(
                  showFallback,
                  nextInstance,
                  renderLanes,
                  null
                )),
                (showFallback.flags |= 2)),
            (showFallback.return = workInProgress),
            (nextProps.return = workInProgress),
            (nextProps.sibling = showFallback),
            (workInProgress.child = nextProps),
            (nextProps = showFallback),
            (showFallback = workInProgress.child),
            (nextInstance = current.child.memoizedState),
            null === nextInstance
              ? (nextInstance = mountSuspenseOffscreenState(renderLanes))
              : ((JSCompiler_temp$jscomp$0 = nextInstance.cachePool),
                null !== JSCompiler_temp$jscomp$0
                  ? ((digest = CacheContext._currentValue),
                    (JSCompiler_temp$jscomp$0 =
                      JSCompiler_temp$jscomp$0.parent !== digest
                        ? { parent: digest, pool: digest }
                        : JSCompiler_temp$jscomp$0))
                  : (JSCompiler_temp$jscomp$0 = getSuspendedCache()),
                (nextInstance = {
                  baseLanes: nextInstance.baseLanes | renderLanes,
                  cachePool: JSCompiler_temp$jscomp$0,
                })),
            (showFallback.memoizedState = nextInstance),
            (showFallback.childLanes = getRemainingWorkInPrimaryTree(
              current,
              JSCompiler_temp,
              renderLanes
            )),
            (workInProgress.memoizedState = SUSPENDED_MARKER),
            nextProps
          );
        pushPrimaryTreeSuspenseHandler(workInProgress);
        renderLanes = current.child;
        current = renderLanes.sibling;
        renderLanes = createWorkInProgress(renderLanes, {
          mode: 'visible',
          children: nextProps.children,
        });
        renderLanes.return = workInProgress;
        renderLanes.sibling = null;
        null !== current &&
          ((JSCompiler_temp = workInProgress.deletions),
          null === JSCompiler_temp
            ? ((workInProgress.deletions = [current]), (workInProgress.flags |= 16))
            : JSCompiler_temp.push(current));
        workInProgress.child = renderLanes;
        workInProgress.memoizedState = null;
        return renderLanes;
      }
      function mountSuspensePrimaryChildren(workInProgress, primaryChildren) {
        primaryChildren = mountWorkInProgressOffscreenFiber(
          { mode: 'visible', children: primaryChildren },
          workInProgress.mode
        );
        primaryChildren.return = workInProgress;
        return (workInProgress.child = primaryChildren);
      }
      function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
        offscreenProps = createFiberImplClass(22, offscreenProps, null, mode);
        offscreenProps.lanes = 0;
        offscreenProps.stateNode = {
          _visibility: 1,
          _pendingMarkers: null,
          _retryCache: null,
          _transitions: null,
        };
        return offscreenProps;
      }
      function retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes) {
        reconcileChildFibers(workInProgress, current.child, null, renderLanes);
        current = mountSuspensePrimaryChildren(
          workInProgress,
          workInProgress.pendingProps.children
        );
        current.flags |= 2;
        workInProgress.memoizedState = null;
        return current;
      }
      function scheduleSuspenseWorkOnFiber(fiber, renderLanes, propagationRoot) {
        fiber.lanes |= renderLanes;
        var alternate = fiber.alternate;
        null !== alternate && (alternate.lanes |= renderLanes);
        scheduleContextWorkOnParentPath(fiber.return, renderLanes, propagationRoot);
      }
      function initSuspenseListRenderState(
        workInProgress,
        isBackwards,
        tail,
        lastContentRow,
        tailMode
      ) {
        var renderState = workInProgress.memoizedState;
        null === renderState
          ? (workInProgress.memoizedState = {
              isBackwards: isBackwards,
              rendering: null,
              renderingStartTime: 0,
              last: lastContentRow,
              tail: tail,
              tailMode: tailMode,
            })
          : ((renderState.isBackwards = isBackwards),
            (renderState.rendering = null),
            (renderState.renderingStartTime = 0),
            (renderState.last = lastContentRow),
            (renderState.tail = tail),
            (renderState.tailMode = tailMode));
      }
      function updateSuspenseListComponent(current, workInProgress, renderLanes) {
        var nextProps = workInProgress.pendingProps,
          revealOrder = nextProps.revealOrder,
          tailMode = nextProps.tail;
        reconcileChildren(current, workInProgress, nextProps.children, renderLanes);
        nextProps = suspenseStackCursor.current;
        if (0 !== (nextProps & 2))
          ((nextProps = (nextProps & 1) | 2), (workInProgress.flags |= 128));
        else {
          if (null !== current && 0 !== (current.flags & 128))
            a: for (current = workInProgress.child; null !== current; ) {
              if (13 === current.tag)
                null !== current.memoizedState &&
                  scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);
              else if (19 === current.tag)
                scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);
              else if (null !== current.child) {
                current.child.return = current;
                current = current.child;
                continue;
              }
              if (current === workInProgress) break a;
              for (; null === current.sibling; ) {
                if (null === current.return || current.return === workInProgress) break a;
                current = current.return;
              }
              current.sibling.return = current.return;
              current = current.sibling;
            }
          nextProps &= 1;
        }
        push(suspenseStackCursor, nextProps);
        switch (revealOrder) {
          case 'forwards':
            renderLanes = workInProgress.child;
            for (revealOrder = null; null !== renderLanes; )
              ((current = renderLanes.alternate),
                null !== current &&
                  null === findFirstSuspended(current) &&
                  (revealOrder = renderLanes),
                (renderLanes = renderLanes.sibling));
            renderLanes = revealOrder;
            null === renderLanes
              ? ((revealOrder = workInProgress.child), (workInProgress.child = null))
              : ((revealOrder = renderLanes.sibling), (renderLanes.sibling = null));
            initSuspenseListRenderState(workInProgress, !1, revealOrder, renderLanes, tailMode);
            break;
          case 'backwards':
            renderLanes = null;
            revealOrder = workInProgress.child;
            for (workInProgress.child = null; null !== revealOrder; ) {
              current = revealOrder.alternate;
              if (null !== current && null === findFirstSuspended(current)) {
                workInProgress.child = revealOrder;
                break;
              }
              current = revealOrder.sibling;
              revealOrder.sibling = renderLanes;
              renderLanes = revealOrder;
              revealOrder = current;
            }
            initSuspenseListRenderState(workInProgress, !0, renderLanes, null, tailMode);
            break;
          case 'together':
            initSuspenseListRenderState(workInProgress, !1, null, null, void 0);
            break;
          default:
            workInProgress.memoizedState = null;
        }
        return workInProgress.child;
      }
      function bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {
        null !== current && (workInProgress.dependencies = current.dependencies);
        workInProgressRootSkippedLanes |= workInProgress.lanes;
        if (0 === (renderLanes & workInProgress.childLanes))
          if (null !== current) {
            if (
              (propagateParentContextChanges(current, workInProgress, renderLanes, !1),
              0 === (renderLanes & workInProgress.childLanes))
            )
              return null;
          } else return null;
        if (null !== current && workInProgress.child !== current.child)
          throw Error(formatProdErrorMessage(153));
        if (null !== workInProgress.child) {
          current = workInProgress.child;
          renderLanes = createWorkInProgress(current, current.pendingProps);
          workInProgress.child = renderLanes;
          for (renderLanes.return = workInProgress; null !== current.sibling; )
            ((current = current.sibling),
              (renderLanes = renderLanes.sibling =
                createWorkInProgress(current, current.pendingProps)),
              (renderLanes.return = workInProgress));
          renderLanes.sibling = null;
        }
        return workInProgress.child;
      }
      function checkScheduledUpdateOrContext(current, renderLanes) {
        if (0 !== (current.lanes & renderLanes)) return !0;
        current = current.dependencies;
        return null !== current && checkIfContextChanged(current) ? !0 : !1;
      }
      function attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes) {
        switch (workInProgress.tag) {
          case 3:
            pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
            pushProvider(workInProgress, CacheContext, current.memoizedState.cache);
            resetHydrationState();
            break;
          case 27:
          case 5:
            pushHostContext(workInProgress);
            break;
          case 4:
            pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
            break;
          case 10:
            pushProvider(workInProgress, workInProgress.type, workInProgress.memoizedProps.value);
            break;
          case 13:
            var state = workInProgress.memoizedState;
            if (null !== state) {
              if (null !== state.dehydrated)
                return (
                  pushPrimaryTreeSuspenseHandler(workInProgress),
                  (workInProgress.flags |= 128),
                  null
                );
              if (0 !== (renderLanes & workInProgress.child.childLanes))
                return updateSuspenseComponent(current, workInProgress, renderLanes);
              pushPrimaryTreeSuspenseHandler(workInProgress);
              current = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
              return null !== current ? current.sibling : null;
            }
            pushPrimaryTreeSuspenseHandler(workInProgress);
            break;
          case 19:
            var didSuspendBefore = 0 !== (current.flags & 128);
            state = 0 !== (renderLanes & workInProgress.childLanes);
            state ||
              (propagateParentContextChanges(current, workInProgress, renderLanes, !1),
              (state = 0 !== (renderLanes & workInProgress.childLanes)));
            if (didSuspendBefore) {
              if (state) return updateSuspenseListComponent(current, workInProgress, renderLanes);
              workInProgress.flags |= 128;
            }
            didSuspendBefore = workInProgress.memoizedState;
            null !== didSuspendBefore &&
              ((didSuspendBefore.rendering = null),
              (didSuspendBefore.tail = null),
              (didSuspendBefore.lastEffect = null));
            push(suspenseStackCursor, suspenseStackCursor.current);
            if (state) break;
            else return null;
          case 22:
          case 23:
            return (
              (workInProgress.lanes = 0),
              updateOffscreenComponent(current, workInProgress, renderLanes)
            );
          case 24:
            pushProvider(workInProgress, CacheContext, current.memoizedState.cache);
        }
        return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
      }
      function beginWork(current, workInProgress, renderLanes) {
        if (null !== current)
          if (current.memoizedProps !== workInProgress.pendingProps) didReceiveUpdate = !0;
          else {
            if (
              !checkScheduledUpdateOrContext(current, renderLanes) &&
              0 === (workInProgress.flags & 128)
            )
              return (
                (didReceiveUpdate = !1),
                attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes)
              );
            didReceiveUpdate = 0 !== (current.flags & 131072) ? !0 : !1;
          }
        else
          ((didReceiveUpdate = !1),
            isHydrating &&
              0 !== (workInProgress.flags & 1048576) &&
              pushTreeId(workInProgress, treeForkCount, workInProgress.index));
        workInProgress.lanes = 0;
        switch (workInProgress.tag) {
          case 16:
            a: {
              current = workInProgress.pendingProps;
              var lazyComponent = workInProgress.elementType,
                init = lazyComponent._init;
              lazyComponent = init(lazyComponent._payload);
              workInProgress.type = lazyComponent;
              if ('function' === typeof lazyComponent)
                shouldConstruct(lazyComponent)
                  ? ((current = resolveClassComponentProps(lazyComponent, current)),
                    (workInProgress.tag = 1),
                    (workInProgress = updateClassComponent(
                      null,
                      workInProgress,
                      lazyComponent,
                      current,
                      renderLanes
                    )))
                  : ((workInProgress.tag = 0),
                    (workInProgress = updateFunctionComponent(
                      null,
                      workInProgress,
                      lazyComponent,
                      current,
                      renderLanes
                    )));
              else {
                if (void 0 !== lazyComponent && null !== lazyComponent)
                  if (((init = lazyComponent.$$typeof), init === REACT_FORWARD_REF_TYPE)) {
                    workInProgress.tag = 11;
                    workInProgress = updateForwardRef(
                      null,
                      workInProgress,
                      lazyComponent,
                      current,
                      renderLanes
                    );
                    break a;
                  } else if (init === REACT_MEMO_TYPE) {
                    workInProgress.tag = 14;
                    workInProgress = updateMemoComponent(
                      null,
                      workInProgress,
                      lazyComponent,
                      current,
                      renderLanes
                    );
                    break a;
                  }
                workInProgress = getComponentNameFromType(lazyComponent) || lazyComponent;
                throw Error(formatProdErrorMessage(306, workInProgress, ''));
              }
            }
            return workInProgress;
          case 0:
            return updateFunctionComponent(
              current,
              workInProgress,
              workInProgress.type,
              workInProgress.pendingProps,
              renderLanes
            );
          case 1:
            return (
              (lazyComponent = workInProgress.type),
              (init = resolveClassComponentProps(lazyComponent, workInProgress.pendingProps)),
              updateClassComponent(current, workInProgress, lazyComponent, init, renderLanes)
            );
          case 3:
            a: {
              pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
              if (null === current) throw Error(formatProdErrorMessage(387));
              lazyComponent = workInProgress.pendingProps;
              var prevState = workInProgress.memoizedState;
              init = prevState.element;
              cloneUpdateQueue(current, workInProgress);
              processUpdateQueue(workInProgress, lazyComponent, null, renderLanes);
              var nextState = workInProgress.memoizedState;
              lazyComponent = nextState.cache;
              pushProvider(workInProgress, CacheContext, lazyComponent);
              lazyComponent !== prevState.cache &&
                propagateContextChanges(workInProgress, [CacheContext], renderLanes, !0);
              suspendIfUpdateReadFromEntangledAsyncAction();
              lazyComponent = nextState.element;
              if (prevState.isDehydrated)
                if (
                  ((prevState = {
                    element: lazyComponent,
                    isDehydrated: !1,
                    cache: nextState.cache,
                  }),
                  (workInProgress.updateQueue.baseState = prevState),
                  (workInProgress.memoizedState = prevState),
                  workInProgress.flags & 256)
                ) {
                  workInProgress = mountHostRootWithoutHydrating(
                    current,
                    workInProgress,
                    lazyComponent,
                    renderLanes
                  );
                  break a;
                } else if (lazyComponent !== init) {
                  init = createCapturedValueAtFiber(
                    Error(formatProdErrorMessage(424)),
                    workInProgress
                  );
                  queueHydrationError(init);
                  workInProgress = mountHostRootWithoutHydrating(
                    current,
                    workInProgress,
                    lazyComponent,
                    renderLanes
                  );
                  break a;
                } else {
                  current = workInProgress.stateNode.containerInfo;
                  switch (current.nodeType) {
                    case 9:
                      current = current.body;
                      break;
                    default:
                      current = 'HTML' === current.nodeName ? current.ownerDocument.body : current;
                  }
                  nextHydratableInstance = getNextHydratable(current.firstChild);
                  hydrationParentFiber = workInProgress;
                  isHydrating = !0;
                  hydrationErrors = null;
                  rootOrSingletonContext = !0;
                  renderLanes = mountChildFibers(workInProgress, null, lazyComponent, renderLanes);
                  for (workInProgress.child = renderLanes; renderLanes; )
                    ((renderLanes.flags = (renderLanes.flags & -3) | 4096),
                      (renderLanes = renderLanes.sibling));
                }
              else {
                resetHydrationState();
                if (lazyComponent === init) {
                  workInProgress = bailoutOnAlreadyFinishedWork(
                    current,
                    workInProgress,
                    renderLanes
                  );
                  break a;
                }
                reconcileChildren(current, workInProgress, lazyComponent, renderLanes);
              }
              workInProgress = workInProgress.child;
            }
            return workInProgress;
          case 26:
            return (
              markRef(current, workInProgress),
              null === current
                ? (renderLanes = getResource(
                    workInProgress.type,
                    null,
                    workInProgress.pendingProps,
                    null
                  ))
                  ? (workInProgress.memoizedState = renderLanes)
                  : isHydrating ||
                    ((renderLanes = workInProgress.type),
                    (current = workInProgress.pendingProps),
                    (lazyComponent = getOwnerDocumentFromRootContainer(
                      rootInstanceStackCursor.current
                    ).createElement(renderLanes)),
                    (lazyComponent[internalInstanceKey] = workInProgress),
                    (lazyComponent[internalPropsKey] = current),
                    setInitialProperties(lazyComponent, renderLanes, current),
                    markNodeAsHoistable(lazyComponent),
                    (workInProgress.stateNode = lazyComponent))
                : (workInProgress.memoizedState = getResource(
                    workInProgress.type,
                    current.memoizedProps,
                    workInProgress.pendingProps,
                    current.memoizedState
                  )),
              null
            );
          case 27:
            return (
              pushHostContext(workInProgress),
              null === current &&
                isHydrating &&
                ((lazyComponent = workInProgress.stateNode =
                  resolveSingletonInstance(
                    workInProgress.type,
                    workInProgress.pendingProps,
                    rootInstanceStackCursor.current
                  )),
                (hydrationParentFiber = workInProgress),
                (rootOrSingletonContext = !0),
                (init = nextHydratableInstance),
                isSingletonScope(workInProgress.type)
                  ? ((previousHydratableOnEnteringScopedSingleton = init),
                    (nextHydratableInstance = getNextHydratable(lazyComponent.firstChild)))
                  : (nextHydratableInstance = init)),
              reconcileChildren(
                current,
                workInProgress,
                workInProgress.pendingProps.children,
                renderLanes
              ),
              markRef(current, workInProgress),
              null === current && (workInProgress.flags |= 4194304),
              workInProgress.child
            );
          case 5:
            if (null === current && isHydrating) {
              if ((init = lazyComponent = nextHydratableInstance))
                ((lazyComponent = canHydrateInstance(
                  lazyComponent,
                  workInProgress.type,
                  workInProgress.pendingProps,
                  rootOrSingletonContext
                )),
                  null !== lazyComponent
                    ? ((workInProgress.stateNode = lazyComponent),
                      (hydrationParentFiber = workInProgress),
                      (nextHydratableInstance = getNextHydratable(lazyComponent.firstChild)),
                      (rootOrSingletonContext = !1),
                      (init = !0))
                    : (init = !1));
              init || throwOnHydrationMismatch(workInProgress);
            }
            pushHostContext(workInProgress);
            init = workInProgress.type;
            prevState = workInProgress.pendingProps;
            nextState = null !== current ? current.memoizedProps : null;
            lazyComponent = prevState.children;
            shouldSetTextContent(init, prevState)
              ? (lazyComponent = null)
              : null !== nextState &&
                shouldSetTextContent(init, nextState) &&
                (workInProgress.flags |= 32);
            null !== workInProgress.memoizedState &&
              ((init = renderWithHooks(
                current,
                workInProgress,
                TransitionAwareHostComponent,
                null,
                null,
                renderLanes
              )),
              (HostTransitionContext._currentValue = init));
            markRef(current, workInProgress);
            reconcileChildren(current, workInProgress, lazyComponent, renderLanes);
            return workInProgress.child;
          case 6:
            if (null === current && isHydrating) {
              if ((current = renderLanes = nextHydratableInstance))
                ((renderLanes = canHydrateTextInstance(
                  renderLanes,
                  workInProgress.pendingProps,
                  rootOrSingletonContext
                )),
                  null !== renderLanes
                    ? ((workInProgress.stateNode = renderLanes),
                      (hydrationParentFiber = workInProgress),
                      (nextHydratableInstance = null),
                      (current = !0))
                    : (current = !1));
              current || throwOnHydrationMismatch(workInProgress);
            }
            return null;
          case 13:
            return updateSuspenseComponent(current, workInProgress, renderLanes);
          case 4:
            return (
              pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo),
              (lazyComponent = workInProgress.pendingProps),
              null === current
                ? (workInProgress.child = reconcileChildFibers(
                    workInProgress,
                    null,
                    lazyComponent,
                    renderLanes
                  ))
                : reconcileChildren(current, workInProgress, lazyComponent, renderLanes),
              workInProgress.child
            );
          case 11:
            return updateForwardRef(
              current,
              workInProgress,
              workInProgress.type,
              workInProgress.pendingProps,
              renderLanes
            );
          case 7:
            return (
              reconcileChildren(current, workInProgress, workInProgress.pendingProps, renderLanes),
              workInProgress.child
            );
          case 8:
            return (
              reconcileChildren(
                current,
                workInProgress,
                workInProgress.pendingProps.children,
                renderLanes
              ),
              workInProgress.child
            );
          case 12:
            return (
              reconcileChildren(
                current,
                workInProgress,
                workInProgress.pendingProps.children,
                renderLanes
              ),
              workInProgress.child
            );
          case 10:
            return (
              (lazyComponent = workInProgress.pendingProps),
              pushProvider(workInProgress, workInProgress.type, lazyComponent.value),
              reconcileChildren(current, workInProgress, lazyComponent.children, renderLanes),
              workInProgress.child
            );
          case 9:
            return (
              (init = workInProgress.type._context),
              (lazyComponent = workInProgress.pendingProps.children),
              prepareToReadContext(workInProgress),
              (init = readContext(init)),
              (lazyComponent = lazyComponent(init)),
              (workInProgress.flags |= 1),
              reconcileChildren(current, workInProgress, lazyComponent, renderLanes),
              workInProgress.child
            );
          case 14:
            return updateMemoComponent(
              current,
              workInProgress,
              workInProgress.type,
              workInProgress.pendingProps,
              renderLanes
            );
          case 15:
            return updateSimpleMemoComponent(
              current,
              workInProgress,
              workInProgress.type,
              workInProgress.pendingProps,
              renderLanes
            );
          case 19:
            return updateSuspenseListComponent(current, workInProgress, renderLanes);
          case 31:
            return (
              (lazyComponent = workInProgress.pendingProps),
              (renderLanes = workInProgress.mode),
              (lazyComponent = {
                mode: lazyComponent.mode,
                children: lazyComponent.children,
              }),
              null === current
                ? ((renderLanes = mountWorkInProgressOffscreenFiber(lazyComponent, renderLanes)),
                  (renderLanes.ref = workInProgress.ref),
                  (workInProgress.child = renderLanes),
                  (renderLanes.return = workInProgress),
                  (workInProgress = renderLanes))
                : ((renderLanes = createWorkInProgress(current.child, lazyComponent)),
                  (renderLanes.ref = workInProgress.ref),
                  (workInProgress.child = renderLanes),
                  (renderLanes.return = workInProgress),
                  (workInProgress = renderLanes)),
              workInProgress
            );
          case 22:
            return updateOffscreenComponent(current, workInProgress, renderLanes);
          case 24:
            return (
              prepareToReadContext(workInProgress),
              (lazyComponent = readContext(CacheContext)),
              null === current
                ? ((init = peekCacheFromPool()),
                  null === init &&
                    ((init = workInProgressRoot),
                    (prevState = createCache()),
                    (init.pooledCache = prevState),
                    prevState.refCount++,
                    null !== prevState && (init.pooledCacheLanes |= renderLanes),
                    (init = prevState)),
                  (workInProgress.memoizedState = {
                    parent: lazyComponent,
                    cache: init,
                  }),
                  initializeUpdateQueue(workInProgress),
                  pushProvider(workInProgress, CacheContext, init))
                : (0 !== (current.lanes & renderLanes) &&
                    (cloneUpdateQueue(current, workInProgress),
                    processUpdateQueue(workInProgress, null, null, renderLanes),
                    suspendIfUpdateReadFromEntangledAsyncAction()),
                  (init = current.memoizedState),
                  (prevState = workInProgress.memoizedState),
                  init.parent !== lazyComponent
                    ? ((init = { parent: lazyComponent, cache: lazyComponent }),
                      (workInProgress.memoizedState = init),
                      0 === workInProgress.lanes &&
                        (workInProgress.memoizedState = workInProgress.updateQueue.baseState =
                          init),
                      pushProvider(workInProgress, CacheContext, lazyComponent))
                    : ((lazyComponent = prevState.cache),
                      pushProvider(workInProgress, CacheContext, lazyComponent),
                      lazyComponent !== init.cache &&
                        propagateContextChanges(workInProgress, [CacheContext], renderLanes, !0))),
              reconcileChildren(
                current,
                workInProgress,
                workInProgress.pendingProps.children,
                renderLanes
              ),
              workInProgress.child
            );
          case 29:
            throw workInProgress.pendingProps;
        }
        throw Error(formatProdErrorMessage(156, workInProgress.tag));
      }
      function markUpdate(workInProgress) {
        workInProgress.flags |= 4;
      }
      function preloadResourceAndSuspendIfNeeded(workInProgress, resource) {
        if ('stylesheet' !== resource.type || 0 !== (resource.state.loading & 4))
          workInProgress.flags &= -16777217;
        else if (((workInProgress.flags |= 16777216), !preloadResource(resource))) {
          resource = suspenseHandlerStackCursor.current;
          if (
            null !== resource &&
            ((workInProgressRootRenderLanes & 4194048) === workInProgressRootRenderLanes
              ? null !== shellBoundary
              : ((workInProgressRootRenderLanes & 62914560) !== workInProgressRootRenderLanes &&
                  0 === (workInProgressRootRenderLanes & 536870912)) ||
                resource !== shellBoundary)
          )
            throw ((suspendedThenable = noopSuspenseyCommitThenable), SuspenseyCommitException);
          workInProgress.flags |= 8192;
        }
      }
      function scheduleRetryEffect(workInProgress, retryQueue) {
        null !== retryQueue && (workInProgress.flags |= 4);
        workInProgress.flags & 16384 &&
          ((retryQueue = 22 !== workInProgress.tag ? claimNextRetryLane() : 536870912),
          (workInProgress.lanes |= retryQueue),
          (workInProgressSuspendedRetryLanes |= retryQueue));
      }
      function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
        if (!isHydrating)
          switch (renderState.tailMode) {
            case 'hidden':
              hasRenderedATailFallback = renderState.tail;
              for (var lastTailNode = null; null !== hasRenderedATailFallback; )
                (null !== hasRenderedATailFallback.alternate &&
                  (lastTailNode = hasRenderedATailFallback),
                  (hasRenderedATailFallback = hasRenderedATailFallback.sibling));
              null === lastTailNode ? (renderState.tail = null) : (lastTailNode.sibling = null);
              break;
            case 'collapsed':
              lastTailNode = renderState.tail;
              for (var lastTailNode$113 = null; null !== lastTailNode; )
                (null !== lastTailNode.alternate && (lastTailNode$113 = lastTailNode),
                  (lastTailNode = lastTailNode.sibling));
              null === lastTailNode$113
                ? hasRenderedATailFallback || null === renderState.tail
                  ? (renderState.tail = null)
                  : (renderState.tail.sibling = null)
                : (lastTailNode$113.sibling = null);
          }
      }
      function bubbleProperties(completedWork) {
        var didBailout =
            null !== completedWork.alternate &&
            completedWork.alternate.child === completedWork.child,
          newChildLanes = 0,
          subtreeFlags = 0;
        if (didBailout)
          for (var child$114 = completedWork.child; null !== child$114; )
            ((newChildLanes |= child$114.lanes | child$114.childLanes),
              (subtreeFlags |= child$114.subtreeFlags & 65011712),
              (subtreeFlags |= child$114.flags & 65011712),
              (child$114.return = completedWork),
              (child$114 = child$114.sibling));
        else
          for (child$114 = completedWork.child; null !== child$114; )
            ((newChildLanes |= child$114.lanes | child$114.childLanes),
              (subtreeFlags |= child$114.subtreeFlags),
              (subtreeFlags |= child$114.flags),
              (child$114.return = completedWork),
              (child$114 = child$114.sibling));
        completedWork.subtreeFlags |= subtreeFlags;
        completedWork.childLanes = newChildLanes;
        return didBailout;
      }
      function completeWork(current, workInProgress, renderLanes) {
        var newProps = workInProgress.pendingProps;
        popTreeContext(workInProgress);
        switch (workInProgress.tag) {
          case 31:
          case 16:
          case 15:
          case 0:
          case 11:
          case 7:
          case 8:
          case 12:
          case 9:
          case 14:
            return (bubbleProperties(workInProgress), null);
          case 1:
            return (bubbleProperties(workInProgress), null);
          case 3:
            renderLanes = workInProgress.stateNode;
            newProps = null;
            null !== current && (newProps = current.memoizedState.cache);
            workInProgress.memoizedState.cache !== newProps && (workInProgress.flags |= 2048);
            popProvider(CacheContext);
            popHostContainer();
            renderLanes.pendingContext &&
              ((renderLanes.context = renderLanes.pendingContext),
              (renderLanes.pendingContext = null));
            if (null === current || null === current.child)
              popHydrationState(workInProgress)
                ? markUpdate(workInProgress)
                : null === current ||
                  (current.memoizedState.isDehydrated && 0 === (workInProgress.flags & 256)) ||
                  ((workInProgress.flags |= 1024), upgradeHydrationErrorsToRecoverable());
            bubbleProperties(workInProgress);
            return null;
          case 26:
            return (
              (renderLanes = workInProgress.memoizedState),
              null === current
                ? (markUpdate(workInProgress),
                  null !== renderLanes
                    ? (bubbleProperties(workInProgress),
                      preloadResourceAndSuspendIfNeeded(workInProgress, renderLanes))
                    : (bubbleProperties(workInProgress), (workInProgress.flags &= -16777217)))
                : renderLanes
                  ? renderLanes !== current.memoizedState
                    ? (markUpdate(workInProgress),
                      bubbleProperties(workInProgress),
                      preloadResourceAndSuspendIfNeeded(workInProgress, renderLanes))
                    : (bubbleProperties(workInProgress), (workInProgress.flags &= -16777217))
                  : (current.memoizedProps !== newProps && markUpdate(workInProgress),
                    bubbleProperties(workInProgress),
                    (workInProgress.flags &= -16777217)),
              null
            );
          case 27:
            popHostContext(workInProgress);
            renderLanes = rootInstanceStackCursor.current;
            var type = workInProgress.type;
            if (null !== current && null != workInProgress.stateNode)
              current.memoizedProps !== newProps && markUpdate(workInProgress);
            else {
              if (!newProps) {
                if (null === workInProgress.stateNode) throw Error(formatProdErrorMessage(166));
                bubbleProperties(workInProgress);
                return null;
              }
              current = contextStackCursor.current;
              popHydrationState(workInProgress)
                ? prepareToHydrateHostInstance(workInProgress, current)
                : ((current = resolveSingletonInstance(type, newProps, renderLanes)),
                  (workInProgress.stateNode = current),
                  markUpdate(workInProgress));
            }
            bubbleProperties(workInProgress);
            return null;
          case 5:
            popHostContext(workInProgress);
            renderLanes = workInProgress.type;
            if (null !== current && null != workInProgress.stateNode)
              current.memoizedProps !== newProps && markUpdate(workInProgress);
            else {
              if (!newProps) {
                if (null === workInProgress.stateNode) throw Error(formatProdErrorMessage(166));
                bubbleProperties(workInProgress);
                return null;
              }
              current = contextStackCursor.current;
              if (popHydrationState(workInProgress))
                prepareToHydrateHostInstance(workInProgress, current);
              else {
                type = getOwnerDocumentFromRootContainer(rootInstanceStackCursor.current);
                switch (current) {
                  case 1:
                    current = type.createElementNS('http://www.w3.org/2000/svg', renderLanes);
                    break;
                  case 2:
                    current = type.createElementNS(
                      'http://www.w3.org/1998/Math/MathML',
                      renderLanes
                    );
                    break;
                  default:
                    switch (renderLanes) {
                      case 'svg':
                        current = type.createElementNS('http://www.w3.org/2000/svg', renderLanes);
                        break;
                      case 'math':
                        current = type.createElementNS(
                          'http://www.w3.org/1998/Math/MathML',
                          renderLanes
                        );
                        break;
                      case 'script':
                        current = type.createElement('div');
                        current.innerHTML = '<script>\x3c/script>';
                        current = current.removeChild(current.firstChild);
                        break;
                      case 'select':
                        current =
                          'string' === typeof newProps.is
                            ? type.createElement('select', { is: newProps.is })
                            : type.createElement('select');
                        newProps.multiple
                          ? (current.multiple = !0)
                          : newProps.size && (current.size = newProps.size);
                        break;
                      default:
                        current =
                          'string' === typeof newProps.is
                            ? type.createElement(renderLanes, { is: newProps.is })
                            : type.createElement(renderLanes);
                    }
                }
                current[internalInstanceKey] = workInProgress;
                current[internalPropsKey] = newProps;
                a: for (type = workInProgress.child; null !== type; ) {
                  if (5 === type.tag || 6 === type.tag) current.appendChild(type.stateNode);
                  else if (4 !== type.tag && 27 !== type.tag && null !== type.child) {
                    type.child.return = type;
                    type = type.child;
                    continue;
                  }
                  if (type === workInProgress) break a;
                  for (; null === type.sibling; ) {
                    if (null === type.return || type.return === workInProgress) break a;
                    type = type.return;
                  }
                  type.sibling.return = type.return;
                  type = type.sibling;
                }
                workInProgress.stateNode = current;
                a: switch ((setInitialProperties(current, renderLanes, newProps), renderLanes)) {
                  case 'button':
                  case 'input':
                  case 'select':
                  case 'textarea':
                    current = !!newProps.autoFocus;
                    break a;
                  case 'img':
                    current = !0;
                    break a;
                  default:
                    current = !1;
                }
                current && markUpdate(workInProgress);
              }
            }
            bubbleProperties(workInProgress);
            workInProgress.flags &= -16777217;
            return null;
          case 6:
            if (current && null != workInProgress.stateNode)
              current.memoizedProps !== newProps && markUpdate(workInProgress);
            else {
              if ('string' !== typeof newProps && null === workInProgress.stateNode)
                throw Error(formatProdErrorMessage(166));
              current = rootInstanceStackCursor.current;
              if (popHydrationState(workInProgress)) {
                current = workInProgress.stateNode;
                renderLanes = workInProgress.memoizedProps;
                newProps = null;
                type = hydrationParentFiber;
                if (null !== type)
                  switch (type.tag) {
                    case 27:
                    case 5:
                      newProps = type.memoizedProps;
                  }
                current[internalInstanceKey] = workInProgress;
                current =
                  current.nodeValue === renderLanes ||
                  (null !== newProps && !0 === newProps.suppressHydrationWarning) ||
                  checkForUnmatchedText(current.nodeValue, renderLanes)
                    ? !0
                    : !1;
                current || throwOnHydrationMismatch(workInProgress);
              } else
                ((current = getOwnerDocumentFromRootContainer(current).createTextNode(newProps)),
                  (current[internalInstanceKey] = workInProgress),
                  (workInProgress.stateNode = current));
            }
            bubbleProperties(workInProgress);
            return null;
          case 13:
            newProps = workInProgress.memoizedState;
            if (
              null === current ||
              (null !== current.memoizedState && null !== current.memoizedState.dehydrated)
            ) {
              type = popHydrationState(workInProgress);
              if (null !== newProps && null !== newProps.dehydrated) {
                if (null === current) {
                  if (!type) throw Error(formatProdErrorMessage(318));
                  type = workInProgress.memoizedState;
                  type = null !== type ? type.dehydrated : null;
                  if (!type) throw Error(formatProdErrorMessage(317));
                  type[internalInstanceKey] = workInProgress;
                } else
                  (resetHydrationState(),
                    0 === (workInProgress.flags & 128) && (workInProgress.memoizedState = null),
                    (workInProgress.flags |= 4));
                bubbleProperties(workInProgress);
                type = !1;
              } else
                ((type = upgradeHydrationErrorsToRecoverable()),
                  null !== current &&
                    null !== current.memoizedState &&
                    (current.memoizedState.hydrationErrors = type),
                  (type = !0));
              if (!type) {
                if (workInProgress.flags & 256)
                  return (popSuspenseHandler(workInProgress), workInProgress);
                popSuspenseHandler(workInProgress);
                return null;
              }
            }
            popSuspenseHandler(workInProgress);
            if (0 !== (workInProgress.flags & 128))
              return ((workInProgress.lanes = renderLanes), workInProgress);
            renderLanes = null !== newProps;
            current = null !== current && null !== current.memoizedState;
            if (renderLanes) {
              newProps = workInProgress.child;
              type = null;
              null !== newProps.alternate &&
                null !== newProps.alternate.memoizedState &&
                null !== newProps.alternate.memoizedState.cachePool &&
                (type = newProps.alternate.memoizedState.cachePool.pool);
              var cache$127 = null;
              null !== newProps.memoizedState &&
                null !== newProps.memoizedState.cachePool &&
                (cache$127 = newProps.memoizedState.cachePool.pool);
              cache$127 !== type && (newProps.flags |= 2048);
            }
            renderLanes !== current && renderLanes && (workInProgress.child.flags |= 8192);
            scheduleRetryEffect(workInProgress, workInProgress.updateQueue);
            bubbleProperties(workInProgress);
            return null;
          case 4:
            return (
              popHostContainer(),
              null === current &&
                listenToAllSupportedEvents(workInProgress.stateNode.containerInfo),
              bubbleProperties(workInProgress),
              null
            );
          case 10:
            return (popProvider(workInProgress.type), bubbleProperties(workInProgress), null);
          case 19:
            pop(suspenseStackCursor);
            type = workInProgress.memoizedState;
            if (null === type) return (bubbleProperties(workInProgress), null);
            newProps = 0 !== (workInProgress.flags & 128);
            cache$127 = type.rendering;
            if (null === cache$127)
              if (newProps) cutOffTailIfNeeded(type, !1);
              else {
                if (
                  0 !== workInProgressRootExitStatus ||
                  (null !== current && 0 !== (current.flags & 128))
                )
                  for (current = workInProgress.child; null !== current; ) {
                    cache$127 = findFirstSuspended(current);
                    if (null !== cache$127) {
                      workInProgress.flags |= 128;
                      cutOffTailIfNeeded(type, !1);
                      current = cache$127.updateQueue;
                      workInProgress.updateQueue = current;
                      scheduleRetryEffect(workInProgress, current);
                      workInProgress.subtreeFlags = 0;
                      current = renderLanes;
                      for (renderLanes = workInProgress.child; null !== renderLanes; )
                        (resetWorkInProgress(renderLanes, current),
                          (renderLanes = renderLanes.sibling));
                      push(suspenseStackCursor, (suspenseStackCursor.current & 1) | 2);
                      return workInProgress.child;
                    }
                    current = current.sibling;
                  }
                null !== type.tail &&
                  now() > workInProgressRootRenderTargetTime &&
                  ((workInProgress.flags |= 128),
                  (newProps = !0),
                  cutOffTailIfNeeded(type, !1),
                  (workInProgress.lanes = 4194304));
              }
            else {
              if (!newProps)
                if (((current = findFirstSuspended(cache$127)), null !== current)) {
                  if (
                    ((workInProgress.flags |= 128),
                    (newProps = !0),
                    (current = current.updateQueue),
                    (workInProgress.updateQueue = current),
                    scheduleRetryEffect(workInProgress, current),
                    cutOffTailIfNeeded(type, !0),
                    null === type.tail &&
                      'hidden' === type.tailMode &&
                      !cache$127.alternate &&
                      !isHydrating)
                  )
                    return (bubbleProperties(workInProgress), null);
                } else
                  2 * now() - type.renderingStartTime > workInProgressRootRenderTargetTime &&
                    536870912 !== renderLanes &&
                    ((workInProgress.flags |= 128),
                    (newProps = !0),
                    cutOffTailIfNeeded(type, !1),
                    (workInProgress.lanes = 4194304));
              type.isBackwards
                ? ((cache$127.sibling = workInProgress.child), (workInProgress.child = cache$127))
                : ((current = type.last),
                  null !== current
                    ? (current.sibling = cache$127)
                    : (workInProgress.child = cache$127),
                  (type.last = cache$127));
            }
            if (null !== type.tail)
              return (
                (workInProgress = type.tail),
                (type.rendering = workInProgress),
                (type.tail = workInProgress.sibling),
                (type.renderingStartTime = now()),
                (workInProgress.sibling = null),
                (current = suspenseStackCursor.current),
                push(suspenseStackCursor, newProps ? (current & 1) | 2 : current & 1),
                workInProgress
              );
            bubbleProperties(workInProgress);
            return null;
          case 22:
          case 23:
            return (
              popSuspenseHandler(workInProgress),
              popHiddenContext(),
              (newProps = null !== workInProgress.memoizedState),
              null !== current
                ? (null !== current.memoizedState) !== newProps && (workInProgress.flags |= 8192)
                : newProps && (workInProgress.flags |= 8192),
              newProps
                ? 0 !== (renderLanes & 536870912) &&
                  0 === (workInProgress.flags & 128) &&
                  (bubbleProperties(workInProgress),
                  workInProgress.subtreeFlags & 6 && (workInProgress.flags |= 8192))
                : bubbleProperties(workInProgress),
              (renderLanes = workInProgress.updateQueue),
              null !== renderLanes && scheduleRetryEffect(workInProgress, renderLanes.retryQueue),
              (renderLanes = null),
              null !== current &&
                null !== current.memoizedState &&
                null !== current.memoizedState.cachePool &&
                (renderLanes = current.memoizedState.cachePool.pool),
              (newProps = null),
              null !== workInProgress.memoizedState &&
                null !== workInProgress.memoizedState.cachePool &&
                (newProps = workInProgress.memoizedState.cachePool.pool),
              newProps !== renderLanes && (workInProgress.flags |= 2048),
              null !== current && pop(resumedCache),
              null
            );
          case 24:
            return (
              (renderLanes = null),
              null !== current && (renderLanes = current.memoizedState.cache),
              workInProgress.memoizedState.cache !== renderLanes && (workInProgress.flags |= 2048),
              popProvider(CacheContext),
              bubbleProperties(workInProgress),
              null
            );
          case 25:
            return null;
          case 30:
            return null;
        }
        throw Error(formatProdErrorMessage(156, workInProgress.tag));
      }
      function unwindWork(current, workInProgress) {
        popTreeContext(workInProgress);
        switch (workInProgress.tag) {
          case 1:
            return (
              (current = workInProgress.flags),
              current & 65536
                ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)
                : null
            );
          case 3:
            return (
              popProvider(CacheContext),
              popHostContainer(),
              (current = workInProgress.flags),
              0 !== (current & 65536) && 0 === (current & 128)
                ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)
                : null
            );
          case 26:
          case 27:
          case 5:
            return (popHostContext(workInProgress), null);
          case 13:
            popSuspenseHandler(workInProgress);
            current = workInProgress.memoizedState;
            if (null !== current && null !== current.dehydrated) {
              if (null === workInProgress.alternate) throw Error(formatProdErrorMessage(340));
              resetHydrationState();
            }
            current = workInProgress.flags;
            return current & 65536
              ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)
              : null;
          case 19:
            return (pop(suspenseStackCursor), null);
          case 4:
            return (popHostContainer(), null);
          case 10:
            return (popProvider(workInProgress.type), null);
          case 22:
          case 23:
            return (
              popSuspenseHandler(workInProgress),
              popHiddenContext(),
              null !== current && pop(resumedCache),
              (current = workInProgress.flags),
              current & 65536
                ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)
                : null
            );
          case 24:
            return (popProvider(CacheContext), null);
          case 25:
            return null;
          default:
            return null;
        }
      }
      function unwindInterruptedWork(current, interruptedWork) {
        popTreeContext(interruptedWork);
        switch (interruptedWork.tag) {
          case 3:
            popProvider(CacheContext);
            popHostContainer();
            break;
          case 26:
          case 27:
          case 5:
            popHostContext(interruptedWork);
            break;
          case 4:
            popHostContainer();
            break;
          case 13:
            popSuspenseHandler(interruptedWork);
            break;
          case 19:
            pop(suspenseStackCursor);
            break;
          case 10:
            popProvider(interruptedWork.type);
            break;
          case 22:
          case 23:
            popSuspenseHandler(interruptedWork);
            popHiddenContext();
            null !== current && pop(resumedCache);
            break;
          case 24:
            popProvider(CacheContext);
        }
      }
      function commitHookEffectListMount(flags, finishedWork) {
        try {
          var updateQueue = finishedWork.updateQueue,
            lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
          if (null !== lastEffect) {
            var firstEffect = lastEffect.next;
            updateQueue = firstEffect;
            do {
              if ((updateQueue.tag & flags) === flags) {
                lastEffect = void 0;
                var create = updateQueue.create,
                  inst = updateQueue.inst;
                lastEffect = create();
                inst.destroy = lastEffect;
              }
              updateQueue = updateQueue.next;
            } while (updateQueue !== firstEffect);
          }
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor$jscomp$0) {
        try {
          var updateQueue = finishedWork.updateQueue,
            lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
          if (null !== lastEffect) {
            var firstEffect = lastEffect.next;
            updateQueue = firstEffect;
            do {
              if ((updateQueue.tag & flags) === flags) {
                var inst = updateQueue.inst,
                  destroy = inst.destroy;
                if (void 0 !== destroy) {
                  inst.destroy = void 0;
                  lastEffect = finishedWork;
                  var nearestMountedAncestor = nearestMountedAncestor$jscomp$0,
                    destroy_ = destroy;
                  try {
                    destroy_();
                  } catch (error) {
                    captureCommitPhaseError(lastEffect, nearestMountedAncestor, error);
                  }
                }
              }
              updateQueue = updateQueue.next;
            } while (updateQueue !== firstEffect);
          }
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      function commitClassCallbacks(finishedWork) {
        var updateQueue = finishedWork.updateQueue;
        if (null !== updateQueue) {
          var instance = finishedWork.stateNode;
          try {
            commitCallbacks(updateQueue, instance);
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
      }
      function safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance) {
        instance.props = resolveClassComponentProps(current.type, current.memoizedProps);
        instance.state = current.memoizedState;
        try {
          instance.componentWillUnmount();
        } catch (error) {
          captureCommitPhaseError(current, nearestMountedAncestor, error);
        }
      }
      function safelyAttachRef(current, nearestMountedAncestor) {
        try {
          var ref = current.ref;
          if (null !== ref) {
            switch (current.tag) {
              case 26:
              case 27:
              case 5:
                var instanceToUse = current.stateNode;
                break;
              case 30:
                instanceToUse = current.stateNode;
                break;
              default:
                instanceToUse = current.stateNode;
            }
            'function' === typeof ref
              ? (current.refCleanup = ref(instanceToUse))
              : (ref.current = instanceToUse);
          }
        } catch (error) {
          captureCommitPhaseError(current, nearestMountedAncestor, error);
        }
      }
      function safelyDetachRef(current, nearestMountedAncestor) {
        var ref = current.ref,
          refCleanup = current.refCleanup;
        if (null !== ref)
          if ('function' === typeof refCleanup)
            try {
              refCleanup();
            } catch (error) {
              captureCommitPhaseError(current, nearestMountedAncestor, error);
            } finally {
              ((current.refCleanup = null),
                (current = current.alternate),
                null != current && (current.refCleanup = null));
            }
          else if ('function' === typeof ref)
            try {
              ref(null);
            } catch (error$143) {
              captureCommitPhaseError(current, nearestMountedAncestor, error$143);
            }
          else ref.current = null;
      }
      function commitHostMount(finishedWork) {
        var type = finishedWork.type,
          props = finishedWork.memoizedProps,
          instance = finishedWork.stateNode;
        try {
          a: switch (type) {
            case 'button':
            case 'input':
            case 'select':
            case 'textarea':
              props.autoFocus && instance.focus();
              break a;
            case 'img':
              props.src
                ? (instance.src = props.src)
                : props.srcSet && (instance.srcset = props.srcSet);
          }
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      function commitHostUpdate(finishedWork, newProps, oldProps) {
        try {
          var domElement = finishedWork.stateNode;
          updateProperties(domElement, finishedWork.type, oldProps, newProps);
          domElement[internalPropsKey] = newProps;
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      function isHostParent(fiber) {
        return (
          5 === fiber.tag ||
          3 === fiber.tag ||
          26 === fiber.tag ||
          (27 === fiber.tag && isSingletonScope(fiber.type)) ||
          4 === fiber.tag
        );
      }
      function getHostSibling(fiber) {
        a: for (;;) {
          for (; null === fiber.sibling; ) {
            if (null === fiber.return || isHostParent(fiber.return)) return null;
            fiber = fiber.return;
          }
          fiber.sibling.return = fiber.return;
          for (fiber = fiber.sibling; 5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag; ) {
            if (27 === fiber.tag && isSingletonScope(fiber.type)) continue a;
            if (fiber.flags & 2) continue a;
            if (null === fiber.child || 4 === fiber.tag) continue a;
            else ((fiber.child.return = fiber), (fiber = fiber.child));
          }
          if (!(fiber.flags & 2)) return fiber.stateNode;
        }
      }
      function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
        var tag = node.tag;
        if (5 === tag || 6 === tag)
          ((node = node.stateNode),
            before
              ? (9 === parent.nodeType
                  ? parent.body
                  : 'HTML' === parent.nodeName
                    ? parent.ownerDocument.body
                    : parent
                ).insertBefore(node, before)
              : ((before =
                  9 === parent.nodeType
                    ? parent.body
                    : 'HTML' === parent.nodeName
                      ? parent.ownerDocument.body
                      : parent),
                before.appendChild(node),
                (parent = parent._reactRootContainer),
                (null !== parent && void 0 !== parent) ||
                  null !== before.onclick ||
                  (before.onclick = noop$1)));
        else if (
          4 !== tag &&
          (27 === tag &&
            isSingletonScope(node.type) &&
            ((parent = node.stateNode), (before = null)),
          (node = node.child),
          null !== node)
        )
          for (
            insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling;
            null !== node;

          )
            (insertOrAppendPlacementNodeIntoContainer(node, before, parent), (node = node.sibling));
      }
      function insertOrAppendPlacementNode(node, before, parent) {
        var tag = node.tag;
        if (5 === tag || 6 === tag)
          ((node = node.stateNode),
            before ? parent.insertBefore(node, before) : parent.appendChild(node));
        else if (
          4 !== tag &&
          (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode),
          (node = node.child),
          null !== node)
        )
          for (
            insertOrAppendPlacementNode(node, before, parent), node = node.sibling;
            null !== node;

          )
            (insertOrAppendPlacementNode(node, before, parent), (node = node.sibling));
      }
      function commitHostSingletonAcquisition(finishedWork) {
        var singleton = finishedWork.stateNode,
          props = finishedWork.memoizedProps;
        try {
          for (var type = finishedWork.type, attributes = singleton.attributes; attributes.length; )
            singleton.removeAttributeNode(attributes[0]);
          setInitialProperties(singleton, type, props);
          singleton[internalInstanceKey] = finishedWork;
          singleton[internalPropsKey] = props;
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      var offscreenSubtreeIsHidden = !1,
        offscreenSubtreeWasHidden = !1,
        needsFormReset = !1,
        PossiblyWeakSet = 'function' === typeof WeakSet ? WeakSet : Set,
        nextEffect = null;
      function commitBeforeMutationEffects(root, firstChild) {
        root = root.containerInfo;
        eventsEnabled = _enabled;
        root = getActiveElementDeep(root);
        if (hasSelectionCapabilities(root)) {
          if ('selectionStart' in root)
            var JSCompiler_temp = {
              start: root.selectionStart,
              end: root.selectionEnd,
            };
          else
            a: {
              JSCompiler_temp =
                ((JSCompiler_temp = root.ownerDocument) && JSCompiler_temp.defaultView) || window;
              var selection = JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();
              if (selection && 0 !== selection.rangeCount) {
                JSCompiler_temp = selection.anchorNode;
                var anchorOffset = selection.anchorOffset,
                  focusNode = selection.focusNode;
                selection = selection.focusOffset;
                try {
                  (JSCompiler_temp.nodeType, focusNode.nodeType);
                } catch (e$20) {
                  JSCompiler_temp = null;
                  break a;
                }
                var length = 0,
                  start = -1,
                  end = -1,
                  indexWithinAnchor = 0,
                  indexWithinFocus = 0,
                  node = root,
                  parentNode = null;
                b: for (;;) {
                  for (var next; ; ) {
                    node !== JSCompiler_temp ||
                      (0 !== anchorOffset && 3 !== node.nodeType) ||
                      (start = length + anchorOffset);
                    node !== focusNode ||
                      (0 !== selection && 3 !== node.nodeType) ||
                      (end = length + selection);
                    3 === node.nodeType && (length += node.nodeValue.length);
                    if (null === (next = node.firstChild)) break;
                    parentNode = node;
                    node = next;
                  }
                  for (;;) {
                    if (node === root) break b;
                    parentNode === JSCompiler_temp &&
                      ++indexWithinAnchor === anchorOffset &&
                      (start = length);
                    parentNode === focusNode && ++indexWithinFocus === selection && (end = length);
                    if (null !== (next = node.nextSibling)) break;
                    node = parentNode;
                    parentNode = node.parentNode;
                  }
                  node = next;
                }
                JSCompiler_temp = -1 === start || -1 === end ? null : { start: start, end: end };
              } else JSCompiler_temp = null;
            }
          JSCompiler_temp = JSCompiler_temp || { start: 0, end: 0 };
        } else JSCompiler_temp = null;
        selectionInformation = { focusedElem: root, selectionRange: JSCompiler_temp };
        _enabled = !1;
        for (nextEffect = firstChild; null !== nextEffect; )
          if (
            ((firstChild = nextEffect),
            (root = firstChild.child),
            0 !== (firstChild.subtreeFlags & 1024) && null !== root)
          )
            ((root.return = firstChild), (nextEffect = root));
          else
            for (; null !== nextEffect; ) {
              firstChild = nextEffect;
              focusNode = firstChild.alternate;
              root = firstChild.flags;
              switch (firstChild.tag) {
                case 0:
                  break;
                case 11:
                case 15:
                  break;
                case 1:
                  if (0 !== (root & 1024) && null !== focusNode) {
                    root = void 0;
                    JSCompiler_temp = firstChild;
                    anchorOffset = focusNode.memoizedProps;
                    focusNode = focusNode.memoizedState;
                    selection = JSCompiler_temp.stateNode;
                    try {
                      var resolvedPrevProps = resolveClassComponentProps(
                        JSCompiler_temp.type,
                        anchorOffset,
                        JSCompiler_temp.elementType === JSCompiler_temp.type
                      );
                      root = selection.getSnapshotBeforeUpdate(resolvedPrevProps, focusNode);
                      selection.__reactInternalSnapshotBeforeUpdate = root;
                    } catch (error) {
                      captureCommitPhaseError(JSCompiler_temp, JSCompiler_temp.return, error);
                    }
                  }
                  break;
                case 3:
                  if (0 !== (root & 1024))
                    if (
                      ((root = firstChild.stateNode.containerInfo),
                      (JSCompiler_temp = root.nodeType),
                      9 === JSCompiler_temp)
                    )
                      clearContainerSparingly(root);
                    else if (1 === JSCompiler_temp)
                      switch (root.nodeName) {
                        case 'HEAD':
                        case 'HTML':
                        case 'BODY':
                          clearContainerSparingly(root);
                          break;
                        default:
                          root.textContent = '';
                      }
                  break;
                case 5:
                case 26:
                case 27:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  if (0 !== (root & 1024)) throw Error(formatProdErrorMessage(163));
              }
              root = firstChild.sibling;
              if (null !== root) {
                root.return = firstChild.return;
                nextEffect = root;
                break;
              }
              nextEffect = firstChild.return;
            }
      }
      function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
        var flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            flags & 4 && commitHookEffectListMount(5, finishedWork);
            break;
          case 1:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            if (flags & 4)
              if (((finishedRoot = finishedWork.stateNode), null === current))
                try {
                  finishedRoot.componentDidMount();
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              else {
                var prevProps = resolveClassComponentProps(
                  finishedWork.type,
                  current.memoizedProps
                );
                current = current.memoizedState;
                try {
                  finishedRoot.componentDidUpdate(
                    prevProps,
                    current,
                    finishedRoot.__reactInternalSnapshotBeforeUpdate
                  );
                } catch (error$142) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error$142);
                }
              }
            flags & 64 && commitClassCallbacks(finishedWork);
            flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
            break;
          case 3:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            if (flags & 64 && ((finishedRoot = finishedWork.updateQueue), null !== finishedRoot)) {
              current = null;
              if (null !== finishedWork.child)
                switch (finishedWork.child.tag) {
                  case 27:
                  case 5:
                    current = finishedWork.child.stateNode;
                    break;
                  case 1:
                    current = finishedWork.child.stateNode;
                }
              try {
                commitCallbacks(finishedRoot, current);
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            }
            break;
          case 27:
            null === current && flags & 4 && commitHostSingletonAcquisition(finishedWork);
          case 26:
          case 5:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            null === current && flags & 4 && commitHostMount(finishedWork);
            flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
            break;
          case 12:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            break;
          case 13:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
            flags & 64 &&
              ((finishedRoot = finishedWork.memoizedState),
              null !== finishedRoot &&
                ((finishedRoot = finishedRoot.dehydrated),
                null !== finishedRoot &&
                  ((finishedWork = retryDehydratedSuspenseBoundary.bind(null, finishedWork)),
                  registerSuspenseInstanceRetry(finishedRoot, finishedWork))));
            break;
          case 22:
            flags = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
            if (!flags) {
              current =
                (null !== current && null !== current.memoizedState) || offscreenSubtreeWasHidden;
              prevProps = offscreenSubtreeIsHidden;
              var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
              offscreenSubtreeIsHidden = flags;
              (offscreenSubtreeWasHidden = current) && !prevOffscreenSubtreeWasHidden
                ? recursivelyTraverseReappearLayoutEffects(
                    finishedRoot,
                    finishedWork,
                    0 !== (finishedWork.subtreeFlags & 8772)
                  )
                : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              offscreenSubtreeIsHidden = prevProps;
              offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
            }
            break;
          case 30:
            break;
          default:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
        }
      }
      function detachFiberAfterEffects(fiber) {
        var alternate = fiber.alternate;
        null !== alternate && ((fiber.alternate = null), detachFiberAfterEffects(alternate));
        fiber.child = null;
        fiber.deletions = null;
        fiber.sibling = null;
        5 === fiber.tag &&
          ((alternate = fiber.stateNode), null !== alternate && detachDeletedInstance(alternate));
        fiber.stateNode = null;
        fiber.return = null;
        fiber.dependencies = null;
        fiber.memoizedProps = null;
        fiber.memoizedState = null;
        fiber.pendingProps = null;
        fiber.stateNode = null;
        fiber.updateQueue = null;
      }
      var hostParent = null,
        hostParentIsContainer = !1;
      function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
        for (parent = parent.child; null !== parent; )
          (commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent),
            (parent = parent.sibling));
      }
      function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
        if (injectedHook && 'function' === typeof injectedHook.onCommitFiberUnmount)
          try {
            injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
          } catch (err) {}
        switch (deletedFiber.tag) {
          case 26:
            offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
            deletedFiber.memoizedState
              ? deletedFiber.memoizedState.count--
              : deletedFiber.stateNode &&
                ((deletedFiber = deletedFiber.stateNode),
                deletedFiber.parentNode.removeChild(deletedFiber));
            break;
          case 27:
            offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
            var prevHostParent = hostParent,
              prevHostParentIsContainer = hostParentIsContainer;
            isSingletonScope(deletedFiber.type) &&
              ((hostParent = deletedFiber.stateNode), (hostParentIsContainer = !1));
            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
            releaseSingletonInstance(deletedFiber.stateNode);
            hostParent = prevHostParent;
            hostParentIsContainer = prevHostParentIsContainer;
            break;
          case 5:
            offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
          case 6:
            prevHostParent = hostParent;
            prevHostParentIsContainer = hostParentIsContainer;
            hostParent = null;
            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
            hostParent = prevHostParent;
            hostParentIsContainer = prevHostParentIsContainer;
            if (null !== hostParent)
              if (hostParentIsContainer)
                try {
                  (9 === hostParent.nodeType
                    ? hostParent.body
                    : 'HTML' === hostParent.nodeName
                      ? hostParent.ownerDocument.body
                      : hostParent
                  ).removeChild(deletedFiber.stateNode);
                } catch (error) {
                  captureCommitPhaseError(deletedFiber, nearestMountedAncestor, error);
                }
              else
                try {
                  hostParent.removeChild(deletedFiber.stateNode);
                } catch (error) {
                  captureCommitPhaseError(deletedFiber, nearestMountedAncestor, error);
                }
            break;
          case 18:
            null !== hostParent &&
              (hostParentIsContainer
                ? ((finishedRoot = hostParent),
                  clearSuspenseBoundary(
                    9 === finishedRoot.nodeType
                      ? finishedRoot.body
                      : 'HTML' === finishedRoot.nodeName
                        ? finishedRoot.ownerDocument.body
                        : finishedRoot,
                    deletedFiber.stateNode
                  ),
                  retryIfBlockedOn(finishedRoot))
                : clearSuspenseBoundary(hostParent, deletedFiber.stateNode));
            break;
          case 4:
            prevHostParent = hostParent;
            prevHostParentIsContainer = hostParentIsContainer;
            hostParent = deletedFiber.stateNode.containerInfo;
            hostParentIsContainer = !0;
            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
            hostParent = prevHostParent;
            hostParentIsContainer = prevHostParentIsContainer;
            break;
          case 0:
          case 11:
          case 14:
          case 15:
            offscreenSubtreeWasHidden ||
              commitHookEffectListUnmount(2, deletedFiber, nearestMountedAncestor);
            offscreenSubtreeWasHidden ||
              commitHookEffectListUnmount(4, deletedFiber, nearestMountedAncestor);
            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
            break;
          case 1:
            offscreenSubtreeWasHidden ||
              (safelyDetachRef(deletedFiber, nearestMountedAncestor),
              (prevHostParent = deletedFiber.stateNode),
              'function' === typeof prevHostParent.componentWillUnmount &&
                safelyCallComponentWillUnmount(
                  deletedFiber,
                  nearestMountedAncestor,
                  prevHostParent
                ));
            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
            break;
          case 21:
            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
            break;
          case 22:
            offscreenSubtreeWasHidden =
              (prevHostParent = offscreenSubtreeWasHidden) || null !== deletedFiber.memoizedState;
            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
            offscreenSubtreeWasHidden = prevHostParent;
            break;
          default:
            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
        }
      }
      function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
        if (
          null === finishedWork.memoizedState &&
          ((finishedRoot = finishedWork.alternate),
          null !== finishedRoot &&
            ((finishedRoot = finishedRoot.memoizedState),
            null !== finishedRoot &&
              ((finishedRoot = finishedRoot.dehydrated), null !== finishedRoot)))
        )
          try {
            retryIfBlockedOn(finishedRoot);
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
      }
      function getRetryCache(finishedWork) {
        switch (finishedWork.tag) {
          case 13:
          case 19:
            var retryCache = finishedWork.stateNode;
            null === retryCache && (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
            return retryCache;
          case 22:
            return (
              (finishedWork = finishedWork.stateNode),
              (retryCache = finishedWork._retryCache),
              null === retryCache &&
                (retryCache = finishedWork._retryCache = new PossiblyWeakSet()),
              retryCache
            );
          default:
            throw Error(formatProdErrorMessage(435, finishedWork.tag));
        }
      }
      function attachSuspenseRetryListeners(finishedWork, wakeables) {
        var retryCache = getRetryCache(finishedWork);
        wakeables.forEach(function (wakeable) {
          var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
          retryCache.has(wakeable) || (retryCache.add(wakeable), wakeable.then(retry, retry));
        });
      }
      function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
        var deletions = parentFiber.deletions;
        if (null !== deletions)
          for (var i = 0; i < deletions.length; i++) {
            var childToDelete = deletions[i],
              root = root$jscomp$0,
              returnFiber = parentFiber,
              parent = returnFiber;
            a: for (; null !== parent; ) {
              switch (parent.tag) {
                case 27:
                  if (isSingletonScope(parent.type)) {
                    hostParent = parent.stateNode;
                    hostParentIsContainer = !1;
                    break a;
                  }
                  break;
                case 5:
                  hostParent = parent.stateNode;
                  hostParentIsContainer = !1;
                  break a;
                case 3:
                case 4:
                  hostParent = parent.stateNode.containerInfo;
                  hostParentIsContainer = !0;
                  break a;
              }
              parent = parent.return;
            }
            if (null === hostParent) throw Error(formatProdErrorMessage(160));
            commitDeletionEffectsOnFiber(root, returnFiber, childToDelete);
            hostParent = null;
            hostParentIsContainer = !1;
            root = childToDelete.alternate;
            null !== root && (root.return = null);
            childToDelete.return = null;
          }
        if (parentFiber.subtreeFlags & 13878)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            (commitMutationEffectsOnFiber(parentFiber, root$jscomp$0),
              (parentFiber = parentFiber.sibling));
      }
      var currentHoistableRoot = null;
      function commitMutationEffectsOnFiber(finishedWork, root) {
        var current = finishedWork.alternate,
          flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            recursivelyTraverseMutationEffects(root, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 4 &&
              (commitHookEffectListUnmount(3, finishedWork, finishedWork.return),
              commitHookEffectListMount(3, finishedWork),
              commitHookEffectListUnmount(5, finishedWork, finishedWork.return));
            break;
          case 1:
            recursivelyTraverseMutationEffects(root, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 512 &&
              (offscreenSubtreeWasHidden ||
                null === current ||
                safelyDetachRef(current, current.return));
            flags & 64 &&
              offscreenSubtreeIsHidden &&
              ((finishedWork = finishedWork.updateQueue),
              null !== finishedWork &&
                ((flags = finishedWork.callbacks),
                null !== flags &&
                  ((current = finishedWork.shared.hiddenCallbacks),
                  (finishedWork.shared.hiddenCallbacks =
                    null === current ? flags : current.concat(flags)))));
            break;
          case 26:
            var hoistableRoot = currentHoistableRoot;
            recursivelyTraverseMutationEffects(root, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 512 &&
              (offscreenSubtreeWasHidden ||
                null === current ||
                safelyDetachRef(current, current.return));
            if (flags & 4) {
              var currentResource = null !== current ? current.memoizedState : null;
              flags = finishedWork.memoizedState;
              if (null === current)
                if (null === flags)
                  if (null === finishedWork.stateNode) {
                    a: {
                      flags = finishedWork.type;
                      current = finishedWork.memoizedProps;
                      hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
                      b: switch (flags) {
                        case 'title':
                          currentResource = hoistableRoot.getElementsByTagName('title')[0];
                          if (
                            !currentResource ||
                            currentResource[internalHoistableMarker] ||
                            currentResource[internalInstanceKey] ||
                            'http://www.w3.org/2000/svg' === currentResource.namespaceURI ||
                            currentResource.hasAttribute('itemprop')
                          )
                            ((currentResource = hoistableRoot.createElement(flags)),
                              hoistableRoot.head.insertBefore(
                                currentResource,
                                hoistableRoot.querySelector('head > title')
                              ));
                          setInitialProperties(currentResource, flags, current);
                          currentResource[internalInstanceKey] = finishedWork;
                          markNodeAsHoistable(currentResource);
                          flags = currentResource;
                          break a;
                        case 'link':
                          var maybeNodes = getHydratableHoistableCache(
                            'link',
                            'href',
                            hoistableRoot
                          ).get(flags + (current.href || ''));
                          if (maybeNodes)
                            for (var i = 0; i < maybeNodes.length; i++)
                              if (
                                ((currentResource = maybeNodes[i]),
                                currentResource.getAttribute('href') ===
                                  (null == current.href || '' === current.href
                                    ? null
                                    : current.href) &&
                                  currentResource.getAttribute('rel') ===
                                    (null == current.rel ? null : current.rel) &&
                                  currentResource.getAttribute('title') ===
                                    (null == current.title ? null : current.title) &&
                                  currentResource.getAttribute('crossorigin') ===
                                    (null == current.crossOrigin ? null : current.crossOrigin))
                              ) {
                                maybeNodes.splice(i, 1);
                                break b;
                              }
                          currentResource = hoistableRoot.createElement(flags);
                          setInitialProperties(currentResource, flags, current);
                          hoistableRoot.head.appendChild(currentResource);
                          break;
                        case 'meta':
                          if (
                            (maybeNodes = getHydratableHoistableCache(
                              'meta',
                              'content',
                              hoistableRoot
                            ).get(flags + (current.content || '')))
                          )
                            for (i = 0; i < maybeNodes.length; i++)
                              if (
                                ((currentResource = maybeNodes[i]),
                                currentResource.getAttribute('content') ===
                                  (null == current.content ? null : '' + current.content) &&
                                  currentResource.getAttribute('name') ===
                                    (null == current.name ? null : current.name) &&
                                  currentResource.getAttribute('property') ===
                                    (null == current.property ? null : current.property) &&
                                  currentResource.getAttribute('http-equiv') ===
                                    (null == current.httpEquiv ? null : current.httpEquiv) &&
                                  currentResource.getAttribute('charset') ===
                                    (null == current.charSet ? null : current.charSet))
                              ) {
                                maybeNodes.splice(i, 1);
                                break b;
                              }
                          currentResource = hoistableRoot.createElement(flags);
                          setInitialProperties(currentResource, flags, current);
                          hoistableRoot.head.appendChild(currentResource);
                          break;
                        default:
                          throw Error(formatProdErrorMessage(468, flags));
                      }
                      currentResource[internalInstanceKey] = finishedWork;
                      markNodeAsHoistable(currentResource);
                      flags = currentResource;
                    }
                    finishedWork.stateNode = flags;
                  } else mountHoistable(hoistableRoot, finishedWork.type, finishedWork.stateNode);
                else
                  finishedWork.stateNode = acquireResource(
                    hoistableRoot,
                    flags,
                    finishedWork.memoizedProps
                  );
              else
                currentResource !== flags
                  ? (null === currentResource
                      ? null !== current.stateNode &&
                        ((current = current.stateNode), current.parentNode.removeChild(current))
                      : currentResource.count--,
                    null === flags
                      ? mountHoistable(hoistableRoot, finishedWork.type, finishedWork.stateNode)
                      : acquireResource(hoistableRoot, flags, finishedWork.memoizedProps))
                  : null === flags &&
                    null !== finishedWork.stateNode &&
                    commitHostUpdate(
                      finishedWork,
                      finishedWork.memoizedProps,
                      current.memoizedProps
                    );
            }
            break;
          case 27:
            recursivelyTraverseMutationEffects(root, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 512 &&
              (offscreenSubtreeWasHidden ||
                null === current ||
                safelyDetachRef(current, current.return));
            null !== current &&
              flags & 4 &&
              commitHostUpdate(finishedWork, finishedWork.memoizedProps, current.memoizedProps);
            break;
          case 5:
            recursivelyTraverseMutationEffects(root, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 512 &&
              (offscreenSubtreeWasHidden ||
                null === current ||
                safelyDetachRef(current, current.return));
            if (finishedWork.flags & 32) {
              hoistableRoot = finishedWork.stateNode;
              try {
                setTextContent(hoistableRoot, '');
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            }
            flags & 4 &&
              null != finishedWork.stateNode &&
              ((hoistableRoot = finishedWork.memoizedProps),
              commitHostUpdate(
                finishedWork,
                hoistableRoot,
                null !== current ? current.memoizedProps : hoistableRoot
              ));
            flags & 1024 && (needsFormReset = !0);
            break;
          case 6:
            recursivelyTraverseMutationEffects(root, finishedWork);
            commitReconciliationEffects(finishedWork);
            if (flags & 4) {
              if (null === finishedWork.stateNode) throw Error(formatProdErrorMessage(162));
              flags = finishedWork.memoizedProps;
              current = finishedWork.stateNode;
              try {
                current.nodeValue = flags;
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            }
            break;
          case 3:
            tagCaches = null;
            hoistableRoot = currentHoistableRoot;
            currentHoistableRoot = getHoistableRoot(root.containerInfo);
            recursivelyTraverseMutationEffects(root, finishedWork);
            currentHoistableRoot = hoistableRoot;
            commitReconciliationEffects(finishedWork);
            if (flags & 4 && null !== current && current.memoizedState.isDehydrated)
              try {
                retryIfBlockedOn(root.containerInfo);
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            needsFormReset && ((needsFormReset = !1), recursivelyResetForms(finishedWork));
            break;
          case 4:
            flags = currentHoistableRoot;
            currentHoistableRoot = getHoistableRoot(finishedWork.stateNode.containerInfo);
            recursivelyTraverseMutationEffects(root, finishedWork);
            commitReconciliationEffects(finishedWork);
            currentHoistableRoot = flags;
            break;
          case 12:
            recursivelyTraverseMutationEffects(root, finishedWork);
            commitReconciliationEffects(finishedWork);
            break;
          case 13:
            recursivelyTraverseMutationEffects(root, finishedWork);
            commitReconciliationEffects(finishedWork);
            finishedWork.child.flags & 8192 &&
              (null !== finishedWork.memoizedState) !==
                (null !== current && null !== current.memoizedState) &&
              (globalMostRecentFallbackTime = now());
            flags & 4 &&
              ((flags = finishedWork.updateQueue),
              null !== flags &&
                ((finishedWork.updateQueue = null),
                attachSuspenseRetryListeners(finishedWork, flags)));
            break;
          case 22:
            hoistableRoot = null !== finishedWork.memoizedState;
            var wasHidden = null !== current && null !== current.memoizedState,
              prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden,
              prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
            offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || hoistableRoot;
            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;
            recursivelyTraverseMutationEffects(root, finishedWork);
            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
            offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
            commitReconciliationEffects(finishedWork);
            if (flags & 8192)
              a: for (
                root = finishedWork.stateNode,
                  root._visibility = hoistableRoot ? root._visibility & -2 : root._visibility | 1,
                  hoistableRoot &&
                    (null === current ||
                      wasHidden ||
                      offscreenSubtreeIsHidden ||
                      offscreenSubtreeWasHidden ||
                      recursivelyTraverseDisappearLayoutEffects(finishedWork)),
                  current = null,
                  root = finishedWork;
                ;

              ) {
                if (5 === root.tag || 26 === root.tag) {
                  if (null === current) {
                    wasHidden = current = root;
                    try {
                      if (((currentResource = wasHidden.stateNode), hoistableRoot))
                        ((maybeNodes = currentResource.style),
                          'function' === typeof maybeNodes.setProperty
                            ? maybeNodes.setProperty('display', 'none', 'important')
                            : (maybeNodes.display = 'none'));
                      else {
                        i = wasHidden.stateNode;
                        var styleProp = wasHidden.memoizedProps.style,
                          display =
                            void 0 !== styleProp &&
                            null !== styleProp &&
                            styleProp.hasOwnProperty('display')
                              ? styleProp.display
                              : null;
                        i.style.display =
                          null == display || 'boolean' === typeof display
                            ? ''
                            : ('' + display).trim();
                      }
                    } catch (error) {
                      captureCommitPhaseError(wasHidden, wasHidden.return, error);
                    }
                  }
                } else if (6 === root.tag) {
                  if (null === current) {
                    wasHidden = root;
                    try {
                      wasHidden.stateNode.nodeValue = hoistableRoot ? '' : wasHidden.memoizedProps;
                    } catch (error) {
                      captureCommitPhaseError(wasHidden, wasHidden.return, error);
                    }
                  }
                } else if (
                  ((22 !== root.tag && 23 !== root.tag) ||
                    null === root.memoizedState ||
                    root === finishedWork) &&
                  null !== root.child
                ) {
                  root.child.return = root;
                  root = root.child;
                  continue;
                }
                if (root === finishedWork) break a;
                for (; null === root.sibling; ) {
                  if (null === root.return || root.return === finishedWork) break a;
                  current === root && (current = null);
                  root = root.return;
                }
                current === root && (current = null);
                root.sibling.return = root.return;
                root = root.sibling;
              }
            flags & 4 &&
              ((flags = finishedWork.updateQueue),
              null !== flags &&
                ((current = flags.retryQueue),
                null !== current &&
                  ((flags.retryQueue = null),
                  attachSuspenseRetryListeners(finishedWork, current))));
            break;
          case 19:
            recursivelyTraverseMutationEffects(root, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 4 &&
              ((flags = finishedWork.updateQueue),
              null !== flags &&
                ((finishedWork.updateQueue = null),
                attachSuspenseRetryListeners(finishedWork, flags)));
            break;
          case 30:
            break;
          case 21:
            break;
          default:
            (recursivelyTraverseMutationEffects(root, finishedWork),
              commitReconciliationEffects(finishedWork));
        }
      }
      function commitReconciliationEffects(finishedWork) {
        var flags = finishedWork.flags;
        if (flags & 2) {
          try {
            for (var hostParentFiber, parentFiber = finishedWork.return; null !== parentFiber; ) {
              if (isHostParent(parentFiber)) {
                hostParentFiber = parentFiber;
                break;
              }
              parentFiber = parentFiber.return;
            }
            if (null == hostParentFiber) throw Error(formatProdErrorMessage(160));
            switch (hostParentFiber.tag) {
              case 27:
                var parent = hostParentFiber.stateNode,
                  before = getHostSibling(finishedWork);
                insertOrAppendPlacementNode(finishedWork, before, parent);
                break;
              case 5:
                var parent$144 = hostParentFiber.stateNode;
                hostParentFiber.flags & 32 &&
                  (setTextContent(parent$144, ''), (hostParentFiber.flags &= -33));
                var before$145 = getHostSibling(finishedWork);
                insertOrAppendPlacementNode(finishedWork, before$145, parent$144);
                break;
              case 3:
              case 4:
                var parent$146 = hostParentFiber.stateNode.containerInfo,
                  before$147 = getHostSibling(finishedWork);
                insertOrAppendPlacementNodeIntoContainer(finishedWork, before$147, parent$146);
                break;
              default:
                throw Error(formatProdErrorMessage(161));
            }
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
          finishedWork.flags &= -3;
        }
        flags & 4096 && (finishedWork.flags &= -4097);
      }
      function recursivelyResetForms(parentFiber) {
        if (parentFiber.subtreeFlags & 1024)
          for (parentFiber = parentFiber.child; null !== parentFiber; ) {
            var fiber = parentFiber;
            recursivelyResetForms(fiber);
            5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();
            parentFiber = parentFiber.sibling;
          }
      }
      function recursivelyTraverseLayoutEffects(root, parentFiber) {
        if (parentFiber.subtreeFlags & 8772)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            (commitLayoutEffectOnFiber(root, parentFiber.alternate, parentFiber),
              (parentFiber = parentFiber.sibling));
      }
      function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          var finishedWork = parentFiber;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
              commitHookEffectListUnmount(4, finishedWork, finishedWork.return);
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 1:
              safelyDetachRef(finishedWork, finishedWork.return);
              var instance = finishedWork.stateNode;
              'function' === typeof instance.componentWillUnmount &&
                safelyCallComponentWillUnmount(finishedWork, finishedWork.return, instance);
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 27:
              releaseSingletonInstance(finishedWork.stateNode);
            case 26:
            case 5:
              safelyDetachRef(finishedWork, finishedWork.return);
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 22:
              null === finishedWork.memoizedState &&
                recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 30:
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            default:
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
          }
          parentFiber = parentFiber.sibling;
        }
      }
      function recursivelyTraverseReappearLayoutEffects(
        finishedRoot$jscomp$0,
        parentFiber,
        includeWorkInProgressEffects
      ) {
        includeWorkInProgressEffects =
          includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          var current = parentFiber.alternate,
            finishedRoot = finishedRoot$jscomp$0,
            finishedWork = parentFiber,
            flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              commitHookEffectListMount(4, finishedWork);
              break;
            case 1:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              current = finishedWork;
              finishedRoot = current.stateNode;
              if ('function' === typeof finishedRoot.componentDidMount)
                try {
                  finishedRoot.componentDidMount();
                } catch (error) {
                  captureCommitPhaseError(current, current.return, error);
                }
              current = finishedWork;
              finishedRoot = current.updateQueue;
              if (null !== finishedRoot) {
                var instance = current.stateNode;
                try {
                  var hiddenCallbacks = finishedRoot.shared.hiddenCallbacks;
                  if (null !== hiddenCallbacks)
                    for (
                      finishedRoot.shared.hiddenCallbacks = null, finishedRoot = 0;
                      finishedRoot < hiddenCallbacks.length;
                      finishedRoot++
                    )
                      callCallback(hiddenCallbacks[finishedRoot], instance);
                } catch (error) {
                  captureCommitPhaseError(current, current.return, error);
                }
              }
              includeWorkInProgressEffects && flags & 64 && commitClassCallbacks(finishedWork);
              safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 27:
              commitHostSingletonAcquisition(finishedWork);
            case 26:
            case 5:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects &&
                null === current &&
                flags & 4 &&
                commitHostMount(finishedWork);
              safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 12:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              break;
            case 13:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects &&
                flags & 4 &&
                commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
              break;
            case 22:
              null === finishedWork.memoizedState &&
                recursivelyTraverseReappearLayoutEffects(
                  finishedRoot,
                  finishedWork,
                  includeWorkInProgressEffects
                );
              safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 30:
              break;
            default:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
          }
          parentFiber = parentFiber.sibling;
        }
      }
      function commitOffscreenPassiveMountEffects(current, finishedWork) {
        var previousCache = null;
        null !== current &&
          null !== current.memoizedState &&
          null !== current.memoizedState.cachePool &&
          (previousCache = current.memoizedState.cachePool.pool);
        current = null;
        null !== finishedWork.memoizedState &&
          null !== finishedWork.memoizedState.cachePool &&
          (current = finishedWork.memoizedState.cachePool.pool);
        current !== previousCache &&
          (null != current && current.refCount++,
          null != previousCache && releaseCache(previousCache));
      }
      function commitCachePassiveMountEffect(current, finishedWork) {
        current = null;
        null !== finishedWork.alternate && (current = finishedWork.alternate.memoizedState.cache);
        finishedWork = finishedWork.memoizedState.cache;
        finishedWork !== current &&
          (finishedWork.refCount++, null != current && releaseCache(current));
      }
      function recursivelyTraversePassiveMountEffects(
        root,
        parentFiber,
        committedLanes,
        committedTransitions
      ) {
        if (parentFiber.subtreeFlags & 10256)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            (commitPassiveMountOnFiber(root, parentFiber, committedLanes, committedTransitions),
              (parentFiber = parentFiber.sibling));
      }
      function commitPassiveMountOnFiber(
        finishedRoot,
        finishedWork,
        committedLanes,
        committedTransitions
      ) {
        var flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            flags & 2048 && commitHookEffectListMount(9, finishedWork);
            break;
          case 1:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            break;
          case 3:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            flags & 2048 &&
              ((finishedRoot = null),
              null !== finishedWork.alternate &&
                (finishedRoot = finishedWork.alternate.memoizedState.cache),
              (finishedWork = finishedWork.memoizedState.cache),
              finishedWork !== finishedRoot &&
                (finishedWork.refCount++, null != finishedRoot && releaseCache(finishedRoot)));
            break;
          case 12:
            if (flags & 2048) {
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions
              );
              finishedRoot = finishedWork.stateNode;
              try {
                var _finishedWork$memoize2 = finishedWork.memoizedProps,
                  id = _finishedWork$memoize2.id,
                  onPostCommit = _finishedWork$memoize2.onPostCommit;
                'function' === typeof onPostCommit &&
                  onPostCommit(
                    id,
                    null === finishedWork.alternate ? 'mount' : 'update',
                    finishedRoot.passiveEffectDuration,
                    -0
                  );
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            } else
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions
              );
            break;
          case 13:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            break;
          case 23:
            break;
          case 22:
            _finishedWork$memoize2 = finishedWork.stateNode;
            id = finishedWork.alternate;
            null !== finishedWork.memoizedState
              ? _finishedWork$memoize2._visibility & 2
                ? recursivelyTraversePassiveMountEffects(
                    finishedRoot,
                    finishedWork,
                    committedLanes,
                    committedTransitions
                  )
                : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork)
              : _finishedWork$memoize2._visibility & 2
                ? recursivelyTraversePassiveMountEffects(
                    finishedRoot,
                    finishedWork,
                    committedLanes,
                    committedTransitions
                  )
                : ((_finishedWork$memoize2._visibility |= 2),
                  recursivelyTraverseReconnectPassiveEffects(
                    finishedRoot,
                    finishedWork,
                    committedLanes,
                    committedTransitions,
                    0 !== (finishedWork.subtreeFlags & 10256)
                  ));
            flags & 2048 && commitOffscreenPassiveMountEffects(id, finishedWork);
            break;
          case 24:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
            break;
          default:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
        }
      }
      function recursivelyTraverseReconnectPassiveEffects(
        finishedRoot$jscomp$0,
        parentFiber,
        committedLanes$jscomp$0,
        committedTransitions$jscomp$0,
        includeWorkInProgressEffects
      ) {
        includeWorkInProgressEffects =
          includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 10256);
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          var finishedRoot = finishedRoot$jscomp$0,
            finishedWork = parentFiber,
            committedLanes = committedLanes$jscomp$0,
            committedTransitions = committedTransitions$jscomp$0,
            flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              );
              commitHookEffectListMount(8, finishedWork);
              break;
            case 23:
              break;
            case 22:
              var instance = finishedWork.stateNode;
              null !== finishedWork.memoizedState
                ? instance._visibility & 2
                  ? recursivelyTraverseReconnectPassiveEffects(
                      finishedRoot,
                      finishedWork,
                      committedLanes,
                      committedTransitions,
                      includeWorkInProgressEffects
                    )
                  : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork)
                : ((instance._visibility |= 2),
                  recursivelyTraverseReconnectPassiveEffects(
                    finishedRoot,
                    finishedWork,
                    committedLanes,
                    committedTransitions,
                    includeWorkInProgressEffects
                  ));
              includeWorkInProgressEffects &&
                flags & 2048 &&
                commitOffscreenPassiveMountEffects(finishedWork.alternate, finishedWork);
              break;
            case 24:
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects &&
                flags & 2048 &&
                commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
              break;
            default:
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              );
          }
          parentFiber = parentFiber.sibling;
        }
      }
      function recursivelyTraverseAtomicPassiveEffects(finishedRoot$jscomp$0, parentFiber) {
        if (parentFiber.subtreeFlags & 10256)
          for (parentFiber = parentFiber.child; null !== parentFiber; ) {
            var finishedRoot = finishedRoot$jscomp$0,
              finishedWork = parentFiber,
              flags = finishedWork.flags;
            switch (finishedWork.tag) {
              case 22:
                recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
                flags & 2048 &&
                  commitOffscreenPassiveMountEffects(finishedWork.alternate, finishedWork);
                break;
              case 24:
                recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
                flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
                break;
              default:
                recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
            }
            parentFiber = parentFiber.sibling;
          }
      }
      var suspenseyCommitFlag = 8192;
      function recursivelyAccumulateSuspenseyCommit(parentFiber) {
        if (parentFiber.subtreeFlags & suspenseyCommitFlag)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            (accumulateSuspenseyCommitOnFiber(parentFiber), (parentFiber = parentFiber.sibling));
      }
      function accumulateSuspenseyCommitOnFiber(fiber) {
        switch (fiber.tag) {
          case 26:
            recursivelyAccumulateSuspenseyCommit(fiber);
            fiber.flags & suspenseyCommitFlag &&
              null !== fiber.memoizedState &&
              suspendResource(currentHoistableRoot, fiber.memoizedState, fiber.memoizedProps);
            break;
          case 5:
            recursivelyAccumulateSuspenseyCommit(fiber);
            break;
          case 3:
          case 4:
            var previousHoistableRoot = currentHoistableRoot;
            currentHoistableRoot = getHoistableRoot(fiber.stateNode.containerInfo);
            recursivelyAccumulateSuspenseyCommit(fiber);
            currentHoistableRoot = previousHoistableRoot;
            break;
          case 22:
            null === fiber.memoizedState &&
              ((previousHoistableRoot = fiber.alternate),
              null !== previousHoistableRoot && null !== previousHoistableRoot.memoizedState
                ? ((previousHoistableRoot = suspenseyCommitFlag),
                  (suspenseyCommitFlag = 16777216),
                  recursivelyAccumulateSuspenseyCommit(fiber),
                  (suspenseyCommitFlag = previousHoistableRoot))
                : recursivelyAccumulateSuspenseyCommit(fiber));
            break;
          default:
            recursivelyAccumulateSuspenseyCommit(fiber);
        }
      }
      function detachAlternateSiblings(parentFiber) {
        var previousFiber = parentFiber.alternate;
        if (null !== previousFiber && ((parentFiber = previousFiber.child), null !== parentFiber)) {
          previousFiber.child = null;
          do
            ((previousFiber = parentFiber.sibling),
              (parentFiber.sibling = null),
              (parentFiber = previousFiber));
          while (null !== parentFiber);
        }
      }
      function recursivelyTraversePassiveUnmountEffects(parentFiber) {
        var deletions = parentFiber.deletions;
        if (0 !== (parentFiber.flags & 16)) {
          if (null !== deletions)
            for (var i = 0; i < deletions.length; i++) {
              var childToDelete = deletions[i];
              nextEffect = childToDelete;
              commitPassiveUnmountEffectsInsideOfDeletedTree_begin(childToDelete, parentFiber);
            }
          detachAlternateSiblings(parentFiber);
        }
        if (parentFiber.subtreeFlags & 10256)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            (commitPassiveUnmountOnFiber(parentFiber), (parentFiber = parentFiber.sibling));
      }
      function commitPassiveUnmountOnFiber(finishedWork) {
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            recursivelyTraversePassiveUnmountEffects(finishedWork);
            finishedWork.flags & 2048 &&
              commitHookEffectListUnmount(9, finishedWork, finishedWork.return);
            break;
          case 3:
            recursivelyTraversePassiveUnmountEffects(finishedWork);
            break;
          case 12:
            recursivelyTraversePassiveUnmountEffects(finishedWork);
            break;
          case 22:
            var instance = finishedWork.stateNode;
            null !== finishedWork.memoizedState &&
            instance._visibility & 2 &&
            (null === finishedWork.return || 13 !== finishedWork.return.tag)
              ? ((instance._visibility &= -3),
                recursivelyTraverseDisconnectPassiveEffects(finishedWork))
              : recursivelyTraversePassiveUnmountEffects(finishedWork);
            break;
          default:
            recursivelyTraversePassiveUnmountEffects(finishedWork);
        }
      }
      function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
        var deletions = parentFiber.deletions;
        if (0 !== (parentFiber.flags & 16)) {
          if (null !== deletions)
            for (var i = 0; i < deletions.length; i++) {
              var childToDelete = deletions[i];
              nextEffect = childToDelete;
              commitPassiveUnmountEffectsInsideOfDeletedTree_begin(childToDelete, parentFiber);
            }
          detachAlternateSiblings(parentFiber);
        }
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          deletions = parentFiber;
          switch (deletions.tag) {
            case 0:
            case 11:
            case 15:
              commitHookEffectListUnmount(8, deletions, deletions.return);
              recursivelyTraverseDisconnectPassiveEffects(deletions);
              break;
            case 22:
              i = deletions.stateNode;
              i._visibility & 2 &&
                ((i._visibility &= -3), recursivelyTraverseDisconnectPassiveEffects(deletions));
              break;
            default:
              recursivelyTraverseDisconnectPassiveEffects(deletions);
          }
          parentFiber = parentFiber.sibling;
        }
      }
      function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
        deletedSubtreeRoot,
        nearestMountedAncestor
      ) {
        for (; null !== nextEffect; ) {
          var fiber = nextEffect;
          switch (fiber.tag) {
            case 0:
            case 11:
            case 15:
              commitHookEffectListUnmount(8, fiber, nearestMountedAncestor);
              break;
            case 23:
            case 22:
              if (null !== fiber.memoizedState && null !== fiber.memoizedState.cachePool) {
                var cache = fiber.memoizedState.cachePool.pool;
                null != cache && cache.refCount++;
              }
              break;
            case 24:
              releaseCache(fiber.memoizedState.cache);
          }
          cache = fiber.child;
          if (null !== cache) ((cache.return = fiber), (nextEffect = cache));
          else
            a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
              cache = nextEffect;
              var sibling = cache.sibling,
                returnFiber = cache.return;
              detachFiberAfterEffects(cache);
              if (cache === fiber) {
                nextEffect = null;
                break a;
              }
              if (null !== sibling) {
                sibling.return = returnFiber;
                nextEffect = sibling;
                break a;
              }
              nextEffect = returnFiber;
            }
        }
      }
      var DefaultAsyncDispatcher = {
          getCacheForType: function (resourceType) {
            var cache = readContext(CacheContext),
              cacheForType = cache.data.get(resourceType);
            void 0 === cacheForType &&
              ((cacheForType = resourceType()), cache.data.set(resourceType, cacheForType));
            return cacheForType;
          },
        },
        PossiblyWeakMap = 'function' === typeof WeakMap ? WeakMap : Map,
        executionContext = 0,
        workInProgressRoot = null,
        workInProgress = null,
        workInProgressRootRenderLanes = 0,
        workInProgressSuspendedReason = 0,
        workInProgressThrownValue = null,
        workInProgressRootDidSkipSuspendedSiblings = !1,
        workInProgressRootIsPrerendering = !1,
        workInProgressRootDidAttachPingListener = !1,
        entangledRenderLanes = 0,
        workInProgressRootExitStatus = 0,
        workInProgressRootSkippedLanes = 0,
        workInProgressRootInterleavedUpdatedLanes = 0,
        workInProgressRootPingedLanes = 0,
        workInProgressDeferredLane = 0,
        workInProgressSuspendedRetryLanes = 0,
        workInProgressRootConcurrentErrors = null,
        workInProgressRootRecoverableErrors = null,
        workInProgressRootDidIncludeRecursiveRenderUpdate = !1,
        globalMostRecentFallbackTime = 0,
        workInProgressRootRenderTargetTime = Infinity,
        workInProgressTransitions = null,
        legacyErrorBoundariesThatAlreadyFailed = null,
        pendingEffectsStatus = 0,
        pendingEffectsRoot = null,
        pendingFinishedWork = null,
        pendingEffectsLanes = 0,
        pendingEffectsRemainingLanes = 0,
        pendingPassiveTransitions = null,
        pendingRecoverableErrors = null,
        nestedUpdateCount = 0,
        rootWithNestedUpdates = null;
      function requestUpdateLane() {
        if (0 !== (executionContext & 2) && 0 !== workInProgressRootRenderLanes)
          return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;
        if (null !== ReactSharedInternals.T) {
          var actionScopeLane = currentEntangledLane;
          return 0 !== actionScopeLane ? actionScopeLane : requestTransitionLane();
        }
        return resolveUpdatePriority();
      }
      function requestDeferredLane() {
        0 === workInProgressDeferredLane &&
          (workInProgressDeferredLane =
            0 === (workInProgressRootRenderLanes & 536870912) || isHydrating
              ? claimNextTransitionLane()
              : 536870912);
        var suspenseHandler = suspenseHandlerStackCursor.current;
        null !== suspenseHandler && (suspenseHandler.flags |= 32);
        return workInProgressDeferredLane;
      }
      function scheduleUpdateOnFiber(root, fiber, lane) {
        if (
          (root === workInProgressRoot &&
            (2 === workInProgressSuspendedReason || 9 === workInProgressSuspendedReason)) ||
          null !== root.cancelPendingCommit
        )
          (prepareFreshStack(root, 0),
            markRootSuspended(root, workInProgressRootRenderLanes, workInProgressDeferredLane, !1));
        markRootUpdated$1(root, lane);
        if (0 === (executionContext & 2) || root !== workInProgressRoot)
          (root === workInProgressRoot &&
            (0 === (executionContext & 2) && (workInProgressRootInterleavedUpdatedLanes |= lane),
            4 === workInProgressRootExitStatus &&
              markRootSuspended(
                root,
                workInProgressRootRenderLanes,
                workInProgressDeferredLane,
                !1
              )),
            ensureRootIsScheduled(root));
      }
      function performWorkOnRoot(root$jscomp$0, lanes, forceSync) {
        if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
        var shouldTimeSlice =
            (!forceSync && 0 === (lanes & 124) && 0 === (lanes & root$jscomp$0.expiredLanes)) ||
            checkIfRootIsPrerendering(root$jscomp$0, lanes),
          exitStatus = shouldTimeSlice
            ? renderRootConcurrent(root$jscomp$0, lanes)
            : renderRootSync(root$jscomp$0, lanes, !0),
          renderWasConcurrent = shouldTimeSlice;
        do {
          if (0 === exitStatus) {
            workInProgressRootIsPrerendering &&
              !shouldTimeSlice &&
              markRootSuspended(root$jscomp$0, lanes, 0, !1);
            break;
          } else {
            forceSync = root$jscomp$0.current.alternate;
            if (renderWasConcurrent && !isRenderConsistentWithExternalStores(forceSync)) {
              exitStatus = renderRootSync(root$jscomp$0, lanes, !1);
              renderWasConcurrent = !1;
              continue;
            }
            if (2 === exitStatus) {
              renderWasConcurrent = lanes;
              if (root$jscomp$0.errorRecoveryDisabledLanes & renderWasConcurrent)
                var JSCompiler_inline_result = 0;
              else
                ((JSCompiler_inline_result = root$jscomp$0.pendingLanes & -536870913),
                  (JSCompiler_inline_result =
                    0 !== JSCompiler_inline_result
                      ? JSCompiler_inline_result
                      : JSCompiler_inline_result & 536870912
                        ? 536870912
                        : 0));
              if (0 !== JSCompiler_inline_result) {
                lanes = JSCompiler_inline_result;
                a: {
                  var root = root$jscomp$0;
                  exitStatus = workInProgressRootConcurrentErrors;
                  var wasRootDehydrated = root.current.memoizedState.isDehydrated;
                  wasRootDehydrated &&
                    (prepareFreshStack(root, JSCompiler_inline_result).flags |= 256);
                  JSCompiler_inline_result = renderRootSync(root, JSCompiler_inline_result, !1);
                  if (2 !== JSCompiler_inline_result) {
                    if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {
                      root.errorRecoveryDisabledLanes |= renderWasConcurrent;
                      workInProgressRootInterleavedUpdatedLanes |= renderWasConcurrent;
                      exitStatus = 4;
                      break a;
                    }
                    renderWasConcurrent = workInProgressRootRecoverableErrors;
                    workInProgressRootRecoverableErrors = exitStatus;
                    null !== renderWasConcurrent &&
                      (null === workInProgressRootRecoverableErrors
                        ? (workInProgressRootRecoverableErrors = renderWasConcurrent)
                        : workInProgressRootRecoverableErrors.push.apply(
                            workInProgressRootRecoverableErrors,
                            renderWasConcurrent
                          ));
                  }
                  exitStatus = JSCompiler_inline_result;
                }
                renderWasConcurrent = !1;
                if (2 !== exitStatus) continue;
              }
            }
            if (1 === exitStatus) {
              prepareFreshStack(root$jscomp$0, 0);
              markRootSuspended(root$jscomp$0, lanes, 0, !0);
              break;
            }
            a: {
              shouldTimeSlice = root$jscomp$0;
              renderWasConcurrent = exitStatus;
              switch (renderWasConcurrent) {
                case 0:
                case 1:
                  throw Error(formatProdErrorMessage(345));
                case 4:
                  if ((lanes & 4194048) !== lanes) break;
                case 6:
                  markRootSuspended(
                    shouldTimeSlice,
                    lanes,
                    workInProgressDeferredLane,
                    !workInProgressRootDidSkipSuspendedSiblings
                  );
                  break a;
                case 2:
                  workInProgressRootRecoverableErrors = null;
                  break;
                case 3:
                case 5:
                  break;
                default:
                  throw Error(formatProdErrorMessage(329));
              }
              if (
                (lanes & 62914560) === lanes &&
                ((exitStatus = globalMostRecentFallbackTime + 300 - now()), 10 < exitStatus)
              ) {
                markRootSuspended(
                  shouldTimeSlice,
                  lanes,
                  workInProgressDeferredLane,
                  !workInProgressRootDidSkipSuspendedSiblings
                );
                if (0 !== getNextLanes(shouldTimeSlice, 0, !0)) break a;
                shouldTimeSlice.timeoutHandle = scheduleTimeout(
                  commitRootWhenReady.bind(
                    null,
                    shouldTimeSlice,
                    forceSync,
                    workInProgressRootRecoverableErrors,
                    workInProgressTransitions,
                    workInProgressRootDidIncludeRecursiveRenderUpdate,
                    lanes,
                    workInProgressDeferredLane,
                    workInProgressRootInterleavedUpdatedLanes,
                    workInProgressSuspendedRetryLanes,
                    workInProgressRootDidSkipSuspendedSiblings,
                    renderWasConcurrent,
                    2,
                    -0,
                    0
                  ),
                  exitStatus
                );
                break a;
              }
              commitRootWhenReady(
                shouldTimeSlice,
                forceSync,
                workInProgressRootRecoverableErrors,
                workInProgressTransitions,
                workInProgressRootDidIncludeRecursiveRenderUpdate,
                lanes,
                workInProgressDeferredLane,
                workInProgressRootInterleavedUpdatedLanes,
                workInProgressSuspendedRetryLanes,
                workInProgressRootDidSkipSuspendedSiblings,
                renderWasConcurrent,
                0,
                -0,
                0
              );
            }
          }
          break;
        } while (1);
        ensureRootIsScheduled(root$jscomp$0);
      }
      function commitRootWhenReady(
        root,
        finishedWork,
        recoverableErrors,
        transitions,
        didIncludeRenderPhaseUpdate,
        lanes,
        spawnedLane,
        updatedLanes,
        suspendedRetryLanes,
        didSkipSuspendedSiblings,
        exitStatus,
        suspendedCommitReason,
        completedRenderStartTime,
        completedRenderEndTime
      ) {
        root.timeoutHandle = -1;
        suspendedCommitReason = finishedWork.subtreeFlags;
        if (suspendedCommitReason & 8192 || 16785408 === (suspendedCommitReason & 16785408))
          if (
            ((suspendedState = { stylesheets: null, count: 0, unsuspend: noop }),
            accumulateSuspenseyCommitOnFiber(finishedWork),
            (suspendedCommitReason = waitForCommitToBeReady()),
            null !== suspendedCommitReason)
          ) {
            root.cancelPendingCommit = suspendedCommitReason(
              commitRoot.bind(
                null,
                root,
                finishedWork,
                lanes,
                recoverableErrors,
                transitions,
                didIncludeRenderPhaseUpdate,
                spawnedLane,
                updatedLanes,
                suspendedRetryLanes,
                exitStatus,
                1,
                completedRenderStartTime,
                completedRenderEndTime
              )
            );
            markRootSuspended(root, lanes, spawnedLane, !didSkipSuspendedSiblings);
            return;
          }
        commitRoot(
          root,
          finishedWork,
          lanes,
          recoverableErrors,
          transitions,
          didIncludeRenderPhaseUpdate,
          spawnedLane,
          updatedLanes,
          suspendedRetryLanes
        );
      }
      function isRenderConsistentWithExternalStores(finishedWork) {
        for (var node = finishedWork; ; ) {
          var tag = node.tag;
          if (
            (0 === tag || 11 === tag || 15 === tag) &&
            node.flags & 16384 &&
            ((tag = node.updateQueue), null !== tag && ((tag = tag.stores), null !== tag))
          )
            for (var i = 0; i < tag.length; i++) {
              var check = tag[i],
                getSnapshot = check.getSnapshot;
              check = check.value;
              try {
                if (!objectIs(getSnapshot(), check)) return !1;
              } catch (error) {
                return !1;
              }
            }
          tag = node.child;
          if (node.subtreeFlags & 16384 && null !== tag) ((tag.return = node), (node = tag));
          else {
            if (node === finishedWork) break;
            for (; null === node.sibling; ) {
              if (null === node.return || node.return === finishedWork) return !0;
              node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
          }
        }
        return !0;
      }
      function markRootSuspended(root, suspendedLanes, spawnedLane, didAttemptEntireTree) {
        suspendedLanes &= ~workInProgressRootPingedLanes;
        suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
        root.suspendedLanes |= suspendedLanes;
        root.pingedLanes &= ~suspendedLanes;
        didAttemptEntireTree && (root.warmLanes |= suspendedLanes);
        didAttemptEntireTree = root.expirationTimes;
        for (var lanes = suspendedLanes; 0 < lanes; ) {
          var index$4 = 31 - clz32(lanes),
            lane = 1 << index$4;
          didAttemptEntireTree[index$4] = -1;
          lanes &= ~lane;
        }
        0 !== spawnedLane && markSpawnedDeferredLane(root, spawnedLane, suspendedLanes);
      }
      function flushSyncWork$1() {
        return 0 === (executionContext & 6) ? (flushSyncWorkAcrossRoots_impl(0, !1), !1) : !0;
      }
      function resetWorkInProgressStack() {
        if (null !== workInProgress) {
          if (0 === workInProgressSuspendedReason) var interruptedWork = workInProgress.return;
          else
            ((interruptedWork = workInProgress),
              (lastContextDependency = currentlyRenderingFiber$1 = null),
              resetHooksOnUnwind(interruptedWork),
              (thenableState = null),
              (thenableIndexCounter = 0),
              (interruptedWork = workInProgress));
          for (; null !== interruptedWork; )
            (unwindInterruptedWork(interruptedWork.alternate, interruptedWork),
              (interruptedWork = interruptedWork.return));
          workInProgress = null;
        }
      }
      function prepareFreshStack(root, lanes) {
        var timeoutHandle = root.timeoutHandle;
        -1 !== timeoutHandle && ((root.timeoutHandle = -1), cancelTimeout(timeoutHandle));
        timeoutHandle = root.cancelPendingCommit;
        null !== timeoutHandle && ((root.cancelPendingCommit = null), timeoutHandle());
        resetWorkInProgressStack();
        workInProgressRoot = root;
        workInProgress = timeoutHandle = createWorkInProgress(root.current, null);
        workInProgressRootRenderLanes = lanes;
        workInProgressSuspendedReason = 0;
        workInProgressThrownValue = null;
        workInProgressRootDidSkipSuspendedSiblings = !1;
        workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);
        workInProgressRootDidAttachPingListener = !1;
        workInProgressSuspendedRetryLanes =
          workInProgressDeferredLane =
          workInProgressRootPingedLanes =
          workInProgressRootInterleavedUpdatedLanes =
          workInProgressRootSkippedLanes =
          workInProgressRootExitStatus =
            0;
        workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = null;
        workInProgressRootDidIncludeRecursiveRenderUpdate = !1;
        0 !== (lanes & 8) && (lanes |= lanes & 32);
        var allEntangledLanes = root.entangledLanes;
        if (0 !== allEntangledLanes)
          for (root = root.entanglements, allEntangledLanes &= lanes; 0 < allEntangledLanes; ) {
            var index$2 = 31 - clz32(allEntangledLanes),
              lane = 1 << index$2;
            lanes |= root[index$2];
            allEntangledLanes &= ~lane;
          }
        entangledRenderLanes = lanes;
        finishQueueingConcurrentUpdates();
        return timeoutHandle;
      }
      function handleThrow(root, thrownValue) {
        currentlyRenderingFiber = null;
        ReactSharedInternals.H = ContextOnlyDispatcher;
        thrownValue === SuspenseException || thrownValue === SuspenseActionException
          ? ((thrownValue = getSuspendedThenable()), (workInProgressSuspendedReason = 3))
          : thrownValue === SuspenseyCommitException
            ? ((thrownValue = getSuspendedThenable()), (workInProgressSuspendedReason = 4))
            : (workInProgressSuspendedReason =
                thrownValue === SelectiveHydrationException
                  ? 8
                  : null !== thrownValue &&
                      'object' === typeof thrownValue &&
                      'function' === typeof thrownValue.then
                    ? 6
                    : 1);
        workInProgressThrownValue = thrownValue;
        null === workInProgress &&
          ((workInProgressRootExitStatus = 1),
          logUncaughtError(root, createCapturedValueAtFiber(thrownValue, root.current)));
      }
      function pushDispatcher() {
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = ContextOnlyDispatcher;
        return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
      }
      function pushAsyncDispatcher() {
        var prevAsyncDispatcher = ReactSharedInternals.A;
        ReactSharedInternals.A = DefaultAsyncDispatcher;
        return prevAsyncDispatcher;
      }
      function renderDidSuspendDelayIfPossible() {
        workInProgressRootExitStatus = 4;
        workInProgressRootDidSkipSuspendedSiblings ||
          ((workInProgressRootRenderLanes & 4194048) !== workInProgressRootRenderLanes &&
            null !== suspenseHandlerStackCursor.current) ||
          (workInProgressRootIsPrerendering = !0);
        (0 === (workInProgressRootSkippedLanes & 134217727) &&
          0 === (workInProgressRootInterleavedUpdatedLanes & 134217727)) ||
          null === workInProgressRoot ||
          markRootSuspended(
            workInProgressRoot,
            workInProgressRootRenderLanes,
            workInProgressDeferredLane,
            !1
          );
      }
      function renderRootSync(root, lanes, shouldYieldForPrerendering) {
        var prevExecutionContext = executionContext;
        executionContext |= 2;
        var prevDispatcher = pushDispatcher(),
          prevAsyncDispatcher = pushAsyncDispatcher();
        if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes)
          ((workInProgressTransitions = null), prepareFreshStack(root, lanes));
        lanes = !1;
        var exitStatus = workInProgressRootExitStatus;
        a: do
          try {
            if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
              var unitOfWork = workInProgress,
                thrownValue = workInProgressThrownValue;
              switch (workInProgressSuspendedReason) {
                case 8:
                  resetWorkInProgressStack();
                  exitStatus = 6;
                  break a;
                case 3:
                case 2:
                case 9:
                case 6:
                  null === suspenseHandlerStackCursor.current && (lanes = !0);
                  var reason = workInProgressSuspendedReason;
                  workInProgressSuspendedReason = 0;
                  workInProgressThrownValue = null;
                  throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);
                  if (shouldYieldForPrerendering && workInProgressRootIsPrerendering) {
                    exitStatus = 0;
                    break a;
                  }
                  break;
                default:
                  ((reason = workInProgressSuspendedReason),
                    (workInProgressSuspendedReason = 0),
                    (workInProgressThrownValue = null),
                    throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason));
              }
            }
            workLoopSync();
            exitStatus = workInProgressRootExitStatus;
            break;
          } catch (thrownValue$167) {
            handleThrow(root, thrownValue$167);
          }
        while (1);
        lanes && root.shellSuspendCounter++;
        lastContextDependency = currentlyRenderingFiber$1 = null;
        executionContext = prevExecutionContext;
        ReactSharedInternals.H = prevDispatcher;
        ReactSharedInternals.A = prevAsyncDispatcher;
        null === workInProgress &&
          ((workInProgressRoot = null),
          (workInProgressRootRenderLanes = 0),
          finishQueueingConcurrentUpdates());
        return exitStatus;
      }
      function workLoopSync() {
        for (; null !== workInProgress; ) performUnitOfWork(workInProgress);
      }
      function renderRootConcurrent(root, lanes) {
        var prevExecutionContext = executionContext;
        executionContext |= 2;
        var prevDispatcher = pushDispatcher(),
          prevAsyncDispatcher = pushAsyncDispatcher();
        workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes
          ? ((workInProgressTransitions = null),
            (workInProgressRootRenderTargetTime = now() + 500),
            prepareFreshStack(root, lanes))
          : (workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes));
        a: do
          try {
            if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
              lanes = workInProgress;
              var thrownValue = workInProgressThrownValue;
              b: switch (workInProgressSuspendedReason) {
                case 1:
                  workInProgressSuspendedReason = 0;
                  workInProgressThrownValue = null;
                  throwAndUnwindWorkLoop(root, lanes, thrownValue, 1);
                  break;
                case 2:
                case 9:
                  if (isThenableResolved(thrownValue)) {
                    workInProgressSuspendedReason = 0;
                    workInProgressThrownValue = null;
                    replaySuspendedUnitOfWork(lanes);
                    break;
                  }
                  lanes = function () {
                    (2 !== workInProgressSuspendedReason && 9 !== workInProgressSuspendedReason) ||
                      workInProgressRoot !== root ||
                      (workInProgressSuspendedReason = 7);
                    ensureRootIsScheduled(root);
                  };
                  thrownValue.then(lanes, lanes);
                  break a;
                case 3:
                  workInProgressSuspendedReason = 7;
                  break a;
                case 4:
                  workInProgressSuspendedReason = 5;
                  break a;
                case 7:
                  isThenableResolved(thrownValue)
                    ? ((workInProgressSuspendedReason = 0),
                      (workInProgressThrownValue = null),
                      replaySuspendedUnitOfWork(lanes))
                    : ((workInProgressSuspendedReason = 0),
                      (workInProgressThrownValue = null),
                      throwAndUnwindWorkLoop(root, lanes, thrownValue, 7));
                  break;
                case 5:
                  var resource = null;
                  switch (workInProgress.tag) {
                    case 26:
                      resource = workInProgress.memoizedState;
                    case 5:
                    case 27:
                      var hostFiber = workInProgress;
                      if (resource ? preloadResource(resource) : 1) {
                        workInProgressSuspendedReason = 0;
                        workInProgressThrownValue = null;
                        var sibling = hostFiber.sibling;
                        if (null !== sibling) workInProgress = sibling;
                        else {
                          var returnFiber = hostFiber.return;
                          null !== returnFiber
                            ? ((workInProgress = returnFiber), completeUnitOfWork(returnFiber))
                            : (workInProgress = null);
                        }
                        break b;
                      }
                  }
                  workInProgressSuspendedReason = 0;
                  workInProgressThrownValue = null;
                  throwAndUnwindWorkLoop(root, lanes, thrownValue, 5);
                  break;
                case 6:
                  workInProgressSuspendedReason = 0;
                  workInProgressThrownValue = null;
                  throwAndUnwindWorkLoop(root, lanes, thrownValue, 6);
                  break;
                case 8:
                  resetWorkInProgressStack();
                  workInProgressRootExitStatus = 6;
                  break a;
                default:
                  throw Error(formatProdErrorMessage(462));
              }
            }
            workLoopConcurrentByScheduler();
            break;
          } catch (thrownValue$169) {
            handleThrow(root, thrownValue$169);
          }
        while (1);
        lastContextDependency = currentlyRenderingFiber$1 = null;
        ReactSharedInternals.H = prevDispatcher;
        ReactSharedInternals.A = prevAsyncDispatcher;
        executionContext = prevExecutionContext;
        if (null !== workInProgress) return 0;
        workInProgressRoot = null;
        workInProgressRootRenderLanes = 0;
        finishQueueingConcurrentUpdates();
        return workInProgressRootExitStatus;
      }
      function workLoopConcurrentByScheduler() {
        for (; null !== workInProgress && !shouldYield(); ) performUnitOfWork(workInProgress);
      }
      function performUnitOfWork(unitOfWork) {
        var next = beginWork(unitOfWork.alternate, unitOfWork, entangledRenderLanes);
        unitOfWork.memoizedProps = unitOfWork.pendingProps;
        null === next ? completeUnitOfWork(unitOfWork) : (workInProgress = next);
      }
      function replaySuspendedUnitOfWork(unitOfWork) {
        var next = unitOfWork;
        var current = next.alternate;
        switch (next.tag) {
          case 15:
          case 0:
            next = replayFunctionComponent(
              current,
              next,
              next.pendingProps,
              next.type,
              void 0,
              workInProgressRootRenderLanes
            );
            break;
          case 11:
            next = replayFunctionComponent(
              current,
              next,
              next.pendingProps,
              next.type.render,
              next.ref,
              workInProgressRootRenderLanes
            );
            break;
          case 5:
            resetHooksOnUnwind(next);
          default:
            (unwindInterruptedWork(current, next),
              (next = workInProgress = resetWorkInProgress(next, entangledRenderLanes)),
              (next = beginWork(current, next, entangledRenderLanes)));
        }
        unitOfWork.memoizedProps = unitOfWork.pendingProps;
        null === next ? completeUnitOfWork(unitOfWork) : (workInProgress = next);
      }
      function throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, suspendedReason) {
        lastContextDependency = currentlyRenderingFiber$1 = null;
        resetHooksOnUnwind(unitOfWork);
        thenableState = null;
        thenableIndexCounter = 0;
        var returnFiber = unitOfWork.return;
        try {
          if (
            throwException(
              root,
              returnFiber,
              unitOfWork,
              thrownValue,
              workInProgressRootRenderLanes
            )
          ) {
            workInProgressRootExitStatus = 1;
            logUncaughtError(root, createCapturedValueAtFiber(thrownValue, root.current));
            workInProgress = null;
            return;
          }
        } catch (error) {
          if (null !== returnFiber) throw ((workInProgress = returnFiber), error);
          workInProgressRootExitStatus = 1;
          logUncaughtError(root, createCapturedValueAtFiber(thrownValue, root.current));
          workInProgress = null;
          return;
        }
        if (unitOfWork.flags & 32768) {
          if (isHydrating || 1 === suspendedReason) root = !0;
          else if (
            workInProgressRootIsPrerendering ||
            0 !== (workInProgressRootRenderLanes & 536870912)
          )
            root = !1;
          else if (
            ((workInProgressRootDidSkipSuspendedSiblings = root = !0),
            2 === suspendedReason ||
              9 === suspendedReason ||
              3 === suspendedReason ||
              6 === suspendedReason)
          )
            ((suspendedReason = suspenseHandlerStackCursor.current),
              null !== suspendedReason &&
                13 === suspendedReason.tag &&
                (suspendedReason.flags |= 16384));
          unwindUnitOfWork(unitOfWork, root);
        } else completeUnitOfWork(unitOfWork);
      }
      function completeUnitOfWork(unitOfWork) {
        var completedWork = unitOfWork;
        do {
          if (0 !== (completedWork.flags & 32768)) {
            unwindUnitOfWork(completedWork, workInProgressRootDidSkipSuspendedSiblings);
            return;
          }
          unitOfWork = completedWork.return;
          var next = completeWork(completedWork.alternate, completedWork, entangledRenderLanes);
          if (null !== next) {
            workInProgress = next;
            return;
          }
          completedWork = completedWork.sibling;
          if (null !== completedWork) {
            workInProgress = completedWork;
            return;
          }
          workInProgress = completedWork = unitOfWork;
        } while (null !== completedWork);
        0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 5);
      }
      function unwindUnitOfWork(unitOfWork, skipSiblings) {
        do {
          var next = unwindWork(unitOfWork.alternate, unitOfWork);
          if (null !== next) {
            next.flags &= 32767;
            workInProgress = next;
            return;
          }
          next = unitOfWork.return;
          null !== next &&
            ((next.flags |= 32768), (next.subtreeFlags = 0), (next.deletions = null));
          if (!skipSiblings && ((unitOfWork = unitOfWork.sibling), null !== unitOfWork)) {
            workInProgress = unitOfWork;
            return;
          }
          workInProgress = unitOfWork = next;
        } while (null !== unitOfWork);
        workInProgressRootExitStatus = 6;
        workInProgress = null;
      }
      function commitRoot(
        root,
        finishedWork,
        lanes,
        recoverableErrors,
        transitions,
        didIncludeRenderPhaseUpdate,
        spawnedLane,
        updatedLanes,
        suspendedRetryLanes
      ) {
        root.cancelPendingCommit = null;
        do flushPendingEffects();
        while (0 !== pendingEffectsStatus);
        if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
        if (null !== finishedWork) {
          if (finishedWork === root.current) throw Error(formatProdErrorMessage(177));
          didIncludeRenderPhaseUpdate = finishedWork.lanes | finishedWork.childLanes;
          didIncludeRenderPhaseUpdate |= concurrentlyUpdatedLanes;
          markRootFinished(
            root,
            lanes,
            didIncludeRenderPhaseUpdate,
            spawnedLane,
            updatedLanes,
            suspendedRetryLanes
          );
          root === workInProgressRoot &&
            ((workInProgress = workInProgressRoot = null), (workInProgressRootRenderLanes = 0));
          pendingFinishedWork = finishedWork;
          pendingEffectsRoot = root;
          pendingEffectsLanes = lanes;
          pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;
          pendingPassiveTransitions = transitions;
          pendingRecoverableErrors = recoverableErrors;
          0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256)
            ? ((root.callbackNode = null),
              (root.callbackPriority = 0),
              scheduleCallback$1(NormalPriority$1, function () {
                flushPassiveEffects(!0);
                return null;
              }))
            : ((root.callbackNode = null), (root.callbackPriority = 0));
          recoverableErrors = 0 !== (finishedWork.flags & 13878);
          if (0 !== (finishedWork.subtreeFlags & 13878) || recoverableErrors) {
            recoverableErrors = ReactSharedInternals.T;
            ReactSharedInternals.T = null;
            transitions = ReactDOMSharedInternals.p;
            ReactDOMSharedInternals.p = 2;
            spawnedLane = executionContext;
            executionContext |= 4;
            try {
              commitBeforeMutationEffects(root, finishedWork, lanes);
            } finally {
              ((executionContext = spawnedLane),
                (ReactDOMSharedInternals.p = transitions),
                (ReactSharedInternals.T = recoverableErrors));
            }
          }
          pendingEffectsStatus = 1;
          flushMutationEffects();
          flushLayoutEffects();
          flushSpawnedWork();
        }
      }
      function flushMutationEffects() {
        if (1 === pendingEffectsStatus) {
          pendingEffectsStatus = 0;
          var root = pendingEffectsRoot,
            finishedWork = pendingFinishedWork,
            rootMutationHasEffect = 0 !== (finishedWork.flags & 13878);
          if (0 !== (finishedWork.subtreeFlags & 13878) || rootMutationHasEffect) {
            rootMutationHasEffect = ReactSharedInternals.T;
            ReactSharedInternals.T = null;
            var previousPriority = ReactDOMSharedInternals.p;
            ReactDOMSharedInternals.p = 2;
            var prevExecutionContext = executionContext;
            executionContext |= 4;
            try {
              commitMutationEffectsOnFiber(finishedWork, root);
              var priorSelectionInformation = selectionInformation,
                curFocusedElem = getActiveElementDeep(root.containerInfo),
                priorFocusedElem = priorSelectionInformation.focusedElem,
                priorSelectionRange = priorSelectionInformation.selectionRange;
              if (
                curFocusedElem !== priorFocusedElem &&
                priorFocusedElem &&
                priorFocusedElem.ownerDocument &&
                containsNode(priorFocusedElem.ownerDocument.documentElement, priorFocusedElem)
              ) {
                if (null !== priorSelectionRange && hasSelectionCapabilities(priorFocusedElem)) {
                  var start = priorSelectionRange.start,
                    end = priorSelectionRange.end;
                  void 0 === end && (end = start);
                  if ('selectionStart' in priorFocusedElem)
                    ((priorFocusedElem.selectionStart = start),
                      (priorFocusedElem.selectionEnd = Math.min(
                        end,
                        priorFocusedElem.value.length
                      )));
                  else {
                    var doc = priorFocusedElem.ownerDocument || document,
                      win = (doc && doc.defaultView) || window;
                    if (win.getSelection) {
                      var selection = win.getSelection(),
                        length = priorFocusedElem.textContent.length,
                        start$jscomp$0 = Math.min(priorSelectionRange.start, length),
                        end$jscomp$0 =
                          void 0 === priorSelectionRange.end
                            ? start$jscomp$0
                            : Math.min(priorSelectionRange.end, length);
                      !selection.extend &&
                        start$jscomp$0 > end$jscomp$0 &&
                        ((curFocusedElem = end$jscomp$0),
                        (end$jscomp$0 = start$jscomp$0),
                        (start$jscomp$0 = curFocusedElem));
                      var startMarker = getNodeForCharacterOffset(priorFocusedElem, start$jscomp$0),
                        endMarker = getNodeForCharacterOffset(priorFocusedElem, end$jscomp$0);
                      if (
                        startMarker &&
                        endMarker &&
                        (1 !== selection.rangeCount ||
                          selection.anchorNode !== startMarker.node ||
                          selection.anchorOffset !== startMarker.offset ||
                          selection.focusNode !== endMarker.node ||
                          selection.focusOffset !== endMarker.offset)
                      ) {
                        var range = doc.createRange();
                        range.setStart(startMarker.node, startMarker.offset);
                        selection.removeAllRanges();
                        start$jscomp$0 > end$jscomp$0
                          ? (selection.addRange(range),
                            selection.extend(endMarker.node, endMarker.offset))
                          : (range.setEnd(endMarker.node, endMarker.offset),
                            selection.addRange(range));
                      }
                    }
                  }
                }
                doc = [];
                for (selection = priorFocusedElem; (selection = selection.parentNode); )
                  1 === selection.nodeType &&
                    doc.push({
                      element: selection,
                      left: selection.scrollLeft,
                      top: selection.scrollTop,
                    });
                'function' === typeof priorFocusedElem.focus && priorFocusedElem.focus();
                for (priorFocusedElem = 0; priorFocusedElem < doc.length; priorFocusedElem++) {
                  var info = doc[priorFocusedElem];
                  info.element.scrollLeft = info.left;
                  info.element.scrollTop = info.top;
                }
              }
              _enabled = !!eventsEnabled;
              selectionInformation = eventsEnabled = null;
            } finally {
              ((executionContext = prevExecutionContext),
                (ReactDOMSharedInternals.p = previousPriority),
                (ReactSharedInternals.T = rootMutationHasEffect));
            }
          }
          root.current = finishedWork;
          pendingEffectsStatus = 2;
        }
      }
      function flushLayoutEffects() {
        if (2 === pendingEffectsStatus) {
          pendingEffectsStatus = 0;
          var root = pendingEffectsRoot,
            finishedWork = pendingFinishedWork,
            rootHasLayoutEffect = 0 !== (finishedWork.flags & 8772);
          if (0 !== (finishedWork.subtreeFlags & 8772) || rootHasLayoutEffect) {
            rootHasLayoutEffect = ReactSharedInternals.T;
            ReactSharedInternals.T = null;
            var previousPriority = ReactDOMSharedInternals.p;
            ReactDOMSharedInternals.p = 2;
            var prevExecutionContext = executionContext;
            executionContext |= 4;
            try {
              commitLayoutEffectOnFiber(root, finishedWork.alternate, finishedWork);
            } finally {
              ((executionContext = prevExecutionContext),
                (ReactDOMSharedInternals.p = previousPriority),
                (ReactSharedInternals.T = rootHasLayoutEffect));
            }
          }
          pendingEffectsStatus = 3;
        }
      }
      function flushSpawnedWork() {
        if (4 === pendingEffectsStatus || 3 === pendingEffectsStatus) {
          pendingEffectsStatus = 0;
          requestPaint();
          var root = pendingEffectsRoot,
            finishedWork = pendingFinishedWork,
            lanes = pendingEffectsLanes,
            recoverableErrors = pendingRecoverableErrors;
          0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256)
            ? (pendingEffectsStatus = 5)
            : ((pendingEffectsStatus = 0),
              (pendingFinishedWork = pendingEffectsRoot = null),
              releaseRootPooledCache(root, root.pendingLanes));
          var remainingLanes = root.pendingLanes;
          0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
          lanesToEventPriority(lanes);
          finishedWork = finishedWork.stateNode;
          if (injectedHook && 'function' === typeof injectedHook.onCommitFiberRoot)
            try {
              injectedHook.onCommitFiberRoot(
                rendererID,
                finishedWork,
                void 0,
                128 === (finishedWork.current.flags & 128)
              );
            } catch (err) {}
          if (null !== recoverableErrors) {
            finishedWork = ReactSharedInternals.T;
            remainingLanes = ReactDOMSharedInternals.p;
            ReactDOMSharedInternals.p = 2;
            ReactSharedInternals.T = null;
            try {
              for (
                var onRecoverableError = root.onRecoverableError, i = 0;
                i < recoverableErrors.length;
                i++
              ) {
                var recoverableError = recoverableErrors[i];
                onRecoverableError(recoverableError.value, {
                  componentStack: recoverableError.stack,
                });
              }
            } finally {
              ((ReactSharedInternals.T = finishedWork),
                (ReactDOMSharedInternals.p = remainingLanes));
            }
          }
          0 !== (pendingEffectsLanes & 3) && flushPendingEffects();
          ensureRootIsScheduled(root);
          remainingLanes = root.pendingLanes;
          0 !== (lanes & 4194090) && 0 !== (remainingLanes & 42)
            ? root === rootWithNestedUpdates
              ? nestedUpdateCount++
              : ((nestedUpdateCount = 0), (rootWithNestedUpdates = root))
            : (nestedUpdateCount = 0);
          flushSyncWorkAcrossRoots_impl(0, !1);
        }
      }
      function releaseRootPooledCache(root, remainingLanes) {
        0 === (root.pooledCacheLanes &= remainingLanes) &&
          ((remainingLanes = root.pooledCache),
          null != remainingLanes && ((root.pooledCache = null), releaseCache(remainingLanes)));
      }
      function flushPendingEffects(wasDelayedCommit) {
        flushMutationEffects();
        flushLayoutEffects();
        flushSpawnedWork();
        return flushPassiveEffects(wasDelayedCommit);
      }
      function flushPassiveEffects() {
        if (5 !== pendingEffectsStatus) return !1;
        var root = pendingEffectsRoot,
          remainingLanes = pendingEffectsRemainingLanes;
        pendingEffectsRemainingLanes = 0;
        var renderPriority = lanesToEventPriority(pendingEffectsLanes),
          prevTransition = ReactSharedInternals.T,
          previousPriority = ReactDOMSharedInternals.p;
        try {
          ReactDOMSharedInternals.p = 32 > renderPriority ? 32 : renderPriority;
          ReactSharedInternals.T = null;
          renderPriority = pendingPassiveTransitions;
          pendingPassiveTransitions = null;
          var root$jscomp$0 = pendingEffectsRoot,
            lanes = pendingEffectsLanes;
          pendingEffectsStatus = 0;
          pendingFinishedWork = pendingEffectsRoot = null;
          pendingEffectsLanes = 0;
          if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(331));
          var prevExecutionContext = executionContext;
          executionContext |= 4;
          commitPassiveUnmountOnFiber(root$jscomp$0.current);
          commitPassiveMountOnFiber(root$jscomp$0, root$jscomp$0.current, lanes, renderPriority);
          executionContext = prevExecutionContext;
          flushSyncWorkAcrossRoots_impl(0, !1);
          if (injectedHook && 'function' === typeof injectedHook.onPostCommitFiberRoot)
            try {
              injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);
            } catch (err) {}
          return !0;
        } finally {
          ((ReactDOMSharedInternals.p = previousPriority),
            (ReactSharedInternals.T = prevTransition),
            releaseRootPooledCache(root, remainingLanes));
        }
      }
      function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
        sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
        sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
        rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
        null !== rootFiber && (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
      }
      function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
        if (3 === sourceFiber.tag) captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
        else
          for (; null !== nearestMountedAncestor; ) {
            if (3 === nearestMountedAncestor.tag) {
              captureCommitPhaseErrorOnRoot(nearestMountedAncestor, sourceFiber, error);
              break;
            } else if (1 === nearestMountedAncestor.tag) {
              var instance = nearestMountedAncestor.stateNode;
              if (
                'function' === typeof nearestMountedAncestor.type.getDerivedStateFromError ||
                ('function' === typeof instance.componentDidCatch &&
                  (null === legacyErrorBoundariesThatAlreadyFailed ||
                    !legacyErrorBoundariesThatAlreadyFailed.has(instance)))
              ) {
                sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
                error = createClassErrorUpdate(2);
                instance = enqueueUpdate(nearestMountedAncestor, error, 2);
                null !== instance &&
                  (initializeClassErrorUpdate(error, instance, nearestMountedAncestor, sourceFiber),
                  markRootUpdated$1(instance, 2),
                  ensureRootIsScheduled(instance));
                break;
              }
            }
            nearestMountedAncestor = nearestMountedAncestor.return;
          }
      }
      function attachPingListener(root, wakeable, lanes) {
        var pingCache = root.pingCache;
        if (null === pingCache) {
          pingCache = root.pingCache = new PossiblyWeakMap();
          var threadIDs = new Set();
          pingCache.set(wakeable, threadIDs);
        } else
          ((threadIDs = pingCache.get(wakeable)),
            void 0 === threadIDs && ((threadIDs = new Set()), pingCache.set(wakeable, threadIDs)));
        threadIDs.has(lanes) ||
          ((workInProgressRootDidAttachPingListener = !0),
          threadIDs.add(lanes),
          (root = pingSuspendedRoot.bind(null, root, wakeable, lanes)),
          wakeable.then(root, root));
      }
      function pingSuspendedRoot(root, wakeable, pingedLanes) {
        var pingCache = root.pingCache;
        null !== pingCache && pingCache.delete(wakeable);
        root.pingedLanes |= root.suspendedLanes & pingedLanes;
        root.warmLanes &= ~pingedLanes;
        workInProgressRoot === root &&
          (workInProgressRootRenderLanes & pingedLanes) === pingedLanes &&
          (4 === workInProgressRootExitStatus ||
          (3 === workInProgressRootExitStatus &&
            (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes &&
            300 > now() - globalMostRecentFallbackTime)
            ? 0 === (executionContext & 2) && prepareFreshStack(root, 0)
            : (workInProgressRootPingedLanes |= pingedLanes),
          workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes &&
            (workInProgressSuspendedRetryLanes = 0));
        ensureRootIsScheduled(root);
      }
      function retryTimedOutBoundary(boundaryFiber, retryLane) {
        0 === retryLane && (retryLane = claimNextRetryLane());
        boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
        null !== boundaryFiber &&
          (markRootUpdated$1(boundaryFiber, retryLane), ensureRootIsScheduled(boundaryFiber));
      }
      function retryDehydratedSuspenseBoundary(boundaryFiber) {
        var suspenseState = boundaryFiber.memoizedState,
          retryLane = 0;
        null !== suspenseState && (retryLane = suspenseState.retryLane);
        retryTimedOutBoundary(boundaryFiber, retryLane);
      }
      function resolveRetryWakeable(boundaryFiber, wakeable) {
        var retryLane = 0;
        switch (boundaryFiber.tag) {
          case 13:
            var retryCache = boundaryFiber.stateNode;
            var suspenseState = boundaryFiber.memoizedState;
            null !== suspenseState && (retryLane = suspenseState.retryLane);
            break;
          case 19:
            retryCache = boundaryFiber.stateNode;
            break;
          case 22:
            retryCache = boundaryFiber.stateNode._retryCache;
            break;
          default:
            throw Error(formatProdErrorMessage(314));
        }
        null !== retryCache && retryCache.delete(wakeable);
        retryTimedOutBoundary(boundaryFiber, retryLane);
      }
      function scheduleCallback$1(priorityLevel, callback) {
        return scheduleCallback$3(priorityLevel, callback);
      }
      var firstScheduledRoot = null,
        lastScheduledRoot = null,
        didScheduleMicrotask = !1,
        mightHavePendingSyncWork = !1,
        isFlushingWork = !1,
        currentEventTransitionLane = 0;
      function ensureRootIsScheduled(root) {
        root !== lastScheduledRoot &&
          null === root.next &&
          (null === lastScheduledRoot
            ? (firstScheduledRoot = lastScheduledRoot = root)
            : (lastScheduledRoot = lastScheduledRoot.next = root));
        mightHavePendingSyncWork = !0;
        didScheduleMicrotask || ((didScheduleMicrotask = !0), scheduleImmediateRootScheduleTask());
      }
      function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
        if (!isFlushingWork && mightHavePendingSyncWork) {
          isFlushingWork = !0;
          do {
            var didPerformSomeWork = !1;
            for (var root$174 = firstScheduledRoot; null !== root$174; ) {
              if (!onlyLegacy)
                if (0 !== syncTransitionLanes) {
                  var pendingLanes = root$174.pendingLanes;
                  if (0 === pendingLanes) var JSCompiler_inline_result = 0;
                  else {
                    var suspendedLanes = root$174.suspendedLanes,
                      pingedLanes = root$174.pingedLanes;
                    JSCompiler_inline_result =
                      (1 << (31 - clz32(42 | syncTransitionLanes) + 1)) - 1;
                    JSCompiler_inline_result &= pendingLanes & ~(suspendedLanes & ~pingedLanes);
                    JSCompiler_inline_result =
                      JSCompiler_inline_result & 201326741
                        ? (JSCompiler_inline_result & 201326741) | 1
                        : JSCompiler_inline_result
                          ? JSCompiler_inline_result | 2
                          : 0;
                  }
                  0 !== JSCompiler_inline_result &&
                    ((didPerformSomeWork = !0),
                    performSyncWorkOnRoot(root$174, JSCompiler_inline_result));
                } else
                  ((JSCompiler_inline_result = workInProgressRootRenderLanes),
                    (JSCompiler_inline_result = getNextLanes(
                      root$174,
                      root$174 === workInProgressRoot ? JSCompiler_inline_result : 0,
                      null !== root$174.cancelPendingCommit || -1 !== root$174.timeoutHandle
                    )),
                    0 === (JSCompiler_inline_result & 3) ||
                      checkIfRootIsPrerendering(root$174, JSCompiler_inline_result) ||
                      ((didPerformSomeWork = !0),
                      performSyncWorkOnRoot(root$174, JSCompiler_inline_result)));
              root$174 = root$174.next;
            }
          } while (didPerformSomeWork);
          isFlushingWork = !1;
        }
      }
      function processRootScheduleInImmediateTask() {
        processRootScheduleInMicrotask();
      }
      function processRootScheduleInMicrotask() {
        mightHavePendingSyncWork = didScheduleMicrotask = !1;
        var syncTransitionLanes = 0;
        0 !== currentEventTransitionLane &&
          (shouldAttemptEagerTransition() && (syncTransitionLanes = currentEventTransitionLane),
          (currentEventTransitionLane = 0));
        for (var currentTime = now(), prev = null, root = firstScheduledRoot; null !== root; ) {
          var next = root.next,
            nextLanes = scheduleTaskForRootDuringMicrotask(root, currentTime);
          if (0 === nextLanes)
            ((root.next = null),
              null === prev ? (firstScheduledRoot = next) : (prev.next = next),
              null === next && (lastScheduledRoot = prev));
          else if (((prev = root), 0 !== syncTransitionLanes || 0 !== (nextLanes & 3)))
            mightHavePendingSyncWork = !0;
          root = next;
        }
        flushSyncWorkAcrossRoots_impl(syncTransitionLanes, !1);
      }
      function scheduleTaskForRootDuringMicrotask(root, currentTime) {
        for (
          var suspendedLanes = root.suspendedLanes,
            pingedLanes = root.pingedLanes,
            expirationTimes = root.expirationTimes,
            lanes = root.pendingLanes & -62914561;
          0 < lanes;

        ) {
          var index$3 = 31 - clz32(lanes),
            lane = 1 << index$3,
            expirationTime = expirationTimes[index$3];
          if (-1 === expirationTime) {
            if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes))
              expirationTimes[index$3] = computeExpirationTime(lane, currentTime);
          } else expirationTime <= currentTime && (root.expiredLanes |= lane);
          lanes &= ~lane;
        }
        currentTime = workInProgressRoot;
        suspendedLanes = workInProgressRootRenderLanes;
        suspendedLanes = getNextLanes(
          root,
          root === currentTime ? suspendedLanes : 0,
          null !== root.cancelPendingCommit || -1 !== root.timeoutHandle
        );
        pingedLanes = root.callbackNode;
        if (
          0 === suspendedLanes ||
          (root === currentTime &&
            (2 === workInProgressSuspendedReason || 9 === workInProgressSuspendedReason)) ||
          null !== root.cancelPendingCommit
        )
          return (
            null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes),
            (root.callbackNode = null),
            (root.callbackPriority = 0)
          );
        if (0 === (suspendedLanes & 3) || checkIfRootIsPrerendering(root, suspendedLanes)) {
          currentTime = suspendedLanes & -suspendedLanes;
          if (currentTime === root.callbackPriority) return currentTime;
          null !== pingedLanes && cancelCallback$1(pingedLanes);
          switch (lanesToEventPriority(suspendedLanes)) {
            case 2:
            case 8:
              suspendedLanes = UserBlockingPriority;
              break;
            case 32:
              suspendedLanes = NormalPriority$1;
              break;
            case 268435456:
              suspendedLanes = IdlePriority;
              break;
            default:
              suspendedLanes = NormalPriority$1;
          }
          pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root);
          suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
          root.callbackPriority = currentTime;
          root.callbackNode = suspendedLanes;
          return currentTime;
        }
        null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes);
        root.callbackPriority = 2;
        root.callbackNode = null;
        return 2;
      }
      function performWorkOnRootViaSchedulerTask(root, didTimeout) {
        if (0 !== pendingEffectsStatus && 5 !== pendingEffectsStatus)
          return ((root.callbackNode = null), (root.callbackPriority = 0), null);
        var originalCallbackNode = root.callbackNode;
        if (flushPendingEffects(!0) && root.callbackNode !== originalCallbackNode) return null;
        var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;
        workInProgressRootRenderLanes$jscomp$0 = getNextLanes(
          root,
          root === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0,
          null !== root.cancelPendingCommit || -1 !== root.timeoutHandle
        );
        if (0 === workInProgressRootRenderLanes$jscomp$0) return null;
        performWorkOnRoot(root, workInProgressRootRenderLanes$jscomp$0, didTimeout);
        scheduleTaskForRootDuringMicrotask(root, now());
        return null != root.callbackNode && root.callbackNode === originalCallbackNode
          ? performWorkOnRootViaSchedulerTask.bind(null, root)
          : null;
      }
      function performSyncWorkOnRoot(root, lanes) {
        if (flushPendingEffects()) return null;
        performWorkOnRoot(root, lanes, !0);
      }
      function scheduleImmediateRootScheduleTask() {
        scheduleMicrotask(function () {
          0 !== (executionContext & 6)
            ? scheduleCallback$3(ImmediatePriority, processRootScheduleInImmediateTask)
            : processRootScheduleInMicrotask();
        });
      }
      function requestTransitionLane() {
        0 === currentEventTransitionLane &&
          (currentEventTransitionLane = claimNextTransitionLane());
        return currentEventTransitionLane;
      }
      function coerceFormActionProp(actionProp) {
        return null == actionProp ||
          'symbol' === typeof actionProp ||
          'boolean' === typeof actionProp
          ? null
          : 'function' === typeof actionProp
            ? actionProp
            : sanitizeURL('' + actionProp);
      }
      function createFormDataWithSubmitter(form, submitter) {
        var temp = submitter.ownerDocument.createElement('input');
        temp.name = submitter.name;
        temp.value = submitter.value;
        form.id && temp.setAttribute('form', form.id);
        submitter.parentNode.insertBefore(temp, submitter);
        form = new FormData(form);
        temp.parentNode.removeChild(temp);
        return form;
      }
      function extractEvents$1(
        dispatchQueue,
        domEventName,
        maybeTargetInst,
        nativeEvent,
        nativeEventTarget
      ) {
        if (
          'submit' === domEventName &&
          maybeTargetInst &&
          maybeTargetInst.stateNode === nativeEventTarget
        ) {
          var action = coerceFormActionProp((nativeEventTarget[internalPropsKey] || null).action),
            submitter = nativeEvent.submitter;
          submitter &&
            ((domEventName = (domEventName = submitter[internalPropsKey] || null)
              ? coerceFormActionProp(domEventName.formAction)
              : submitter.getAttribute('formAction')),
            null !== domEventName && ((action = domEventName), (submitter = null)));
          var event = new SyntheticEvent('action', 'action', null, nativeEvent, nativeEventTarget);
          dispatchQueue.push({
            event: event,
            listeners: [
              {
                instance: null,
                listener: function () {
                  if (nativeEvent.defaultPrevented) {
                    if (0 !== currentEventTransitionLane) {
                      var formData = submitter
                        ? createFormDataWithSubmitter(nativeEventTarget, submitter)
                        : new FormData(nativeEventTarget);
                      startHostTransition(
                        maybeTargetInst,
                        {
                          pending: !0,
                          data: formData,
                          method: nativeEventTarget.method,
                          action: action,
                        },
                        null,
                        formData
                      );
                    }
                  } else
                    'function' === typeof action &&
                      (event.preventDefault(),
                      (formData = submitter
                        ? createFormDataWithSubmitter(nativeEventTarget, submitter)
                        : new FormData(nativeEventTarget)),
                      startHostTransition(
                        maybeTargetInst,
                        {
                          pending: !0,
                          data: formData,
                          method: nativeEventTarget.method,
                          action: action,
                        },
                        action,
                        formData
                      ));
                },
                currentTarget: nativeEventTarget,
              },
            ],
          });
        }
      }
      for (
        var i$jscomp$inline_1528 = 0;
        i$jscomp$inline_1528 < simpleEventPluginEvents.length;
        i$jscomp$inline_1528++
      ) {
        var eventName$jscomp$inline_1529 = simpleEventPluginEvents[i$jscomp$inline_1528],
          domEventName$jscomp$inline_1530 = eventName$jscomp$inline_1529.toLowerCase(),
          capitalizedEvent$jscomp$inline_1531 =
            eventName$jscomp$inline_1529[0].toUpperCase() + eventName$jscomp$inline_1529.slice(1);
        registerSimpleEvent(
          domEventName$jscomp$inline_1530,
          'on' + capitalizedEvent$jscomp$inline_1531
        );
      }
      registerSimpleEvent(ANIMATION_END, 'onAnimationEnd');
      registerSimpleEvent(ANIMATION_ITERATION, 'onAnimationIteration');
      registerSimpleEvent(ANIMATION_START, 'onAnimationStart');
      registerSimpleEvent('dblclick', 'onDoubleClick');
      registerSimpleEvent('focusin', 'onFocus');
      registerSimpleEvent('focusout', 'onBlur');
      registerSimpleEvent(TRANSITION_RUN, 'onTransitionRun');
      registerSimpleEvent(TRANSITION_START, 'onTransitionStart');
      registerSimpleEvent(TRANSITION_CANCEL, 'onTransitionCancel');
      registerSimpleEvent(TRANSITION_END, 'onTransitionEnd');
      registerDirectEvent('onMouseEnter', ['mouseout', 'mouseover']);
      registerDirectEvent('onMouseLeave', ['mouseout', 'mouseover']);
      registerDirectEvent('onPointerEnter', ['pointerout', 'pointerover']);
      registerDirectEvent('onPointerLeave', ['pointerout', 'pointerover']);
      registerTwoPhaseEvent(
        'onChange',
        'change click focusin focusout input keydown keyup selectionchange'.split(' ')
      );
      registerTwoPhaseEvent(
        'onSelect',
        'focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange'.split(
          ' '
        )
      );
      registerTwoPhaseEvent('onBeforeInput', ['compositionend', 'keypress', 'textInput', 'paste']);
      registerTwoPhaseEvent(
        'onCompositionEnd',
        'compositionend focusout keydown keypress keyup mousedown'.split(' ')
      );
      registerTwoPhaseEvent(
        'onCompositionStart',
        'compositionstart focusout keydown keypress keyup mousedown'.split(' ')
      );
      registerTwoPhaseEvent(
        'onCompositionUpdate',
        'compositionupdate focusout keydown keypress keyup mousedown'.split(' ')
      );
      var mediaEventTypes =
          'abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting'.split(
            ' '
          ),
        nonDelegatedEvents = new Set(
          'beforetoggle cancel close invalid load scroll scrollend toggle'
            .split(' ')
            .concat(mediaEventTypes)
        );
      function processDispatchQueue(dispatchQueue, eventSystemFlags) {
        eventSystemFlags = 0 !== (eventSystemFlags & 4);
        for (var i = 0; i < dispatchQueue.length; i++) {
          var _dispatchQueue$i = dispatchQueue[i],
            event = _dispatchQueue$i.event;
          _dispatchQueue$i = _dispatchQueue$i.listeners;
          a: {
            var previousInstance = void 0;
            if (eventSystemFlags)
              for (var i$jscomp$0 = _dispatchQueue$i.length - 1; 0 <= i$jscomp$0; i$jscomp$0--) {
                var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0],
                  instance = _dispatchListeners$i.instance,
                  currentTarget = _dispatchListeners$i.currentTarget;
                _dispatchListeners$i = _dispatchListeners$i.listener;
                if (instance !== previousInstance && event.isPropagationStopped()) break a;
                previousInstance = _dispatchListeners$i;
                event.currentTarget = currentTarget;
                try {
                  previousInstance(event);
                } catch (error) {
                  reportGlobalError(error);
                }
                event.currentTarget = null;
                previousInstance = instance;
              }
            else
              for (i$jscomp$0 = 0; i$jscomp$0 < _dispatchQueue$i.length; i$jscomp$0++) {
                _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];
                instance = _dispatchListeners$i.instance;
                currentTarget = _dispatchListeners$i.currentTarget;
                _dispatchListeners$i = _dispatchListeners$i.listener;
                if (instance !== previousInstance && event.isPropagationStopped()) break a;
                previousInstance = _dispatchListeners$i;
                event.currentTarget = currentTarget;
                try {
                  previousInstance(event);
                } catch (error) {
                  reportGlobalError(error);
                }
                event.currentTarget = null;
                previousInstance = instance;
              }
          }
        }
      }
      function listenToNonDelegatedEvent(domEventName, targetElement) {
        var JSCompiler_inline_result = targetElement[internalEventHandlersKey];
        void 0 === JSCompiler_inline_result &&
          (JSCompiler_inline_result = targetElement[internalEventHandlersKey] = new Set());
        var listenerSetKey = domEventName + '__bubble';
        JSCompiler_inline_result.has(listenerSetKey) ||
          (addTrappedEventListener(targetElement, domEventName, 2, !1),
          JSCompiler_inline_result.add(listenerSetKey));
      }
      function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
        var eventSystemFlags = 0;
        isCapturePhaseListener && (eventSystemFlags |= 4);
        addTrappedEventListener(target, domEventName, eventSystemFlags, isCapturePhaseListener);
      }
      var listeningMarker = '_reactListening' + Math.random().toString(36).slice(2);
      function listenToAllSupportedEvents(rootContainerElement) {
        if (!rootContainerElement[listeningMarker]) {
          rootContainerElement[listeningMarker] = !0;
          allNativeEvents.forEach(function (domEventName) {
            'selectionchange' !== domEventName &&
              (nonDelegatedEvents.has(domEventName) ||
                listenToNativeEvent(domEventName, !1, rootContainerElement),
              listenToNativeEvent(domEventName, !0, rootContainerElement));
          });
          var ownerDocument =
            9 === rootContainerElement.nodeType
              ? rootContainerElement
              : rootContainerElement.ownerDocument;
          null === ownerDocument ||
            ownerDocument[listeningMarker] ||
            ((ownerDocument[listeningMarker] = !0),
            listenToNativeEvent('selectionchange', !1, ownerDocument));
        }
      }
      function addTrappedEventListener(
        targetContainer,
        domEventName,
        eventSystemFlags,
        isCapturePhaseListener
      ) {
        switch (getEventPriority(domEventName)) {
          case 2:
            var listenerWrapper = dispatchDiscreteEvent;
            break;
          case 8:
            listenerWrapper = dispatchContinuousEvent;
            break;
          default:
            listenerWrapper = dispatchEvent;
        }
        eventSystemFlags = listenerWrapper.bind(
          null,
          domEventName,
          eventSystemFlags,
          targetContainer
        );
        listenerWrapper = void 0;
        !passiveBrowserEventsSupported ||
          ('touchstart' !== domEventName &&
            'touchmove' !== domEventName &&
            'wheel' !== domEventName) ||
          (listenerWrapper = !0);
        isCapturePhaseListener
          ? void 0 !== listenerWrapper
            ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
                capture: !0,
                passive: listenerWrapper,
              })
            : targetContainer.addEventListener(domEventName, eventSystemFlags, !0)
          : void 0 !== listenerWrapper
            ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
                passive: listenerWrapper,
              })
            : targetContainer.addEventListener(domEventName, eventSystemFlags, !1);
      }
      function dispatchEventForPluginEventSystem(
        domEventName,
        eventSystemFlags,
        nativeEvent,
        targetInst$jscomp$0,
        targetContainer
      ) {
        var ancestorInst = targetInst$jscomp$0;
        if (
          0 === (eventSystemFlags & 1) &&
          0 === (eventSystemFlags & 2) &&
          null !== targetInst$jscomp$0
        )
          a: for (;;) {
            if (null === targetInst$jscomp$0) return;
            var nodeTag = targetInst$jscomp$0.tag;
            if (3 === nodeTag || 4 === nodeTag) {
              var container = targetInst$jscomp$0.stateNode.containerInfo;
              if (container === targetContainer) break;
              if (4 === nodeTag)
                for (nodeTag = targetInst$jscomp$0.return; null !== nodeTag; ) {
                  var grandTag = nodeTag.tag;
                  if (
                    (3 === grandTag || 4 === grandTag) &&
                    nodeTag.stateNode.containerInfo === targetContainer
                  )
                    return;
                  nodeTag = nodeTag.return;
                }
              for (; null !== container; ) {
                nodeTag = getClosestInstanceFromNode(container);
                if (null === nodeTag) return;
                grandTag = nodeTag.tag;
                if (5 === grandTag || 6 === grandTag || 26 === grandTag || 27 === grandTag) {
                  targetInst$jscomp$0 = ancestorInst = nodeTag;
                  continue a;
                }
                container = container.parentNode;
              }
            }
            targetInst$jscomp$0 = targetInst$jscomp$0.return;
          }
        batchedUpdates$1(function () {
          var targetInst = ancestorInst,
            nativeEventTarget = getEventTarget(nativeEvent),
            dispatchQueue = [];
          a: {
            var reactName = topLevelEventsToReactNames.get(domEventName);
            if (void 0 !== reactName) {
              var SyntheticEventCtor = SyntheticEvent,
                reactEventType = domEventName;
              switch (domEventName) {
                case 'keypress':
                  if (0 === getEventCharCode(nativeEvent)) break a;
                case 'keydown':
                case 'keyup':
                  SyntheticEventCtor = SyntheticKeyboardEvent;
                  break;
                case 'focusin':
                  reactEventType = 'focus';
                  SyntheticEventCtor = SyntheticFocusEvent;
                  break;
                case 'focusout':
                  reactEventType = 'blur';
                  SyntheticEventCtor = SyntheticFocusEvent;
                  break;
                case 'beforeblur':
                case 'afterblur':
                  SyntheticEventCtor = SyntheticFocusEvent;
                  break;
                case 'click':
                  if (2 === nativeEvent.button) break a;
                case 'auxclick':
                case 'dblclick':
                case 'mousedown':
                case 'mousemove':
                case 'mouseup':
                case 'mouseout':
                case 'mouseover':
                case 'contextmenu':
                  SyntheticEventCtor = SyntheticMouseEvent;
                  break;
                case 'drag':
                case 'dragend':
                case 'dragenter':
                case 'dragexit':
                case 'dragleave':
                case 'dragover':
                case 'dragstart':
                case 'drop':
                  SyntheticEventCtor = SyntheticDragEvent;
                  break;
                case 'touchcancel':
                case 'touchend':
                case 'touchmove':
                case 'touchstart':
                  SyntheticEventCtor = SyntheticTouchEvent;
                  break;
                case ANIMATION_END:
                case ANIMATION_ITERATION:
                case ANIMATION_START:
                  SyntheticEventCtor = SyntheticAnimationEvent;
                  break;
                case TRANSITION_END:
                  SyntheticEventCtor = SyntheticTransitionEvent;
                  break;
                case 'scroll':
                case 'scrollend':
                  SyntheticEventCtor = SyntheticUIEvent;
                  break;
                case 'wheel':
                  SyntheticEventCtor = SyntheticWheelEvent;
                  break;
                case 'copy':
                case 'cut':
                case 'paste':
                  SyntheticEventCtor = SyntheticClipboardEvent;
                  break;
                case 'gotpointercapture':
                case 'lostpointercapture':
                case 'pointercancel':
                case 'pointerdown':
                case 'pointermove':
                case 'pointerout':
                case 'pointerover':
                case 'pointerup':
                  SyntheticEventCtor = SyntheticPointerEvent;
                  break;
                case 'toggle':
                case 'beforetoggle':
                  SyntheticEventCtor = SyntheticToggleEvent;
              }
              var inCapturePhase = 0 !== (eventSystemFlags & 4),
                accumulateTargetOnly =
                  !inCapturePhase && ('scroll' === domEventName || 'scrollend' === domEventName),
                reactEventName = inCapturePhase
                  ? null !== reactName
                    ? reactName + 'Capture'
                    : null
                  : reactName;
              inCapturePhase = [];
              for (var instance = targetInst, lastHostComponent; null !== instance; ) {
                var _instance = instance;
                lastHostComponent = _instance.stateNode;
                _instance = _instance.tag;
                (5 !== _instance && 26 !== _instance && 27 !== _instance) ||
                  null === lastHostComponent ||
                  null === reactEventName ||
                  ((_instance = getListener(instance, reactEventName)),
                  null != _instance &&
                    inCapturePhase.push(
                      createDispatchListener(instance, _instance, lastHostComponent)
                    ));
                if (accumulateTargetOnly) break;
                instance = instance.return;
              }
              0 < inCapturePhase.length &&
                ((reactName = new SyntheticEventCtor(
                  reactName,
                  reactEventType,
                  null,
                  nativeEvent,
                  nativeEventTarget
                )),
                dispatchQueue.push({ event: reactName, listeners: inCapturePhase }));
            }
          }
          if (0 === (eventSystemFlags & 7)) {
            a: {
              reactName = 'mouseover' === domEventName || 'pointerover' === domEventName;
              SyntheticEventCtor = 'mouseout' === domEventName || 'pointerout' === domEventName;
              if (
                reactName &&
                nativeEvent !== currentReplayingEvent &&
                (reactEventType = nativeEvent.relatedTarget || nativeEvent.fromElement) &&
                (getClosestInstanceFromNode(reactEventType) ||
                  reactEventType[internalContainerInstanceKey])
              )
                break a;
              if (SyntheticEventCtor || reactName) {
                reactName =
                  nativeEventTarget.window === nativeEventTarget
                    ? nativeEventTarget
                    : (reactName = nativeEventTarget.ownerDocument)
                      ? reactName.defaultView || reactName.parentWindow
                      : window;
                if (SyntheticEventCtor) {
                  if (
                    ((reactEventType = nativeEvent.relatedTarget || nativeEvent.toElement),
                    (SyntheticEventCtor = targetInst),
                    (reactEventType = reactEventType
                      ? getClosestInstanceFromNode(reactEventType)
                      : null),
                    null !== reactEventType &&
                      ((accumulateTargetOnly = getNearestMountedFiber(reactEventType)),
                      (inCapturePhase = reactEventType.tag),
                      reactEventType !== accumulateTargetOnly ||
                        (5 !== inCapturePhase && 27 !== inCapturePhase && 6 !== inCapturePhase)))
                  )
                    reactEventType = null;
                } else ((SyntheticEventCtor = null), (reactEventType = targetInst));
                if (SyntheticEventCtor !== reactEventType) {
                  inCapturePhase = SyntheticMouseEvent;
                  _instance = 'onMouseLeave';
                  reactEventName = 'onMouseEnter';
                  instance = 'mouse';
                  if ('pointerout' === domEventName || 'pointerover' === domEventName)
                    ((inCapturePhase = SyntheticPointerEvent),
                      (_instance = 'onPointerLeave'),
                      (reactEventName = 'onPointerEnter'),
                      (instance = 'pointer'));
                  accumulateTargetOnly =
                    null == SyntheticEventCtor
                      ? reactName
                      : getNodeFromInstance(SyntheticEventCtor);
                  lastHostComponent =
                    null == reactEventType ? reactName : getNodeFromInstance(reactEventType);
                  reactName = new inCapturePhase(
                    _instance,
                    instance + 'leave',
                    SyntheticEventCtor,
                    nativeEvent,
                    nativeEventTarget
                  );
                  reactName.target = accumulateTargetOnly;
                  reactName.relatedTarget = lastHostComponent;
                  _instance = null;
                  getClosestInstanceFromNode(nativeEventTarget) === targetInst &&
                    ((inCapturePhase = new inCapturePhase(
                      reactEventName,
                      instance + 'enter',
                      reactEventType,
                      nativeEvent,
                      nativeEventTarget
                    )),
                    (inCapturePhase.target = lastHostComponent),
                    (inCapturePhase.relatedTarget = accumulateTargetOnly),
                    (_instance = inCapturePhase));
                  accumulateTargetOnly = _instance;
                  if (SyntheticEventCtor && reactEventType)
                    b: {
                      inCapturePhase = SyntheticEventCtor;
                      reactEventName = reactEventType;
                      instance = 0;
                      for (
                        lastHostComponent = inCapturePhase;
                        lastHostComponent;
                        lastHostComponent = getParent(lastHostComponent)
                      )
                        instance++;
                      lastHostComponent = 0;
                      for (_instance = reactEventName; _instance; _instance = getParent(_instance))
                        lastHostComponent++;
                      for (; 0 < instance - lastHostComponent; )
                        ((inCapturePhase = getParent(inCapturePhase)), instance--);
                      for (; 0 < lastHostComponent - instance; )
                        ((reactEventName = getParent(reactEventName)), lastHostComponent--);
                      for (; instance--; ) {
                        if (
                          inCapturePhase === reactEventName ||
                          (null !== reactEventName && inCapturePhase === reactEventName.alternate)
                        )
                          break b;
                        inCapturePhase = getParent(inCapturePhase);
                        reactEventName = getParent(reactEventName);
                      }
                      inCapturePhase = null;
                    }
                  else inCapturePhase = null;
                  null !== SyntheticEventCtor &&
                    accumulateEnterLeaveListenersForEvent(
                      dispatchQueue,
                      reactName,
                      SyntheticEventCtor,
                      inCapturePhase,
                      !1
                    );
                  null !== reactEventType &&
                    null !== accumulateTargetOnly &&
                    accumulateEnterLeaveListenersForEvent(
                      dispatchQueue,
                      accumulateTargetOnly,
                      reactEventType,
                      inCapturePhase,
                      !0
                    );
                }
              }
            }
            a: {
              reactName = targetInst ? getNodeFromInstance(targetInst) : window;
              SyntheticEventCtor = reactName.nodeName && reactName.nodeName.toLowerCase();
              if (
                'select' === SyntheticEventCtor ||
                ('input' === SyntheticEventCtor && 'file' === reactName.type)
              )
                var getTargetInstFunc = getTargetInstForChangeEvent;
              else if (isTextInputElement(reactName))
                if (isInputEventSupported) getTargetInstFunc = getTargetInstForInputOrChangeEvent;
                else {
                  getTargetInstFunc = getTargetInstForInputEventPolyfill;
                  var handleEventFunc = handleEventsForInputEventPolyfill;
                }
              else
                ((SyntheticEventCtor = reactName.nodeName),
                  !SyntheticEventCtor ||
                  'input' !== SyntheticEventCtor.toLowerCase() ||
                  ('checkbox' !== reactName.type && 'radio' !== reactName.type)
                    ? targetInst &&
                      isCustomElement(targetInst.elementType) &&
                      (getTargetInstFunc = getTargetInstForChangeEvent)
                    : (getTargetInstFunc = getTargetInstForClickEvent));
              if (
                getTargetInstFunc &&
                (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))
              ) {
                createAndAccumulateChangeEvent(
                  dispatchQueue,
                  getTargetInstFunc,
                  nativeEvent,
                  nativeEventTarget
                );
                break a;
              }
              handleEventFunc && handleEventFunc(domEventName, reactName, targetInst);
              'focusout' === domEventName &&
                targetInst &&
                'number' === reactName.type &&
                null != targetInst.memoizedProps.value &&
                setDefaultValue(reactName, 'number', reactName.value);
            }
            handleEventFunc = targetInst ? getNodeFromInstance(targetInst) : window;
            switch (domEventName) {
              case 'focusin':
                if (
                  isTextInputElement(handleEventFunc) ||
                  'true' === handleEventFunc.contentEditable
                )
                  ((activeElement = handleEventFunc),
                    (activeElementInst = targetInst),
                    (lastSelection = null));
                break;
              case 'focusout':
                lastSelection = activeElementInst = activeElement = null;
                break;
              case 'mousedown':
                mouseDown = !0;
                break;
              case 'contextmenu':
              case 'mouseup':
              case 'dragend':
                mouseDown = !1;
                constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
                break;
              case 'selectionchange':
                if (skipSelectionChangeEvent) break;
              case 'keydown':
              case 'keyup':
                constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
            }
            var fallbackData;
            if (canUseCompositionEvent)
              b: {
                switch (domEventName) {
                  case 'compositionstart':
                    var eventType = 'onCompositionStart';
                    break b;
                  case 'compositionend':
                    eventType = 'onCompositionEnd';
                    break b;
                  case 'compositionupdate':
                    eventType = 'onCompositionUpdate';
                    break b;
                }
                eventType = void 0;
              }
            else
              isComposing
                ? isFallbackCompositionEnd(domEventName, nativeEvent) &&
                  (eventType = 'onCompositionEnd')
                : 'keydown' === domEventName &&
                  229 === nativeEvent.keyCode &&
                  (eventType = 'onCompositionStart');
            eventType &&
              (useFallbackCompositionData &&
                'ko' !== nativeEvent.locale &&
                (isComposing || 'onCompositionStart' !== eventType
                  ? 'onCompositionEnd' === eventType && isComposing && (fallbackData = getData())
                  : ((root = nativeEventTarget),
                    (startText = 'value' in root ? root.value : root.textContent),
                    (isComposing = !0))),
              (handleEventFunc = accumulateTwoPhaseListeners(targetInst, eventType)),
              0 < handleEventFunc.length &&
                ((eventType = new SyntheticCompositionEvent(
                  eventType,
                  domEventName,
                  null,
                  nativeEvent,
                  nativeEventTarget
                )),
                dispatchQueue.push({ event: eventType, listeners: handleEventFunc }),
                fallbackData
                  ? (eventType.data = fallbackData)
                  : ((fallbackData = getDataFromCustomEvent(nativeEvent)),
                    null !== fallbackData && (eventType.data = fallbackData))));
            if (
              (fallbackData = canUseTextInputEvent
                ? getNativeBeforeInputChars(domEventName, nativeEvent)
                : getFallbackBeforeInputChars(domEventName, nativeEvent))
            )
              ((eventType = accumulateTwoPhaseListeners(targetInst, 'onBeforeInput')),
                0 < eventType.length &&
                  ((handleEventFunc = new SyntheticCompositionEvent(
                    'onBeforeInput',
                    'beforeinput',
                    null,
                    nativeEvent,
                    nativeEventTarget
                  )),
                  dispatchQueue.push({
                    event: handleEventFunc,
                    listeners: eventType,
                  }),
                  (handleEventFunc.data = fallbackData)));
            extractEvents$1(
              dispatchQueue,
              domEventName,
              targetInst,
              nativeEvent,
              nativeEventTarget
            );
          }
          processDispatchQueue(dispatchQueue, eventSystemFlags);
        });
      }
      function createDispatchListener(instance, listener, currentTarget) {
        return {
          instance: instance,
          listener: listener,
          currentTarget: currentTarget,
        };
      }
      function accumulateTwoPhaseListeners(targetFiber, reactName) {
        for (var captureName = reactName + 'Capture', listeners = []; null !== targetFiber; ) {
          var _instance2 = targetFiber,
            stateNode = _instance2.stateNode;
          _instance2 = _instance2.tag;
          (5 !== _instance2 && 26 !== _instance2 && 27 !== _instance2) ||
            null === stateNode ||
            ((_instance2 = getListener(targetFiber, captureName)),
            null != _instance2 &&
              listeners.unshift(createDispatchListener(targetFiber, _instance2, stateNode)),
            (_instance2 = getListener(targetFiber, reactName)),
            null != _instance2 &&
              listeners.push(createDispatchListener(targetFiber, _instance2, stateNode)));
          if (3 === targetFiber.tag) return listeners;
          targetFiber = targetFiber.return;
        }
        return [];
      }
      function getParent(inst) {
        if (null === inst) return null;
        do inst = inst.return;
        while (inst && 5 !== inst.tag && 27 !== inst.tag);
        return inst ? inst : null;
      }
      function accumulateEnterLeaveListenersForEvent(
        dispatchQueue,
        event,
        target,
        common,
        inCapturePhase
      ) {
        for (
          var registrationName = event._reactName, listeners = [];
          null !== target && target !== common;

        ) {
          var _instance3 = target,
            alternate = _instance3.alternate,
            stateNode = _instance3.stateNode;
          _instance3 = _instance3.tag;
          if (null !== alternate && alternate === common) break;
          (5 !== _instance3 && 26 !== _instance3 && 27 !== _instance3) ||
            null === stateNode ||
            ((alternate = stateNode),
            inCapturePhase
              ? ((stateNode = getListener(target, registrationName)),
                null != stateNode &&
                  listeners.unshift(createDispatchListener(target, stateNode, alternate)))
              : inCapturePhase ||
                ((stateNode = getListener(target, registrationName)),
                null != stateNode &&
                  listeners.push(createDispatchListener(target, stateNode, alternate))));
          target = target.return;
        }
        0 !== listeners.length && dispatchQueue.push({ event: event, listeners: listeners });
      }
      var NORMALIZE_NEWLINES_REGEX = /\r\n?/g,
        NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
      function normalizeMarkupForTextOrAttribute(markup) {
        return ('string' === typeof markup ? markup : '' + markup)
          .replace(NORMALIZE_NEWLINES_REGEX, '\n')
          .replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, '');
      }
      function checkForUnmatchedText(serverText, clientText) {
        clientText = normalizeMarkupForTextOrAttribute(clientText);
        return normalizeMarkupForTextOrAttribute(serverText) === clientText ? !0 : !1;
      }
      function noop$1() {}
      function setProp(domElement, tag, key, value, props, prevValue) {
        switch (key) {
          case 'children':
            'string' === typeof value
              ? 'body' === tag ||
                ('textarea' === tag && '' === value) ||
                setTextContent(domElement, value)
              : ('number' === typeof value || 'bigint' === typeof value) &&
                'body' !== tag &&
                setTextContent(domElement, '' + value);
            break;
          case 'className':
            setValueForKnownAttribute(domElement, 'class', value);
            break;
          case 'tabIndex':
            setValueForKnownAttribute(domElement, 'tabindex', value);
            break;
          case 'dir':
          case 'role':
          case 'viewBox':
          case 'width':
          case 'height':
            setValueForKnownAttribute(domElement, key, value);
            break;
          case 'style':
            setValueForStyles(domElement, value, prevValue);
            break;
          case 'data':
            if ('object' !== tag) {
              setValueForKnownAttribute(domElement, 'data', value);
              break;
            }
          case 'src':
          case 'href':
            if ('' === value && ('a' !== tag || 'href' !== key)) {
              domElement.removeAttribute(key);
              break;
            }
            if (
              null == value ||
              'function' === typeof value ||
              'symbol' === typeof value ||
              'boolean' === typeof value
            ) {
              domElement.removeAttribute(key);
              break;
            }
            value = sanitizeURL('' + value);
            domElement.setAttribute(key, value);
            break;
          case 'action':
          case 'formAction':
            if ('function' === typeof value) {
              domElement.setAttribute(
                key,
                "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
              );
              break;
            } else
              'function' === typeof prevValue &&
                ('formAction' === key
                  ? ('input' !== tag && setProp(domElement, tag, 'name', props.name, props, null),
                    setProp(domElement, tag, 'formEncType', props.formEncType, props, null),
                    setProp(domElement, tag, 'formMethod', props.formMethod, props, null),
                    setProp(domElement, tag, 'formTarget', props.formTarget, props, null))
                  : (setProp(domElement, tag, 'encType', props.encType, props, null),
                    setProp(domElement, tag, 'method', props.method, props, null),
                    setProp(domElement, tag, 'target', props.target, props, null)));
            if (null == value || 'symbol' === typeof value || 'boolean' === typeof value) {
              domElement.removeAttribute(key);
              break;
            }
            value = sanitizeURL('' + value);
            domElement.setAttribute(key, value);
            break;
          case 'onClick':
            null != value && (domElement.onclick = noop$1);
            break;
          case 'onScroll':
            null != value && listenToNonDelegatedEvent('scroll', domElement);
            break;
          case 'onScrollEnd':
            null != value && listenToNonDelegatedEvent('scrollend', domElement);
            break;
          case 'dangerouslySetInnerHTML':
            if (null != value) {
              if ('object' !== typeof value || !('__html' in value))
                throw Error(formatProdErrorMessage(61));
              key = value.__html;
              if (null != key) {
                if (null != props.children) throw Error(formatProdErrorMessage(60));
                domElement.innerHTML = key;
              }
            }
            break;
          case 'multiple':
            domElement.multiple = value && 'function' !== typeof value && 'symbol' !== typeof value;
            break;
          case 'muted':
            domElement.muted = value && 'function' !== typeof value && 'symbol' !== typeof value;
            break;
          case 'suppressContentEditableWarning':
          case 'suppressHydrationWarning':
          case 'defaultValue':
          case 'defaultChecked':
          case 'innerHTML':
          case 'ref':
            break;
          case 'autoFocus':
            break;
          case 'xlinkHref':
            if (
              null == value ||
              'function' === typeof value ||
              'boolean' === typeof value ||
              'symbol' === typeof value
            ) {
              domElement.removeAttribute('xlink:href');
              break;
            }
            key = sanitizeURL('' + value);
            domElement.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', key);
            break;
          case 'contentEditable':
          case 'spellCheck':
          case 'draggable':
          case 'value':
          case 'autoReverse':
          case 'externalResourcesRequired':
          case 'focusable':
          case 'preserveAlpha':
            null != value && 'function' !== typeof value && 'symbol' !== typeof value
              ? domElement.setAttribute(key, '' + value)
              : domElement.removeAttribute(key);
            break;
          case 'inert':
          case 'allowFullScreen':
          case 'async':
          case 'autoPlay':
          case 'controls':
          case 'default':
          case 'defer':
          case 'disabled':
          case 'disablePictureInPicture':
          case 'disableRemotePlayback':
          case 'formNoValidate':
          case 'hidden':
          case 'loop':
          case 'noModule':
          case 'noValidate':
          case 'open':
          case 'playsInline':
          case 'readOnly':
          case 'required':
          case 'reversed':
          case 'scoped':
          case 'seamless':
          case 'itemScope':
            value && 'function' !== typeof value && 'symbol' !== typeof value
              ? domElement.setAttribute(key, '')
              : domElement.removeAttribute(key);
            break;
          case 'capture':
          case 'download':
            !0 === value
              ? domElement.setAttribute(key, '')
              : !1 !== value &&
                  null != value &&
                  'function' !== typeof value &&
                  'symbol' !== typeof value
                ? domElement.setAttribute(key, value)
                : domElement.removeAttribute(key);
            break;
          case 'cols':
          case 'rows':
          case 'size':
          case 'span':
            null != value &&
            'function' !== typeof value &&
            'symbol' !== typeof value &&
            !isNaN(value) &&
            1 <= value
              ? domElement.setAttribute(key, value)
              : domElement.removeAttribute(key);
            break;
          case 'rowSpan':
          case 'start':
            null == value ||
            'function' === typeof value ||
            'symbol' === typeof value ||
            isNaN(value)
              ? domElement.removeAttribute(key)
              : domElement.setAttribute(key, value);
            break;
          case 'popover':
            listenToNonDelegatedEvent('beforetoggle', domElement);
            listenToNonDelegatedEvent('toggle', domElement);
            setValueForAttribute(domElement, 'popover', value);
            break;
          case 'xlinkActuate':
            setValueForNamespacedAttribute(
              domElement,
              'http://www.w3.org/1999/xlink',
              'xlink:actuate',
              value
            );
            break;
          case 'xlinkArcrole':
            setValueForNamespacedAttribute(
              domElement,
              'http://www.w3.org/1999/xlink',
              'xlink:arcrole',
              value
            );
            break;
          case 'xlinkRole':
            setValueForNamespacedAttribute(
              domElement,
              'http://www.w3.org/1999/xlink',
              'xlink:role',
              value
            );
            break;
          case 'xlinkShow':
            setValueForNamespacedAttribute(
              domElement,
              'http://www.w3.org/1999/xlink',
              'xlink:show',
              value
            );
            break;
          case 'xlinkTitle':
            setValueForNamespacedAttribute(
              domElement,
              'http://www.w3.org/1999/xlink',
              'xlink:title',
              value
            );
            break;
          case 'xlinkType':
            setValueForNamespacedAttribute(
              domElement,
              'http://www.w3.org/1999/xlink',
              'xlink:type',
              value
            );
            break;
          case 'xmlBase':
            setValueForNamespacedAttribute(
              domElement,
              'http://www.w3.org/XML/1998/namespace',
              'xml:base',
              value
            );
            break;
          case 'xmlLang':
            setValueForNamespacedAttribute(
              domElement,
              'http://www.w3.org/XML/1998/namespace',
              'xml:lang',
              value
            );
            break;
          case 'xmlSpace':
            setValueForNamespacedAttribute(
              domElement,
              'http://www.w3.org/XML/1998/namespace',
              'xml:space',
              value
            );
            break;
          case 'is':
            setValueForAttribute(domElement, 'is', value);
            break;
          case 'innerText':
          case 'textContent':
            break;
          default:
            if (
              !(2 < key.length) ||
              ('o' !== key[0] && 'O' !== key[0]) ||
              ('n' !== key[1] && 'N' !== key[1])
            )
              ((key = aliases.get(key) || key), setValueForAttribute(domElement, key, value));
        }
      }
      function setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {
        switch (key) {
          case 'style':
            setValueForStyles(domElement, value, prevValue);
            break;
          case 'dangerouslySetInnerHTML':
            if (null != value) {
              if ('object' !== typeof value || !('__html' in value))
                throw Error(formatProdErrorMessage(61));
              key = value.__html;
              if (null != key) {
                if (null != props.children) throw Error(formatProdErrorMessage(60));
                domElement.innerHTML = key;
              }
            }
            break;
          case 'children':
            'string' === typeof value
              ? setTextContent(domElement, value)
              : ('number' === typeof value || 'bigint' === typeof value) &&
                setTextContent(domElement, '' + value);
            break;
          case 'onScroll':
            null != value && listenToNonDelegatedEvent('scroll', domElement);
            break;
          case 'onScrollEnd':
            null != value && listenToNonDelegatedEvent('scrollend', domElement);
            break;
          case 'onClick':
            null != value && (domElement.onclick = noop$1);
            break;
          case 'suppressContentEditableWarning':
          case 'suppressHydrationWarning':
          case 'innerHTML':
          case 'ref':
            break;
          case 'innerText':
          case 'textContent':
            break;
          default:
            if (!registrationNameDependencies.hasOwnProperty(key))
              a: {
                if (
                  'o' === key[0] &&
                  'n' === key[1] &&
                  ((props = key.endsWith('Capture')),
                  (tag = key.slice(2, props ? key.length - 7 : void 0)),
                  (prevValue = domElement[internalPropsKey] || null),
                  (prevValue = null != prevValue ? prevValue[key] : null),
                  'function' === typeof prevValue &&
                    domElement.removeEventListener(tag, prevValue, props),
                  'function' === typeof value)
                ) {
                  'function' !== typeof prevValue &&
                    null !== prevValue &&
                    (key in domElement
                      ? (domElement[key] = null)
                      : domElement.hasAttribute(key) && domElement.removeAttribute(key));
                  domElement.addEventListener(tag, value, props);
                  break a;
                }
                key in domElement
                  ? (domElement[key] = value)
                  : !0 === value
                    ? domElement.setAttribute(key, '')
                    : setValueForAttribute(domElement, key, value);
              }
        }
      }
      function setInitialProperties(domElement, tag, props) {
        switch (tag) {
          case 'div':
          case 'span':
          case 'svg':
          case 'path':
          case 'a':
          case 'g':
          case 'p':
          case 'li':
            break;
          case 'img':
            listenToNonDelegatedEvent('error', domElement);
            listenToNonDelegatedEvent('load', domElement);
            var hasSrc = !1,
              hasSrcSet = !1,
              propKey;
            for (propKey in props)
              if (props.hasOwnProperty(propKey)) {
                var propValue = props[propKey];
                if (null != propValue)
                  switch (propKey) {
                    case 'src':
                      hasSrc = !0;
                      break;
                    case 'srcSet':
                      hasSrcSet = !0;
                      break;
                    case 'children':
                    case 'dangerouslySetInnerHTML':
                      throw Error(formatProdErrorMessage(137, tag));
                    default:
                      setProp(domElement, tag, propKey, propValue, props, null);
                  }
              }
            hasSrcSet && setProp(domElement, tag, 'srcSet', props.srcSet, props, null);
            hasSrc && setProp(domElement, tag, 'src', props.src, props, null);
            return;
          case 'input':
            listenToNonDelegatedEvent('invalid', domElement);
            var defaultValue = (propKey = propValue = hasSrcSet = null),
              checked = null,
              defaultChecked = null;
            for (hasSrc in props)
              if (props.hasOwnProperty(hasSrc)) {
                var propValue$188 = props[hasSrc];
                if (null != propValue$188)
                  switch (hasSrc) {
                    case 'name':
                      hasSrcSet = propValue$188;
                      break;
                    case 'type':
                      propValue = propValue$188;
                      break;
                    case 'checked':
                      checked = propValue$188;
                      break;
                    case 'defaultChecked':
                      defaultChecked = propValue$188;
                      break;
                    case 'value':
                      propKey = propValue$188;
                      break;
                    case 'defaultValue':
                      defaultValue = propValue$188;
                      break;
                    case 'children':
                    case 'dangerouslySetInnerHTML':
                      if (null != propValue$188) throw Error(formatProdErrorMessage(137, tag));
                      break;
                    default:
                      setProp(domElement, tag, hasSrc, propValue$188, props, null);
                  }
              }
            initInput(
              domElement,
              propKey,
              defaultValue,
              checked,
              defaultChecked,
              propValue,
              hasSrcSet,
              !1
            );
            track(domElement);
            return;
          case 'select':
            listenToNonDelegatedEvent('invalid', domElement);
            hasSrc = propValue = propKey = null;
            for (hasSrcSet in props)
              if (
                props.hasOwnProperty(hasSrcSet) &&
                ((defaultValue = props[hasSrcSet]), null != defaultValue)
              )
                switch (hasSrcSet) {
                  case 'value':
                    propKey = defaultValue;
                    break;
                  case 'defaultValue':
                    propValue = defaultValue;
                    break;
                  case 'multiple':
                    hasSrc = defaultValue;
                  default:
                    setProp(domElement, tag, hasSrcSet, defaultValue, props, null);
                }
            tag = propKey;
            props = propValue;
            domElement.multiple = !!hasSrc;
            null != tag
              ? updateOptions(domElement, !!hasSrc, tag, !1)
              : null != props && updateOptions(domElement, !!hasSrc, props, !0);
            return;
          case 'textarea':
            listenToNonDelegatedEvent('invalid', domElement);
            propKey = hasSrcSet = hasSrc = null;
            for (propValue in props)
              if (
                props.hasOwnProperty(propValue) &&
                ((defaultValue = props[propValue]), null != defaultValue)
              )
                switch (propValue) {
                  case 'value':
                    hasSrc = defaultValue;
                    break;
                  case 'defaultValue':
                    hasSrcSet = defaultValue;
                    break;
                  case 'children':
                    propKey = defaultValue;
                    break;
                  case 'dangerouslySetInnerHTML':
                    if (null != defaultValue) throw Error(formatProdErrorMessage(91));
                    break;
                  default:
                    setProp(domElement, tag, propValue, defaultValue, props, null);
                }
            initTextarea(domElement, hasSrc, hasSrcSet, propKey);
            track(domElement);
            return;
          case 'option':
            for (checked in props)
              if (props.hasOwnProperty(checked) && ((hasSrc = props[checked]), null != hasSrc))
                switch (checked) {
                  case 'selected':
                    domElement.selected =
                      hasSrc && 'function' !== typeof hasSrc && 'symbol' !== typeof hasSrc;
                    break;
                  default:
                    setProp(domElement, tag, checked, hasSrc, props, null);
                }
            return;
          case 'dialog':
            listenToNonDelegatedEvent('beforetoggle', domElement);
            listenToNonDelegatedEvent('toggle', domElement);
            listenToNonDelegatedEvent('cancel', domElement);
            listenToNonDelegatedEvent('close', domElement);
            break;
          case 'iframe':
          case 'object':
            listenToNonDelegatedEvent('load', domElement);
            break;
          case 'video':
          case 'audio':
            for (hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++)
              listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);
            break;
          case 'image':
            listenToNonDelegatedEvent('error', domElement);
            listenToNonDelegatedEvent('load', domElement);
            break;
          case 'details':
            listenToNonDelegatedEvent('toggle', domElement);
            break;
          case 'embed':
          case 'source':
          case 'link':
            (listenToNonDelegatedEvent('error', domElement),
              listenToNonDelegatedEvent('load', domElement));
          case 'area':
          case 'base':
          case 'br':
          case 'col':
          case 'hr':
          case 'keygen':
          case 'meta':
          case 'param':
          case 'track':
          case 'wbr':
          case 'menuitem':
            for (defaultChecked in props)
              if (
                props.hasOwnProperty(defaultChecked) &&
                ((hasSrc = props[defaultChecked]), null != hasSrc)
              )
                switch (defaultChecked) {
                  case 'children':
                  case 'dangerouslySetInnerHTML':
                    throw Error(formatProdErrorMessage(137, tag));
                  default:
                    setProp(domElement, tag, defaultChecked, hasSrc, props, null);
                }
            return;
          default:
            if (isCustomElement(tag)) {
              for (propValue$188 in props)
                props.hasOwnProperty(propValue$188) &&
                  ((hasSrc = props[propValue$188]),
                  void 0 !== hasSrc &&
                    setPropOnCustomElement(domElement, tag, propValue$188, hasSrc, props, void 0));
              return;
            }
        }
        for (defaultValue in props)
          props.hasOwnProperty(defaultValue) &&
            ((hasSrc = props[defaultValue]),
            null != hasSrc && setProp(domElement, tag, defaultValue, hasSrc, props, null));
      }
      function updateProperties(domElement, tag, lastProps, nextProps) {
        switch (tag) {
          case 'div':
          case 'span':
          case 'svg':
          case 'path':
          case 'a':
          case 'g':
          case 'p':
          case 'li':
            break;
          case 'input':
            var name = null,
              type = null,
              value = null,
              defaultValue = null,
              lastDefaultValue = null,
              checked = null,
              defaultChecked = null;
            for (propKey in lastProps) {
              var lastProp = lastProps[propKey];
              if (lastProps.hasOwnProperty(propKey) && null != lastProp)
                switch (propKey) {
                  case 'checked':
                    break;
                  case 'value':
                    break;
                  case 'defaultValue':
                    lastDefaultValue = lastProp;
                  default:
                    nextProps.hasOwnProperty(propKey) ||
                      setProp(domElement, tag, propKey, null, nextProps, lastProp);
                }
            }
            for (var propKey$205 in nextProps) {
              var propKey = nextProps[propKey$205];
              lastProp = lastProps[propKey$205];
              if (nextProps.hasOwnProperty(propKey$205) && (null != propKey || null != lastProp))
                switch (propKey$205) {
                  case 'type':
                    type = propKey;
                    break;
                  case 'name':
                    name = propKey;
                    break;
                  case 'checked':
                    checked = propKey;
                    break;
                  case 'defaultChecked':
                    defaultChecked = propKey;
                    break;
                  case 'value':
                    value = propKey;
                    break;
                  case 'defaultValue':
                    defaultValue = propKey;
                    break;
                  case 'children':
                  case 'dangerouslySetInnerHTML':
                    if (null != propKey) throw Error(formatProdErrorMessage(137, tag));
                    break;
                  default:
                    propKey !== lastProp &&
                      setProp(domElement, tag, propKey$205, propKey, nextProps, lastProp);
                }
            }
            updateInput(
              domElement,
              value,
              defaultValue,
              lastDefaultValue,
              checked,
              defaultChecked,
              type,
              name
            );
            return;
          case 'select':
            propKey = value = defaultValue = propKey$205 = null;
            for (type in lastProps)
              if (
                ((lastDefaultValue = lastProps[type]),
                lastProps.hasOwnProperty(type) && null != lastDefaultValue)
              )
                switch (type) {
                  case 'value':
                    break;
                  case 'multiple':
                    propKey = lastDefaultValue;
                  default:
                    nextProps.hasOwnProperty(type) ||
                      setProp(domElement, tag, type, null, nextProps, lastDefaultValue);
                }
            for (name in nextProps)
              if (
                ((type = nextProps[name]),
                (lastDefaultValue = lastProps[name]),
                nextProps.hasOwnProperty(name) && (null != type || null != lastDefaultValue))
              )
                switch (name) {
                  case 'value':
                    propKey$205 = type;
                    break;
                  case 'defaultValue':
                    defaultValue = type;
                    break;
                  case 'multiple':
                    value = type;
                  default:
                    type !== lastDefaultValue &&
                      setProp(domElement, tag, name, type, nextProps, lastDefaultValue);
                }
            tag = defaultValue;
            lastProps = value;
            nextProps = propKey;
            null != propKey$205
              ? updateOptions(domElement, !!lastProps, propKey$205, !1)
              : !!nextProps !== !!lastProps &&
                (null != tag
                  ? updateOptions(domElement, !!lastProps, tag, !0)
                  : updateOptions(domElement, !!lastProps, lastProps ? [] : '', !1));
            return;
          case 'textarea':
            propKey = propKey$205 = null;
            for (defaultValue in lastProps)
              if (
                ((name = lastProps[defaultValue]),
                lastProps.hasOwnProperty(defaultValue) &&
                  null != name &&
                  !nextProps.hasOwnProperty(defaultValue))
              )
                switch (defaultValue) {
                  case 'value':
                    break;
                  case 'children':
                    break;
                  default:
                    setProp(domElement, tag, defaultValue, null, nextProps, name);
                }
            for (value in nextProps)
              if (
                ((name = nextProps[value]),
                (type = lastProps[value]),
                nextProps.hasOwnProperty(value) && (null != name || null != type))
              )
                switch (value) {
                  case 'value':
                    propKey$205 = name;
                    break;
                  case 'defaultValue':
                    propKey = name;
                    break;
                  case 'children':
                    break;
                  case 'dangerouslySetInnerHTML':
                    if (null != name) throw Error(formatProdErrorMessage(91));
                    break;
                  default:
                    name !== type && setProp(domElement, tag, value, name, nextProps, type);
                }
            updateTextarea(domElement, propKey$205, propKey);
            return;
          case 'option':
            for (var propKey$221 in lastProps)
              if (
                ((propKey$205 = lastProps[propKey$221]),
                lastProps.hasOwnProperty(propKey$221) &&
                  null != propKey$205 &&
                  !nextProps.hasOwnProperty(propKey$221))
              )
                switch (propKey$221) {
                  case 'selected':
                    domElement.selected = !1;
                    break;
                  default:
                    setProp(domElement, tag, propKey$221, null, nextProps, propKey$205);
                }
            for (lastDefaultValue in nextProps)
              if (
                ((propKey$205 = nextProps[lastDefaultValue]),
                (propKey = lastProps[lastDefaultValue]),
                nextProps.hasOwnProperty(lastDefaultValue) &&
                  propKey$205 !== propKey &&
                  (null != propKey$205 || null != propKey))
              )
                switch (lastDefaultValue) {
                  case 'selected':
                    domElement.selected =
                      propKey$205 &&
                      'function' !== typeof propKey$205 &&
                      'symbol' !== typeof propKey$205;
                    break;
                  default:
                    setProp(domElement, tag, lastDefaultValue, propKey$205, nextProps, propKey);
                }
            return;
          case 'img':
          case 'link':
          case 'area':
          case 'base':
          case 'br':
          case 'col':
          case 'embed':
          case 'hr':
          case 'keygen':
          case 'meta':
          case 'param':
          case 'source':
          case 'track':
          case 'wbr':
          case 'menuitem':
            for (var propKey$226 in lastProps)
              ((propKey$205 = lastProps[propKey$226]),
                lastProps.hasOwnProperty(propKey$226) &&
                  null != propKey$205 &&
                  !nextProps.hasOwnProperty(propKey$226) &&
                  setProp(domElement, tag, propKey$226, null, nextProps, propKey$205));
            for (checked in nextProps)
              if (
                ((propKey$205 = nextProps[checked]),
                (propKey = lastProps[checked]),
                nextProps.hasOwnProperty(checked) &&
                  propKey$205 !== propKey &&
                  (null != propKey$205 || null != propKey))
              )
                switch (checked) {
                  case 'children':
                  case 'dangerouslySetInnerHTML':
                    if (null != propKey$205) throw Error(formatProdErrorMessage(137, tag));
                    break;
                  default:
                    setProp(domElement, tag, checked, propKey$205, nextProps, propKey);
                }
            return;
          default:
            if (isCustomElement(tag)) {
              for (var propKey$231 in lastProps)
                ((propKey$205 = lastProps[propKey$231]),
                  lastProps.hasOwnProperty(propKey$231) &&
                    void 0 !== propKey$205 &&
                    !nextProps.hasOwnProperty(propKey$231) &&
                    setPropOnCustomElement(
                      domElement,
                      tag,
                      propKey$231,
                      void 0,
                      nextProps,
                      propKey$205
                    ));
              for (defaultChecked in nextProps)
                ((propKey$205 = nextProps[defaultChecked]),
                  (propKey = lastProps[defaultChecked]),
                  !nextProps.hasOwnProperty(defaultChecked) ||
                    propKey$205 === propKey ||
                    (void 0 === propKey$205 && void 0 === propKey) ||
                    setPropOnCustomElement(
                      domElement,
                      tag,
                      defaultChecked,
                      propKey$205,
                      nextProps,
                      propKey
                    ));
              return;
            }
        }
        for (var propKey$236 in lastProps)
          ((propKey$205 = lastProps[propKey$236]),
            lastProps.hasOwnProperty(propKey$236) &&
              null != propKey$205 &&
              !nextProps.hasOwnProperty(propKey$236) &&
              setProp(domElement, tag, propKey$236, null, nextProps, propKey$205));
        for (lastProp in nextProps)
          ((propKey$205 = nextProps[lastProp]),
            (propKey = lastProps[lastProp]),
            !nextProps.hasOwnProperty(lastProp) ||
              propKey$205 === propKey ||
              (null == propKey$205 && null == propKey) ||
              setProp(domElement, tag, lastProp, propKey$205, nextProps, propKey));
      }
      var eventsEnabled = null,
        selectionInformation = null;
      function getOwnerDocumentFromRootContainer(rootContainerElement) {
        return 9 === rootContainerElement.nodeType
          ? rootContainerElement
          : rootContainerElement.ownerDocument;
      }
      function getOwnHostContext(namespaceURI) {
        switch (namespaceURI) {
          case 'http://www.w3.org/2000/svg':
            return 1;
          case 'http://www.w3.org/1998/Math/MathML':
            return 2;
          default:
            return 0;
        }
      }
      function getChildHostContextProd(parentNamespace, type) {
        if (0 === parentNamespace)
          switch (type) {
            case 'svg':
              return 1;
            case 'math':
              return 2;
            default:
              return 0;
          }
        return 1 === parentNamespace && 'foreignObject' === type ? 0 : parentNamespace;
      }
      function shouldSetTextContent(type, props) {
        return (
          'textarea' === type ||
          'noscript' === type ||
          'string' === typeof props.children ||
          'number' === typeof props.children ||
          'bigint' === typeof props.children ||
          ('object' === typeof props.dangerouslySetInnerHTML &&
            null !== props.dangerouslySetInnerHTML &&
            null != props.dangerouslySetInnerHTML.__html)
        );
      }
      var currentPopstateTransitionEvent = null;
      function shouldAttemptEagerTransition() {
        var event = window.event;
        if (event && 'popstate' === event.type) {
          if (event === currentPopstateTransitionEvent) return !1;
          currentPopstateTransitionEvent = event;
          return !0;
        }
        currentPopstateTransitionEvent = null;
        return !1;
      }
      var scheduleTimeout = 'function' === typeof setTimeout ? setTimeout : void 0,
        cancelTimeout = 'function' === typeof clearTimeout ? clearTimeout : void 0,
        localPromise = 'function' === typeof Promise ? Promise : void 0,
        scheduleMicrotask =
          'function' === typeof queueMicrotask
            ? queueMicrotask
            : 'undefined' !== typeof localPromise
              ? function (callback) {
                  return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
                }
              : scheduleTimeout;
      function handleErrorInNextTick(error) {
        setTimeout(function () {
          throw error;
        });
      }
      function isSingletonScope(type) {
        return 'head' === type;
      }
      function clearSuspenseBoundary(parentInstance, suspenseInstance) {
        var node = suspenseInstance,
          possiblePreambleContribution = 0,
          depth = 0;
        do {
          var nextNode = node.nextSibling;
          parentInstance.removeChild(node);
          if (nextNode && 8 === nextNode.nodeType)
            if (((node = nextNode.data), '/$' === node)) {
              if (0 < possiblePreambleContribution && 8 > possiblePreambleContribution) {
                node = possiblePreambleContribution;
                var ownerDocument = parentInstance.ownerDocument;
                node & 1 && releaseSingletonInstance(ownerDocument.documentElement);
                node & 2 && releaseSingletonInstance(ownerDocument.body);
                if (node & 4)
                  for (
                    node = ownerDocument.head,
                      releaseSingletonInstance(node),
                      ownerDocument = node.firstChild;
                    ownerDocument;

                  ) {
                    var nextNode$jscomp$0 = ownerDocument.nextSibling,
                      nodeName = ownerDocument.nodeName;
                    ownerDocument[internalHoistableMarker] ||
                      'SCRIPT' === nodeName ||
                      'STYLE' === nodeName ||
                      ('LINK' === nodeName && 'stylesheet' === ownerDocument.rel.toLowerCase()) ||
                      node.removeChild(ownerDocument);
                    ownerDocument = nextNode$jscomp$0;
                  }
              }
              if (0 === depth) {
                parentInstance.removeChild(nextNode);
                retryIfBlockedOn(suspenseInstance);
                return;
              }
              depth--;
            } else
              '$' === node || '$?' === node || '$!' === node
                ? depth++
                : (possiblePreambleContribution = node.charCodeAt(0) - 48);
          else possiblePreambleContribution = 0;
          node = nextNode;
        } while (node);
        retryIfBlockedOn(suspenseInstance);
      }
      function clearContainerSparingly(container) {
        var nextNode = container.firstChild;
        nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);
        for (; nextNode; ) {
          var node = nextNode;
          nextNode = nextNode.nextSibling;
          switch (node.nodeName) {
            case 'HTML':
            case 'HEAD':
            case 'BODY':
              clearContainerSparingly(node);
              detachDeletedInstance(node);
              continue;
            case 'SCRIPT':
            case 'STYLE':
              continue;
            case 'LINK':
              if ('stylesheet' === node.rel.toLowerCase()) continue;
          }
          container.removeChild(node);
        }
      }
      function canHydrateInstance(instance, type, props, inRootOrSingleton) {
        for (; 1 === instance.nodeType; ) {
          var anyProps = props;
          if (instance.nodeName.toLowerCase() !== type.toLowerCase()) {
            if (!inRootOrSingleton && ('INPUT' !== instance.nodeName || 'hidden' !== instance.type))
              break;
          } else if (!inRootOrSingleton)
            if ('input' === type && 'hidden' === instance.type) {
              var name = null == anyProps.name ? null : '' + anyProps.name;
              if ('hidden' === anyProps.type && instance.getAttribute('name') === name)
                return instance;
            } else return instance;
          else if (!instance[internalHoistableMarker])
            switch (type) {
              case 'meta':
                if (!instance.hasAttribute('itemprop')) break;
                return instance;
              case 'link':
                name = instance.getAttribute('rel');
                if ('stylesheet' === name && instance.hasAttribute('data-precedence')) break;
                else if (
                  name !== anyProps.rel ||
                  instance.getAttribute('href') !==
                    (null == anyProps.href || '' === anyProps.href ? null : anyProps.href) ||
                  instance.getAttribute('crossorigin') !==
                    (null == anyProps.crossOrigin ? null : anyProps.crossOrigin) ||
                  instance.getAttribute('title') !==
                    (null == anyProps.title ? null : anyProps.title)
                )
                  break;
                return instance;
              case 'style':
                if (instance.hasAttribute('data-precedence')) break;
                return instance;
              case 'script':
                name = instance.getAttribute('src');
                if (
                  (name !== (null == anyProps.src ? null : anyProps.src) ||
                    instance.getAttribute('type') !==
                      (null == anyProps.type ? null : anyProps.type) ||
                    instance.getAttribute('crossorigin') !==
                      (null == anyProps.crossOrigin ? null : anyProps.crossOrigin)) &&
                  name &&
                  instance.hasAttribute('async') &&
                  !instance.hasAttribute('itemprop')
                )
                  break;
                return instance;
              default:
                return instance;
            }
          instance = getNextHydratable(instance.nextSibling);
          if (null === instance) break;
        }
        return null;
      }
      function canHydrateTextInstance(instance, text, inRootOrSingleton) {
        if ('' === text) return null;
        for (; 3 !== instance.nodeType; ) {
          if (
            (1 !== instance.nodeType ||
              'INPUT' !== instance.nodeName ||
              'hidden' !== instance.type) &&
            !inRootOrSingleton
          )
            return null;
          instance = getNextHydratable(instance.nextSibling);
          if (null === instance) return null;
        }
        return instance;
      }
      function isSuspenseInstanceFallback(instance) {
        return (
          '$!' === instance.data ||
          ('$?' === instance.data && 'complete' === instance.ownerDocument.readyState)
        );
      }
      function registerSuspenseInstanceRetry(instance, callback) {
        var ownerDocument = instance.ownerDocument;
        if ('$?' !== instance.data || 'complete' === ownerDocument.readyState) callback();
        else {
          var listener = function () {
            callback();
            ownerDocument.removeEventListener('DOMContentLoaded', listener);
          };
          ownerDocument.addEventListener('DOMContentLoaded', listener);
          instance._reactRetry = listener;
        }
      }
      function getNextHydratable(node) {
        for (; null != node; node = node.nextSibling) {
          var nodeType = node.nodeType;
          if (1 === nodeType || 3 === nodeType) break;
          if (8 === nodeType) {
            nodeType = node.data;
            if (
              '$' === nodeType ||
              '$!' === nodeType ||
              '$?' === nodeType ||
              'F!' === nodeType ||
              'F' === nodeType
            )
              break;
            if ('/$' === nodeType) return null;
          }
        }
        return node;
      }
      var previousHydratableOnEnteringScopedSingleton = null;
      function getParentSuspenseInstance(targetInstance) {
        targetInstance = targetInstance.previousSibling;
        for (var depth = 0; targetInstance; ) {
          if (8 === targetInstance.nodeType) {
            var data = targetInstance.data;
            if ('$' === data || '$!' === data || '$?' === data) {
              if (0 === depth) return targetInstance;
              depth--;
            } else '/$' === data && depth++;
          }
          targetInstance = targetInstance.previousSibling;
        }
        return null;
      }
      function resolveSingletonInstance(type, props, rootContainerInstance) {
        props = getOwnerDocumentFromRootContainer(rootContainerInstance);
        switch (type) {
          case 'html':
            type = props.documentElement;
            if (!type) throw Error(formatProdErrorMessage(452));
            return type;
          case 'head':
            type = props.head;
            if (!type) throw Error(formatProdErrorMessage(453));
            return type;
          case 'body':
            type = props.body;
            if (!type) throw Error(formatProdErrorMessage(454));
            return type;
          default:
            throw Error(formatProdErrorMessage(451));
        }
      }
      function releaseSingletonInstance(instance) {
        for (var attributes = instance.attributes; attributes.length; )
          instance.removeAttributeNode(attributes[0]);
        detachDeletedInstance(instance);
      }
      var preloadPropsMap = new Map(),
        preconnectsSet = new Set();
      function getHoistableRoot(container) {
        return 'function' === typeof container.getRootNode
          ? container.getRootNode()
          : 9 === container.nodeType
            ? container
            : container.ownerDocument;
      }
      var previousDispatcher = ReactDOMSharedInternals.d;
      ReactDOMSharedInternals.d = {
        f: flushSyncWork,
        r: requestFormReset,
        D: prefetchDNS,
        C: preconnect,
        L: preload,
        m: preloadModule,
        X: preinitScript,
        S: preinitStyle,
        M: preinitModuleScript,
      };
      function flushSyncWork() {
        var previousWasRendering = previousDispatcher.f(),
          wasRendering = flushSyncWork$1();
        return previousWasRendering || wasRendering;
      }
      function requestFormReset(form) {
        var formInst = getInstanceFromNode(form);
        null !== formInst && 5 === formInst.tag && 'form' === formInst.type
          ? requestFormReset$1(formInst)
          : previousDispatcher.r(form);
      }
      var globalDocument = 'undefined' === typeof document ? null : document;
      function preconnectAs(rel, href, crossOrigin) {
        var ownerDocument = globalDocument;
        if (ownerDocument && 'string' === typeof href && href) {
          var limitedEscapedHref = escapeSelectorAttributeValueInsideDoubleQuotes(href);
          limitedEscapedHref = 'link[rel="' + rel + '"][href="' + limitedEscapedHref + '"]';
          'string' === typeof crossOrigin &&
            (limitedEscapedHref += '[crossorigin="' + crossOrigin + '"]');
          preconnectsSet.has(limitedEscapedHref) ||
            (preconnectsSet.add(limitedEscapedHref),
            (rel = { rel: rel, crossOrigin: crossOrigin, href: href }),
            null === ownerDocument.querySelector(limitedEscapedHref) &&
              ((href = ownerDocument.createElement('link')),
              setInitialProperties(href, 'link', rel),
              markNodeAsHoistable(href),
              ownerDocument.head.appendChild(href)));
        }
      }
      function prefetchDNS(href) {
        previousDispatcher.D(href);
        preconnectAs('dns-prefetch', href, null);
      }
      function preconnect(href, crossOrigin) {
        previousDispatcher.C(href, crossOrigin);
        preconnectAs('preconnect', href, crossOrigin);
      }
      function preload(href, as, options) {
        previousDispatcher.L(href, as, options);
        var ownerDocument = globalDocument;
        if (ownerDocument && href && as) {
          var preloadSelector =
            'link[rel="preload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"]';
          'image' === as
            ? options && options.imageSrcSet
              ? ((preloadSelector +=
                  '[imagesrcset="' +
                  escapeSelectorAttributeValueInsideDoubleQuotes(options.imageSrcSet) +
                  '"]'),
                'string' === typeof options.imageSizes &&
                  (preloadSelector +=
                    '[imagesizes="' +
                    escapeSelectorAttributeValueInsideDoubleQuotes(options.imageSizes) +
                    '"]'))
              : (preloadSelector +=
                  '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]')
            : (preloadSelector +=
                '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]');
          var key = preloadSelector;
          switch (as) {
            case 'style':
              key = getStyleKey(href);
              break;
            case 'script':
              key = getScriptKey(href);
          }
          preloadPropsMap.has(key) ||
            ((href = assign(
              {
                rel: 'preload',
                href: 'image' === as && options && options.imageSrcSet ? void 0 : href,
                as: as,
              },
              options
            )),
            preloadPropsMap.set(key, href),
            null !== ownerDocument.querySelector(preloadSelector) ||
              ('style' === as && ownerDocument.querySelector(getStylesheetSelectorFromKey(key))) ||
              ('script' === as && ownerDocument.querySelector(getScriptSelectorFromKey(key))) ||
              ((as = ownerDocument.createElement('link')),
              setInitialProperties(as, 'link', href),
              markNodeAsHoistable(as),
              ownerDocument.head.appendChild(as)));
        }
      }
      function preloadModule(href, options) {
        previousDispatcher.m(href, options);
        var ownerDocument = globalDocument;
        if (ownerDocument && href) {
          var as = options && 'string' === typeof options.as ? options.as : 'script',
            preloadSelector =
              'link[rel="modulepreload"][as="' +
              escapeSelectorAttributeValueInsideDoubleQuotes(as) +
              '"][href="' +
              escapeSelectorAttributeValueInsideDoubleQuotes(href) +
              '"]',
            key = preloadSelector;
          switch (as) {
            case 'audioworklet':
            case 'paintworklet':
            case 'serviceworker':
            case 'sharedworker':
            case 'worker':
            case 'script':
              key = getScriptKey(href);
          }
          if (
            !preloadPropsMap.has(key) &&
            ((href = assign({ rel: 'modulepreload', href: href }, options)),
            preloadPropsMap.set(key, href),
            null === ownerDocument.querySelector(preloadSelector))
          ) {
            switch (as) {
              case 'audioworklet':
              case 'paintworklet':
              case 'serviceworker':
              case 'sharedworker':
              case 'worker':
              case 'script':
                if (ownerDocument.querySelector(getScriptSelectorFromKey(key))) return;
            }
            as = ownerDocument.createElement('link');
            setInitialProperties(as, 'link', href);
            markNodeAsHoistable(as);
            ownerDocument.head.appendChild(as);
          }
        }
      }
      function preinitStyle(href, precedence, options) {
        previousDispatcher.S(href, precedence, options);
        var ownerDocument = globalDocument;
        if (ownerDocument && href) {
          var styles = getResourcesFromRoot(ownerDocument).hoistableStyles,
            key = getStyleKey(href);
          precedence = precedence || 'default';
          var resource = styles.get(key);
          if (!resource) {
            var state = { loading: 0, preload: null };
            if ((resource = ownerDocument.querySelector(getStylesheetSelectorFromKey(key))))
              state.loading = 5;
            else {
              href = assign(
                { rel: 'stylesheet', href: href, 'data-precedence': precedence },
                options
              );
              (options = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(href, options);
              var link = (resource = ownerDocument.createElement('link'));
              markNodeAsHoistable(link);
              setInitialProperties(link, 'link', href);
              link._p = new Promise(function (resolve, reject) {
                link.onload = resolve;
                link.onerror = reject;
              });
              link.addEventListener('load', function () {
                state.loading |= 1;
              });
              link.addEventListener('error', function () {
                state.loading |= 2;
              });
              state.loading |= 4;
              insertStylesheet(resource, precedence, ownerDocument);
            }
            resource = {
              type: 'stylesheet',
              instance: resource,
              count: 1,
              state: state,
            };
            styles.set(key, resource);
          }
        }
      }
      function preinitScript(src, options) {
        previousDispatcher.X(src, options);
        var ownerDocument = globalDocument;
        if (ownerDocument && src) {
          var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts,
            key = getScriptKey(src),
            resource = scripts.get(key);
          resource ||
            ((resource = ownerDocument.querySelector(getScriptSelectorFromKey(key))),
            resource ||
              ((src = assign({ src: src, async: !0 }, options)),
              (options = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options),
              (resource = ownerDocument.createElement('script')),
              markNodeAsHoistable(resource),
              setInitialProperties(resource, 'link', src),
              ownerDocument.head.appendChild(resource)),
            (resource = {
              type: 'script',
              instance: resource,
              count: 1,
              state: null,
            }),
            scripts.set(key, resource));
        }
      }
      function preinitModuleScript(src, options) {
        previousDispatcher.M(src, options);
        var ownerDocument = globalDocument;
        if (ownerDocument && src) {
          var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts,
            key = getScriptKey(src),
            resource = scripts.get(key);
          resource ||
            ((resource = ownerDocument.querySelector(getScriptSelectorFromKey(key))),
            resource ||
              ((src = assign({ src: src, async: !0, type: 'module' }, options)),
              (options = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options),
              (resource = ownerDocument.createElement('script')),
              markNodeAsHoistable(resource),
              setInitialProperties(resource, 'link', src),
              ownerDocument.head.appendChild(resource)),
            (resource = {
              type: 'script',
              instance: resource,
              count: 1,
              state: null,
            }),
            scripts.set(key, resource));
        }
      }
      function getResource(type, currentProps, pendingProps, currentResource) {
        var JSCompiler_inline_result = (JSCompiler_inline_result = rootInstanceStackCursor.current)
          ? getHoistableRoot(JSCompiler_inline_result)
          : null;
        if (!JSCompiler_inline_result) throw Error(formatProdErrorMessage(446));
        switch (type) {
          case 'meta':
          case 'title':
            return null;
          case 'style':
            return 'string' === typeof pendingProps.precedence &&
              'string' === typeof pendingProps.href
              ? ((currentProps = getStyleKey(pendingProps.href)),
                (pendingProps = getResourcesFromRoot(JSCompiler_inline_result).hoistableStyles),
                (currentResource = pendingProps.get(currentProps)),
                currentResource ||
                  ((currentResource = {
                    type: 'style',
                    instance: null,
                    count: 0,
                    state: null,
                  }),
                  pendingProps.set(currentProps, currentResource)),
                currentResource)
              : { type: 'void', instance: null, count: 0, state: null };
          case 'link':
            if (
              'stylesheet' === pendingProps.rel &&
              'string' === typeof pendingProps.href &&
              'string' === typeof pendingProps.precedence
            ) {
              type = getStyleKey(pendingProps.href);
              var styles$244 = getResourcesFromRoot(JSCompiler_inline_result).hoistableStyles,
                resource$245 = styles$244.get(type);
              resource$245 ||
                ((JSCompiler_inline_result =
                  JSCompiler_inline_result.ownerDocument || JSCompiler_inline_result),
                (resource$245 = {
                  type: 'stylesheet',
                  instance: null,
                  count: 0,
                  state: { loading: 0, preload: null },
                }),
                styles$244.set(type, resource$245),
                (styles$244 = JSCompiler_inline_result.querySelector(
                  getStylesheetSelectorFromKey(type)
                )) &&
                  !styles$244._p &&
                  ((resource$245.instance = styles$244), (resource$245.state.loading = 5)),
                preloadPropsMap.has(type) ||
                  ((pendingProps = {
                    rel: 'preload',
                    as: 'style',
                    href: pendingProps.href,
                    crossOrigin: pendingProps.crossOrigin,
                    integrity: pendingProps.integrity,
                    media: pendingProps.media,
                    hrefLang: pendingProps.hrefLang,
                    referrerPolicy: pendingProps.referrerPolicy,
                  }),
                  preloadPropsMap.set(type, pendingProps),
                  styles$244 ||
                    preloadStylesheet(
                      JSCompiler_inline_result,
                      type,
                      pendingProps,
                      resource$245.state
                    )));
              if (currentProps && null === currentResource)
                throw Error(formatProdErrorMessage(528, ''));
              return resource$245;
            }
            if (currentProps && null !== currentResource)
              throw Error(formatProdErrorMessage(529, ''));
            return null;
          case 'script':
            return (
              (currentProps = pendingProps.async),
              (pendingProps = pendingProps.src),
              'string' === typeof pendingProps &&
              currentProps &&
              'function' !== typeof currentProps &&
              'symbol' !== typeof currentProps
                ? ((currentProps = getScriptKey(pendingProps)),
                  (pendingProps = getResourcesFromRoot(JSCompiler_inline_result).hoistableScripts),
                  (currentResource = pendingProps.get(currentProps)),
                  currentResource ||
                    ((currentResource = {
                      type: 'script',
                      instance: null,
                      count: 0,
                      state: null,
                    }),
                    pendingProps.set(currentProps, currentResource)),
                  currentResource)
                : { type: 'void', instance: null, count: 0, state: null }
            );
          default:
            throw Error(formatProdErrorMessage(444, type));
        }
      }
      function getStyleKey(href) {
        return 'href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"';
      }
      function getStylesheetSelectorFromKey(key) {
        return 'link[rel="stylesheet"][' + key + ']';
      }
      function stylesheetPropsFromRawProps(rawProps) {
        return assign({}, rawProps, {
          'data-precedence': rawProps.precedence,
          precedence: null,
        });
      }
      function preloadStylesheet(ownerDocument, key, preloadProps, state) {
        ownerDocument.querySelector('link[rel="preload"][as="style"][' + key + ']')
          ? (state.loading = 1)
          : ((key = ownerDocument.createElement('link')),
            (state.preload = key),
            key.addEventListener('load', function () {
              return (state.loading |= 1);
            }),
            key.addEventListener('error', function () {
              return (state.loading |= 2);
            }),
            setInitialProperties(key, 'link', preloadProps),
            markNodeAsHoistable(key),
            ownerDocument.head.appendChild(key));
      }
      function getScriptKey(src) {
        return '[src="' + escapeSelectorAttributeValueInsideDoubleQuotes(src) + '"]';
      }
      function getScriptSelectorFromKey(key) {
        return 'script[async]' + key;
      }
      function acquireResource(hoistableRoot, resource, props) {
        resource.count++;
        if (null === resource.instance)
          switch (resource.type) {
            case 'style':
              var instance = hoistableRoot.querySelector(
                'style[data-href~="' +
                  escapeSelectorAttributeValueInsideDoubleQuotes(props.href) +
                  '"]'
              );
              if (instance)
                return ((resource.instance = instance), markNodeAsHoistable(instance), instance);
              var styleProps = assign({}, props, {
                'data-href': props.href,
                'data-precedence': props.precedence,
                href: null,
                precedence: null,
              });
              instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement('style');
              markNodeAsHoistable(instance);
              setInitialProperties(instance, 'style', styleProps);
              insertStylesheet(instance, props.precedence, hoistableRoot);
              return (resource.instance = instance);
            case 'stylesheet':
              styleProps = getStyleKey(props.href);
              var instance$250 = hoistableRoot.querySelector(
                getStylesheetSelectorFromKey(styleProps)
              );
              if (instance$250)
                return (
                  (resource.state.loading |= 4),
                  (resource.instance = instance$250),
                  markNodeAsHoistable(instance$250),
                  instance$250
                );
              instance = stylesheetPropsFromRawProps(props);
              (styleProps = preloadPropsMap.get(styleProps)) &&
                adoptPreloadPropsForStylesheet(instance, styleProps);
              instance$250 = (hoistableRoot.ownerDocument || hoistableRoot).createElement('link');
              markNodeAsHoistable(instance$250);
              var linkInstance = instance$250;
              linkInstance._p = new Promise(function (resolve, reject) {
                linkInstance.onload = resolve;
                linkInstance.onerror = reject;
              });
              setInitialProperties(instance$250, 'link', instance);
              resource.state.loading |= 4;
              insertStylesheet(instance$250, props.precedence, hoistableRoot);
              return (resource.instance = instance$250);
            case 'script':
              instance$250 = getScriptKey(props.src);
              if (
                (styleProps = hoistableRoot.querySelector(getScriptSelectorFromKey(instance$250)))
              )
                return (
                  (resource.instance = styleProps),
                  markNodeAsHoistable(styleProps),
                  styleProps
                );
              instance = props;
              if ((styleProps = preloadPropsMap.get(instance$250)))
                ((instance = assign({}, props)), adoptPreloadPropsForScript(instance, styleProps));
              hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
              styleProps = hoistableRoot.createElement('script');
              markNodeAsHoistable(styleProps);
              setInitialProperties(styleProps, 'link', instance);
              hoistableRoot.head.appendChild(styleProps);
              return (resource.instance = styleProps);
            case 'void':
              return null;
            default:
              throw Error(formatProdErrorMessage(443, resource.type));
          }
        else
          'stylesheet' === resource.type &&
            0 === (resource.state.loading & 4) &&
            ((instance = resource.instance),
            (resource.state.loading |= 4),
            insertStylesheet(instance, props.precedence, hoistableRoot));
        return resource.instance;
      }
      function insertStylesheet(instance, precedence, root) {
        for (
          var nodes = root.querySelectorAll(
              'link[rel="stylesheet"][data-precedence],style[data-precedence]'
            ),
            last = nodes.length ? nodes[nodes.length - 1] : null,
            prior = last,
            i = 0;
          i < nodes.length;
          i++
        ) {
          var node = nodes[i];
          if (node.dataset.precedence === precedence) prior = node;
          else if (prior !== last) break;
        }
        prior
          ? prior.parentNode.insertBefore(instance, prior.nextSibling)
          : ((precedence = 9 === root.nodeType ? root.head : root),
            precedence.insertBefore(instance, precedence.firstChild));
      }
      function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {
        null == stylesheetProps.crossOrigin &&
          (stylesheetProps.crossOrigin = preloadProps.crossOrigin);
        null == stylesheetProps.referrerPolicy &&
          (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);
        null == stylesheetProps.title && (stylesheetProps.title = preloadProps.title);
      }
      function adoptPreloadPropsForScript(scriptProps, preloadProps) {
        null == scriptProps.crossOrigin && (scriptProps.crossOrigin = preloadProps.crossOrigin);
        null == scriptProps.referrerPolicy &&
          (scriptProps.referrerPolicy = preloadProps.referrerPolicy);
        null == scriptProps.integrity && (scriptProps.integrity = preloadProps.integrity);
      }
      var tagCaches = null;
      function getHydratableHoistableCache(type, keyAttribute, ownerDocument) {
        if (null === tagCaches) {
          var cache = new Map();
          var caches = (tagCaches = new Map());
          caches.set(ownerDocument, cache);
        } else
          ((caches = tagCaches),
            (cache = caches.get(ownerDocument)),
            cache || ((cache = new Map()), caches.set(ownerDocument, cache)));
        if (cache.has(type)) return cache;
        cache.set(type, null);
        ownerDocument = ownerDocument.getElementsByTagName(type);
        for (caches = 0; caches < ownerDocument.length; caches++) {
          var node = ownerDocument[caches];
          if (
            !(
              node[internalHoistableMarker] ||
              node[internalInstanceKey] ||
              ('link' === type && 'stylesheet' === node.getAttribute('rel'))
            ) &&
            'http://www.w3.org/2000/svg' !== node.namespaceURI
          ) {
            var nodeKey = node.getAttribute(keyAttribute) || '';
            nodeKey = type + nodeKey;
            var existing = cache.get(nodeKey);
            existing ? existing.push(node) : cache.set(nodeKey, [node]);
          }
        }
        return cache;
      }
      function mountHoistable(hoistableRoot, type, instance) {
        hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
        hoistableRoot.head.insertBefore(
          instance,
          'title' === type ? hoistableRoot.querySelector('head > title') : null
        );
      }
      function isHostHoistableType(type, props, hostContext) {
        if (1 === hostContext || null != props.itemProp) return !1;
        switch (type) {
          case 'meta':
          case 'title':
            return !0;
          case 'style':
            if (
              'string' !== typeof props.precedence ||
              'string' !== typeof props.href ||
              '' === props.href
            )
              break;
            return !0;
          case 'link':
            if (
              'string' !== typeof props.rel ||
              'string' !== typeof props.href ||
              '' === props.href ||
              props.onLoad ||
              props.onError
            )
              break;
            switch (props.rel) {
              case 'stylesheet':
                return (
                  (type = props.disabled),
                  'string' === typeof props.precedence && null == type
                );
              default:
                return !0;
            }
          case 'script':
            if (
              props.async &&
              'function' !== typeof props.async &&
              'symbol' !== typeof props.async &&
              !props.onLoad &&
              !props.onError &&
              props.src &&
              'string' === typeof props.src
            )
              return !0;
        }
        return !1;
      }
      function preloadResource(resource) {
        return 'stylesheet' === resource.type && 0 === (resource.state.loading & 3) ? !1 : !0;
      }
      var suspendedState = null;
      function noop() {}
      function suspendResource(hoistableRoot, resource, props) {
        if (null === suspendedState) throw Error(formatProdErrorMessage(475));
        var state = suspendedState;
        if (
          'stylesheet' === resource.type &&
          ('string' !== typeof props.media || !1 !== matchMedia(props.media).matches) &&
          0 === (resource.state.loading & 4)
        ) {
          if (null === resource.instance) {
            var key = getStyleKey(props.href),
              instance = hoistableRoot.querySelector(getStylesheetSelectorFromKey(key));
            if (instance) {
              hoistableRoot = instance._p;
              null !== hoistableRoot &&
                'object' === typeof hoistableRoot &&
                'function' === typeof hoistableRoot.then &&
                (state.count++,
                (state = onUnsuspend.bind(state)),
                hoistableRoot.then(state, state));
              resource.state.loading |= 4;
              resource.instance = instance;
              markNodeAsHoistable(instance);
              return;
            }
            instance = hoistableRoot.ownerDocument || hoistableRoot;
            props = stylesheetPropsFromRawProps(props);
            (key = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(props, key);
            instance = instance.createElement('link');
            markNodeAsHoistable(instance);
            var linkInstance = instance;
            linkInstance._p = new Promise(function (resolve, reject) {
              linkInstance.onload = resolve;
              linkInstance.onerror = reject;
            });
            setInitialProperties(instance, 'link', props);
            resource.instance = instance;
          }
          null === state.stylesheets && (state.stylesheets = new Map());
          state.stylesheets.set(resource, hoistableRoot);
          (hoistableRoot = resource.state.preload) &&
            0 === (resource.state.loading & 3) &&
            (state.count++,
            (resource = onUnsuspend.bind(state)),
            hoistableRoot.addEventListener('load', resource),
            hoistableRoot.addEventListener('error', resource));
        }
      }
      function waitForCommitToBeReady() {
        if (null === suspendedState) throw Error(formatProdErrorMessage(475));
        var state = suspendedState;
        state.stylesheets &&
          0 === state.count &&
          insertSuspendedStylesheets(state, state.stylesheets);
        return 0 < state.count
          ? function (commit) {
              var stylesheetTimer = setTimeout(function () {
                state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets);
                if (state.unsuspend) {
                  var unsuspend = state.unsuspend;
                  state.unsuspend = null;
                  unsuspend();
                }
              }, 6e4);
              state.unsuspend = commit;
              return function () {
                state.unsuspend = null;
                clearTimeout(stylesheetTimer);
              };
            }
          : null;
      }
      function onUnsuspend() {
        this.count--;
        if (0 === this.count)
          if (this.stylesheets) insertSuspendedStylesheets(this, this.stylesheets);
          else if (this.unsuspend) {
            var unsuspend = this.unsuspend;
            this.unsuspend = null;
            unsuspend();
          }
      }
      var precedencesByRoot = null;
      function insertSuspendedStylesheets(state, resources) {
        state.stylesheets = null;
        null !== state.unsuspend &&
          (state.count++,
          (precedencesByRoot = new Map()),
          resources.forEach(insertStylesheetIntoRoot, state),
          (precedencesByRoot = null),
          onUnsuspend.call(state));
      }
      function insertStylesheetIntoRoot(root, resource) {
        if (!(resource.state.loading & 4)) {
          var precedences = precedencesByRoot.get(root);
          if (precedences) var last = precedences.get(null);
          else {
            precedences = new Map();
            precedencesByRoot.set(root, precedences);
            for (
              var nodes = root.querySelectorAll('link[data-precedence],style[data-precedence]'),
                i = 0;
              i < nodes.length;
              i++
            ) {
              var node = nodes[i];
              if ('LINK' === node.nodeName || 'not all' !== node.getAttribute('media'))
                (precedences.set(node.dataset.precedence, node), (last = node));
            }
            last && precedences.set(null, last);
          }
          nodes = resource.instance;
          node = nodes.getAttribute('data-precedence');
          i = precedences.get(node) || last;
          i === last && precedences.set(null, nodes);
          precedences.set(node, nodes);
          this.count++;
          last = onUnsuspend.bind(this);
          nodes.addEventListener('load', last);
          nodes.addEventListener('error', last);
          i
            ? i.parentNode.insertBefore(nodes, i.nextSibling)
            : ((root = 9 === root.nodeType ? root.head : root),
              root.insertBefore(nodes, root.firstChild));
          resource.state.loading |= 4;
        }
      }
      var HostTransitionContext = {
        $$typeof: REACT_CONTEXT_TYPE,
        Provider: null,
        Consumer: null,
        _currentValue: sharedNotPendingObject,
        _currentValue2: sharedNotPendingObject,
        _threadCount: 0,
      };
      function FiberRootNode(
        containerInfo,
        tag,
        hydrate,
        identifierPrefix,
        onUncaughtError,
        onCaughtError,
        onRecoverableError,
        formState
      ) {
        this.tag = 1;
        this.containerInfo = containerInfo;
        this.pingCache = this.current = this.pendingChildren = null;
        this.timeoutHandle = -1;
        this.callbackNode =
          this.next =
          this.pendingContext =
          this.context =
          this.cancelPendingCommit =
            null;
        this.callbackPriority = 0;
        this.expirationTimes = createLaneMap(-1);
        this.entangledLanes =
          this.shellSuspendCounter =
          this.errorRecoveryDisabledLanes =
          this.expiredLanes =
          this.warmLanes =
          this.pingedLanes =
          this.suspendedLanes =
          this.pendingLanes =
            0;
        this.entanglements = createLaneMap(0);
        this.hiddenUpdates = createLaneMap(null);
        this.identifierPrefix = identifierPrefix;
        this.onUncaughtError = onUncaughtError;
        this.onCaughtError = onCaughtError;
        this.onRecoverableError = onRecoverableError;
        this.pooledCache = null;
        this.pooledCacheLanes = 0;
        this.formState = formState;
        this.incompleteTransitions = new Map();
      }
      function createFiberRoot(
        containerInfo,
        tag,
        hydrate,
        initialChildren,
        hydrationCallbacks,
        isStrictMode,
        identifierPrefix,
        onUncaughtError,
        onCaughtError,
        onRecoverableError,
        transitionCallbacks,
        formState
      ) {
        containerInfo = new FiberRootNode(
          containerInfo,
          tag,
          hydrate,
          identifierPrefix,
          onUncaughtError,
          onCaughtError,
          onRecoverableError,
          formState
        );
        tag = 1;
        !0 === isStrictMode && (tag |= 24);
        isStrictMode = createFiberImplClass(3, null, null, tag);
        containerInfo.current = isStrictMode;
        isStrictMode.stateNode = containerInfo;
        tag = createCache();
        tag.refCount++;
        containerInfo.pooledCache = tag;
        tag.refCount++;
        isStrictMode.memoizedState = {
          element: initialChildren,
          isDehydrated: hydrate,
          cache: tag,
        };
        initializeUpdateQueue(isStrictMode);
        return containerInfo;
      }
      function getContextForSubtree(parentComponent) {
        if (!parentComponent) return emptyContextObject;
        parentComponent = emptyContextObject;
        return parentComponent;
      }
      function updateContainerImpl(rootFiber, lane, element, container, parentComponent, callback) {
        parentComponent = getContextForSubtree(parentComponent);
        null === container.context
          ? (container.context = parentComponent)
          : (container.pendingContext = parentComponent);
        container = createUpdate(lane);
        container.payload = { element: element };
        callback = void 0 === callback ? null : callback;
        null !== callback && (container.callback = callback);
        element = enqueueUpdate(rootFiber, container, lane);
        null !== element &&
          (scheduleUpdateOnFiber(element, rootFiber, lane),
          entangleTransitions(element, rootFiber, lane));
      }
      function markRetryLaneImpl(fiber, retryLane) {
        fiber = fiber.memoizedState;
        if (null !== fiber && null !== fiber.dehydrated) {
          var a = fiber.retryLane;
          fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;
        }
      }
      function markRetryLaneIfNotHydrated(fiber, retryLane) {
        markRetryLaneImpl(fiber, retryLane);
        (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
      }
      function attemptContinuousHydration(fiber) {
        if (13 === fiber.tag) {
          var root = enqueueConcurrentRenderForLane(fiber, 67108864);
          null !== root && scheduleUpdateOnFiber(root, fiber, 67108864);
          markRetryLaneIfNotHydrated(fiber, 67108864);
        }
      }
      var _enabled = !0;
      function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
        var prevTransition = ReactSharedInternals.T;
        ReactSharedInternals.T = null;
        var previousPriority = ReactDOMSharedInternals.p;
        try {
          ((ReactDOMSharedInternals.p = 2),
            dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent));
        } finally {
          ((ReactDOMSharedInternals.p = previousPriority),
            (ReactSharedInternals.T = prevTransition));
        }
      }
      function dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {
        var prevTransition = ReactSharedInternals.T;
        ReactSharedInternals.T = null;
        var previousPriority = ReactDOMSharedInternals.p;
        try {
          ((ReactDOMSharedInternals.p = 8),
            dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent));
        } finally {
          ((ReactDOMSharedInternals.p = previousPriority),
            (ReactSharedInternals.T = prevTransition));
        }
      }
      function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        if (_enabled) {
          var blockedOn = findInstanceBlockingEvent(nativeEvent);
          if (null === blockedOn)
            (dispatchEventForPluginEventSystem(
              domEventName,
              eventSystemFlags,
              nativeEvent,
              return_targetInst,
              targetContainer
            ),
              clearIfContinuousEvent(domEventName, nativeEvent));
          else if (
            queueIfContinuousEvent(
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            )
          )
            nativeEvent.stopPropagation();
          else if (
            (clearIfContinuousEvent(domEventName, nativeEvent),
            eventSystemFlags & 4 && -1 < discreteReplayableEvents.indexOf(domEventName))
          ) {
            for (; null !== blockedOn; ) {
              var fiber = getInstanceFromNode(blockedOn);
              if (null !== fiber)
                switch (fiber.tag) {
                  case 3:
                    fiber = fiber.stateNode;
                    if (fiber.current.memoizedState.isDehydrated) {
                      var lanes = getHighestPriorityLanes(fiber.pendingLanes);
                      if (0 !== lanes) {
                        var root = fiber;
                        root.pendingLanes |= 2;
                        for (root.entangledLanes |= 2; lanes; ) {
                          var lane = 1 << (31 - clz32(lanes));
                          root.entanglements[1] |= lane;
                          lanes &= ~lane;
                        }
                        ensureRootIsScheduled(fiber);
                        0 === (executionContext & 6) &&
                          ((workInProgressRootRenderTargetTime = now() + 500),
                          flushSyncWorkAcrossRoots_impl(0, !1));
                      }
                    }
                    break;
                  case 13:
                    ((root = enqueueConcurrentRenderForLane(fiber, 2)),
                      null !== root && scheduleUpdateOnFiber(root, fiber, 2),
                      flushSyncWork$1(),
                      markRetryLaneIfNotHydrated(fiber, 2));
                }
              fiber = findInstanceBlockingEvent(nativeEvent);
              null === fiber &&
                dispatchEventForPluginEventSystem(
                  domEventName,
                  eventSystemFlags,
                  nativeEvent,
                  return_targetInst,
                  targetContainer
                );
              if (fiber === blockedOn) break;
              blockedOn = fiber;
            }
            null !== blockedOn && nativeEvent.stopPropagation();
          } else
            dispatchEventForPluginEventSystem(
              domEventName,
              eventSystemFlags,
              nativeEvent,
              null,
              targetContainer
            );
        }
      }
      function findInstanceBlockingEvent(nativeEvent) {
        nativeEvent = getEventTarget(nativeEvent);
        return findInstanceBlockingTarget(nativeEvent);
      }
      var return_targetInst = null;
      function findInstanceBlockingTarget(targetNode) {
        return_targetInst = null;
        targetNode = getClosestInstanceFromNode(targetNode);
        if (null !== targetNode) {
          var nearestMounted = getNearestMountedFiber(targetNode);
          if (null === nearestMounted) targetNode = null;
          else {
            var tag = nearestMounted.tag;
            if (13 === tag) {
              targetNode = getSuspenseInstanceFromFiber(nearestMounted);
              if (null !== targetNode) return targetNode;
              targetNode = null;
            } else if (3 === tag) {
              if (nearestMounted.stateNode.current.memoizedState.isDehydrated)
                return 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
              targetNode = null;
            } else nearestMounted !== targetNode && (targetNode = null);
          }
        }
        return_targetInst = targetNode;
        return null;
      }
      function getEventPriority(domEventName) {
        switch (domEventName) {
          case 'beforetoggle':
          case 'cancel':
          case 'click':
          case 'close':
          case 'contextmenu':
          case 'copy':
          case 'cut':
          case 'auxclick':
          case 'dblclick':
          case 'dragend':
          case 'dragstart':
          case 'drop':
          case 'focusin':
          case 'focusout':
          case 'input':
          case 'invalid':
          case 'keydown':
          case 'keypress':
          case 'keyup':
          case 'mousedown':
          case 'mouseup':
          case 'paste':
          case 'pause':
          case 'play':
          case 'pointercancel':
          case 'pointerdown':
          case 'pointerup':
          case 'ratechange':
          case 'reset':
          case 'resize':
          case 'seeked':
          case 'submit':
          case 'toggle':
          case 'touchcancel':
          case 'touchend':
          case 'touchstart':
          case 'volumechange':
          case 'change':
          case 'selectionchange':
          case 'textInput':
          case 'compositionstart':
          case 'compositionend':
          case 'compositionupdate':
          case 'beforeblur':
          case 'afterblur':
          case 'beforeinput':
          case 'blur':
          case 'fullscreenchange':
          case 'focus':
          case 'hashchange':
          case 'popstate':
          case 'select':
          case 'selectstart':
            return 2;
          case 'drag':
          case 'dragenter':
          case 'dragexit':
          case 'dragleave':
          case 'dragover':
          case 'mousemove':
          case 'mouseout':
          case 'mouseover':
          case 'pointermove':
          case 'pointerout':
          case 'pointerover':
          case 'scroll':
          case 'touchmove':
          case 'wheel':
          case 'mouseenter':
          case 'mouseleave':
          case 'pointerenter':
          case 'pointerleave':
            return 8;
          case 'message':
            switch (getCurrentPriorityLevel()) {
              case ImmediatePriority:
                return 2;
              case UserBlockingPriority:
                return 8;
              case NormalPriority$1:
              case LowPriority:
                return 32;
              case IdlePriority:
                return 268435456;
              default:
                return 32;
            }
          default:
            return 32;
        }
      }
      var hasScheduledReplayAttempt = !1,
        queuedFocus = null,
        queuedDrag = null,
        queuedMouse = null,
        queuedPointers = new Map(),
        queuedPointerCaptures = new Map(),
        queuedExplicitHydrationTargets = [],
        discreteReplayableEvents =
          'mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset'.split(
            ' '
          );
      function clearIfContinuousEvent(domEventName, nativeEvent) {
        switch (domEventName) {
          case 'focusin':
          case 'focusout':
            queuedFocus = null;
            break;
          case 'dragenter':
          case 'dragleave':
            queuedDrag = null;
            break;
          case 'mouseover':
          case 'mouseout':
            queuedMouse = null;
            break;
          case 'pointerover':
          case 'pointerout':
            queuedPointers.delete(nativeEvent.pointerId);
            break;
          case 'gotpointercapture':
          case 'lostpointercapture':
            queuedPointerCaptures.delete(nativeEvent.pointerId);
        }
      }
      function accumulateOrCreateContinuousQueuedReplayableEvent(
        existingQueuedEvent,
        blockedOn,
        domEventName,
        eventSystemFlags,
        targetContainer,
        nativeEvent
      ) {
        if (null === existingQueuedEvent || existingQueuedEvent.nativeEvent !== nativeEvent)
          return (
            (existingQueuedEvent = {
              blockedOn: blockedOn,
              domEventName: domEventName,
              eventSystemFlags: eventSystemFlags,
              nativeEvent: nativeEvent,
              targetContainers: [targetContainer],
            }),
            null !== blockedOn &&
              ((blockedOn = getInstanceFromNode(blockedOn)),
              null !== blockedOn && attemptContinuousHydration(blockedOn)),
            existingQueuedEvent
          );
        existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
        blockedOn = existingQueuedEvent.targetContainers;
        null !== targetContainer &&
          -1 === blockedOn.indexOf(targetContainer) &&
          blockedOn.push(targetContainer);
        return existingQueuedEvent;
      }
      function queueIfContinuousEvent(
        blockedOn,
        domEventName,
        eventSystemFlags,
        targetContainer,
        nativeEvent
      ) {
        switch (domEventName) {
          case 'focusin':
            return (
              (queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(
                queuedFocus,
                blockedOn,
                domEventName,
                eventSystemFlags,
                targetContainer,
                nativeEvent
              )),
              !0
            );
          case 'dragenter':
            return (
              (queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(
                queuedDrag,
                blockedOn,
                domEventName,
                eventSystemFlags,
                targetContainer,
                nativeEvent
              )),
              !0
            );
          case 'mouseover':
            return (
              (queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(
                queuedMouse,
                blockedOn,
                domEventName,
                eventSystemFlags,
                targetContainer,
                nativeEvent
              )),
              !0
            );
          case 'pointerover':
            var pointerId = nativeEvent.pointerId;
            queuedPointers.set(
              pointerId,
              accumulateOrCreateContinuousQueuedReplayableEvent(
                queuedPointers.get(pointerId) || null,
                blockedOn,
                domEventName,
                eventSystemFlags,
                targetContainer,
                nativeEvent
              )
            );
            return !0;
          case 'gotpointercapture':
            return (
              (pointerId = nativeEvent.pointerId),
              queuedPointerCaptures.set(
                pointerId,
                accumulateOrCreateContinuousQueuedReplayableEvent(
                  queuedPointerCaptures.get(pointerId) || null,
                  blockedOn,
                  domEventName,
                  eventSystemFlags,
                  targetContainer,
                  nativeEvent
                )
              ),
              !0
            );
        }
        return !1;
      }
      function attemptExplicitHydrationTarget(queuedTarget) {
        var targetInst = getClosestInstanceFromNode(queuedTarget.target);
        if (null !== targetInst) {
          var nearestMounted = getNearestMountedFiber(targetInst);
          if (null !== nearestMounted)
            if (((targetInst = nearestMounted.tag), 13 === targetInst)) {
              if (
                ((targetInst = getSuspenseInstanceFromFiber(nearestMounted)), null !== targetInst)
              ) {
                queuedTarget.blockedOn = targetInst;
                runWithPriority(queuedTarget.priority, function () {
                  if (13 === nearestMounted.tag) {
                    var lane = requestUpdateLane();
                    lane = getBumpedLaneForHydrationByLane(lane);
                    var root = enqueueConcurrentRenderForLane(nearestMounted, lane);
                    null !== root && scheduleUpdateOnFiber(root, nearestMounted, lane);
                    markRetryLaneIfNotHydrated(nearestMounted, lane);
                  }
                });
                return;
              }
            } else if (
              3 === targetInst &&
              nearestMounted.stateNode.current.memoizedState.isDehydrated
            ) {
              queuedTarget.blockedOn =
                3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
              return;
            }
        }
        queuedTarget.blockedOn = null;
      }
      function attemptReplayContinuousQueuedEvent(queuedEvent) {
        if (null !== queuedEvent.blockedOn) return !1;
        for (var targetContainers = queuedEvent.targetContainers; 0 < targetContainers.length; ) {
          var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);
          if (null === nextBlockedOn) {
            nextBlockedOn = queuedEvent.nativeEvent;
            var nativeEventClone = new nextBlockedOn.constructor(nextBlockedOn.type, nextBlockedOn);
            currentReplayingEvent = nativeEventClone;
            nextBlockedOn.target.dispatchEvent(nativeEventClone);
            currentReplayingEvent = null;
          } else
            return (
              (targetContainers = getInstanceFromNode(nextBlockedOn)),
              null !== targetContainers && attemptContinuousHydration(targetContainers),
              (queuedEvent.blockedOn = nextBlockedOn),
              !1
            );
          targetContainers.shift();
        }
        return !0;
      }
      function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
        attemptReplayContinuousQueuedEvent(queuedEvent) && map.delete(key);
      }
      function replayUnblockedEvents() {
        hasScheduledReplayAttempt = !1;
        null !== queuedFocus &&
          attemptReplayContinuousQueuedEvent(queuedFocus) &&
          (queuedFocus = null);
        null !== queuedDrag &&
          attemptReplayContinuousQueuedEvent(queuedDrag) &&
          (queuedDrag = null);
        null !== queuedMouse &&
          attemptReplayContinuousQueuedEvent(queuedMouse) &&
          (queuedMouse = null);
        queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
        queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
      }
      function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
        queuedEvent.blockedOn === unblocked &&
          ((queuedEvent.blockedOn = null),
          hasScheduledReplayAttempt ||
            ((hasScheduledReplayAttempt = !0),
            Scheduler.unstable_scheduleCallback(
              Scheduler.unstable_NormalPriority,
              replayUnblockedEvents
            )));
      }
      var lastScheduledReplayQueue = null;
      function scheduleReplayQueueIfNeeded(formReplayingQueue) {
        lastScheduledReplayQueue !== formReplayingQueue &&
          ((lastScheduledReplayQueue = formReplayingQueue),
          Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, function () {
            lastScheduledReplayQueue === formReplayingQueue && (lastScheduledReplayQueue = null);
            for (var i = 0; i < formReplayingQueue.length; i += 3) {
              var form = formReplayingQueue[i],
                submitterOrAction = formReplayingQueue[i + 1],
                formData = formReplayingQueue[i + 2];
              if ('function' !== typeof submitterOrAction)
                if (null === findInstanceBlockingTarget(submitterOrAction || form)) continue;
                else break;
              var formInst = getInstanceFromNode(form);
              null !== formInst &&
                (formReplayingQueue.splice(i, 3),
                (i -= 3),
                startHostTransition(
                  formInst,
                  {
                    pending: !0,
                    data: formData,
                    method: form.method,
                    action: submitterOrAction,
                  },
                  submitterOrAction,
                  formData
                ));
            }
          }));
      }
      function retryIfBlockedOn(unblocked) {
        function unblock(queuedEvent) {
          return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
        }
        null !== queuedFocus && scheduleCallbackIfUnblocked(queuedFocus, unblocked);
        null !== queuedDrag && scheduleCallbackIfUnblocked(queuedDrag, unblocked);
        null !== queuedMouse && scheduleCallbackIfUnblocked(queuedMouse, unblocked);
        queuedPointers.forEach(unblock);
        queuedPointerCaptures.forEach(unblock);
        for (var i = 0; i < queuedExplicitHydrationTargets.length; i++) {
          var queuedTarget = queuedExplicitHydrationTargets[i];
          queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);
        }
        for (
          ;
          0 < queuedExplicitHydrationTargets.length &&
          ((i = queuedExplicitHydrationTargets[0]), null === i.blockedOn);

        )
          (attemptExplicitHydrationTarget(i),
            null === i.blockedOn && queuedExplicitHydrationTargets.shift());
        i = (unblocked.ownerDocument || unblocked).$$reactFormReplay;
        if (null != i)
          for (queuedTarget = 0; queuedTarget < i.length; queuedTarget += 3) {
            var form = i[queuedTarget],
              submitterOrAction = i[queuedTarget + 1],
              formProps = form[internalPropsKey] || null;
            if ('function' === typeof submitterOrAction)
              formProps || scheduleReplayQueueIfNeeded(i);
            else if (formProps) {
              var action = null;
              if (submitterOrAction && submitterOrAction.hasAttribute('formAction'))
                if (
                  ((form = submitterOrAction),
                  (formProps = submitterOrAction[internalPropsKey] || null))
                )
                  action = formProps.formAction;
                else {
                  if (null !== findInstanceBlockingTarget(form)) continue;
                }
              else action = formProps.action;
              'function' === typeof action
                ? (i[queuedTarget + 1] = action)
                : (i.splice(queuedTarget, 3), (queuedTarget -= 3));
              scheduleReplayQueueIfNeeded(i);
            }
          }
      }
      function ReactDOMRoot(internalRoot) {
        this._internalRoot = internalRoot;
      }
      ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function (children) {
        var root = this._internalRoot;
        if (null === root) throw Error(formatProdErrorMessage(409));
        var current = root.current,
          lane = requestUpdateLane();
        updateContainerImpl(current, lane, children, root, null, null);
      };
      ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function () {
        var root = this._internalRoot;
        if (null !== root) {
          this._internalRoot = null;
          var container = root.containerInfo;
          updateContainerImpl(root.current, 2, null, root, null, null);
          flushSyncWork$1();
          container[internalContainerInstanceKey] = null;
        }
      };
      function ReactDOMHydrationRoot(internalRoot) {
        this._internalRoot = internalRoot;
      }
      ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function (target) {
        if (target) {
          var updatePriority = resolveUpdatePriority();
          target = { blockedOn: null, target: target, priority: updatePriority };
          for (
            var i = 0;
            i < queuedExplicitHydrationTargets.length &&
            0 !== updatePriority &&
            updatePriority < queuedExplicitHydrationTargets[i].priority;
            i++
          );
          queuedExplicitHydrationTargets.splice(i, 0, target);
          0 === i && attemptExplicitHydrationTarget(target);
        }
      };
      var isomorphicReactPackageVersion$jscomp$inline_1785 = React.version;
      if ('19.1.1' !== isomorphicReactPackageVersion$jscomp$inline_1785)
        throw Error(
          formatProdErrorMessage(527, isomorphicReactPackageVersion$jscomp$inline_1785, '19.1.1')
        );
      ReactDOMSharedInternals.findDOMNode = function (componentOrElement) {
        var fiber = componentOrElement._reactInternals;
        if (void 0 === fiber) {
          if ('function' === typeof componentOrElement.render)
            throw Error(formatProdErrorMessage(188));
          componentOrElement = Object.keys(componentOrElement).join(',');
          throw Error(formatProdErrorMessage(268, componentOrElement));
        }
        componentOrElement = findCurrentFiberUsingSlowPath(fiber);
        componentOrElement =
          null !== componentOrElement ? findCurrentHostFiberImpl(componentOrElement) : null;
        componentOrElement = null === componentOrElement ? null : componentOrElement.stateNode;
        return componentOrElement;
      };
      var internals$jscomp$inline_2256 = {
        bundleType: 0,
        version: '19.1.1',
        rendererPackageName: 'react-dom',
        currentDispatcherRef: ReactSharedInternals,
        reconcilerVersion: '19.1.1',
      };
      if ('undefined' !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
        var hook$jscomp$inline_2257 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (!hook$jscomp$inline_2257.isDisabled && hook$jscomp$inline_2257.supportsFiber)
          try {
            ((rendererID = hook$jscomp$inline_2257.inject(internals$jscomp$inline_2256)),
              (injectedHook = hook$jscomp$inline_2257));
          } catch (err) {}
      }
      exports.createRoot = function (container, options) {
        if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299));
        var isStrictMode = !1,
          identifierPrefix = '',
          onUncaughtError = defaultOnUncaughtError,
          onCaughtError = defaultOnCaughtError,
          onRecoverableError = defaultOnRecoverableError,
          transitionCallbacks = null;
        null !== options &&
          void 0 !== options &&
          (!0 === options.unstable_strictMode && (isStrictMode = !0),
          void 0 !== options.identifierPrefix && (identifierPrefix = options.identifierPrefix),
          void 0 !== options.onUncaughtError && (onUncaughtError = options.onUncaughtError),
          void 0 !== options.onCaughtError && (onCaughtError = options.onCaughtError),
          void 0 !== options.onRecoverableError &&
            (onRecoverableError = options.onRecoverableError),
          void 0 !== options.unstable_transitionCallbacks &&
            (transitionCallbacks = options.unstable_transitionCallbacks));
        options = createFiberRoot(
          container,
          1,
          !1,
          null,
          null,
          isStrictMode,
          identifierPrefix,
          onUncaughtError,
          onCaughtError,
          onRecoverableError,
          transitionCallbacks,
          null
        );
        container[internalContainerInstanceKey] = options.current;
        listenToAllSupportedEvents(container);
        return new ReactDOMRoot(options);
      };
      exports.hydrateRoot = function (container, initialChildren, options) {
        if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299));
        var isStrictMode = !1,
          identifierPrefix = '',
          onUncaughtError = defaultOnUncaughtError,
          onCaughtError = defaultOnCaughtError,
          onRecoverableError = defaultOnRecoverableError,
          transitionCallbacks = null,
          formState = null;
        null !== options &&
          void 0 !== options &&
          (!0 === options.unstable_strictMode && (isStrictMode = !0),
          void 0 !== options.identifierPrefix && (identifierPrefix = options.identifierPrefix),
          void 0 !== options.onUncaughtError && (onUncaughtError = options.onUncaughtError),
          void 0 !== options.onCaughtError && (onCaughtError = options.onCaughtError),
          void 0 !== options.onRecoverableError &&
            (onRecoverableError = options.onRecoverableError),
          void 0 !== options.unstable_transitionCallbacks &&
            (transitionCallbacks = options.unstable_transitionCallbacks),
          void 0 !== options.formState && (formState = options.formState));
        initialChildren = createFiberRoot(
          container,
          1,
          !0,
          initialChildren,
          null != options ? options : null,
          isStrictMode,
          identifierPrefix,
          onUncaughtError,
          onCaughtError,
          onRecoverableError,
          transitionCallbacks,
          formState
        );
        initialChildren.context = getContextForSubtree(null);
        options = initialChildren.current;
        isStrictMode = requestUpdateLane();
        isStrictMode = getBumpedLaneForHydrationByLane(isStrictMode);
        identifierPrefix = createUpdate(isStrictMode);
        identifierPrefix.callback = null;
        enqueueUpdate(options, identifierPrefix, isStrictMode);
        options = isStrictMode;
        initialChildren.current.lanes = options;
        markRootUpdated$1(initialChildren, options);
        ensureRootIsScheduled(initialChildren);
        container[internalContainerInstanceKey] = initialChildren.current;
        listenToAllSupportedEvents(container);
        return new ReactDOMHydrationRoot(initialChildren);
      };
      exports.version = '19.1.1';

      /***/
    },

    /***/ 790: /***/ (module) => {
      module.exports = function (item) {
        var content = item[1];
        var cssMapping = item[3];
        if (!cssMapping) {
          return content;
        }
        if (typeof btoa === 'function') {
          var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
          var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,'.concat(base64);
          var sourceMapping = '/*# '.concat(data, ' */');
          return [content].concat([sourceMapping]).join('\n');
        }
        return [content].join('\n');
      };

      /***/
    },

    /***/ 813: /***/ (module, __unused_webpack_exports, __webpack_require__) => {
      if (true) {
        module.exports = __webpack_require__(701);
      } // removed by dead control flow
      else {
      }

      /***/
    },

    /***/ 909: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
      /**
       * @license React
       * react-dom.production.js
       *
       * Copyright (c) Meta Platforms, Inc. and affiliates.
       *
       * This source code is licensed under the MIT license found in the
       * LICENSE file in the root directory of this source tree.
       */

      var React = __webpack_require__(729);
      function formatProdErrorMessage(code) {
        var url = 'https://react.dev/errors/' + code;
        if (1 < arguments.length) {
          url += '?args[]=' + encodeURIComponent(arguments[1]);
          for (var i = 2; i < arguments.length; i++)
            url += '&args[]=' + encodeURIComponent(arguments[i]);
        }
        return (
          'Minified React error #' +
          code +
          '; visit ' +
          url +
          ' for the full message or use the non-minified dev environment for full errors and additional helpful warnings.'
        );
      }
      function noop() {}
      var Internals = {
          d: {
            f: noop,
            r: function () {
              throw Error(formatProdErrorMessage(522));
            },
            D: noop,
            C: noop,
            L: noop,
            m: noop,
            X: noop,
            S: noop,
            M: noop,
          },
          p: 0,
          findDOMNode: null,
        },
        REACT_PORTAL_TYPE = Symbol.for('react.portal');
      function createPortal$1(children, containerInfo, implementation) {
        var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
        return {
          $$typeof: REACT_PORTAL_TYPE,
          key: null == key ? null : '' + key,
          children: children,
          containerInfo: containerInfo,
          implementation: implementation,
        };
      }
      var ReactSharedInternals =
        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
      function getCrossOriginStringAs(as, input) {
        if ('font' === as) return '';
        if ('string' === typeof input) return 'use-credentials' === input ? input : '';
      }
      exports.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
      exports.createPortal = function (children, container) {
        var key = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
        if (
          !container ||
          (1 !== container.nodeType && 9 !== container.nodeType && 11 !== container.nodeType)
        )
          throw Error(formatProdErrorMessage(299));
        return createPortal$1(children, container, null, key);
      };
      exports.flushSync = function (fn) {
        var previousTransition = ReactSharedInternals.T,
          previousUpdatePriority = Internals.p;
        try {
          if (((ReactSharedInternals.T = null), (Internals.p = 2), fn)) return fn();
        } finally {
          ((ReactSharedInternals.T = previousTransition),
            (Internals.p = previousUpdatePriority),
            Internals.d.f());
        }
      };
      exports.preconnect = function (href, options) {
        'string' === typeof href &&
          (options
            ? ((options = options.crossOrigin),
              (options =
                'string' === typeof options
                  ? 'use-credentials' === options
                    ? options
                    : ''
                  : void 0))
            : (options = null),
          Internals.d.C(href, options));
      };
      exports.prefetchDNS = function (href) {
        'string' === typeof href && Internals.d.D(href);
      };
      exports.preinit = function (href, options) {
        if ('string' === typeof href && options && 'string' === typeof options.as) {
          var as = options.as,
            crossOrigin = getCrossOriginStringAs(as, options.crossOrigin),
            integrity = 'string' === typeof options.integrity ? options.integrity : void 0,
            fetchPriority =
              'string' === typeof options.fetchPriority ? options.fetchPriority : void 0;
          'style' === as
            ? Internals.d.S(
                href,
                'string' === typeof options.precedence ? options.precedence : void 0,
                {
                  crossOrigin: crossOrigin,
                  integrity: integrity,
                  fetchPriority: fetchPriority,
                }
              )
            : 'script' === as &&
              Internals.d.X(href, {
                crossOrigin: crossOrigin,
                integrity: integrity,
                fetchPriority: fetchPriority,
                nonce: 'string' === typeof options.nonce ? options.nonce : void 0,
              });
        }
      };
      exports.preinitModule = function (href, options) {
        if ('string' === typeof href)
          if ('object' === typeof options && null !== options) {
            if (null == options.as || 'script' === options.as) {
              var crossOrigin = getCrossOriginStringAs(options.as, options.crossOrigin);
              Internals.d.M(href, {
                crossOrigin: crossOrigin,
                integrity: 'string' === typeof options.integrity ? options.integrity : void 0,
                nonce: 'string' === typeof options.nonce ? options.nonce : void 0,
              });
            }
          } else null == options && Internals.d.M(href);
      };
      exports.preload = function (href, options) {
        if (
          'string' === typeof href &&
          'object' === typeof options &&
          null !== options &&
          'string' === typeof options.as
        ) {
          var as = options.as,
            crossOrigin = getCrossOriginStringAs(as, options.crossOrigin);
          Internals.d.L(href, as, {
            crossOrigin: crossOrigin,
            integrity: 'string' === typeof options.integrity ? options.integrity : void 0,
            nonce: 'string' === typeof options.nonce ? options.nonce : void 0,
            type: 'string' === typeof options.type ? options.type : void 0,
            fetchPriority:
              'string' === typeof options.fetchPriority ? options.fetchPriority : void 0,
            referrerPolicy:
              'string' === typeof options.referrerPolicy ? options.referrerPolicy : void 0,
            imageSrcSet: 'string' === typeof options.imageSrcSet ? options.imageSrcSet : void 0,
            imageSizes: 'string' === typeof options.imageSizes ? options.imageSizes : void 0,
            media: 'string' === typeof options.media ? options.media : void 0,
          });
        }
      };
      exports.preloadModule = function (href, options) {
        if ('string' === typeof href)
          if (options) {
            var crossOrigin = getCrossOriginStringAs(options.as, options.crossOrigin);
            Internals.d.m(href, {
              as: 'string' === typeof options.as && 'script' !== options.as ? options.as : void 0,
              crossOrigin: crossOrigin,
              integrity: 'string' === typeof options.integrity ? options.integrity : void 0,
            });
          } else Internals.d.m(href);
      };
      exports.requestFormReset = function (form) {
        Internals.d.r(form);
      };
      exports.unstable_batchedUpdates = function (fn, a) {
        return fn(a);
      };
      exports.useFormState = function (action, initialState, permalink) {
        return ReactSharedInternals.H.useFormState(action, initialState, permalink);
      };
      exports.useFormStatus = function () {
        return ReactSharedInternals.H.useHostTransitionStatus();
      };
      exports.version = '19.1.1';

      /***/
    },

    /***/ 937: /***/ (module, __unused_webpack_exports, __webpack_require__) => {
      function checkDCE() {
        /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
        if (
          typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||
          typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'
        ) {
          return;
        }
        if (false) {
          // removed by dead control flow
        }
        try {
          // Verify that the code above has been dead code eliminated (DCE'd).
          __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
        } catch (err) {
          // DevTools shouldn't crash React, no matter what.
          // We should still report in case we break this code.
          console.error(err);
        }
      }

      if (true) {
        // DCE check should happen before ReactDOM bundle executes so that
        // DevTools can report bad minification during injection.
        checkDCE();
        module.exports = __webpack_require__(909);
      } // removed by dead control flow
      else {
      }

      /***/
    },

    /******/
  };
  /************************************************************************/
  /******/ // The module cache
  /******/ var __webpack_module_cache__ = {};
  /******/
  /******/ // The require function
  /******/ function __webpack_require__(moduleId) {
    /******/ // Check if module is in cache
    /******/ var cachedModule = __webpack_module_cache__[moduleId];
    /******/ if (cachedModule !== undefined) {
      /******/ return cachedModule.exports;
      /******/
    }
    /******/ // Create a new module (and put it into the cache)
    /******/ var module = (__webpack_module_cache__[moduleId] = {
      /******/ id: moduleId,
      /******/ // no module.loaded needed
      /******/ exports: {},
      /******/
    });
    /******/
    /******/ // Execute the module function
    /******/ __webpack_modules__[moduleId](module, module.exports, __webpack_require__);
    /******/
    /******/ // Return the exports of the module
    /******/ return module.exports;
    /******/
  }
  /******/
  /************************************************************************/
  /******/ /* webpack/runtime/compat get default export */
  /******/ (() => {
    /******/ // getDefaultExport function for compatibility with non-harmony modules
    /******/ __webpack_require__.n = (module) => {
      /******/ var getter =
        module && module.__esModule ? /******/ () => module['default'] : /******/ () => module;
      /******/ __webpack_require__.d(getter, { a: getter });
      /******/ return getter;
      /******/
    };
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/create fake namespace object */
  /******/ (() => {
    /******/ var getProto = Object.getPrototypeOf
      ? (obj) => Object.getPrototypeOf(obj)
      : (obj) => obj.__proto__;
    /******/ var leafPrototypes;
    /******/ // create a fake namespace object
    /******/ // mode & 1: value is a module id, require it
    /******/ // mode & 2: merge all properties of value into the ns
    /******/ // mode & 4: return value when already ns object
    /******/ // mode & 16: return value when it's Promise-like
    /******/ // mode & 8|1: behave like require
    /******/ __webpack_require__.t = function (value, mode) {
      /******/ if (mode & 1) value = this(value);
      /******/ if (mode & 8) return value;
      /******/ if (typeof value === 'object' && value) {
        /******/ if (mode & 4 && value.__esModule) return value;
        /******/ if (mode & 16 && typeof value.then === 'function') return value;
        /******/
      }
      /******/ var ns = Object.create(null);
      /******/ __webpack_require__.r(ns);
      /******/ var def = {};
      /******/ leafPrototypes = leafPrototypes || [
        null,
        getProto({}),
        getProto([]),
        getProto(getProto),
      ];
      /******/ for (
        var current = mode & 2 && value;
        (typeof current == 'object' || typeof current == 'function') &&
        !~leafPrototypes.indexOf(current);
        current = getProto(current)
      ) {
        /******/ Object.getOwnPropertyNames(current).forEach(
          (key) => (def[key] = () => value[key])
        );
        /******/
      }
      /******/ def['default'] = () => value;
      /******/ __webpack_require__.d(ns, def);
      /******/ return ns;
      /******/
    };
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/define property getters */
  /******/ (() => {
    /******/ // define getter functions for harmony exports
    /******/ __webpack_require__.d = (exports, definition) => {
      /******/ for (var key in definition) {
        /******/ if (
          __webpack_require__.o(definition, key) &&
          !__webpack_require__.o(exports, key)
        ) {
          /******/ Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
          /******/
        }
        /******/
      }
      /******/
    };
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/hasOwnProperty shorthand */
  /******/ (() => {
    /******/ __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/make namespace object */
  /******/ (() => {
    /******/ // define __esModule on exports
    /******/ __webpack_require__.r = (exports) => {
      /******/ if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
        /******/ Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
        /******/
      }
      /******/ Object.defineProperty(exports, '__esModule', { value: true });
      /******/
    };
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/nonce */
  /******/ (() => {
    /******/ __webpack_require__.nc = undefined;
    /******/
  })();
  /******/
  /************************************************************************/
  var __webpack_exports__ = {};

  // EXTERNAL MODULE: ./node_modules/.pnpm/react@19.1.1/node_modules/react/jsx-runtime.js
  var jsx_runtime = __webpack_require__(813);
  // EXTERNAL MODULE: ./node_modules/.pnpm/react-dom@19.1.1_react@19.1.1/node_modules/react-dom/client.js
  var client = __webpack_require__(66);
  // EXTERNAL MODULE: ./node_modules/.pnpm/react@19.1.1/node_modules/react/index.js
  var react = __webpack_require__(729);
  var react_namespaceObject = /*#__PURE__*/ __webpack_require__.t(react, 2); // ./app-config.ts
  const APP_CONFIG_DEFAULTS = {
    companyName: 'LiveKit',
    pageTitle: 'LiveKit Voice Agent',
    pageDescription: 'A voice agent built with LiveKit',
    supportsChatInput: true,
    supportsVideoInput: true,
    supportsScreenShare: true,
    isPreConnectBufferEnabled: true,
    logo: '/lk-logo.svg',
    accent: '#002cf2',
    logoDark: '/lk-logo-dark.svg',
    accentDark: '#1fd5f9',
    startButtonText: 'Start call',
    // for LiveKit Cloud Sandbox
    sandboxId: undefined,
    agentName: 'choudou-agent', // Explicitly dispatch our Choudou agent
  }; // ./lib/env.ts

  const CONFIG_ENDPOINT = 'MISSING_ENV_VAR'.NEXT_PUBLIC_APP_CONFIG_ENDPOINT;
  const SANDBOX_ID = 'MISSING_ENV_VAR'.SANDBOX_ID;
  const THEME_STORAGE_KEY = 'theme-mode';
  const THEME_MEDIA_QUERY = '(prefers-color-scheme: dark)';
  function getOrigin(headers) {
    const host = headers.get('host');
    const proto = headers.get('x-forwarded-proto') || 'https';
    return `${proto}://${host}`;
  }
  function getSandboxId(origin) {
    return SANDBOX_ID !== null && SANDBOX_ID !== void 0 ? SANDBOX_ID : origin.split('.')[0];
  }
  // https://react.dev/reference/react/cache#caveats
  // > React will invalidate the cache for all memoized functions for each server request.
  const getAppConfig = (0, react.cache)(async (origin, sandboxIdAttribute) => {
    if (CONFIG_ENDPOINT) {
      const sandboxId =
        sandboxIdAttribute !== null && sandboxIdAttribute !== void 0
          ? sandboxIdAttribute
          : getSandboxId(origin);
      try {
        const response = await fetch(CONFIG_ENDPOINT, {
          cache: 'no-store',
          headers: { 'X-Sandbox-ID': sandboxId },
        });
        const remoteConfig = await response.json();
        const config = Object.assign({}, APP_CONFIG_DEFAULTS);
        for (const [key, entry] of Object.entries(remoteConfig)) {
          if (entry === null) continue;
          if (
            key in config &&
            typeof config[key] === entry.type &&
            typeof config[key] === typeof entry.value
          ) {
            // @ts-expect-error I'm not sure quite how to appease TypeScript, but we've thoroughly checked types above
            config[key] = entry.value;
          }
        }
        return config;
      } catch (error) {
        console.error('!!!', error);
      }
    }
    return APP_CONFIG_DEFAULTS;
  });

  // EXTERNAL MODULE: ./styles/globals.css
  var globals = __webpack_require__(625); // ./node_modules/.pnpm/livekit-client@2.15.8_@types+dom-mediacapture-record@1.0.22/node_modules/livekit-client/dist/livekit-client.esm.mjs
  function _mergeNamespaces(n, m) {
    m.forEach(function (e) {
      e &&
        typeof e !== 'string' &&
        !Array.isArray(e) &&
        Object.keys(e).forEach(function (k) {
          if (k !== 'default' && !(k in n)) {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(
              n,
              k,
              d.get
                ? d
                : {
                    enumerable: true,
                    get: function () {
                      return e[k];
                    },
                  }
            );
          }
        });
    });
    return Object.freeze(n);
  }

  var livekit_client_esm_e = Object.defineProperty;
  var livekit_client_esm_h = (i, s, t) =>
    s in i
      ? livekit_client_esm_e(i, s, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: t,
        })
      : (i[s] = t);
  var o = (i, s, t) => livekit_client_esm_h(i, typeof s != 'symbol' ? s + '' : s, t);
  class livekit_client_esm_ {
    constructor() {
      o(this, '_locking');
      o(this, '_locks');
      ((this._locking = Promise.resolve()), (this._locks = 0));
    }
    isLocked() {
      return this._locks > 0;
    }
    lock() {
      this._locks += 1;
      let s;
      const t = new Promise(
          (l) =>
            (s = () => {
              ((this._locks -= 1), l());
            })
        ),
        c = this._locking.then(() => s);
      return ((this._locking = this._locking.then(() => t)), c);
    }
  }

  // Copyright 2021-2024 Buf Technologies, Inc.
  //
  // Licensed under the Apache License, Version 2.0 (the "License");
  // you may not use this file except in compliance with the License.
  // You may obtain a copy of the License at
  //
  //      http://www.apache.org/licenses/LICENSE-2.0
  //
  // Unless required by applicable law or agreed to in writing, software
  // distributed under the License is distributed on an "AS IS" BASIS,
  // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  // See the License for the specific language governing permissions and
  // limitations under the License.
  /**
   * Assert that condition is truthy or throw error (with message)
   */
  function assert(condition, msg) {
    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions -- we want the implicit conversion to boolean
    if (!condition) {
      throw new Error(msg);
    }
  }
  const FLOAT32_MAX = 3.4028234663852886e38,
    FLOAT32_MIN = -34028234663852886e22,
    UINT32_MAX = 0xffffffff,
    INT32_MAX = 0x7fffffff,
    INT32_MIN = -2147483648;
  /**
   * Assert a valid signed protobuf 32-bit integer.
   */
  function assertInt32(arg) {
    if (typeof arg !== 'number') throw new Error('invalid int 32: ' + typeof arg);
    if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN)
      throw new Error('invalid int 32: ' + arg); // eslint-disable-line @typescript-eslint/restrict-plus-operands -- we want the implicit conversion to string
  }
  /**
   * Assert a valid unsigned protobuf 32-bit integer.
   */
  function assertUInt32(arg) {
    if (typeof arg !== 'number') throw new Error('invalid uint 32: ' + typeof arg);
    if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0)
      throw new Error('invalid uint 32: ' + arg); // eslint-disable-line @typescript-eslint/restrict-plus-operands -- we want the implicit conversion to string
  }
  /**
   * Assert a valid protobuf float value.
   */
  function assertFloat32(arg) {
    if (typeof arg !== 'number') throw new Error('invalid float 32: ' + typeof arg);
    if (!Number.isFinite(arg)) return;
    if (arg > FLOAT32_MAX || arg < FLOAT32_MIN) throw new Error('invalid float 32: ' + arg); // eslint-disable-line @typescript-eslint/restrict-plus-operands -- we want the implicit conversion to string
  }

  // Copyright 2021-2024 Buf Technologies, Inc.
  //
  // Licensed under the Apache License, Version 2.0 (the "License");
  // you may not use this file except in compliance with the License.
  // You may obtain a copy of the License at
  //
  //      http://www.apache.org/licenses/LICENSE-2.0
  //
  // Unless required by applicable law or agreed to in writing, software
  // distributed under the License is distributed on an "AS IS" BASIS,
  // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  // See the License for the specific language governing permissions and
  // limitations under the License.
  const enumTypeSymbol = Symbol('@bufbuild/protobuf/enum-type');
  /**
   * Get reflection information from a generated enum.
   * If this function is called on something other than a generated
   * enum, it raises an error.
   */
  function getEnumType(enumObject) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-explicit-any
    const t = enumObject[enumTypeSymbol];
    assert(t, 'missing enum type on enum object');
    return t; // eslint-disable-line @typescript-eslint/no-unsafe-return
  }
  /**
   * Sets reflection information on a generated enum.
   */
  function setEnumType(enumObject, typeName, values, opt) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any
    enumObject[enumTypeSymbol] = makeEnumType(
      typeName,
      values.map((v) => ({
        no: v.no,
        name: v.name,
        localName: enumObject[v.no],
      }))
    );
  }
  /**
   * Create a new EnumType with the given values.
   */
  function makeEnumType(
    typeName,
    values,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _opt
  ) {
    const names = Object.create(null);
    const numbers = Object.create(null);
    const normalValues = [];
    for (const value of values) {
      // We do not surface options at this time
      // const value: EnumValueInfo = {...v, options: v.options ?? emptyReadonlyObject};
      const n = normalizeEnumValue(value);
      normalValues.push(n);
      names[value.name] = n;
      numbers[value.no] = n;
    }
    return {
      typeName,
      values: normalValues,
      // We do not surface options at this time
      // options: opt?.options ?? Object.create(null),
      findName(name) {
        return names[name];
      },
      findNumber(no) {
        return numbers[no];
      },
    };
  }
  /**
   * Create a new enum object with the given values.
   * Sets reflection information.
   */
  function makeEnum(typeName, values, opt) {
    const enumObject = {};
    for (const value of values) {
      const n = normalizeEnumValue(value);
      enumObject[n.localName] = n.no;
      enumObject[n.no] = n.localName;
    }
    setEnumType(enumObject, typeName, values);
    return enumObject;
  }
  function normalizeEnumValue(value) {
    if ('localName' in value) {
      return value;
    }
    return Object.assign(Object.assign({}, value), {
      localName: value.name,
    });
  }

  // Copyright 2021-2024 Buf Technologies, Inc.
  //
  // Licensed under the Apache License, Version 2.0 (the "License");
  // you may not use this file except in compliance with the License.
  // You may obtain a copy of the License at
  //
  //      http://www.apache.org/licenses/LICENSE-2.0
  //
  // Unless required by applicable law or agreed to in writing, software
  // distributed under the License is distributed on an "AS IS" BASIS,
  // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  // See the License for the specific language governing permissions and
  // limitations under the License.
  /**
   * Message is the base class of every message, generated, or created at
   * runtime.
   *
   * It is _not_ safe to extend this class. If you want to create a message at
   * run time, use proto3.makeMessageType().
   */
  class Message {
    /**
     * Compare with a message of the same type.
     * Note that this function disregards extensions and unknown fields.
     */
    equals(other) {
      return this.getType().runtime.util.equals(this.getType(), this, other);
    }
    /**
     * Create a deep copy.
     */
    clone() {
      return this.getType().runtime.util.clone(this);
    }
    /**
     * Parse from binary data, merging fields.
     *
     * Repeated fields are appended. Map entries are added, overwriting
     * existing keys.
     *
     * If a message field is already present, it will be merged with the
     * new data.
     */
    fromBinary(bytes, options) {
      const type = this.getType(),
        format = type.runtime.bin,
        opt = format.makeReadOptions(options);
      format.readMessage(this, opt.readerFactory(bytes), bytes.byteLength, opt);
      return this;
    }
    /**
     * Parse a message from a JSON value.
     */
    fromJson(jsonValue, options) {
      const type = this.getType(),
        format = type.runtime.json,
        opt = format.makeReadOptions(options);
      format.readMessage(type, jsonValue, opt, this);
      return this;
    }
    /**
     * Parse a message from a JSON string.
     */
    fromJsonString(jsonString, options) {
      let json;
      try {
        json = JSON.parse(jsonString);
      } catch (e) {
        throw new Error(
          'cannot decode '
            .concat(this.getType().typeName, ' from JSON: ')
            .concat(e instanceof Error ? e.message : String(e))
        );
      }
      return this.fromJson(json, options);
    }
    /**
     * Serialize the message to binary data.
     */
    toBinary(options) {
      const type = this.getType(),
        bin = type.runtime.bin,
        opt = bin.makeWriteOptions(options),
        writer = opt.writerFactory();
      bin.writeMessage(this, writer, opt);
      return writer.finish();
    }
    /**
     * Serialize the message to a JSON value, a JavaScript value that can be
     * passed to JSON.stringify().
     */
    toJson(options) {
      const type = this.getType(),
        json = type.runtime.json,
        opt = json.makeWriteOptions(options);
      return json.writeMessage(this, opt);
    }
    /**
     * Serialize the message to a JSON string.
     */
    toJsonString(options) {
      var _a;
      const value = this.toJson(options);
      return JSON.stringify(
        value,
        null,
        (_a = options === null || options === void 0 ? void 0 : options.prettySpaces) !== null &&
          _a !== void 0
          ? _a
          : 0
      );
    }
    /**
     * Override for serialization behavior. This will be invoked when calling
     * JSON.stringify on this message (i.e. JSON.stringify(msg)).
     *
     * Note that this will not serialize google.protobuf.Any with a packed
     * message because the protobuf JSON format specifies that it needs to be
     * unpacked, and this is only possible with a type registry to look up the
     * message type.  As a result, attempting to serialize a message with this
     * type will throw an Error.
     *
     * This method is protected because you should not need to invoke it
     * directly -- instead use JSON.stringify or toJsonString for
     * stringified JSON.  Alternatively, if actual JSON is desired, you should
     * use toJson.
     */
    toJSON() {
      return this.toJson({
        emitDefaultValues: true,
      });
    }
    /**
     * Retrieve the MessageType of this message - a singleton that represents
     * the protobuf message declaration and provides metadata for reflection-
     * based operations.
     */
    getType() {
      // Any class that extends Message _must_ provide a complete static
      // implementation of MessageType.
      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-return
      return Object.getPrototypeOf(this).constructor;
    }
  }

  // Copyright 2021-2024 Buf Technologies, Inc.
  //
  // Licensed under the Apache License, Version 2.0 (the "License");
  // you may not use this file except in compliance with the License.
  // You may obtain a copy of the License at
  //
  //      http://www.apache.org/licenses/LICENSE-2.0
  //
  // Unless required by applicable law or agreed to in writing, software
  // distributed under the License is distributed on an "AS IS" BASIS,
  // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  // See the License for the specific language governing permissions and
  // limitations under the License.
  /**
   * Create a new message type using the given runtime.
   */
  function makeMessageType(runtime, typeName, fields, opt) {
    var _a;
    const localName =
      (_a = opt === null || opt === void 0 ? void 0 : opt.localName) !== null && _a !== void 0
        ? _a
        : typeName.substring(typeName.lastIndexOf('.') + 1);
    const type = {
      [localName]: function (data) {
        runtime.util.initFields(this);
        runtime.util.initPartial(data, this);
      },
    }[localName];
    Object.setPrototypeOf(type.prototype, new Message());
    Object.assign(type, {
      runtime,
      typeName,
      fields: runtime.util.newFieldList(fields),
      fromBinary(bytes, options) {
        return new type().fromBinary(bytes, options);
      },
      fromJson(jsonValue, options) {
        return new type().fromJson(jsonValue, options);
      },
      fromJsonString(jsonString, options) {
        return new type().fromJsonString(jsonString, options);
      },
      equals(a, b) {
        return runtime.util.equals(type, a, b);
      },
    });
    return type;
  }

  // Copyright 2008 Google Inc.  All rights reserved.
  //
  // Redistribution and use in source and binary forms, with or without
  // modification, are permitted provided that the following conditions are
  // met:
  //
  // * Redistributions of source code must retain the above copyright
  // notice, this list of conditions and the following disclaimer.
  // * Redistributions in binary form must reproduce the above
  // copyright notice, this list of conditions and the following disclaimer
  // in the documentation and/or other materials provided with the
  // distribution.
  // * Neither the name of Google Inc. nor the names of its
  // contributors may be used to endorse or promote products derived from
  // this software without specific prior written permission.
  //
  // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  //
  // Code generated by the Protocol Buffer compiler is owned by the owner
  // of the input file used when generating it.  This code is not
  // standalone and requires a support library to be linked with it.  This
  // support library is itself covered by the above license.
  /* eslint-disable prefer-const,@typescript-eslint/restrict-plus-operands */
  /**
   * Read a 64 bit varint as two JS numbers.
   *
   * Returns tuple:
   * [0]: low bits
   * [1]: high bits
   *
   * Copyright 2008 Google Inc.  All rights reserved.
   *
   * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L175
   */
  function varint64read() {
    let lowBits = 0;
    let highBits = 0;
    for (let shift = 0; shift < 28; shift += 7) {
      let b = this.buf[this.pos++];
      lowBits |= (b & 0x7f) << shift;
      if ((b & 0x80) == 0) {
        this.assertBounds();
        return [lowBits, highBits];
      }
    }
    let middleByte = this.buf[this.pos++];
    // last four bits of the first 32 bit number
    lowBits |= (middleByte & 0x0f) << 28;
    // 3 upper bits are part of the next 32 bit number
    highBits = (middleByte & 0x70) >> 4;
    if ((middleByte & 0x80) == 0) {
      this.assertBounds();
      return [lowBits, highBits];
    }
    for (let shift = 3; shift <= 31; shift += 7) {
      let b = this.buf[this.pos++];
      highBits |= (b & 0x7f) << shift;
      if ((b & 0x80) == 0) {
        this.assertBounds();
        return [lowBits, highBits];
      }
    }
    throw new Error('invalid varint');
  }
  /**
   * Write a 64 bit varint, given as two JS numbers, to the given bytes array.
   *
   * Copyright 2008 Google Inc.  All rights reserved.
   *
   * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/writer.js#L344
   */
  function varint64write(lo, hi, bytes) {
    for (let i = 0; i < 28; i = i + 7) {
      const shift = lo >>> i;
      const hasNext = !(shift >>> 7 == 0 && hi == 0);
      const byte = (hasNext ? shift | 0x80 : shift) & 0xff;
      bytes.push(byte);
      if (!hasNext) {
        return;
      }
    }
    const splitBits = ((lo >>> 28) & 0x0f) | ((hi & 0x07) << 4);
    const hasMoreBits = !(hi >> 3 == 0);
    bytes.push((hasMoreBits ? splitBits | 0x80 : splitBits) & 0xff);
    if (!hasMoreBits) {
      return;
    }
    for (let i = 3; i < 31; i = i + 7) {
      const shift = hi >>> i;
      const hasNext = !(shift >>> 7 == 0);
      const byte = (hasNext ? shift | 0x80 : shift) & 0xff;
      bytes.push(byte);
      if (!hasNext) {
        return;
      }
    }
    bytes.push((hi >>> 31) & 0x01);
  }
  // constants for binary math
  const TWO_PWR_32_DBL = 0x100000000;
  /**
   * Parse decimal string of 64 bit integer value as two JS numbers.
   *
   * Copyright 2008 Google Inc.  All rights reserved.
   *
   * See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10
   */
  function int64FromString(dec) {
    // Check for minus sign.
    const minus = dec[0] === '-';
    if (minus) {
      dec = dec.slice(1);
    }
    // Work 6 decimal digits at a time, acting like we're converting base 1e6
    // digits to binary. This is safe to do with floating point math because
    // Number.isSafeInteger(ALL_32_BITS * 1e6) == true.
    const base = 1e6;
    let lowBits = 0;
    let highBits = 0;
    function add1e6digit(begin, end) {
      // Note: Number('') is 0.
      const digit1e6 = Number(dec.slice(begin, end));
      highBits *= base;
      lowBits = lowBits * base + digit1e6;
      // Carry bits from lowBits to
      if (lowBits >= TWO_PWR_32_DBL) {
        highBits = highBits + ((lowBits / TWO_PWR_32_DBL) | 0);
        lowBits = lowBits % TWO_PWR_32_DBL;
      }
    }
    add1e6digit(-24, -18);
    add1e6digit(-18, -12);
    add1e6digit(-12, -6);
    add1e6digit(-6);
    return minus ? negate(lowBits, highBits) : newBits(lowBits, highBits);
  }
  /**
   * Losslessly converts a 64-bit signed integer in 32:32 split representation
   * into a decimal string.
   *
   * Copyright 2008 Google Inc.  All rights reserved.
   *
   * See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10
   */
  function int64ToString(lo, hi) {
    let bits = newBits(lo, hi);
    // If we're treating the input as a signed value and the high bit is set, do
    // a manual two's complement conversion before the decimal conversion.
    const negative = bits.hi & 0x80000000;
    if (negative) {
      bits = negate(bits.lo, bits.hi);
    }
    const result = uInt64ToString(bits.lo, bits.hi);
    return negative ? '-' + result : result;
  }
  /**
   * Losslessly converts a 64-bit unsigned integer in 32:32 split representation
   * into a decimal string.
   *
   * Copyright 2008 Google Inc.  All rights reserved.
   *
   * See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10
   */
  function uInt64ToString(lo, hi) {
    ({ lo, hi } = toUnsigned(lo, hi));
    // Skip the expensive conversion if the number is small enough to use the
    // built-in conversions.
    // Number.MAX_SAFE_INTEGER = 0x001FFFFF FFFFFFFF, thus any number with
    // highBits <= 0x1FFFFF can be safely expressed with a double and retain
    // integer precision.
    // Proven by: Number.isSafeInteger(0x1FFFFF * 2**32 + 0xFFFFFFFF) == true.
    if (hi <= 0x1fffff) {
      return String(TWO_PWR_32_DBL * hi + lo);
    }
    // What this code is doing is essentially converting the input number from
    // base-2 to base-1e7, which allows us to represent the 64-bit range with
    // only 3 (very large) digits. Those digits are then trivial to convert to
    // a base-10 string.
    // The magic numbers used here are -
    // 2^24 = 16777216 = (1,6777216) in base-1e7.
    // 2^48 = 281474976710656 = (2,8147497,6710656) in base-1e7.
    // Split 32:32 representation into 16:24:24 representation so our
    // intermediate digits don't overflow.
    const low = lo & 0xffffff;
    const mid = ((lo >>> 24) | (hi << 8)) & 0xffffff;
    const high = (hi >> 16) & 0xffff;
    // Assemble our three base-1e7 digits, ignoring carries. The maximum
    // value in a digit at this step is representable as a 48-bit integer, which
    // can be stored in a 64-bit floating point number.
    let digitA = low + mid * 6777216 + high * 6710656;
    let digitB = mid + high * 8147497;
    let digitC = high * 2;
    // Apply carries from A to B and from B to C.
    const base = 10000000;
    if (digitA >= base) {
      digitB += Math.floor(digitA / base);
      digitA %= base;
    }
    if (digitB >= base) {
      digitC += Math.floor(digitB / base);
      digitB %= base;
    }
    // If digitC is 0, then we should have returned in the trivial code path
    // at the top for non-safe integers. Given this, we can assume both digitB
    // and digitA need leading zeros.
    return (
      digitC.toString() +
      decimalFrom1e7WithLeadingZeros(digitB) +
      decimalFrom1e7WithLeadingZeros(digitA)
    );
  }
  function toUnsigned(lo, hi) {
    return {
      lo: lo >>> 0,
      hi: hi >>> 0,
    };
  }
  function newBits(lo, hi) {
    return {
      lo: lo | 0,
      hi: hi | 0,
    };
  }
  /**
   * Returns two's compliment negation of input.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Signed_32-bit_integers
   */
  function negate(lowBits, highBits) {
    highBits = ~highBits;
    if (lowBits) {
      lowBits = ~lowBits + 1;
    } else {
      // If lowBits is 0, then bitwise-not is 0xFFFFFFFF,
      // adding 1 to that, results in 0x100000000, which leaves
      // the low bits 0x0 and simply adds one to the high bits.
      highBits += 1;
    }
    return newBits(lowBits, highBits);
  }
  /**
   * Returns decimal representation of digit1e7 with leading zeros.
   */
  const decimalFrom1e7WithLeadingZeros = (digit1e7) => {
    const partial = String(digit1e7);
    return '0000000'.slice(partial.length) + partial;
  };
  /**
   * Write a 32 bit varint, signed or unsigned. Same as `varint64write(0, value, bytes)`
   *
   * Copyright 2008 Google Inc.  All rights reserved.
   *
   * See https://github.com/protocolbuffers/protobuf/blob/1b18833f4f2a2f681f4e4a25cdf3b0a43115ec26/js/binary/encoder.js#L144
   */
  function varint32write(value, bytes) {
    if (value >= 0) {
      // write value as varint 32
      while (value > 0x7f) {
        bytes.push((value & 0x7f) | 0x80);
        value = value >>> 7;
      }
      bytes.push(value);
    } else {
      for (let i = 0; i < 9; i++) {
        bytes.push((value & 127) | 128);
        value = value >> 7;
      }
      bytes.push(1);
    }
  }
  /**
   * Read an unsigned 32 bit varint.
   *
   * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L220
   */
  function varint32read() {
    let b = this.buf[this.pos++];
    let result = b & 0x7f;
    if ((b & 0x80) == 0) {
      this.assertBounds();
      return result;
    }
    b = this.buf[this.pos++];
    result |= (b & 0x7f) << 7;
    if ((b & 0x80) == 0) {
      this.assertBounds();
      return result;
    }
    b = this.buf[this.pos++];
    result |= (b & 0x7f) << 14;
    if ((b & 0x80) == 0) {
      this.assertBounds();
      return result;
    }
    b = this.buf[this.pos++];
    result |= (b & 0x7f) << 21;
    if ((b & 0x80) == 0) {
      this.assertBounds();
      return result;
    }
    // Extract only last 4 bits
    b = this.buf[this.pos++];
    result |= (b & 0x0f) << 28;
    for (let readBytes = 5; (b & 0x80) !== 0 && readBytes < 10; readBytes++)
      b = this.buf[this.pos++];
    if ((b & 0x80) != 0) throw new Error('invalid varint');
    this.assertBounds();
    // Result can have 32 bits, convert it to unsigned
    return result >>> 0;
  }

  // Copyright 2021-2024 Buf Technologies, Inc.
  //
  // Licensed under the Apache License, Version 2.0 (the "License");
  // you may not use this file except in compliance with the License.
  // You may obtain a copy of the License at
  //
  //      http://www.apache.org/licenses/LICENSE-2.0
  //
  // Unless required by applicable law or agreed to in writing, software
  // distributed under the License is distributed on an "AS IS" BASIS,
  // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  // See the License for the specific language governing permissions and
  // limitations under the License.
  function makeInt64Support() {
    const dv = new DataView(new ArrayBuffer(8));
    // note that Safari 14 implements BigInt, but not the DataView methods
    const ok =
      typeof BigInt === 'function' &&
      typeof dv.getBigInt64 === 'function' &&
      typeof dv.getBigUint64 === 'function' &&
      typeof dv.setBigInt64 === 'function' &&
      typeof dv.setBigUint64 === 'function' &&
      (typeof process != 'object' || 'string' != 'object' || 0);
    if (ok) {
      const MIN = BigInt('-9223372036854775808'),
        MAX = BigInt('9223372036854775807'),
        UMIN = BigInt('0'),
        UMAX = BigInt('18446744073709551615');
      return {
        zero: BigInt(0),
        supported: true,
        parse(value) {
          const bi = typeof value == 'bigint' ? value : BigInt(value);
          if (bi > MAX || bi < MIN) {
            throw new Error('int64 invalid: '.concat(value));
          }
          return bi;
        },
        uParse(value) {
          const bi = typeof value == 'bigint' ? value : BigInt(value);
          if (bi > UMAX || bi < UMIN) {
            throw new Error('uint64 invalid: '.concat(value));
          }
          return bi;
        },
        enc(value) {
          dv.setBigInt64(0, this.parse(value), true);
          return {
            lo: dv.getInt32(0, true),
            hi: dv.getInt32(4, true),
          };
        },
        uEnc(value) {
          dv.setBigInt64(0, this.uParse(value), true);
          return {
            lo: dv.getInt32(0, true),
            hi: dv.getInt32(4, true),
          };
        },
        dec(lo, hi) {
          dv.setInt32(0, lo, true);
          dv.setInt32(4, hi, true);
          return dv.getBigInt64(0, true);
        },
        uDec(lo, hi) {
          dv.setInt32(0, lo, true);
          dv.setInt32(4, hi, true);
          return dv.getBigUint64(0, true);
        },
      };
    }
    const assertInt64String = (value) =>
      assert(/^-?[0-9]+$/.test(value), 'int64 invalid: '.concat(value));
    const assertUInt64String = (value) =>
      assert(/^[0-9]+$/.test(value), 'uint64 invalid: '.concat(value));
    return {
      zero: '0',
      supported: false,
      parse(value) {
        if (typeof value != 'string') {
          value = value.toString();
        }
        assertInt64String(value);
        return value;
      },
      uParse(value) {
        if (typeof value != 'string') {
          value = value.toString();
        }
        assertUInt64String(value);
        return value;
      },
      enc(value) {
        if (typeof value != 'string') {
          value = value.toString();
        }
        assertInt64String(value);
        return int64FromString(value);
      },
      uEnc(value) {
        if (typeof value != 'string') {
          value = value.toString();
        }
        assertUInt64String(value);
        return int64FromString(value);
      },
      dec(lo, hi) {
        return int64ToString(lo, hi);
      },
      uDec(lo, hi) {
        return uInt64ToString(lo, hi);
      },
    };
  }
  const protoInt64 = makeInt64Support();

  // Copyright 2021-2024 Buf Technologies, Inc.
  //
  // Licensed under the Apache License, Version 2.0 (the "License");
  // you may not use this file except in compliance with the License.
  // You may obtain a copy of the License at
  //
  //      http://www.apache.org/licenses/LICENSE-2.0
  //
  // Unless required by applicable law or agreed to in writing, software
  // distributed under the License is distributed on an "AS IS" BASIS,
  // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  // See the License for the specific language governing permissions and
  // limitations under the License.
  /**
   * Scalar value types. This is a subset of field types declared by protobuf
   * enum google.protobuf.FieldDescriptorProto.Type The types GROUP and MESSAGE
   * are omitted, but the numerical values are identical.
   */
  var ScalarType;
  (function (ScalarType) {
    // 0 is reserved for errors.
    // Order is weird for historical reasons.
    ScalarType[(ScalarType['DOUBLE'] = 1)] = 'DOUBLE';
    ScalarType[(ScalarType['FLOAT'] = 2)] = 'FLOAT';
    // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if
    // negative values are likely.
    ScalarType[(ScalarType['INT64'] = 3)] = 'INT64';
    ScalarType[(ScalarType['UINT64'] = 4)] = 'UINT64';
    // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if
    // negative values are likely.
    ScalarType[(ScalarType['INT32'] = 5)] = 'INT32';
    ScalarType[(ScalarType['FIXED64'] = 6)] = 'FIXED64';
    ScalarType[(ScalarType['FIXED32'] = 7)] = 'FIXED32';
    ScalarType[(ScalarType['BOOL'] = 8)] = 'BOOL';
    ScalarType[(ScalarType['STRING'] = 9)] = 'STRING';
    // Tag-delimited aggregate.
    // Group type is deprecated and not supported in proto3. However, Proto3
    // implementations should still be able to parse the group wire format and
    // treat group fields as unknown fields.
    // TYPE_GROUP = 10,
    // TYPE_MESSAGE = 11,  // Length-delimited aggregate.
    // New in version 2.
    ScalarType[(ScalarType['BYTES'] = 12)] = 'BYTES';
    ScalarType[(ScalarType['UINT32'] = 13)] = 'UINT32';
    // TYPE_ENUM = 14,
    ScalarType[(ScalarType['SFIXED32'] = 15)] = 'SFIXED32';
    ScalarType[(ScalarType['SFIXED64'] = 16)] = 'SFIXED64';
    ScalarType[(ScalarType['SINT32'] = 17)] = 'SINT32';
    ScalarType[(ScalarType['SINT64'] = 18)] = 'SINT64';
  })(ScalarType || (ScalarType = {}));
  /**
   * JavaScript representation of fields with 64 bit integral types (int64, uint64,
   * sint64, fixed64, sfixed64).
   *
   * This is a subset of google.protobuf.FieldOptions.JSType, which defines JS_NORMAL,
   * JS_STRING, and JS_NUMBER. Protobuf-ES uses BigInt by default, but will use
   * String if `[jstype = JS_STRING]` is specified.
   *
   * ```protobuf
   * uint64 field_a = 1; // BigInt
   * uint64 field_b = 2 [jstype = JS_NORMAL]; // BigInt
   * uint64 field_b = 2 [jstype = JS_NUMBER]; // BigInt
   * uint64 field_b = 2 [jstype = JS_STRING]; // String
   * ```
   */
  var LongType;
  (function (LongType) {
    /**
     * Use JavaScript BigInt.
     */
    LongType[(LongType['BIGINT'] = 0)] = 'BIGINT';
    /**
     * Use JavaScript String.
     *
     * Field option `[jstype = JS_STRING]`.
     */
    LongType[(LongType['STRING'] = 1)] = 'STRING';
  })(LongType || (LongType = {}));

  // Copyright 2021-2024 Buf Technologies, Inc.
  //
  // Licensed under the Apache License, Version 2.0 (the "License");
  // you may not use this file except in compliance with the License.
  // You may obtain a copy of the License at
  //
  //      http://www.apache.org/licenses/LICENSE-2.0
  //
  // Unless required by applicable law or agreed to in writing, software
  // distributed under the License is distributed on an "AS IS" BASIS,
  // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  // See the License for the specific language governing permissions and
  // limitations under the License.
  /**
   * Returns true if both scalar values are equal.
   */
  function scalarEquals(type, a, b) {
    if (a === b) {
      // This correctly matches equal values except BYTES and (possibly) 64-bit integers.
      return true;
    }
    // Special case BYTES - we need to compare each byte individually
    if (type == ScalarType.BYTES) {
      if (!(a instanceof Uint8Array) || !(b instanceof Uint8Array)) {
        return false;
      }
      if (a.length !== b.length) {
        return false;
      }
      for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
          return false;
        }
      }
      return true;
    }
    // Special case 64-bit integers - we support number, string and bigint representation.
    // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check
    switch (type) {
      case ScalarType.UINT64:
      case ScalarType.FIXED64:
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        // Loose comparison will match between 0n, 0 and "0".
        return a == b;
    }
    // Anything that hasn't been caught by strict comparison or special cased
    // BYTES and 64-bit integers is not equal.
    return false;
  }
  /**
   * Returns the zero value for the given scalar type.
   */
  function scalarZeroValue(type, longType) {
    switch (type) {
      case ScalarType.BOOL:
        return false;
      case ScalarType.UINT64:
      case ScalarType.FIXED64:
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison -- acceptable since it's covered by tests
        return longType == 0 ? protoInt64.zero : '0';
      case ScalarType.DOUBLE:
      case ScalarType.FLOAT:
        return 0.0;
      case ScalarType.BYTES:
        return new Uint8Array(0);
      case ScalarType.STRING:
        return '';
      default:
        // Handles INT32, UINT32, SINT32, FIXED32, SFIXED32.
        // We do not use individual cases to save a few bytes code size.
        return 0;
    }
  }
  /**
   * Returns true for a zero-value. For example, an integer has the zero-value `0`,
   * a boolean is `false`, a string is `""`, and bytes is an empty Uint8Array.
   *
   * In proto3, zero-values are not written to the wire, unless the field is
   * optional or repeated.
   */
  function isScalarZeroValue(type, value) {
    switch (type) {
      case ScalarType.BOOL:
        return value === false;
      case ScalarType.STRING:
        return value === '';
      case ScalarType.BYTES:
        return value instanceof Uint8Array && !value.byteLength;
      default:
        return value == 0;
      // Loose comparison matches 0n, 0 and "0"
    }
  }

  // Copyright 2021-2024 Buf Technologies, Inc.
  //
  // Licensed under the Apache License, Version 2.0 (the "License");
  // you may not use this file except in compliance with the License.
  // You may obtain a copy of the License at
  //
  //      http://www.apache.org/licenses/LICENSE-2.0
  //
  // Unless required by applicable law or agreed to in writing, software
  // distributed under the License is distributed on an "AS IS" BASIS,
  // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  // See the License for the specific language governing permissions and
  // limitations under the License.
  /* eslint-disable prefer-const,no-case-declarations,@typescript-eslint/restrict-plus-operands */
  /**
   * Protobuf binary format wire types.
   *
   * A wire type provides just enough information to find the length of the
   * following value.
   *
   * See https://developers.google.com/protocol-buffers/docs/encoding#structure
   */
  var WireType;
  (function (WireType) {
    /**
     * Used for int32, int64, uint32, uint64, sint32, sint64, bool, enum
     */
    WireType[(WireType['Varint'] = 0)] = 'Varint';
    /**
     * Used for fixed64, sfixed64, double.
     * Always 8 bytes with little-endian byte order.
     */
    WireType[(WireType['Bit64'] = 1)] = 'Bit64';
    /**
     * Used for string, bytes, embedded messages, packed repeated fields
     *
     * Only repeated numeric types (types which use the varint, 32-bit,
     * or 64-bit wire types) can be packed. In proto3, such fields are
     * packed by default.
     */
    WireType[(WireType['LengthDelimited'] = 2)] = 'LengthDelimited';
    /**
     * Start of a tag-delimited aggregate, such as a proto2 group, or a message
     * in editions with message_encoding = DELIMITED.
     */
    WireType[(WireType['StartGroup'] = 3)] = 'StartGroup';
    /**
     * End of a tag-delimited aggregate.
     */
    WireType[(WireType['EndGroup'] = 4)] = 'EndGroup';
    /**
     * Used for fixed32, sfixed32, float.
     * Always 4 bytes with little-endian byte order.
     */
    WireType[(WireType['Bit32'] = 5)] = 'Bit32';
  })(WireType || (WireType = {}));
  class BinaryWriter {
    constructor(textEncoder) {
      /**
       * Previous fork states.
       */
      this.stack = [];
      this.textEncoder =
        textEncoder !== null && textEncoder !== void 0 ? textEncoder : new TextEncoder();
      this.chunks = [];
      this.buf = [];
    }
    /**
     * Return all bytes written and reset this writer.
     */
    finish() {
      this.chunks.push(new Uint8Array(this.buf)); // flush the buffer
      let len = 0;
      for (let i = 0; i < this.chunks.length; i++) len += this.chunks[i].length;
      let bytes = new Uint8Array(len);
      let offset = 0;
      for (let i = 0; i < this.chunks.length; i++) {
        bytes.set(this.chunks[i], offset);
        offset += this.chunks[i].length;
      }
      this.chunks = [];
      return bytes;
    }
    /**
     * Start a new fork for length-delimited data like a message
     * or a packed repeated field.
     *
     * Must be joined later with `join()`.
     */
    fork() {
      this.stack.push({
        chunks: this.chunks,
        buf: this.buf,
      });
      this.chunks = [];
      this.buf = [];
      return this;
    }
    /**
     * Join the last fork. Write its length and bytes, then
     * return to the previous state.
     */
    join() {
      // get chunk of fork
      let chunk = this.finish();
      // restore previous state
      let prev = this.stack.pop();
      if (!prev) throw new Error('invalid state, fork stack empty');
      this.chunks = prev.chunks;
      this.buf = prev.buf;
      // write length of chunk as varint
      this.uint32(chunk.byteLength);
      return this.raw(chunk);
    }
    /**
     * Writes a tag (field number and wire type).
     *
     * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.
     *
     * Generated code should compute the tag ahead of time and call `uint32()`.
     */
    tag(fieldNo, type) {
      return this.uint32(((fieldNo << 3) | type) >>> 0);
    }
    /**
     * Write a chunk of raw bytes.
     */
    raw(chunk) {
      if (this.buf.length) {
        this.chunks.push(new Uint8Array(this.buf));
        this.buf = [];
      }
      this.chunks.push(chunk);
      return this;
    }
    /**
     * Write a `uint32` value, an unsigned 32 bit varint.
     */
    uint32(value) {
      assertUInt32(value);
      // write value as varint 32, inlined for speed
      while (value > 0x7f) {
        this.buf.push((value & 0x7f) | 0x80);
        value = value >>> 7;
      }
      this.buf.push(value);
      return this;
    }
    /**
     * Write a `int32` value, a signed 32 bit varint.
     */
    int32(value) {
      assertInt32(value);
      varint32write(value, this.buf);
      return this;
    }
    /**
     * Write a `bool` value, a variant.
     */
    bool(value) {
      this.buf.push(value ? 1 : 0);
      return this;
    }
    /**
     * Write a `bytes` value, length-delimited arbitrary data.
     */
    bytes(value) {
      this.uint32(value.byteLength); // write length of chunk as varint
      return this.raw(value);
    }
    /**
     * Write a `string` value, length-delimited data converted to UTF-8 text.
     */
    string(value) {
      let chunk = this.textEncoder.encode(value);
      this.uint32(chunk.byteLength); // write length of chunk as varint
      return this.raw(chunk);
    }
    /**
     * Write a `float` value, 32-bit floating point number.
     */
    float(value) {
      assertFloat32(value);
      let chunk = new Uint8Array(4);
      new DataView(chunk.buffer).setFloat32(0, value, true);
      return this.raw(chunk);
    }
    /**
     * Write a `double` value, a 64-bit floating point number.
     */
    double(value) {
      let chunk = new Uint8Array(8);
      new DataView(chunk.buffer).setFloat64(0, value, true);
      return this.raw(chunk);
    }
    /**
     * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
     */
    fixed32(value) {
      assertUInt32(value);
      let chunk = new Uint8Array(4);
      new DataView(chunk.buffer).setUint32(0, value, true);
      return this.raw(chunk);
    }
    /**
     * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
     */
    sfixed32(value) {
      assertInt32(value);
      let chunk = new Uint8Array(4);
      new DataView(chunk.buffer).setInt32(0, value, true);
      return this.raw(chunk);
    }
    /**
     * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
     */
    sint32(value) {
      assertInt32(value);
      // zigzag encode
      value = ((value << 1) ^ (value >> 31)) >>> 0;
      varint32write(value, this.buf);
      return this;
    }
    /**
     * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
     */
    sfixed64(value) {
      let chunk = new Uint8Array(8),
        view = new DataView(chunk.buffer),
        tc = protoInt64.enc(value);
      view.setInt32(0, tc.lo, true);
      view.setInt32(4, tc.hi, true);
      return this.raw(chunk);
    }
    /**
     * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
     */
    fixed64(value) {
      let chunk = new Uint8Array(8),
        view = new DataView(chunk.buffer),
        tc = protoInt64.uEnc(value);
      view.setInt32(0, tc.lo, true);
      view.setInt32(4, tc.hi, true);
      return this.raw(chunk);
    }
    /**
     * Write a `int64` value, a signed 64-bit varint.
     */
    int64(value) {
      let tc = protoInt64.enc(value);
      varint64write(tc.lo, tc.hi, this.buf);
      return this;
    }
    /**
     * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
     */
    sint64(value) {
      let tc = protoInt64.enc(value),
        // zigzag encode
        sign = tc.hi >> 31,
        lo = (tc.lo << 1) ^ sign,
        hi = ((tc.hi << 1) | (tc.lo >>> 31)) ^ sign;
      varint64write(lo, hi, this.buf);
      return this;
    }
    /**
     * Write a `uint64` value, an unsigned 64-bit varint.
     */
    uint64(value) {
      let tc = protoInt64.uEnc(value);
      varint64write(tc.lo, tc.hi, this.buf);
      return this;
    }
  }
  class BinaryReader {
    constructor(buf, textDecoder) {
      this.varint64 = varint64read; // dirty cast for `this`
      /**
       * Read a `uint32` field, an unsigned 32 bit varint.
       */
      this.uint32 = varint32read; // dirty cast for `this` and access to protected `buf`
      this.buf = buf;
      this.len = buf.length;
      this.pos = 0;
      this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      this.textDecoder =
        textDecoder !== null && textDecoder !== void 0 ? textDecoder : new TextDecoder();
    }
    /**
     * Reads a tag - field number and wire type.
     */
    tag() {
      let tag = this.uint32(),
        fieldNo = tag >>> 3,
        wireType = tag & 7;
      if (fieldNo <= 0 || wireType < 0 || wireType > 5)
        throw new Error('illegal tag: field no ' + fieldNo + ' wire type ' + wireType);
      return [fieldNo, wireType];
    }
    /**
     * Skip one element and return the skipped data.
     *
     * When skipping StartGroup, provide the tags field number to check for
     * matching field number in the EndGroup tag.
     */
    skip(wireType, fieldNo) {
      let start = this.pos;
      switch (wireType) {
        case WireType.Varint:
          while (this.buf[this.pos++] & 0x80) {
            // ignore
          }
          break;
        // eslint-disable-next-line
        // @ts-ignore TS7029: Fallthrough case in switch
        case WireType.Bit64:
          this.pos += 4;
        // eslint-disable-next-line
        // @ts-ignore TS7029: Fallthrough case in switch
        case WireType.Bit32:
          this.pos += 4;
          break;
        case WireType.LengthDelimited:
          let len = this.uint32();
          this.pos += len;
          break;
        case WireType.StartGroup:
          for (;;) {
            const [fn, wt] = this.tag();
            if (wt === WireType.EndGroup) {
              if (fieldNo !== undefined && fn !== fieldNo) {
                throw new Error('invalid end group tag');
              }
              break;
            }
            this.skip(wt, fn);
          }
          break;
        default:
          throw new Error('cant skip wire type ' + wireType);
      }
      this.assertBounds();
      return this.buf.subarray(start, this.pos);
    }
    /**
     * Throws error if position in byte array is out of range.
     */
    assertBounds() {
      if (this.pos > this.len) throw new RangeError('premature EOF');
    }
    /**
     * Read a `int32` field, a signed 32 bit varint.
     */
    int32() {
      return this.uint32() | 0;
    }
    /**
     * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
     */
    sint32() {
      let zze = this.uint32();
      // decode zigzag
      return (zze >>> 1) ^ -(zze & 1);
    }
    /**
     * Read a `int64` field, a signed 64-bit varint.
     */
    int64() {
      return protoInt64.dec(...this.varint64());
    }
    /**
     * Read a `uint64` field, an unsigned 64-bit varint.
     */
    uint64() {
      return protoInt64.uDec(...this.varint64());
    }
    /**
     * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
     */
    sint64() {
      let [lo, hi] = this.varint64();
      // decode zig zag
      let s = -(lo & 1);
      lo = ((lo >>> 1) | ((hi & 1) << 31)) ^ s;
      hi = (hi >>> 1) ^ s;
      return protoInt64.dec(lo, hi);
    }
    /**
     * Read a `bool` field, a variant.
     */
    bool() {
      let [lo, hi] = this.varint64();
      return lo !== 0 || hi !== 0;
    }
    /**
     * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
     */
    fixed32() {
      return this.view.getUint32((this.pos += 4) - 4, true);
    }
    /**
     * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
     */
    sfixed32() {
      return this.view.getInt32((this.pos += 4) - 4, true);
    }
    /**
     * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
     */
    fixed64() {
      return protoInt64.uDec(this.sfixed32(), this.sfixed32());
    }
    /**
     * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
     */
    sfixed64() {
      return protoInt64.dec(this.sfixed32(), this.sfixed32());
    }
    /**
     * Read a `float` field, 32-bit floating point number.
     */
    float() {
      return this.view.getFloat32((this.pos += 4) - 4, true);
    }
    /**
     * Read a `double` field, a 64-bit floating point number.
     */
    double() {
      return this.view.getFloat64((this.pos += 8) - 8, true);
    }
    /**
     * Read a `bytes` field, length-delimited arbitrary data.
     */
    bytes() {
      let len = this.uint32(),
        start = this.pos;
      this.pos += len;
      this.assertBounds();
      return this.buf.subarray(start, start + len);
    }
    /**
     * Read a `string` field, length-delimited data converted to UTF-8 text.
     */
    string() {
      return this.textDecoder.decode(this.bytes());
    }
  }

  // Copyright 2021-2024 Buf Technologies, Inc.
  //
  // Licensed under the Apache License, Version 2.0 (the "License");
  // you may not use this file except in compliance with the License.
  // You may obtain a copy of the License at
  //
  //      http://www.apache.org/licenses/LICENSE-2.0
  //
  // Unless required by applicable law or agreed to in writing, software
  // distributed under the License is distributed on an "AS IS" BASIS,
  // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  // See the License for the specific language governing permissions and
  // limitations under the License.
  /**
   * Create a new extension using the given runtime.
   */
  function makeExtension(runtime, typeName, extendee, field) {
    let fi;
    return {
      typeName,
      extendee,
      get field() {
        if (!fi) {
          const i = typeof field == 'function' ? field() : field;
          i.name = typeName.split('.').pop();
          i.jsonName = '['.concat(typeName, ']');
          fi = runtime.util.newFieldList([i]).list()[0];
        }
        return fi;
      },
      runtime,
    };
  }
  /**
   * Create a container that allows us to read extension fields into it with the
   * same logic as regular fields.
   */
  function createExtensionContainer(extension) {
    const localName = extension.field.localName;
    const container = Object.create(null);
    container[localName] = initExtensionField(extension);
    return [container, () => container[localName]];
  }
  function initExtensionField(ext) {
    const field = ext.field;
    if (field.repeated) {
      return [];
    }
    if (field.default !== undefined) {
      return field.default;
    }
    switch (field.kind) {
      case 'enum':
        return field.T.values[0].no;
      case 'scalar':
        return scalarZeroValue(field.T, field.L);
      case 'message':
        // eslint-disable-next-line no-case-declarations
        const T = field.T,
          value = new T();
        return T.fieldWrapper ? T.fieldWrapper.unwrapField(value) : value;
      case 'map':
        throw 'map fields are not allowed to be extensions';
    }
  }
  /**
   * Helper to filter unknown fields, optimized based on field type.
   */
  function filterUnknownFields(unknownFields, field) {
    if (!field.repeated && (field.kind == 'enum' || field.kind == 'scalar')) {
      // singular scalar fields do not merge, we pick the last
      for (let i = unknownFields.length - 1; i >= 0; --i) {
        if (unknownFields[i].no == field.no) {
          return [unknownFields[i]];
        }
      }
      return [];
    }
    return unknownFields.filter((uf) => uf.no === field.no);
  }

  // Copyright 2021-2024 Buf Technologies, Inc.
  //
  // Licensed under the Apache License, Version 2.0 (the "License");
  // you may not use this file except in compliance with the License.
  // You may obtain a copy of the License at
  //
  //      http://www.apache.org/licenses/LICENSE-2.0
  //
  // Unless required by applicable law or agreed to in writing, software
  // distributed under the License is distributed on an "AS IS" BASIS,
  // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  // See the License for the specific language governing permissions and
  // limitations under the License.
  /* eslint-disable @typescript-eslint/ban-ts-comment, @typescript-eslint/no-unnecessary-condition, prefer-const */
  // lookup table from base64 character to byte
  let encTable = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');
  // lookup table from base64 character *code* to byte because lookup by number is fast
  let decTable = [];
  for (let i = 0; i < encTable.length; i++) decTable[encTable[i].charCodeAt(0)] = i;
  // support base64url variants
  decTable['-'.charCodeAt(0)] = encTable.indexOf('+');
  decTable['_'.charCodeAt(0)] = encTable.indexOf('/');
  const protoBase64 = {
    /**
     * Decodes a base64 string to a byte array.
     *
     * - ignores white-space, including line breaks and tabs
     * - allows inner padding (can decode concatenated base64 strings)
     * - does not require padding
     * - understands base64url encoding:
     *   "-" instead of "+",
     *   "_" instead of "/",
     *   no padding
     */
    dec(base64Str) {
      // estimate byte size, not accounting for inner padding and whitespace
      let es = (base64Str.length * 3) / 4;
      if (base64Str[base64Str.length - 2] == '=') es -= 2;
      else if (base64Str[base64Str.length - 1] == '=') es -= 1;
      let bytes = new Uint8Array(es),
        bytePos = 0,
        // position in byte array
        groupPos = 0,
        // position in base64 group
        b,
        // current byte
        p = 0; // previous byte
      for (let i = 0; i < base64Str.length; i++) {
        b = decTable[base64Str.charCodeAt(i)];
        if (b === undefined) {
          switch (base64Str[i]) {
            // @ts-ignore TS7029: Fallthrough case in switch
            case '=':
              groupPos = 0;
            // reset state when padding found
            // @ts-ignore TS7029: Fallthrough case in switch
            case '\n':
            case '\r':
            case '\t':
            case ' ':
              continue;
            // skip white-space, and padding
            default:
              throw Error('invalid base64 string.');
          }
        }
        switch (groupPos) {
          case 0:
            p = b;
            groupPos = 1;
            break;
          case 1:
            bytes[bytePos++] = (p << 2) | ((b & 48) >> 4);
            p = b;
            groupPos = 2;
            break;
          case 2:
            bytes[bytePos++] = ((p & 15) << 4) | ((b & 60) >> 2);
            p = b;
            groupPos = 3;
            break;
          case 3:
            bytes[bytePos++] = ((p & 3) << 6) | b;
            groupPos = 0;
            break;
        }
      }
      if (groupPos == 1) throw Error('invalid base64 string.');
      return bytes.subarray(0, bytePos);
    },
    /**
     * Encode a byte array to a base64 string.
     */
    enc(bytes) {
      let base64 = '',
        groupPos = 0,
        // position in base64 group
        b,
        // current byte
        p = 0; // carry over from previous byte
      for (let i = 0; i < bytes.length; i++) {
        b = bytes[i];
        switch (groupPos) {
          case 0:
            base64 += encTable[b >> 2];
            p = (b & 3) << 4;
            groupPos = 1;
            break;
          case 1:
            base64 += encTable[p | (b >> 4)];
            p = (b & 15) << 2;
            groupPos = 2;
            break;
          case 2:
            base64 += encTable[p | (b >> 6)];
            base64 += encTable[b & 63];
            groupPos = 0;
            break;
        }
      }
      // add output padding
      if (groupPos) {
        base64 += encTable[p];
        base64 += '=';
        if (groupPos == 1) base64 += '=';
      }
      return base64;
    },
  };

  // Copyright 2021-2024 Buf Technologies, Inc.
  //
  // Licensed under the Apache License, Version 2.0 (the "License");
  // you may not use this file except in compliance with the License.
  // You may obtain a copy of the License at
  //
  //      http://www.apache.org/licenses/LICENSE-2.0
  //
  // Unless required by applicable law or agreed to in writing, software
  // distributed under the License is distributed on an "AS IS" BASIS,
  // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  // See the License for the specific language governing permissions and
  // limitations under the License.
  /**
   * Retrieve an extension value from a message.
   *
   * The function never returns undefined. Use hasExtension() to check whether an
   * extension is set. If the extension is not set, this function returns the
   * default value (if one was specified in the protobuf source), or the zero value
   * (for example `0` for numeric types, `[]` for repeated extension fields, and
   * an empty message instance for message fields).
   *
   * Extensions are stored as unknown fields on a message. To mutate an extension
   * value, make sure to store the new value with setExtension() after mutating.
   *
   * If the extension does not extend the given message, an error is raised.
   */
  function getExtension(message, extension, options) {
    assertExtendee(extension, message);
    const opt = extension.runtime.bin.makeReadOptions(options);
    const ufs = filterUnknownFields(
      message.getType().runtime.bin.listUnknownFields(message),
      extension.field
    );
    const [container, get] = createExtensionContainer(extension);
    for (const uf of ufs) {
      extension.runtime.bin.readField(
        container,
        opt.readerFactory(uf.data),
        extension.field,
        uf.wireType,
        opt
      );
    }
    return get();
  }
  /**
   * Set an extension value on a message. If the message already has a value for
   * this extension, the value is replaced.
   *
   * If the extension does not extend the given message, an error is raised.
   */
  function setExtension(message, extension, value, options) {
    assertExtendee(extension, message);
    const readOpt = extension.runtime.bin.makeReadOptions(options);
    const writeOpt = extension.runtime.bin.makeWriteOptions(options);
    if (hasExtension(message, extension)) {
      const ufs = message
        .getType()
        .runtime.bin.listUnknownFields(message)
        .filter((uf) => uf.no != extension.field.no);
      message.getType().runtime.bin.discardUnknownFields(message);
      for (const uf of ufs) {
        message.getType().runtime.bin.onUnknownField(message, uf.no, uf.wireType, uf.data);
      }
    }
    const writer = writeOpt.writerFactory();
    let f = extension.field;
    // Implicit presence does not apply to extensions, see https://github.com/protocolbuffers/protobuf/issues/8234
    // We patch the field info to use explicit presence:
    if (!f.opt && !f.repeated && (f.kind == 'enum' || f.kind == 'scalar')) {
      f = Object.assign(Object.assign({}, extension.field), {
        opt: true,
      });
    }
    extension.runtime.bin.writeField(f, value, writer, writeOpt);
    const reader = readOpt.readerFactory(writer.finish());
    while (reader.pos < reader.len) {
      const [no, wireType] = reader.tag();
      const data = reader.skip(wireType, no);
      message.getType().runtime.bin.onUnknownField(message, no, wireType, data);
    }
  }
  /**
   * Check whether an extension is set on a message.
   */
  function hasExtension(message, extension) {
    const messageType = message.getType();
    return (
      extension.extendee.typeName === messageType.typeName &&
      !!messageType.runtime.bin.listUnknownFields(message).find((uf) => uf.no == extension.field.no)
    );
  }
  function assertExtendee(extension, message) {
    assert(
      extension.extendee.typeName == message.getType().typeName,
      'extension '
        .concat(extension.typeName, ' can only be applied to message ')
        .concat(extension.extendee.typeName)
    );
  }

  // Copyright 2021-2024 Buf Technologies, Inc.
  //
  // Licensed under the Apache License, Version 2.0 (the "License");
  // you may not use this file except in compliance with the License.
  // You may obtain a copy of the License at
  //
  //      http://www.apache.org/licenses/LICENSE-2.0
  //
  // Unless required by applicable law or agreed to in writing, software
  // distributed under the License is distributed on an "AS IS" BASIS,
  // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  // See the License for the specific language governing permissions and
  // limitations under the License.
  /**
   * Returns true if the field is set.
   */
  function isFieldSet(field, target) {
    const localName = field.localName;
    if (field.repeated) {
      return target[localName].length > 0;
    }
    if (field.oneof) {
      return target[field.oneof.localName].case === localName; // eslint-disable-line @typescript-eslint/no-unsafe-member-access
    }
    switch (field.kind) {
      case 'enum':
      case 'scalar':
        if (field.opt || field.req) {
          // explicit presence
          return target[localName] !== undefined;
        }
        // implicit presence
        if (field.kind == 'enum') {
          return target[localName] !== field.T.values[0].no;
        }
        return !isScalarZeroValue(field.T, target[localName]);
      case 'message':
        return target[localName] !== undefined;
      case 'map':
        return Object.keys(target[localName]).length > 0;
      // eslint-disable-line @typescript-eslint/no-unsafe-argument
    }
  }
  /**
   * Resets the field, so that isFieldSet() will return false.
   */
  function clearField(field, target) {
    const localName = field.localName;
    const implicitPresence = !field.opt && !field.req;
    if (field.repeated) {
      target[localName] = [];
    } else if (field.oneof) {
      target[field.oneof.localName] = {
        case: undefined,
      };
    } else {
      switch (field.kind) {
        case 'map':
          target[localName] = {};
          break;
        case 'enum':
          target[localName] = implicitPresence ? field.T.values[0].no : undefined;
          break;
        case 'scalar':
          target[localName] = implicitPresence ? scalarZeroValue(field.T, field.L) : undefined;
          break;
        case 'message':
          target[localName] = undefined;
          break;
      }
    }
  }

  // Copyright 2021-2024 Buf Technologies, Inc.
  //
  // Licensed under the Apache License, Version 2.0 (the "License");
  // you may not use this file except in compliance with the License.
  // You may obtain a copy of the License at
  //
  //      http://www.apache.org/licenses/LICENSE-2.0
  //
  // Unless required by applicable law or agreed to in writing, software
  // distributed under the License is distributed on an "AS IS" BASIS,
  // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  // See the License for the specific language governing permissions and
  // limitations under the License.
  /**
   * Check whether the given object is any subtype of Message or is a specific
   * Message by passing the type.
   *
   * Just like `instanceof`, `isMessage` narrows the type. The advantage of
   * `isMessage` is that it compares identity by the message type name, not by
   * class identity. This makes it robust against the dual package hazard and
   * similar situations, where the same message is duplicated.
   *
   * This function is _mostly_ equivalent to the `instanceof` operator. For
   * example, `isMessage(foo, MyMessage)` is the same as `foo instanceof MyMessage`,
   * and `isMessage(foo)` is the same as `foo instanceof Message`. In most cases,
   * `isMessage` should be preferred over `instanceof`.
   *
   * However, due to the fact that `isMessage` does not use class identity, there
   * are subtle differences between this function and `instanceof`. Notably,
   * calling `isMessage` on an explicit type of Message will return false.
   */
  function isMessage(arg, type) {
    if (arg === null || typeof arg != 'object') {
      return false;
    }
    if (
      !Object.getOwnPropertyNames(Message.prototype).every(
        (m) => m in arg && typeof arg[m] == 'function'
      )
    ) {
      return false;
    }
    const actualType = arg.getType();
    if (
      actualType === null ||
      typeof actualType != 'function' ||
      !('typeName' in actualType) ||
      typeof actualType.typeName != 'string'
    ) {
      return false;
    }
    return type === undefined ? true : actualType.typeName == type.typeName;
  }

  // Copyright 2021-2024 Buf Technologies, Inc.
  //
  // Licensed under the Apache License, Version 2.0 (the "License");
  // you may not use this file except in compliance with the License.
  // You may obtain a copy of the License at
  //
  //      http://www.apache.org/licenses/LICENSE-2.0
  //
  // Unless required by applicable law or agreed to in writing, software
  // distributed under the License is distributed on an "AS IS" BASIS,
  // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  // See the License for the specific language governing permissions and
  // limitations under the License.
  /**
   * Wrap a primitive message field value in its corresponding wrapper
   * message. This function is idempotent.
   */
  function wrapField(type, value) {
    if (isMessage(value) || !type.fieldWrapper) {
      return value;
    }
    return type.fieldWrapper.wrapField(value);
  }
  ({
    'google.protobuf.DoubleValue': ScalarType.DOUBLE,
    'google.protobuf.FloatValue': ScalarType.FLOAT,
    'google.protobuf.Int64Value': ScalarType.INT64,
    'google.protobuf.UInt64Value': ScalarType.UINT64,
    'google.protobuf.Int32Value': ScalarType.INT32,
    'google.protobuf.UInt32Value': ScalarType.UINT32,
    'google.protobuf.BoolValue': ScalarType.BOOL,
    'google.protobuf.StringValue': ScalarType.STRING,
    'google.protobuf.BytesValue': ScalarType.BYTES,
  });

  // Copyright 2021-2024 Buf Technologies, Inc.
  //
  // Licensed under the Apache License, Version 2.0 (the "License");
  // you may not use this file except in compliance with the License.
  // You may obtain a copy of the License at
  //
  //      http://www.apache.org/licenses/LICENSE-2.0
  //
  // Unless required by applicable law or agreed to in writing, software
  // distributed under the License is distributed on an "AS IS" BASIS,
  // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  // See the License for the specific language governing permissions and
  // limitations under the License.
  /* eslint-disable no-case-declarations,@typescript-eslint/no-unsafe-argument,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-call */
  // Default options for parsing JSON.
  const jsonReadDefaults = {
    ignoreUnknownFields: false,
  };
  // Default options for serializing to JSON.
  const jsonWriteDefaults = {
    emitDefaultValues: false,
    enumAsInteger: false,
    useProtoFieldName: false,
    prettySpaces: 0,
  };
  function makeReadOptions$1(options) {
    return options ? Object.assign(Object.assign({}, jsonReadDefaults), options) : jsonReadDefaults;
  }
  function makeWriteOptions$1(options) {
    return options
      ? Object.assign(Object.assign({}, jsonWriteDefaults), options)
      : jsonWriteDefaults;
  }
  const tokenNull = Symbol();
  const tokenIgnoredUnknownEnum = Symbol();
  function makeJsonFormat() {
    return {
      makeReadOptions: makeReadOptions$1,
      makeWriteOptions: makeWriteOptions$1,
      readMessage(type, json, options, message) {
        if (json == null || Array.isArray(json) || typeof json != 'object') {
          throw new Error(
            'cannot decode message '
              .concat(type.typeName, ' from JSON: ')
              .concat(debugJsonValue(json))
          );
        }
        message = message !== null && message !== void 0 ? message : new type();
        const oneofSeen = new Map();
        const registry = options.typeRegistry;
        for (const [jsonKey, jsonValue] of Object.entries(json)) {
          const field = type.fields.findJsonName(jsonKey);
          if (field) {
            if (field.oneof) {
              if (jsonValue === null && field.kind == 'scalar') {
                // see conformance test Required.Proto3.JsonInput.OneofFieldNull{First,Second}
                continue;
              }
              const seen = oneofSeen.get(field.oneof);
              if (seen !== undefined) {
                throw new Error(
                  'cannot decode message '
                    .concat(type.typeName, ' from JSON: multiple keys for oneof "')
                    .concat(field.oneof.name, '" present: "')
                    .concat(seen, '", "')
                    .concat(jsonKey, '"')
                );
              }
              oneofSeen.set(field.oneof, jsonKey);
            }
            readField$1(message, jsonValue, field, options, type);
          } else {
            let found = false;
            if (
              (registry === null || registry === void 0 ? void 0 : registry.findExtension) &&
              jsonKey.startsWith('[') &&
              jsonKey.endsWith(']')
            ) {
              const ext = registry.findExtension(jsonKey.substring(1, jsonKey.length - 1));
              if (ext && ext.extendee.typeName == type.typeName) {
                found = true;
                const [container, get] = createExtensionContainer(ext);
                readField$1(container, jsonValue, ext.field, options, ext);
                // We pass on the options as BinaryReadOptions/BinaryWriteOptions,
                // so that users can bring their own binary reader and writer factories
                // if necessary.
                setExtension(message, ext, get(), options);
              }
            }
            if (!found && !options.ignoreUnknownFields) {
              throw new Error(
                'cannot decode message '
                  .concat(type.typeName, ' from JSON: key "')
                  .concat(jsonKey, '" is unknown')
              );
            }
          }
        }
        return message;
      },
      writeMessage(message, options) {
        const type = message.getType();
        const json = {};
        let field;
        try {
          for (field of type.fields.byNumber()) {
            if (!isFieldSet(field, message)) {
              // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
              if (field.req) {
                throw 'required field not set';
              }
              if (!options.emitDefaultValues) {
                continue;
              }
              if (!canEmitFieldDefaultValue(field)) {
                continue;
              }
            }
            const value = field.oneof
              ? message[field.oneof.localName].value
              : message[field.localName];
            const jsonValue = writeField$1(field, value, options);
            if (jsonValue !== undefined) {
              json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue;
            }
          }
          const registry = options.typeRegistry;
          if (registry === null || registry === void 0 ? void 0 : registry.findExtensionFor) {
            for (const uf of type.runtime.bin.listUnknownFields(message)) {
              const ext = registry.findExtensionFor(type.typeName, uf.no);
              if (ext && hasExtension(message, ext)) {
                // We pass on the options as BinaryReadOptions, so that users can bring their own
                // binary reader factory if necessary.
                const value = getExtension(message, ext, options);
                const jsonValue = writeField$1(ext.field, value, options);
                if (jsonValue !== undefined) {
                  json[ext.field.jsonName] = jsonValue;
                }
              }
            }
          }
        } catch (e) {
          const m = field
            ? 'cannot encode field '.concat(type.typeName, '.').concat(field.name, ' to JSON')
            : 'cannot encode message '.concat(type.typeName, ' to JSON');
          const r = e instanceof Error ? e.message : String(e);
          throw new Error(m + (r.length > 0 ? ': '.concat(r) : ''));
        }
        return json;
      },
      readScalar(type, json, longType) {
        // The signature of our internal function has changed. For backwards-
        // compatibility, we support the old form that is part of the public API
        // through the interface JsonFormat.
        return readScalar$1(
          type,
          json,
          longType !== null && longType !== void 0 ? longType : LongType.BIGINT,
          true
        );
      },
      writeScalar(type, value, emitDefaultValues) {
        // The signature of our internal function has changed. For backwards-
        // compatibility, we support the old form that is part of the public API
        // through the interface JsonFormat.
        if (value === undefined) {
          return undefined;
        }
        if (emitDefaultValues || isScalarZeroValue(type, value)) {
          return writeScalar$1(type, value);
        }
        return undefined;
      },
      debug: debugJsonValue,
    };
  }
  function debugJsonValue(json) {
    if (json === null) {
      return 'null';
    }
    switch (typeof json) {
      case 'object':
        return Array.isArray(json) ? 'array' : 'object';
      case 'string':
        return json.length > 100 ? 'string' : '"'.concat(json.split('"').join('\\"'), '"');
      default:
        return String(json);
    }
  }
  // Read a JSON value for a field.
  // The "parentType" argument is only used to provide context in errors.
  function readField$1(target, jsonValue, field, options, parentType) {
    let localName = field.localName;
    if (field.repeated) {
      assert(field.kind != 'map');
      if (jsonValue === null) {
        return;
      }
      if (!Array.isArray(jsonValue)) {
        throw new Error(
          'cannot decode field '
            .concat(parentType.typeName, '.')
            .concat(field.name, ' from JSON: ')
            .concat(debugJsonValue(jsonValue))
        );
      }
      const targetArray = target[localName];
      for (const jsonItem of jsonValue) {
        if (jsonItem === null) {
          throw new Error(
            'cannot decode field '
              .concat(parentType.typeName, '.')
              .concat(field.name, ' from JSON: ')
              .concat(debugJsonValue(jsonItem))
          );
        }
        switch (field.kind) {
          case 'message':
            targetArray.push(field.T.fromJson(jsonItem, options));
            break;
          case 'enum':
            const enumValue = readEnum(field.T, jsonItem, options.ignoreUnknownFields, true);
            if (enumValue !== tokenIgnoredUnknownEnum) {
              targetArray.push(enumValue);
            }
            break;
          case 'scalar':
            try {
              targetArray.push(readScalar$1(field.T, jsonItem, field.L, true));
            } catch (e) {
              let m = 'cannot decode field '
                .concat(parentType.typeName, '.')
                .concat(field.name, ' from JSON: ')
                .concat(debugJsonValue(jsonItem));
              if (e instanceof Error && e.message.length > 0) {
                m += ': '.concat(e.message);
              }
              throw new Error(m);
            }
            break;
        }
      }
    } else if (field.kind == 'map') {
      if (jsonValue === null) {
        return;
      }
      if (typeof jsonValue != 'object' || Array.isArray(jsonValue)) {
        throw new Error(
          'cannot decode field '
            .concat(parentType.typeName, '.')
            .concat(field.name, ' from JSON: ')
            .concat(debugJsonValue(jsonValue))
        );
      }
      const targetMap = target[localName];
      for (const [jsonMapKey, jsonMapValue] of Object.entries(jsonValue)) {
        if (jsonMapValue === null) {
          throw new Error(
            'cannot decode field '
              .concat(parentType.typeName, '.')
              .concat(field.name, ' from JSON: map value null')
          );
        }
        let key;
        try {
          key = readMapKey(field.K, jsonMapKey);
        } catch (e) {
          let m = 'cannot decode map key for field '
            .concat(parentType.typeName, '.')
            .concat(field.name, ' from JSON: ')
            .concat(debugJsonValue(jsonValue));
          if (e instanceof Error && e.message.length > 0) {
            m += ': '.concat(e.message);
          }
          throw new Error(m);
        }
        switch (field.V.kind) {
          case 'message':
            targetMap[key] = field.V.T.fromJson(jsonMapValue, options);
            break;
          case 'enum':
            const enumValue = readEnum(field.V.T, jsonMapValue, options.ignoreUnknownFields, true);
            if (enumValue !== tokenIgnoredUnknownEnum) {
              targetMap[key] = enumValue;
            }
            break;
          case 'scalar':
            try {
              targetMap[key] = readScalar$1(field.V.T, jsonMapValue, LongType.BIGINT, true);
            } catch (e) {
              let m = 'cannot decode map value for field '
                .concat(parentType.typeName, '.')
                .concat(field.name, ' from JSON: ')
                .concat(debugJsonValue(jsonValue));
              if (e instanceof Error && e.message.length > 0) {
                m += ': '.concat(e.message);
              }
              throw new Error(m);
            }
            break;
        }
      }
    } else {
      if (field.oneof) {
        target = target[field.oneof.localName] = {
          case: localName,
        };
        localName = 'value';
      }
      switch (field.kind) {
        case 'message':
          const messageType = field.T;
          if (jsonValue === null && messageType.typeName != 'google.protobuf.Value') {
            return;
          }
          let currentValue = target[localName];
          if (isMessage(currentValue)) {
            currentValue.fromJson(jsonValue, options);
          } else {
            target[localName] = currentValue = messageType.fromJson(jsonValue, options);
            if (messageType.fieldWrapper && !field.oneof) {
              target[localName] = messageType.fieldWrapper.unwrapField(currentValue);
            }
          }
          break;
        case 'enum':
          const enumValue = readEnum(field.T, jsonValue, options.ignoreUnknownFields, false);
          switch (enumValue) {
            case tokenNull:
              clearField(field, target);
              break;
            case tokenIgnoredUnknownEnum:
              break;
            default:
              target[localName] = enumValue;
              break;
          }
          break;
        case 'scalar':
          try {
            const scalarValue = readScalar$1(field.T, jsonValue, field.L, false);
            switch (scalarValue) {
              case tokenNull:
                clearField(field, target);
                break;
              default:
                target[localName] = scalarValue;
                break;
            }
          } catch (e) {
            let m = 'cannot decode field '
              .concat(parentType.typeName, '.')
              .concat(field.name, ' from JSON: ')
              .concat(debugJsonValue(jsonValue));
            if (e instanceof Error && e.message.length > 0) {
              m += ': '.concat(e.message);
            }
            throw new Error(m);
          }
          break;
      }
    }
  }
  function readMapKey(type, json) {
    if (type === ScalarType.BOOL) {
      // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check
      switch (json) {
        case 'true':
          json = true;
          break;
        case 'false':
          json = false;
          break;
      }
    }
    return readScalar$1(type, json, LongType.BIGINT, true).toString();
  }
  function readScalar$1(type, json, longType, nullAsZeroValue) {
    if (json === null) {
      if (nullAsZeroValue) {
        return scalarZeroValue(type, longType);
      }
      return tokenNull;
    }
    // every valid case in the switch below returns, and every fall
    // through is regarded as a failure.
    switch (type) {
      // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
      // Either numbers or strings are accepted. Exponent notation is also accepted.
      case ScalarType.DOUBLE:
      case ScalarType.FLOAT:
        if (json === 'NaN') return Number.NaN;
        if (json === 'Infinity') return Number.POSITIVE_INFINITY;
        if (json === '-Infinity') return Number.NEGATIVE_INFINITY;
        if (json === '') {
          // empty string is not a number
          break;
        }
        if (typeof json == 'string' && json.trim().length !== json.length) {
          // extra whitespace
          break;
        }
        if (typeof json != 'string' && typeof json != 'number') {
          break;
        }
        const float = Number(json);
        if (Number.isNaN(float)) {
          // not a number
          break;
        }
        if (!Number.isFinite(float)) {
          // infinity and -infinity are handled by string representation above, so this is an error
          break;
        }
        if (type == ScalarType.FLOAT) assertFloat32(float);
        return float;
      // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
      case ScalarType.INT32:
      case ScalarType.FIXED32:
      case ScalarType.SFIXED32:
      case ScalarType.SINT32:
      case ScalarType.UINT32:
        let int32;
        if (typeof json == 'number') int32 = json;
        else if (typeof json == 'string' && json.length > 0) {
          if (json.trim().length === json.length) int32 = Number(json);
        }
        if (int32 === undefined) break;
        if (type == ScalarType.UINT32 || type == ScalarType.FIXED32) assertUInt32(int32);
        else assertInt32(int32);
        return int32;
      // int64, fixed64, uint64: JSON value will be a decimal string. Either numbers or strings are accepted.
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        if (typeof json != 'number' && typeof json != 'string') break;
        const long = protoInt64.parse(json);
        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
        return longType ? long.toString() : long;
      case ScalarType.FIXED64:
      case ScalarType.UINT64:
        if (typeof json != 'number' && typeof json != 'string') break;
        const uLong = protoInt64.uParse(json);
        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
        return longType ? uLong.toString() : uLong;
      // bool:
      case ScalarType.BOOL:
        if (typeof json !== 'boolean') break;
        return json;
      // string:
      case ScalarType.STRING:
        if (typeof json !== 'string') {
          break;
        }
        // A string must always contain UTF-8 encoded or 7-bit ASCII.
        // We validate with encodeURIComponent, which appears to be the fastest widely available option.
        try {
          encodeURIComponent(json);
        } catch (e) {
          throw new Error('invalid UTF8');
        }
        return json;
      // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
      // Either standard or URL-safe base64 encoding with/without paddings are accepted.
      case ScalarType.BYTES:
        if (json === '') return new Uint8Array(0);
        if (typeof json !== 'string') break;
        return protoBase64.dec(json);
    }
    throw new Error();
  }
  function readEnum(type, json, ignoreUnknownFields, nullAsZeroValue) {
    if (json === null) {
      if (type.typeName == 'google.protobuf.NullValue') {
        return 0; // google.protobuf.NullValue.NULL_VALUE = 0
      }
      return nullAsZeroValue ? type.values[0].no : tokenNull;
    }
    // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check
    switch (typeof json) {
      case 'number':
        if (Number.isInteger(json)) {
          return json;
        }
        break;
      case 'string':
        const value = type.findName(json);
        if (value !== undefined) {
          return value.no;
        }
        if (ignoreUnknownFields) {
          return tokenIgnoredUnknownEnum;
        }
        break;
    }
    throw new Error(
      'cannot decode enum '.concat(type.typeName, ' from JSON: ').concat(debugJsonValue(json))
    );
  }
  // Decide whether an unset field should be emitted with JSON write option `emitDefaultValues`
  function canEmitFieldDefaultValue(field) {
    if (field.repeated || field.kind == 'map') {
      // maps are {}, repeated fields are []
      return true;
    }
    if (field.oneof) {
      // oneof fields are never emitted
      return false;
    }
    if (field.kind == 'message') {
      // singular message field are allowed to emit JSON null, but we do not
      return false;
    }
    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
    if (field.opt || field.req) {
      // the field uses explicit presence, so we cannot emit a zero value
      return false;
    }
    return true;
  }
  function writeField$1(field, value, options) {
    if (field.kind == 'map') {
      assert(typeof value == 'object' && value != null);
      const jsonObj = {};
      const entries = Object.entries(value);
      switch (field.V.kind) {
        case 'scalar':
          for (const [entryKey, entryValue] of entries) {
            jsonObj[entryKey.toString()] = writeScalar$1(field.V.T, entryValue); // JSON standard allows only (double quoted) string as property key
          }
          break;
        case 'message':
          for (const [entryKey, entryValue] of entries) {
            // JSON standard allows only (double quoted) string as property key
            jsonObj[entryKey.toString()] = entryValue.toJson(options);
          }
          break;
        case 'enum':
          const enumType = field.V.T;
          for (const [entryKey, entryValue] of entries) {
            // JSON standard allows only (double quoted) string as property key
            jsonObj[entryKey.toString()] = writeEnum(enumType, entryValue, options.enumAsInteger);
          }
          break;
      }
      return options.emitDefaultValues || entries.length > 0 ? jsonObj : undefined;
    }
    if (field.repeated) {
      assert(Array.isArray(value));
      const jsonArr = [];
      switch (field.kind) {
        case 'scalar':
          for (let i = 0; i < value.length; i++) {
            jsonArr.push(writeScalar$1(field.T, value[i]));
          }
          break;
        case 'enum':
          for (let i = 0; i < value.length; i++) {
            jsonArr.push(writeEnum(field.T, value[i], options.enumAsInteger));
          }
          break;
        case 'message':
          for (let i = 0; i < value.length; i++) {
            jsonArr.push(value[i].toJson(options));
          }
          break;
      }
      return options.emitDefaultValues || jsonArr.length > 0 ? jsonArr : undefined;
    }
    switch (field.kind) {
      case 'scalar':
        return writeScalar$1(field.T, value);
      case 'enum':
        return writeEnum(field.T, value, options.enumAsInteger);
      case 'message':
        return wrapField(field.T, value).toJson(options);
    }
  }
  function writeEnum(type, value, enumAsInteger) {
    var _a;
    assert(typeof value == 'number');
    if (type.typeName == 'google.protobuf.NullValue') {
      return null;
    }
    if (enumAsInteger) {
      return value;
    }
    const val = type.findNumber(value);
    return (_a = val === null || val === void 0 ? void 0 : val.name) !== null && _a !== void 0
      ? _a
      : value; // if we don't know the enum value, just return the number
  }
  function writeScalar$1(type, value) {
    switch (type) {
      // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
      case ScalarType.INT32:
      case ScalarType.SFIXED32:
      case ScalarType.SINT32:
      case ScalarType.FIXED32:
      case ScalarType.UINT32:
        assert(typeof value == 'number');
        return value;
      // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
      // Either numbers or strings are accepted. Exponent notation is also accepted.
      case ScalarType.FLOAT:
      // assertFloat32(value);
      case ScalarType.DOUBLE:
        // eslint-disable-line no-fallthrough
        assert(typeof value == 'number');
        if (Number.isNaN(value)) return 'NaN';
        if (value === Number.POSITIVE_INFINITY) return 'Infinity';
        if (value === Number.NEGATIVE_INFINITY) return '-Infinity';
        return value;
      // string:
      case ScalarType.STRING:
        assert(typeof value == 'string');
        return value;
      // bool:
      case ScalarType.BOOL:
        assert(typeof value == 'boolean');
        return value;
      // JSON value will be a decimal string. Either numbers or strings are accepted.
      case ScalarType.UINT64:
      case ScalarType.FIXED64:
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        assert(typeof value == 'bigint' || typeof value == 'string' || typeof value == 'number');
        return value.toString();
      // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
      // Either standard or URL-safe base64 encoding with/without paddings are accepted.
      case ScalarType.BYTES:
        assert(value instanceof Uint8Array);
        return protoBase64.enc(value);
    }
  }

  // Copyright 2021-2024 Buf Technologies, Inc.
  //
  // Licensed under the Apache License, Version 2.0 (the "License");
  // you may not use this file except in compliance with the License.
  // You may obtain a copy of the License at
  //
  //      http://www.apache.org/licenses/LICENSE-2.0
  //
  // Unless required by applicable law or agreed to in writing, software
  // distributed under the License is distributed on an "AS IS" BASIS,
  // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  // See the License for the specific language governing permissions and
  // limitations under the License.
  /* eslint-disable prefer-const,no-case-declarations,@typescript-eslint/no-explicit-any,@typescript-eslint/no-unsafe-argument,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-call,@typescript-eslint/no-unsafe-return */
  const unknownFieldsSymbol = Symbol('@bufbuild/protobuf/unknown-fields');
  // Default options for parsing binary data.
  const readDefaults = {
    readUnknownFields: true,
    readerFactory: (bytes) => new BinaryReader(bytes),
  };
  // Default options for serializing binary data.
  const writeDefaults = {
    writeUnknownFields: true,
    writerFactory: () => new BinaryWriter(),
  };
  function makeReadOptions(options) {
    return options ? Object.assign(Object.assign({}, readDefaults), options) : readDefaults;
  }
  function makeWriteOptions(options) {
    return options ? Object.assign(Object.assign({}, writeDefaults), options) : writeDefaults;
  }
  function makeBinaryFormat() {
    return {
      makeReadOptions,
      makeWriteOptions,
      listUnknownFields(message) {
        var _a;
        return (_a = message[unknownFieldsSymbol]) !== null && _a !== void 0 ? _a : [];
      },
      discardUnknownFields(message) {
        delete message[unknownFieldsSymbol];
      },
      writeUnknownFields(message, writer) {
        const m = message;
        const c = m[unknownFieldsSymbol];
        if (c) {
          for (const f of c) {
            writer.tag(f.no, f.wireType).raw(f.data);
          }
        }
      },
      onUnknownField(message, no, wireType, data) {
        const m = message;
        if (!Array.isArray(m[unknownFieldsSymbol])) {
          m[unknownFieldsSymbol] = [];
        }
        m[unknownFieldsSymbol].push({
          no,
          wireType,
          data,
        });
      },
      readMessage(message, reader, lengthOrEndTagFieldNo, options, delimitedMessageEncoding) {
        const type = message.getType();
        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
        const end = delimitedMessageEncoding ? reader.len : reader.pos + lengthOrEndTagFieldNo;
        let fieldNo, wireType;
        while (reader.pos < end) {
          [fieldNo, wireType] = reader.tag();
          if (delimitedMessageEncoding === true && wireType == WireType.EndGroup) {
            break;
          }
          const field = type.fields.find(fieldNo);
          if (!field) {
            const data = reader.skip(wireType, fieldNo);
            if (options.readUnknownFields) {
              this.onUnknownField(message, fieldNo, wireType, data);
            }
            continue;
          }
          readField(message, reader, field, wireType, options);
        }
        if (
          delimitedMessageEncoding &&
          // eslint-disable-line @typescript-eslint/strict-boolean-expressions
          (wireType != WireType.EndGroup || fieldNo !== lengthOrEndTagFieldNo)
        ) {
          throw new Error('invalid end group tag');
        }
      },
      readField,
      writeMessage(message, writer, options) {
        const type = message.getType();
        for (const field of type.fields.byNumber()) {
          if (!isFieldSet(field, message)) {
            if (field.req) {
              throw new Error(
                'cannot encode field '
                  .concat(type.typeName, '.')
                  .concat(field.name, ' to binary: required field not set')
              );
            }
            continue;
          }
          const value = field.oneof
            ? message[field.oneof.localName].value
            : message[field.localName];
          writeField(field, value, writer, options);
        }
        if (options.writeUnknownFields) {
          this.writeUnknownFields(message, writer);
        }
        return writer;
      },
      writeField(field, value, writer, options) {
        // The behavior of our internal function has changed, it does no longer
        // accept `undefined` values for singular scalar and map.
        // For backwards-compatibility, we support the old form that is part of
        // the public API through the interface BinaryFormat.
        if (value === undefined) {
          return undefined;
        }
        writeField(field, value, writer, options);
      },
    };
  }
  function readField(
    target,
    // eslint-disable-line @typescript-eslint/no-explicit-any -- `any` is the best choice for dynamic access
    reader,
    field,
    wireType,
    options
  ) {
    let { repeated, localName } = field;
    if (field.oneof) {
      target = target[field.oneof.localName];
      if (target.case != localName) {
        delete target.value;
      }
      target.case = localName;
      localName = 'value';
    }
    switch (field.kind) {
      case 'scalar':
      case 'enum':
        const scalarType = field.kind == 'enum' ? ScalarType.INT32 : field.T;
        let read = readScalar;
        // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison -- acceptable since it's covered by tests
        if (field.kind == 'scalar' && field.L > 0) {
          read = readScalarLTString;
        }
        if (repeated) {
          let arr = target[localName]; // safe to assume presence of array, oneof cannot contain repeated values
          const isPacked =
            wireType == WireType.LengthDelimited &&
            scalarType != ScalarType.STRING &&
            scalarType != ScalarType.BYTES;
          if (isPacked) {
            let e = reader.uint32() + reader.pos;
            while (reader.pos < e) {
              arr.push(read(reader, scalarType));
            }
          } else {
            arr.push(read(reader, scalarType));
          }
        } else {
          target[localName] = read(reader, scalarType);
        }
        break;
      case 'message':
        const messageType = field.T;
        if (repeated) {
          // safe to assume presence of array, oneof cannot contain repeated values
          target[localName].push(readMessageField(reader, new messageType(), options, field));
        } else {
          if (isMessage(target[localName])) {
            readMessageField(reader, target[localName], options, field);
          } else {
            target[localName] = readMessageField(reader, new messageType(), options, field);
            if (messageType.fieldWrapper && !field.oneof && !field.repeated) {
              target[localName] = messageType.fieldWrapper.unwrapField(target[localName]);
            }
          }
        }
        break;
      case 'map':
        let [mapKey, mapVal] = readMapEntry(field, reader, options);
        // safe to assume presence of map object, oneof cannot contain repeated values
        target[localName][mapKey] = mapVal;
        break;
    }
  }
  // Read a message, avoiding MessageType.fromBinary() to re-use the
  // BinaryReadOptions and the IBinaryReader.
  function readMessageField(reader, message, options, field) {
    const format = message.getType().runtime.bin;
    const delimited = field === null || field === void 0 ? void 0 : field.delimited;
    format.readMessage(
      message,
      reader,
      delimited ? field.no : reader.uint32(),
      // eslint-disable-line @typescript-eslint/strict-boolean-expressions
      options,
      delimited
    );
    return message;
  }
  // Read a map field, expecting key field = 1, value field = 2
  function readMapEntry(field, reader, options) {
    const length = reader.uint32(),
      end = reader.pos + length;
    let key, val;
    while (reader.pos < end) {
      const [fieldNo] = reader.tag();
      switch (fieldNo) {
        case 1:
          key = readScalar(reader, field.K);
          break;
        case 2:
          switch (field.V.kind) {
            case 'scalar':
              val = readScalar(reader, field.V.T);
              break;
            case 'enum':
              val = reader.int32();
              break;
            case 'message':
              val = readMessageField(reader, new field.V.T(), options, undefined);
              break;
          }
          break;
      }
    }
    if (key === undefined) {
      key = scalarZeroValue(field.K, LongType.BIGINT);
    }
    if (typeof key != 'string' && typeof key != 'number') {
      key = key.toString();
    }
    if (val === undefined) {
      switch (field.V.kind) {
        case 'scalar':
          val = scalarZeroValue(field.V.T, LongType.BIGINT);
          break;
        case 'enum':
          val = field.V.T.values[0].no;
          break;
        case 'message':
          val = new field.V.T();
          break;
      }
    }
    return [key, val];
  }
  // Read a scalar value, but return 64 bit integral types (int64, uint64,
  // sint64, fixed64, sfixed64) as string instead of bigint.
  function readScalarLTString(reader, type) {
    const v = readScalar(reader, type);
    return typeof v == 'bigint' ? v.toString() : v;
  }
  // Does not use scalarTypeInfo() for better performance.
  function readScalar(reader, type) {
    switch (type) {
      case ScalarType.STRING:
        return reader.string();
      case ScalarType.BOOL:
        return reader.bool();
      case ScalarType.DOUBLE:
        return reader.double();
      case ScalarType.FLOAT:
        return reader.float();
      case ScalarType.INT32:
        return reader.int32();
      case ScalarType.INT64:
        return reader.int64();
      case ScalarType.UINT64:
        return reader.uint64();
      case ScalarType.FIXED64:
        return reader.fixed64();
      case ScalarType.BYTES:
        return reader.bytes();
      case ScalarType.FIXED32:
        return reader.fixed32();
      case ScalarType.SFIXED32:
        return reader.sfixed32();
      case ScalarType.SFIXED64:
        return reader.sfixed64();
      case ScalarType.SINT64:
        return reader.sint64();
      case ScalarType.UINT32:
        return reader.uint32();
      case ScalarType.SINT32:
        return reader.sint32();
    }
  }
  function writeField(field, value, writer, options) {
    assert(value !== undefined);
    const repeated = field.repeated;
    switch (field.kind) {
      case 'scalar':
      case 'enum':
        let scalarType = field.kind == 'enum' ? ScalarType.INT32 : field.T;
        if (repeated) {
          assert(Array.isArray(value));
          if (field.packed) {
            writePacked(writer, scalarType, field.no, value);
          } else {
            for (const item of value) {
              writeScalar(writer, scalarType, field.no, item);
            }
          }
        } else {
          writeScalar(writer, scalarType, field.no, value);
        }
        break;
      case 'message':
        if (repeated) {
          assert(Array.isArray(value));
          for (const item of value) {
            writeMessageField(writer, options, field, item);
          }
        } else {
          writeMessageField(writer, options, field, value);
        }
        break;
      case 'map':
        assert(typeof value == 'object' && value != null);
        for (const [key, val] of Object.entries(value)) {
          writeMapEntry(writer, options, field, key, val);
        }
        break;
    }
  }
  function writeMapEntry(writer, options, field, key, value) {
    writer.tag(field.no, WireType.LengthDelimited);
    writer.fork();
    // javascript only allows number or string for object properties
    // we convert from our representation to the protobuf type
    let keyValue = key;
    // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- we deliberately handle just the special cases for map keys
    switch (field.K) {
      case ScalarType.INT32:
      case ScalarType.FIXED32:
      case ScalarType.UINT32:
      case ScalarType.SFIXED32:
      case ScalarType.SINT32:
        keyValue = Number.parseInt(key);
        break;
      case ScalarType.BOOL:
        assert(key == 'true' || key == 'false');
        keyValue = key == 'true';
        break;
    }
    // write key, expecting key field number = 1
    writeScalar(writer, field.K, 1, keyValue);
    // write value, expecting value field number = 2
    switch (field.V.kind) {
      case 'scalar':
        writeScalar(writer, field.V.T, 2, value);
        break;
      case 'enum':
        writeScalar(writer, ScalarType.INT32, 2, value);
        break;
      case 'message':
        assert(value !== undefined);
        writer.tag(2, WireType.LengthDelimited).bytes(value.toBinary(options));
        break;
    }
    writer.join();
  }
  // Value must not be undefined
  function writeMessageField(writer, options, field, value) {
    const message = wrapField(field.T, value);
    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
    if (field.delimited)
      writer
        .tag(field.no, WireType.StartGroup)
        .raw(message.toBinary(options))
        .tag(field.no, WireType.EndGroup);
    else writer.tag(field.no, WireType.LengthDelimited).bytes(message.toBinary(options));
  }
  function writeScalar(writer, type, fieldNo, value) {
    assert(value !== undefined);
    let [wireType, method] = scalarTypeInfo(type);
    writer.tag(fieldNo, wireType)[method](value);
  }
  function writePacked(writer, type, fieldNo, value) {
    if (!value.length) {
      return;
    }
    writer.tag(fieldNo, WireType.LengthDelimited).fork();
    let [, method] = scalarTypeInfo(type);
    for (let i = 0; i < value.length; i++) {
      writer[method](value[i]);
    }
    writer.join();
  }
  /**
   * Get information for writing a scalar value.
   *
   * Returns tuple:
   * [0]: appropriate WireType
   * [1]: name of the appropriate method of IBinaryWriter
   * [2]: whether the given value is a default value for proto3 semantics
   *
   * If argument `value` is omitted, [2] is always false.
   */
  // TODO replace call-sites writeScalar() and writePacked(), then remove
  function scalarTypeInfo(type) {
    let wireType = WireType.Varint;
    // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- INT32, UINT32, SINT32 are covered by the defaults
    switch (type) {
      case ScalarType.BYTES:
      case ScalarType.STRING:
        wireType = WireType.LengthDelimited;
        break;
      case ScalarType.DOUBLE:
      case ScalarType.FIXED64:
      case ScalarType.SFIXED64:
        wireType = WireType.Bit64;
        break;
      case ScalarType.FIXED32:
      case ScalarType.SFIXED32:
      case ScalarType.FLOAT:
        wireType = WireType.Bit32;
        break;
    }
    const method = ScalarType[type].toLowerCase();
    return [wireType, method];
  }

  // Copyright 2021-2024 Buf Technologies, Inc.
  //
  // Licensed under the Apache License, Version 2.0 (the "License");
  // you may not use this file except in compliance with the License.
  // You may obtain a copy of the License at
  //
  //      http://www.apache.org/licenses/LICENSE-2.0
  //
  // Unless required by applicable law or agreed to in writing, software
  // distributed under the License is distributed on an "AS IS" BASIS,
  // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  // See the License for the specific language governing permissions and
  // limitations under the License.
  /* eslint-disable @typescript-eslint/no-explicit-any,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-argument,no-case-declarations */
  function makeUtilCommon() {
    return {
      setEnumType,
      initPartial(source, target) {
        if (source === undefined) {
          return;
        }
        const type = target.getType();
        for (const member of type.fields.byMember()) {
          const localName = member.localName,
            t = target,
            s = source;
          if (s[localName] == null) {
            // TODO if source is a Message instance, we should use isFieldSet() here to support future field presence
            continue;
          }
          switch (member.kind) {
            case 'oneof':
              const sk = s[localName].case;
              if (sk === undefined) {
                continue;
              }
              const sourceField = member.findField(sk);
              let val = s[localName].value;
              if (sourceField && sourceField.kind == 'message' && !isMessage(val, sourceField.T)) {
                val = new sourceField.T(val);
              } else if (
                sourceField &&
                sourceField.kind === 'scalar' &&
                sourceField.T === ScalarType.BYTES
              ) {
                val = toU8Arr(val);
              }
              t[localName] = {
                case: sk,
                value: val,
              };
              break;
            case 'scalar':
            case 'enum':
              let copy = s[localName];
              if (member.T === ScalarType.BYTES) {
                copy = member.repeated ? copy.map(toU8Arr) : toU8Arr(copy);
              }
              t[localName] = copy;
              break;
            case 'map':
              switch (member.V.kind) {
                case 'scalar':
                case 'enum':
                  if (member.V.T === ScalarType.BYTES) {
                    for (const [k, v] of Object.entries(s[localName])) {
                      t[localName][k] = toU8Arr(v);
                    }
                  } else {
                    Object.assign(t[localName], s[localName]);
                  }
                  break;
                case 'message':
                  const messageType = member.V.T;
                  for (const k of Object.keys(s[localName])) {
                    let val = s[localName][k];
                    if (!messageType.fieldWrapper) {
                      // We only take partial input for messages that are not a wrapper type.
                      // For those messages, we recursively normalize the partial input.
                      val = new messageType(val);
                    }
                    t[localName][k] = val;
                  }
                  break;
              }
              break;
            case 'message':
              const mt = member.T;
              if (member.repeated) {
                t[localName] = s[localName].map((val) => (isMessage(val, mt) ? val : new mt(val)));
              } else {
                const val = s[localName];
                if (mt.fieldWrapper) {
                  if (
                    // We can't use BytesValue.typeName as that will create a circular import
                    mt.typeName === 'google.protobuf.BytesValue'
                  ) {
                    t[localName] = toU8Arr(val);
                  } else {
                    t[localName] = val;
                  }
                } else {
                  t[localName] = isMessage(val, mt) ? val : new mt(val);
                }
              }
              break;
          }
        }
      },
      // TODO use isFieldSet() here to support future field presence
      equals(type, a, b) {
        if (a === b) {
          return true;
        }
        if (!a || !b) {
          return false;
        }
        return type.fields.byMember().every((m) => {
          const va = a[m.localName];
          const vb = b[m.localName];
          if (m.repeated) {
            if (va.length !== vb.length) {
              return false;
            }
            // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- repeated fields are never "map"
            switch (m.kind) {
              case 'message':
                return va.every((a, i) => m.T.equals(a, vb[i]));
              case 'scalar':
                return va.every((a, i) => scalarEquals(m.T, a, vb[i]));
              case 'enum':
                return va.every((a, i) => scalarEquals(ScalarType.INT32, a, vb[i]));
            }
            throw new Error('repeated cannot contain '.concat(m.kind));
          }
          switch (m.kind) {
            case 'message':
              let a = va;
              let b = vb;
              if (m.T.fieldWrapper) {
                if (a !== undefined && !isMessage(a)) {
                  a = m.T.fieldWrapper.wrapField(a);
                }
                if (b !== undefined && !isMessage(b)) {
                  b = m.T.fieldWrapper.wrapField(b);
                }
              }
              return m.T.equals(a, b);
            case 'enum':
              return scalarEquals(ScalarType.INT32, va, vb);
            case 'scalar':
              return scalarEquals(m.T, va, vb);
            case 'oneof':
              if (va.case !== vb.case) {
                return false;
              }
              const s = m.findField(va.case);
              if (s === undefined) {
                return true;
              }
              // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- oneof fields are never "map"
              switch (s.kind) {
                case 'message':
                  return s.T.equals(va.value, vb.value);
                case 'enum':
                  return scalarEquals(ScalarType.INT32, va.value, vb.value);
                case 'scalar':
                  return scalarEquals(s.T, va.value, vb.value);
              }
              throw new Error('oneof cannot contain '.concat(s.kind));
            case 'map':
              const keys = Object.keys(va).concat(Object.keys(vb));
              switch (m.V.kind) {
                case 'message':
                  const messageType = m.V.T;
                  return keys.every((k) => messageType.equals(va[k], vb[k]));
                case 'enum':
                  return keys.every((k) => scalarEquals(ScalarType.INT32, va[k], vb[k]));
                case 'scalar':
                  const scalarType = m.V.T;
                  return keys.every((k) => scalarEquals(scalarType, va[k], vb[k]));
              }
              break;
          }
        });
      },
      // TODO use isFieldSet() here to support future field presence
      clone(message) {
        const type = message.getType(),
          target = new type(),
          any = target;
        for (const member of type.fields.byMember()) {
          const source = message[member.localName];
          let copy;
          if (member.repeated) {
            copy = source.map(cloneSingularField);
          } else if (member.kind == 'map') {
            copy = any[member.localName];
            for (const [key, v] of Object.entries(source)) {
              copy[key] = cloneSingularField(v);
            }
          } else if (member.kind == 'oneof') {
            const f = member.findField(source.case);
            copy = f
              ? {
                  case: source.case,
                  value: cloneSingularField(source.value),
                }
              : {
                  case: undefined,
                };
          } else {
            copy = cloneSingularField(source);
          }
          any[member.localName] = copy;
        }
        for (const uf of type.runtime.bin.listUnknownFields(message)) {
          type.runtime.bin.onUnknownField(any, uf.no, uf.wireType, uf.data);
        }
        return target;
      },
    };
  }
  // clone a single field value - i.e. the element type of repeated fields, the value type of maps
  function cloneSingularField(value) {
    if (value === undefined) {
      return value;
    }
    if (isMessage(value)) {
      return value.clone();
    }
    if (value instanceof Uint8Array) {
      const c = new Uint8Array(value.byteLength);
      c.set(value);
      return c;
    }
    return value;
  }
  // converts any ArrayLike<number> to Uint8Array if necessary.
  function toU8Arr(input) {
    return input instanceof Uint8Array ? input : new Uint8Array(input);
  }

  // Copyright 2021-2024 Buf Technologies, Inc.
  //
  // Licensed under the Apache License, Version 2.0 (the "License");
  // you may not use this file except in compliance with the License.
  // You may obtain a copy of the License at
  //
  //      http://www.apache.org/licenses/LICENSE-2.0
  //
  // Unless required by applicable law or agreed to in writing, software
  // distributed under the License is distributed on an "AS IS" BASIS,
  // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  // See the License for the specific language governing permissions and
  // limitations under the License.
  function makeProtoRuntime(syntax, newFieldList, initFields) {
    return {
      syntax,
      json: makeJsonFormat(),
      bin: makeBinaryFormat(),
      util: Object.assign(Object.assign({}, makeUtilCommon()), {
        newFieldList,
        initFields,
      }),
      makeMessageType(typeName, fields, opt) {
        return makeMessageType(this, typeName, fields, opt);
      },
      makeEnum,
      makeEnumType,
      getEnumType,
      makeExtension(typeName, extendee, field) {
        return makeExtension(this, typeName, extendee, field);
      },
    };
  }

  // Copyright 2021-2024 Buf Technologies, Inc.
  //
  // Licensed under the Apache License, Version 2.0 (the "License");
  // you may not use this file except in compliance with the License.
  // You may obtain a copy of the License at
  //
  //      http://www.apache.org/licenses/LICENSE-2.0
  //
  // Unless required by applicable law or agreed to in writing, software
  // distributed under the License is distributed on an "AS IS" BASIS,
  // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  // See the License for the specific language governing permissions and
  // limitations under the License.
  class InternalFieldList {
    constructor(fields, normalizer) {
      this._fields = fields;
      this._normalizer = normalizer;
    }
    findJsonName(jsonName) {
      if (!this.jsonNames) {
        const t = {};
        for (const f of this.list()) {
          t[f.jsonName] = t[f.name] = f;
        }
        this.jsonNames = t;
      }
      return this.jsonNames[jsonName];
    }
    find(fieldNo) {
      if (!this.numbers) {
        const t = {};
        for (const f of this.list()) {
          t[f.no] = f;
        }
        this.numbers = t;
      }
      return this.numbers[fieldNo];
    }
    list() {
      if (!this.all) {
        this.all = this._normalizer(this._fields);
      }
      return this.all;
    }
    byNumber() {
      if (!this.numbersAsc) {
        this.numbersAsc = this.list()
          .concat()
          .sort((a, b) => a.no - b.no);
      }
      return this.numbersAsc;
    }
    byMember() {
      if (!this.members) {
        this.members = [];
        const a = this.members;
        let o;
        for (const f of this.list()) {
          if (f.oneof) {
            if (f.oneof !== o) {
              o = f.oneof;
              a.push(o);
            }
          } else {
            a.push(f);
          }
        }
      }
      return this.members;
    }
  }

  // Copyright 2021-2024 Buf Technologies, Inc.
  //
  // Licensed under the Apache License, Version 2.0 (the "License");
  // you may not use this file except in compliance with the License.
  // You may obtain a copy of the License at
  //
  //      http://www.apache.org/licenses/LICENSE-2.0
  //
  // Unless required by applicable law or agreed to in writing, software
  // distributed under the License is distributed on an "AS IS" BASIS,
  // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  // See the License for the specific language governing permissions and
  // limitations under the License.
  /**
   * Returns the name of a protobuf element in generated code.
   *
   * Field names - including oneofs - are converted to lowerCamelCase. For
   * messages, enumerations and services, the package name is stripped from
   * the type name. For nested messages and enumerations, the names are joined
   * with an underscore. For methods, the first character is made lowercase.
   */
  /**
   * Returns the name of a field in generated code.
   */
  function localFieldName(protoName, inOneof) {
    const name = protoCamelCase(protoName);
    if (inOneof) {
      // oneof member names are not properties, but values of the `case` property.
      return name;
    }
    return safeObjectProperty(safeMessageProperty(name));
  }
  /**
   * Returns the name of a oneof group in generated code.
   */
  function localOneofName(protoName) {
    return localFieldName(protoName, false);
  }
  /**
   * Returns the JSON name for a protobuf field, exactly like protoc does.
   */
  const fieldJsonName = protoCamelCase;
  /**
   * Converts snake_case to protoCamelCase according to the convention
   * used by protoc to convert a field name to a JSON name.
   */
  function protoCamelCase(snakeCase) {
    let capNext = false;
    const b = [];
    for (let i = 0; i < snakeCase.length; i++) {
      let c = snakeCase.charAt(i);
      switch (c) {
        case '_':
          capNext = true;
          break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          b.push(c);
          capNext = false;
          break;
        default:
          if (capNext) {
            capNext = false;
            c = c.toUpperCase();
          }
          b.push(c);
          break;
      }
    }
    return b.join('');
  }
  /**
   * Names that cannot be used for object properties because they are reserved
   * by built-in JavaScript properties.
   */
  const reservedObjectProperties = new Set([
    // names reserved by JavaScript
    'constructor',
    'toString',
    'toJSON',
    'valueOf',
  ]);
  /**
   * Names that cannot be used for object properties because they are reserved
   * by the runtime.
   */
  const reservedMessageProperties = new Set([
    // names reserved by the runtime
    'getType',
    'clone',
    'equals',
    'fromBinary',
    'fromJson',
    'fromJsonString',
    'toBinary',
    'toJson',
    'toJsonString',
    // names reserved by the runtime for the future
    'toObject',
  ]);
  const fallback = (name) => ''.concat(name, '$');
  /**
   * Will wrap names that are Object prototype properties or names reserved
   * for `Message`s.
   */
  const safeMessageProperty = (name) => {
    if (reservedMessageProperties.has(name)) {
      return fallback(name);
    }
    return name;
  };
  /**
   * Names that cannot be used for object properties because they are reserved
   * by built-in JavaScript properties.
   */
  const safeObjectProperty = (name) => {
    if (reservedObjectProperties.has(name)) {
      return fallback(name);
    }
    return name;
  };

  // Copyright 2021-2024 Buf Technologies, Inc.
  //
  // Licensed under the Apache License, Version 2.0 (the "License");
  // you may not use this file except in compliance with the License.
  // You may obtain a copy of the License at
  //
  //      http://www.apache.org/licenses/LICENSE-2.0
  //
  // Unless required by applicable law or agreed to in writing, software
  // distributed under the License is distributed on an "AS IS" BASIS,
  // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  // See the License for the specific language governing permissions and
  // limitations under the License.
  class InternalOneofInfo {
    constructor(name) {
      this.kind = 'oneof';
      this.repeated = false;
      this.packed = false;
      this.opt = false;
      this.req = false;
      this.default = undefined;
      this.fields = [];
      this.name = name;
      this.localName = localOneofName(name);
    }
    addField(field) {
      assert(field.oneof === this, 'field '.concat(field.name, ' not one of ').concat(this.name));
      this.fields.push(field);
    }
    findField(localName) {
      if (!this._lookup) {
        this._lookup = Object.create(null);
        for (let i = 0; i < this.fields.length; i++) {
          this._lookup[this.fields[i].localName] = this.fields[i];
        }
      }
      return this._lookup[localName];
    }
  }

  // Copyright 2021-2024 Buf Technologies, Inc.
  //
  // Licensed under the Apache License, Version 2.0 (the "License");
  // you may not use this file except in compliance with the License.
  // You may obtain a copy of the License at
  //
  //      http://www.apache.org/licenses/LICENSE-2.0
  //
  // Unless required by applicable law or agreed to in writing, software
  // distributed under the License is distributed on an "AS IS" BASIS,
  // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  // See the License for the specific language governing permissions and
  // limitations under the License.
  /**
   * Convert a collection of field info to an array of normalized FieldInfo.
   *
   * The argument `packedByDefault` specifies whether fields that do not specify
   * `packed` should be packed (proto3) or unpacked (proto2).
   */
  function normalizeFieldInfos(fieldInfos, packedByDefault) {
    var _a, _b, _c, _d, _e, _f;
    const r = [];
    let o;
    for (const field of typeof fieldInfos == 'function' ? fieldInfos() : fieldInfos) {
      const f = field;
      f.localName = localFieldName(field.name, field.oneof !== undefined);
      f.jsonName = (_a = field.jsonName) !== null && _a !== void 0 ? _a : fieldJsonName(field.name);
      f.repeated = (_b = field.repeated) !== null && _b !== void 0 ? _b : false;
      if (field.kind == 'scalar') {
        f.L = (_c = field.L) !== null && _c !== void 0 ? _c : LongType.BIGINT;
      }
      f.delimited = (_d = field.delimited) !== null && _d !== void 0 ? _d : false;
      f.req = (_e = field.req) !== null && _e !== void 0 ? _e : false;
      f.opt = (_f = field.opt) !== null && _f !== void 0 ? _f : false;
      if (field.packed === undefined) {
        {
          f.packed =
            field.kind == 'enum' ||
            (field.kind == 'scalar' && field.T != ScalarType.BYTES && field.T != ScalarType.STRING);
        }
      }
      // We do not surface options at this time
      // f.options = field.options ?? emptyReadonlyObject;
      if (field.oneof !== undefined) {
        const ooname = typeof field.oneof == 'string' ? field.oneof : field.oneof.name;
        if (!o || o.name != ooname) {
          o = new InternalOneofInfo(ooname);
        }
        f.oneof = o;
        o.addField(f);
      }
      r.push(f);
    }
    return r;
  }

  // Copyright 2021-2024 Buf Technologies, Inc.
  //
  // Licensed under the Apache License, Version 2.0 (the "License");
  // you may not use this file except in compliance with the License.
  // You may obtain a copy of the License at
  //
  //      http://www.apache.org/licenses/LICENSE-2.0
  //
  // Unless required by applicable law or agreed to in writing, software
  // distributed under the License is distributed on an "AS IS" BASIS,
  // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  // See the License for the specific language governing permissions and
  // limitations under the License.
  /**
   * Provides functionality for messages defined with the proto3 syntax.
   */
  const proto3 = makeProtoRuntime(
    'proto3',
    (fields) => {
      return new InternalFieldList(fields, (source) => normalizeFieldInfos(source));
    },
    // TODO merge with proto2 and initExtensionField, also see initPartial, equals, clone
    (target) => {
      for (const member of target.getType().fields.byMember()) {
        if (member.opt) {
          continue;
        }
        const name = member.localName,
          t = target;
        if (member.repeated) {
          t[name] = [];
          continue;
        }
        switch (member.kind) {
          case 'oneof':
            t[name] = {
              case: undefined,
            };
            break;
          case 'enum':
            t[name] = 0;
            break;
          case 'map':
            t[name] = {};
            break;
          case 'scalar':
            t[name] = scalarZeroValue(member.T, member.L);
            break;
        }
      }
    }
  );

  // Copyright 2021-2024 Buf Technologies, Inc.
  //
  // Licensed under the Apache License, Version 2.0 (the "License");
  // you may not use this file except in compliance with the License.
  // You may obtain a copy of the License at
  //
  //      http://www.apache.org/licenses/LICENSE-2.0
  //
  // Unless required by applicable law or agreed to in writing, software
  // distributed under the License is distributed on an "AS IS" BASIS,
  // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  // See the License for the specific language governing permissions and
  // limitations under the License.
  /**
   * A Timestamp represents a point in time independent of any time zone or local
   * calendar, encoded as a count of seconds and fractions of seconds at
   * nanosecond resolution. The count is relative to an epoch at UTC midnight on
   * January 1, 1970, in the proleptic Gregorian calendar which extends the
   * Gregorian calendar backwards to year one.
   *
   * All minutes are 60 seconds long. Leap seconds are "smeared" so that no leap
   * second table is needed for interpretation, using a [24-hour linear
   * smear](https://developers.google.com/time/smear).
   *
   * The range is from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z. By
   * restricting to that range, we ensure that we can convert to and from [RFC
   * 3339](https://www.ietf.org/rfc/rfc3339.txt) date strings.
   *
   * # Examples
   *
   * Example 1: Compute Timestamp from POSIX `time()`.
   *
   *     Timestamp timestamp;
   *     timestamp.set_seconds(time(NULL));
   *     timestamp.set_nanos(0);
   *
   * Example 2: Compute Timestamp from POSIX `gettimeofday()`.
   *
   *     struct timeval tv;
   *     gettimeofday(&tv, NULL);
   *
   *     Timestamp timestamp;
   *     timestamp.set_seconds(tv.tv_sec);
   *     timestamp.set_nanos(tv.tv_usec * 1000);
   *
   * Example 3: Compute Timestamp from Win32 `GetSystemTimeAsFileTime()`.
   *
   *     FILETIME ft;
   *     GetSystemTimeAsFileTime(&ft);
   *     UINT64 ticks = (((UINT64)ft.dwHighDateTime) << 32) | ft.dwLowDateTime;
   *
   *     // A Windows tick is 100 nanoseconds. Windows epoch 1601-01-01T00:00:00Z
   *     // is 11644473600 seconds before Unix epoch 1970-01-01T00:00:00Z.
   *     Timestamp timestamp;
   *     timestamp.set_seconds((INT64) ((ticks / 10000000) - 11644473600LL));
   *     timestamp.set_nanos((INT32) ((ticks % 10000000) * 100));
   *
   * Example 4: Compute Timestamp from Java `System.currentTimeMillis()`.
   *
   *     long millis = System.currentTimeMillis();
   *
   *     Timestamp timestamp = Timestamp.newBuilder().setSeconds(millis / 1000)
   *         .setNanos((int) ((millis % 1000) * 1000000)).build();
   *
   * Example 5: Compute Timestamp from Java `Instant.now()`.
   *
   *     Instant now = Instant.now();
   *
   *     Timestamp timestamp =
   *         Timestamp.newBuilder().setSeconds(now.getEpochSecond())
   *             .setNanos(now.getNano()).build();
   *
   * Example 6: Compute Timestamp from current time in Python.
   *
   *     timestamp = Timestamp()
   *     timestamp.GetCurrentTime()
   *
   * # JSON Mapping
   *
   * In JSON format, the Timestamp type is encoded as a string in the
   * [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format. That is, the
   * format is "{year}-{month}-{day}T{hour}:{min}:{sec}[.{frac_sec}]Z"
   * where {year} is always expressed using four digits while {month}, {day},
   * {hour}, {min}, and {sec} are zero-padded to two digits each. The fractional
   * seconds, which can go up to 9 digits (i.e. up to 1 nanosecond resolution),
   * are optional. The "Z" suffix indicates the timezone ("UTC"); the timezone
   * is required. A proto3 JSON serializer should always use UTC (as indicated by
   * "Z") when printing the Timestamp type and a proto3 JSON parser should be
   * able to accept both UTC and other timezones (as indicated by an offset).
   *
   * For example, "2017-01-15T01:30:15.01Z" encodes 15.01 seconds past
   * 01:30 UTC on January 15, 2017.
   *
   * In JavaScript, one can convert a Date object to this format using the
   * standard
   * [toISOString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString)
   * method. In Python, a standard `datetime.datetime` object can be converted
   * to this format using
   * [`strftime`](https://docs.python.org/2/library/time.html#time.strftime) with
   * the time format spec '%Y-%m-%dT%H:%M:%S.%fZ'. Likewise, in Java, one can use
   * the Joda Time's [`ISODateTimeFormat.dateTime()`](
   * http://joda-time.sourceforge.net/apidocs/org/joda/time/format/ISODateTimeFormat.html#dateTime()
   * ) to obtain a formatter capable of generating timestamps in this format.
   *
   *
   * @generated from message google.protobuf.Timestamp
   */
  class Timestamp extends Message {
    constructor(data) {
      super();
      /**
       * Represents seconds of UTC time since Unix epoch
       * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
       * 9999-12-31T23:59:59Z inclusive.
       *
       * @generated from field: int64 seconds = 1;
       */
      this.seconds = protoInt64.zero;
      /**
       * Non-negative fractions of a second at nanosecond resolution. Negative
       * second values with fractions must still have non-negative nanos values
       * that count forward in time. Must be from 0 to 999,999,999
       * inclusive.
       *
       * @generated from field: int32 nanos = 2;
       */
      this.nanos = 0;
      proto3.util.initPartial(data, this);
    }
    fromJson(json, options) {
      if (typeof json !== 'string') {
        throw new Error(
          'cannot decode google.protobuf.Timestamp from JSON: '.concat(proto3.json.debug(json))
        );
      }
      const matches = json.match(
        /^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:Z|\.([0-9]{3,9})Z|([+-][0-9][0-9]:[0-9][0-9]))$/
      );
      if (!matches) {
        throw new Error(
          'cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string'
        );
      }
      const ms = Date.parse(
        matches[1] +
          '-' +
          matches[2] +
          '-' +
          matches[3] +
          'T' +
          matches[4] +
          ':' +
          matches[5] +
          ':' +
          matches[6] +
          (matches[8] ? matches[8] : 'Z')
      );
      if (Number.isNaN(ms)) {
        throw new Error(
          'cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string'
        );
      }
      if (ms < Date.parse('0001-01-01T00:00:00Z') || ms > Date.parse('9999-12-31T23:59:59Z')) {
        throw new Error(
          'cannot decode message google.protobuf.Timestamp from JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive'
        );
      }
      this.seconds = protoInt64.parse(ms / 1000);
      this.nanos = 0;
      if (matches[7]) {
        this.nanos = parseInt('1' + matches[7] + '0'.repeat(9 - matches[7].length)) - 1000000000;
      }
      return this;
    }
    toJson(options) {
      const ms = Number(this.seconds) * 1000;
      if (ms < Date.parse('0001-01-01T00:00:00Z') || ms > Date.parse('9999-12-31T23:59:59Z')) {
        throw new Error(
          'cannot encode google.protobuf.Timestamp to JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive'
        );
      }
      if (this.nanos < 0) {
        throw new Error(
          'cannot encode google.protobuf.Timestamp to JSON: nanos must not be negative'
        );
      }
      let z = 'Z';
      if (this.nanos > 0) {
        const nanosStr = (this.nanos + 1000000000).toString().substring(1);
        if (nanosStr.substring(3) === '000000') {
          z = '.' + nanosStr.substring(0, 3) + 'Z';
        } else if (nanosStr.substring(6) === '000') {
          z = '.' + nanosStr.substring(0, 6) + 'Z';
        } else {
          z = '.' + nanosStr + 'Z';
        }
      }
      return new Date(ms).toISOString().replace('.000Z', z);
    }
    toDate() {
      return new Date(Number(this.seconds) * 1000 + Math.ceil(this.nanos / 1000000));
    }
    static now() {
      return Timestamp.fromDate(new Date());
    }
    static fromDate(date) {
      const ms = date.getTime();
      return new Timestamp({
        seconds: protoInt64.parse(Math.floor(ms / 1000)),
        nanos: (ms % 1000) * 1000000,
      });
    }
    static fromBinary(bytes, options) {
      return new Timestamp().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new Timestamp().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new Timestamp().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto3.util.equals(Timestamp, a, b);
    }
  }
  Timestamp.runtime = proto3;
  Timestamp.typeName = 'google.protobuf.Timestamp';
  Timestamp.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'seconds',
      kind: 'scalar',
      T: 3 /* ScalarType.INT64 */,
    },
    {
      no: 2,
      name: 'nanos',
      kind: 'scalar',
      T: 5 /* ScalarType.INT32 */,
    },
  ]);

  const MetricsBatch = /* @__PURE__ */ proto3.makeMessageType('livekit.MetricsBatch', () => [
    {
      no: 1,
      name: 'timestamp_ms',
      kind: 'scalar',
      T: 3,
      /* ScalarType.INT64 */
    },
    {
      no: 2,
      name: 'normalized_timestamp',
      kind: 'message',
      T: Timestamp,
    },
    {
      no: 3,
      name: 'str_data',
      kind: 'scalar',
      T: 9,
      repeated: true,
    },
    {
      no: 4,
      name: 'time_series',
      kind: 'message',
      T: TimeSeriesMetric,
      repeated: true,
    },
    {
      no: 5,
      name: 'events',
      kind: 'message',
      T: EventMetric,
      repeated: true,
    },
  ]);
  const TimeSeriesMetric = /* @__PURE__ */ proto3.makeMessageType(
    'livekit.TimeSeriesMetric',
    () => [
      {
        no: 1,
        name: 'label',
        kind: 'scalar',
        T: 13,
        /* ScalarType.UINT32 */
      },
      {
        no: 2,
        name: 'participant_identity',
        kind: 'scalar',
        T: 13,
        /* ScalarType.UINT32 */
      },
      {
        no: 3,
        name: 'track_sid',
        kind: 'scalar',
        T: 13,
        /* ScalarType.UINT32 */
      },
      {
        no: 4,
        name: 'samples',
        kind: 'message',
        T: MetricSample,
        repeated: true,
      },
      {
        no: 5,
        name: 'rid',
        kind: 'scalar',
        T: 13,
        /* ScalarType.UINT32 */
      },
    ]
  );
  const MetricSample = /* @__PURE__ */ proto3.makeMessageType('livekit.MetricSample', () => [
    {
      no: 1,
      name: 'timestamp_ms',
      kind: 'scalar',
      T: 3,
      /* ScalarType.INT64 */
    },
    {
      no: 2,
      name: 'normalized_timestamp',
      kind: 'message',
      T: Timestamp,
    },
    {
      no: 3,
      name: 'value',
      kind: 'scalar',
      T: 2,
      /* ScalarType.FLOAT */
    },
  ]);
  const EventMetric = /* @__PURE__ */ proto3.makeMessageType('livekit.EventMetric', () => [
    {
      no: 1,
      name: 'label',
      kind: 'scalar',
      T: 13,
      /* ScalarType.UINT32 */
    },
    {
      no: 2,
      name: 'participant_identity',
      kind: 'scalar',
      T: 13,
      /* ScalarType.UINT32 */
    },
    {
      no: 3,
      name: 'track_sid',
      kind: 'scalar',
      T: 13,
      /* ScalarType.UINT32 */
    },
    {
      no: 4,
      name: 'start_timestamp_ms',
      kind: 'scalar',
      T: 3,
      /* ScalarType.INT64 */
    },
    {
      no: 5,
      name: 'end_timestamp_ms',
      kind: 'scalar',
      T: 3,
      opt: true,
    },
    {
      no: 6,
      name: 'normalized_start_timestamp',
      kind: 'message',
      T: Timestamp,
    },
    {
      no: 7,
      name: 'normalized_end_timestamp',
      kind: 'message',
      T: Timestamp,
      opt: true,
    },
    {
      no: 8,
      name: 'metadata',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 9,
      name: 'rid',
      kind: 'scalar',
      T: 13,
      /* ScalarType.UINT32 */
    },
  ]);
  const AudioCodec = /* @__PURE__ */ proto3.makeEnum('livekit.AudioCodec', [
    {
      no: 0,
      name: 'DEFAULT_AC',
    },
    {
      no: 1,
      name: 'OPUS',
    },
    {
      no: 2,
      name: 'AAC',
    },
    {
      no: 3,
      name: 'AC_MP3',
    },
  ]);
  const VideoCodec = /* @__PURE__ */ proto3.makeEnum('livekit.VideoCodec', [
    {
      no: 0,
      name: 'DEFAULT_VC',
    },
    {
      no: 1,
      name: 'H264_BASELINE',
    },
    {
      no: 2,
      name: 'H264_MAIN',
    },
    {
      no: 3,
      name: 'H264_HIGH',
    },
    {
      no: 4,
      name: 'VP8',
    },
  ]);
  const ImageCodec = /* @__PURE__ */ proto3.makeEnum('livekit.ImageCodec', [
    {
      no: 0,
      name: 'IC_DEFAULT',
    },
    {
      no: 1,
      name: 'IC_JPEG',
    },
  ]);
  const BackupCodecPolicy$1 = /* @__PURE__ */ proto3.makeEnum('livekit.BackupCodecPolicy', [
    {
      no: 0,
      name: 'PREFER_REGRESSION',
    },
    {
      no: 1,
      name: 'SIMULCAST',
    },
    {
      no: 2,
      name: 'REGRESSION',
    },
  ]);
  const TrackType = /* @__PURE__ */ proto3.makeEnum('livekit.TrackType', [
    {
      no: 0,
      name: 'AUDIO',
    },
    {
      no: 1,
      name: 'VIDEO',
    },
    {
      no: 2,
      name: 'DATA',
    },
  ]);
  const TrackSource = /* @__PURE__ */ proto3.makeEnum('livekit.TrackSource', [
    {
      no: 0,
      name: 'UNKNOWN',
    },
    {
      no: 1,
      name: 'CAMERA',
    },
    {
      no: 2,
      name: 'MICROPHONE',
    },
    {
      no: 3,
      name: 'SCREEN_SHARE',
    },
    {
      no: 4,
      name: 'SCREEN_SHARE_AUDIO',
    },
  ]);
  const VideoQuality$1 = /* @__PURE__ */ proto3.makeEnum('livekit.VideoQuality', [
    {
      no: 0,
      name: 'LOW',
    },
    {
      no: 1,
      name: 'MEDIUM',
    },
    {
      no: 2,
      name: 'HIGH',
    },
    {
      no: 3,
      name: 'OFF',
    },
  ]);
  const ConnectionQuality$1 = /* @__PURE__ */ proto3.makeEnum('livekit.ConnectionQuality', [
    {
      no: 0,
      name: 'POOR',
    },
    {
      no: 1,
      name: 'GOOD',
    },
    {
      no: 2,
      name: 'EXCELLENT',
    },
    {
      no: 3,
      name: 'LOST',
    },
  ]);
  const ClientConfigSetting = /* @__PURE__ */ proto3.makeEnum('livekit.ClientConfigSetting', [
    {
      no: 0,
      name: 'UNSET',
    },
    {
      no: 1,
      name: 'DISABLED',
    },
    {
      no: 2,
      name: 'ENABLED',
    },
  ]);
  const DisconnectReason = /* @__PURE__ */ proto3.makeEnum('livekit.DisconnectReason', [
    {
      no: 0,
      name: 'UNKNOWN_REASON',
    },
    {
      no: 1,
      name: 'CLIENT_INITIATED',
    },
    {
      no: 2,
      name: 'DUPLICATE_IDENTITY',
    },
    {
      no: 3,
      name: 'SERVER_SHUTDOWN',
    },
    {
      no: 4,
      name: 'PARTICIPANT_REMOVED',
    },
    {
      no: 5,
      name: 'ROOM_DELETED',
    },
    {
      no: 6,
      name: 'STATE_MISMATCH',
    },
    {
      no: 7,
      name: 'JOIN_FAILURE',
    },
    {
      no: 8,
      name: 'MIGRATION',
    },
    {
      no: 9,
      name: 'SIGNAL_CLOSE',
    },
    {
      no: 10,
      name: 'ROOM_CLOSED',
    },
    {
      no: 11,
      name: 'USER_UNAVAILABLE',
    },
    {
      no: 12,
      name: 'USER_REJECTED',
    },
    {
      no: 13,
      name: 'SIP_TRUNK_FAILURE',
    },
    {
      no: 14,
      name: 'CONNECTION_TIMEOUT',
    },
    {
      no: 15,
      name: 'MEDIA_FAILURE',
    },
  ]);
  const ReconnectReason = /* @__PURE__ */ proto3.makeEnum('livekit.ReconnectReason', [
    {
      no: 0,
      name: 'RR_UNKNOWN',
    },
    {
      no: 1,
      name: 'RR_SIGNAL_DISCONNECTED',
    },
    {
      no: 2,
      name: 'RR_PUBLISHER_FAILED',
    },
    {
      no: 3,
      name: 'RR_SUBSCRIBER_FAILED',
    },
    {
      no: 4,
      name: 'RR_SWITCH_CANDIDATE',
    },
  ]);
  const SubscriptionError = /* @__PURE__ */ proto3.makeEnum('livekit.SubscriptionError', [
    {
      no: 0,
      name: 'SE_UNKNOWN',
    },
    {
      no: 1,
      name: 'SE_CODEC_UNSUPPORTED',
    },
    {
      no: 2,
      name: 'SE_TRACK_NOTFOUND',
    },
  ]);
  const AudioTrackFeature = /* @__PURE__ */ proto3.makeEnum('livekit.AudioTrackFeature', [
    {
      no: 0,
      name: 'TF_STEREO',
    },
    {
      no: 1,
      name: 'TF_NO_DTX',
    },
    {
      no: 2,
      name: 'TF_AUTO_GAIN_CONTROL',
    },
    {
      no: 3,
      name: 'TF_ECHO_CANCELLATION',
    },
    {
      no: 4,
      name: 'TF_NOISE_SUPPRESSION',
    },
    {
      no: 5,
      name: 'TF_ENHANCED_NOISE_CANCELLATION',
    },
    {
      no: 6,
      name: 'TF_PRECONNECT_BUFFER',
    },
  ]);
  const Room$1 = /* @__PURE__ */ proto3.makeMessageType('livekit.Room', () => [
    {
      no: 1,
      name: 'sid',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'name',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: 'empty_timeout',
      kind: 'scalar',
      T: 13,
      /* ScalarType.UINT32 */
    },
    {
      no: 14,
      name: 'departure_timeout',
      kind: 'scalar',
      T: 13,
      /* ScalarType.UINT32 */
    },
    {
      no: 4,
      name: 'max_participants',
      kind: 'scalar',
      T: 13,
      /* ScalarType.UINT32 */
    },
    {
      no: 5,
      name: 'creation_time',
      kind: 'scalar',
      T: 3,
      /* ScalarType.INT64 */
    },
    {
      no: 15,
      name: 'creation_time_ms',
      kind: 'scalar',
      T: 3,
      /* ScalarType.INT64 */
    },
    {
      no: 6,
      name: 'turn_password',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 7,
      name: 'enabled_codecs',
      kind: 'message',
      T: Codec,
      repeated: true,
    },
    {
      no: 8,
      name: 'metadata',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 9,
      name: 'num_participants',
      kind: 'scalar',
      T: 13,
      /* ScalarType.UINT32 */
    },
    {
      no: 11,
      name: 'num_publishers',
      kind: 'scalar',
      T: 13,
      /* ScalarType.UINT32 */
    },
    {
      no: 10,
      name: 'active_recording',
      kind: 'scalar',
      T: 8,
      /* ScalarType.BOOL */
    },
    {
      no: 13,
      name: 'version',
      kind: 'message',
      T: TimedVersion,
    },
  ]);
  const Codec = /* @__PURE__ */ proto3.makeMessageType('livekit.Codec', () => [
    {
      no: 1,
      name: 'mime',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'fmtp_line',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ]);
  const ParticipantPermission = /* @__PURE__ */ proto3.makeMessageType(
    'livekit.ParticipantPermission',
    () => [
      {
        no: 1,
        name: 'can_subscribe',
        kind: 'scalar',
        T: 8,
        /* ScalarType.BOOL */
      },
      {
        no: 2,
        name: 'can_publish',
        kind: 'scalar',
        T: 8,
        /* ScalarType.BOOL */
      },
      {
        no: 3,
        name: 'can_publish_data',
        kind: 'scalar',
        T: 8,
        /* ScalarType.BOOL */
      },
      {
        no: 9,
        name: 'can_publish_sources',
        kind: 'enum',
        T: proto3.getEnumType(TrackSource),
        repeated: true,
      },
      {
        no: 7,
        name: 'hidden',
        kind: 'scalar',
        T: 8,
        /* ScalarType.BOOL */
      },
      {
        no: 8,
        name: 'recorder',
        kind: 'scalar',
        T: 8,
        /* ScalarType.BOOL */
      },
      {
        no: 10,
        name: 'can_update_metadata',
        kind: 'scalar',
        T: 8,
        /* ScalarType.BOOL */
      },
      {
        no: 11,
        name: 'agent',
        kind: 'scalar',
        T: 8,
        /* ScalarType.BOOL */
      },
      {
        no: 12,
        name: 'can_subscribe_metrics',
        kind: 'scalar',
        T: 8,
        /* ScalarType.BOOL */
      },
    ]
  );
  const ParticipantInfo = /* @__PURE__ */ proto3.makeMessageType('livekit.ParticipantInfo', () => [
    {
      no: 1,
      name: 'sid',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'identity',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: 'state',
      kind: 'enum',
      T: proto3.getEnumType(ParticipantInfo_State),
    },
    {
      no: 4,
      name: 'tracks',
      kind: 'message',
      T: TrackInfo,
      repeated: true,
    },
    {
      no: 5,
      name: 'metadata',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 6,
      name: 'joined_at',
      kind: 'scalar',
      T: 3,
      /* ScalarType.INT64 */
    },
    {
      no: 17,
      name: 'joined_at_ms',
      kind: 'scalar',
      T: 3,
      /* ScalarType.INT64 */
    },
    {
      no: 9,
      name: 'name',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 10,
      name: 'version',
      kind: 'scalar',
      T: 13,
      /* ScalarType.UINT32 */
    },
    {
      no: 11,
      name: 'permission',
      kind: 'message',
      T: ParticipantPermission,
    },
    {
      no: 12,
      name: 'region',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 13,
      name: 'is_publisher',
      kind: 'scalar',
      T: 8,
      /* ScalarType.BOOL */
    },
    {
      no: 14,
      name: 'kind',
      kind: 'enum',
      T: proto3.getEnumType(ParticipantInfo_Kind),
    },
    {
      no: 15,
      name: 'attributes',
      kind: 'map',
      K: 9,
      V: {
        kind: 'scalar',
        T: 9,
        /* ScalarType.STRING */
      },
    },
    {
      no: 16,
      name: 'disconnect_reason',
      kind: 'enum',
      T: proto3.getEnumType(DisconnectReason),
    },
    {
      no: 18,
      name: 'kind_details',
      kind: 'enum',
      T: proto3.getEnumType(ParticipantInfo_KindDetail),
      repeated: true,
    },
  ]);
  const ParticipantInfo_State = /* @__PURE__ */ proto3.makeEnum('livekit.ParticipantInfo.State', [
    {
      no: 0,
      name: 'JOINING',
    },
    {
      no: 1,
      name: 'JOINED',
    },
    {
      no: 2,
      name: 'ACTIVE',
    },
    {
      no: 3,
      name: 'DISCONNECTED',
    },
  ]);
  const ParticipantInfo_Kind = /* @__PURE__ */ proto3.makeEnum('livekit.ParticipantInfo.Kind', [
    {
      no: 0,
      name: 'STANDARD',
    },
    {
      no: 1,
      name: 'INGRESS',
    },
    {
      no: 2,
      name: 'EGRESS',
    },
    {
      no: 3,
      name: 'SIP',
    },
    {
      no: 4,
      name: 'AGENT',
    },
  ]);
  const ParticipantInfo_KindDetail = /* @__PURE__ */ proto3.makeEnum(
    'livekit.ParticipantInfo.KindDetail',
    [
      {
        no: 0,
        name: 'CLOUD_AGENT',
      },
      {
        no: 1,
        name: 'FORWARDED',
      },
    ]
  );
  const Encryption_Type = /* @__PURE__ */ proto3.makeEnum('livekit.Encryption.Type', [
    {
      no: 0,
      name: 'NONE',
    },
    {
      no: 1,
      name: 'GCM',
    },
    {
      no: 2,
      name: 'CUSTOM',
    },
  ]);
  const SimulcastCodecInfo = /* @__PURE__ */ proto3.makeMessageType(
    'livekit.SimulcastCodecInfo',
    () => [
      {
        no: 1,
        name: 'mime_type',
        kind: 'scalar',
        T: 9,
        /* ScalarType.STRING */
      },
      {
        no: 2,
        name: 'mid',
        kind: 'scalar',
        T: 9,
        /* ScalarType.STRING */
      },
      {
        no: 3,
        name: 'cid',
        kind: 'scalar',
        T: 9,
        /* ScalarType.STRING */
      },
      {
        no: 4,
        name: 'layers',
        kind: 'message',
        T: VideoLayer,
        repeated: true,
      },
      {
        no: 5,
        name: 'video_layer_mode',
        kind: 'enum',
        T: proto3.getEnumType(VideoLayer_Mode),
      },
      {
        no: 6,
        name: 'sdp_cid',
        kind: 'scalar',
        T: 9,
        /* ScalarType.STRING */
      },
    ]
  );
  const TrackInfo = /* @__PURE__ */ proto3.makeMessageType('livekit.TrackInfo', () => [
    {
      no: 1,
      name: 'sid',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'type',
      kind: 'enum',
      T: proto3.getEnumType(TrackType),
    },
    {
      no: 3,
      name: 'name',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: 'muted',
      kind: 'scalar',
      T: 8,
      /* ScalarType.BOOL */
    },
    {
      no: 5,
      name: 'width',
      kind: 'scalar',
      T: 13,
      /* ScalarType.UINT32 */
    },
    {
      no: 6,
      name: 'height',
      kind: 'scalar',
      T: 13,
      /* ScalarType.UINT32 */
    },
    {
      no: 7,
      name: 'simulcast',
      kind: 'scalar',
      T: 8,
      /* ScalarType.BOOL */
    },
    {
      no: 8,
      name: 'disable_dtx',
      kind: 'scalar',
      T: 8,
      /* ScalarType.BOOL */
    },
    {
      no: 9,
      name: 'source',
      kind: 'enum',
      T: proto3.getEnumType(TrackSource),
    },
    {
      no: 10,
      name: 'layers',
      kind: 'message',
      T: VideoLayer,
      repeated: true,
    },
    {
      no: 11,
      name: 'mime_type',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 12,
      name: 'mid',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 13,
      name: 'codecs',
      kind: 'message',
      T: SimulcastCodecInfo,
      repeated: true,
    },
    {
      no: 14,
      name: 'stereo',
      kind: 'scalar',
      T: 8,
      /* ScalarType.BOOL */
    },
    {
      no: 15,
      name: 'disable_red',
      kind: 'scalar',
      T: 8,
      /* ScalarType.BOOL */
    },
    {
      no: 16,
      name: 'encryption',
      kind: 'enum',
      T: proto3.getEnumType(Encryption_Type),
    },
    {
      no: 17,
      name: 'stream',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 18,
      name: 'version',
      kind: 'message',
      T: TimedVersion,
    },
    {
      no: 19,
      name: 'audio_features',
      kind: 'enum',
      T: proto3.getEnumType(AudioTrackFeature),
      repeated: true,
    },
    {
      no: 20,
      name: 'backup_codec_policy',
      kind: 'enum',
      T: proto3.getEnumType(BackupCodecPolicy$1),
    },
  ]);
  const VideoLayer = /* @__PURE__ */ proto3.makeMessageType('livekit.VideoLayer', () => [
    {
      no: 1,
      name: 'quality',
      kind: 'enum',
      T: proto3.getEnumType(VideoQuality$1),
    },
    {
      no: 2,
      name: 'width',
      kind: 'scalar',
      T: 13,
      /* ScalarType.UINT32 */
    },
    {
      no: 3,
      name: 'height',
      kind: 'scalar',
      T: 13,
      /* ScalarType.UINT32 */
    },
    {
      no: 4,
      name: 'bitrate',
      kind: 'scalar',
      T: 13,
      /* ScalarType.UINT32 */
    },
    {
      no: 5,
      name: 'ssrc',
      kind: 'scalar',
      T: 13,
      /* ScalarType.UINT32 */
    },
    {
      no: 6,
      name: 'spatial_layer',
      kind: 'scalar',
      T: 5,
      /* ScalarType.INT32 */
    },
    {
      no: 7,
      name: 'rid',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ]);
  const VideoLayer_Mode = /* @__PURE__ */ proto3.makeEnum('livekit.VideoLayer.Mode', [
    {
      no: 0,
      name: 'MODE_UNUSED',
    },
    {
      no: 1,
      name: 'ONE_SPATIAL_LAYER_PER_STREAM',
    },
    {
      no: 2,
      name: 'MULTIPLE_SPATIAL_LAYERS_PER_STREAM',
    },
    {
      no: 3,
      name: 'ONE_SPATIAL_LAYER_PER_STREAM_INCOMPLETE_RTCP_SR',
    },
  ]);
  const DataPacket = /* @__PURE__ */ proto3.makeMessageType('livekit.DataPacket', () => [
    {
      no: 1,
      name: 'kind',
      kind: 'enum',
      T: proto3.getEnumType(DataPacket_Kind),
    },
    {
      no: 4,
      name: 'participant_identity',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 5,
      name: 'destination_identities',
      kind: 'scalar',
      T: 9,
      repeated: true,
    },
    {
      no: 2,
      name: 'user',
      kind: 'message',
      T: UserPacket,
      oneof: 'value',
    },
    {
      no: 3,
      name: 'speaker',
      kind: 'message',
      T: ActiveSpeakerUpdate,
      oneof: 'value',
    },
    {
      no: 6,
      name: 'sip_dtmf',
      kind: 'message',
      T: SipDTMF,
      oneof: 'value',
    },
    {
      no: 7,
      name: 'transcription',
      kind: 'message',
      T: Transcription,
      oneof: 'value',
    },
    {
      no: 8,
      name: 'metrics',
      kind: 'message',
      T: MetricsBatch,
      oneof: 'value',
    },
    {
      no: 9,
      name: 'chat_message',
      kind: 'message',
      T: ChatMessage,
      oneof: 'value',
    },
    {
      no: 10,
      name: 'rpc_request',
      kind: 'message',
      T: RpcRequest,
      oneof: 'value',
    },
    {
      no: 11,
      name: 'rpc_ack',
      kind: 'message',
      T: RpcAck,
      oneof: 'value',
    },
    {
      no: 12,
      name: 'rpc_response',
      kind: 'message',
      T: RpcResponse,
      oneof: 'value',
    },
    {
      no: 13,
      name: 'stream_header',
      kind: 'message',
      T: DataStream_Header,
      oneof: 'value',
    },
    {
      no: 14,
      name: 'stream_chunk',
      kind: 'message',
      T: DataStream_Chunk,
      oneof: 'value',
    },
    {
      no: 15,
      name: 'stream_trailer',
      kind: 'message',
      T: DataStream_Trailer,
      oneof: 'value',
    },
    {
      no: 18,
      name: 'encrypted_packet',
      kind: 'message',
      T: EncryptedPacket,
      oneof: 'value',
    },
    {
      no: 16,
      name: 'sequence',
      kind: 'scalar',
      T: 13,
      /* ScalarType.UINT32 */
    },
    {
      no: 17,
      name: 'participant_sid',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ]);
  const DataPacket_Kind = /* @__PURE__ */ proto3.makeEnum('livekit.DataPacket.Kind', [
    {
      no: 0,
      name: 'RELIABLE',
    },
    {
      no: 1,
      name: 'LOSSY',
    },
  ]);
  const EncryptedPacket = /* @__PURE__ */ proto3.makeMessageType('livekit.EncryptedPacket', () => [
    {
      no: 1,
      name: 'encryption_type',
      kind: 'enum',
      T: proto3.getEnumType(Encryption_Type),
    },
    {
      no: 2,
      name: 'iv',
      kind: 'scalar',
      T: 12,
      /* ScalarType.BYTES */
    },
    {
      no: 3,
      name: 'key_index',
      kind: 'scalar',
      T: 13,
      /* ScalarType.UINT32 */
    },
    {
      no: 4,
      name: 'encrypted_value',
      kind: 'scalar',
      T: 12,
      /* ScalarType.BYTES */
    },
  ]);
  const EncryptedPacketPayload = /* @__PURE__ */ proto3.makeMessageType(
    'livekit.EncryptedPacketPayload',
    () => [
      {
        no: 1,
        name: 'user',
        kind: 'message',
        T: UserPacket,
        oneof: 'value',
      },
      {
        no: 3,
        name: 'chat_message',
        kind: 'message',
        T: ChatMessage,
        oneof: 'value',
      },
      {
        no: 4,
        name: 'rpc_request',
        kind: 'message',
        T: RpcRequest,
        oneof: 'value',
      },
      {
        no: 5,
        name: 'rpc_ack',
        kind: 'message',
        T: RpcAck,
        oneof: 'value',
      },
      {
        no: 6,
        name: 'rpc_response',
        kind: 'message',
        T: RpcResponse,
        oneof: 'value',
      },
      {
        no: 7,
        name: 'stream_header',
        kind: 'message',
        T: DataStream_Header,
        oneof: 'value',
      },
      {
        no: 8,
        name: 'stream_chunk',
        kind: 'message',
        T: DataStream_Chunk,
        oneof: 'value',
      },
      {
        no: 9,
        name: 'stream_trailer',
        kind: 'message',
        T: DataStream_Trailer,
        oneof: 'value',
      },
    ]
  );
  const ActiveSpeakerUpdate = /* @__PURE__ */ proto3.makeMessageType(
    'livekit.ActiveSpeakerUpdate',
    () => [
      {
        no: 1,
        name: 'speakers',
        kind: 'message',
        T: SpeakerInfo,
        repeated: true,
      },
    ]
  );
  const SpeakerInfo = /* @__PURE__ */ proto3.makeMessageType('livekit.SpeakerInfo', () => [
    {
      no: 1,
      name: 'sid',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'level',
      kind: 'scalar',
      T: 2,
      /* ScalarType.FLOAT */
    },
    {
      no: 3,
      name: 'active',
      kind: 'scalar',
      T: 8,
      /* ScalarType.BOOL */
    },
  ]);
  const UserPacket = /* @__PURE__ */ proto3.makeMessageType('livekit.UserPacket', () => [
    {
      no: 1,
      name: 'participant_sid',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 5,
      name: 'participant_identity',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'payload',
      kind: 'scalar',
      T: 12,
      /* ScalarType.BYTES */
    },
    {
      no: 3,
      name: 'destination_sids',
      kind: 'scalar',
      T: 9,
      repeated: true,
    },
    {
      no: 6,
      name: 'destination_identities',
      kind: 'scalar',
      T: 9,
      repeated: true,
    },
    {
      no: 4,
      name: 'topic',
      kind: 'scalar',
      T: 9,
      opt: true,
    },
    {
      no: 8,
      name: 'id',
      kind: 'scalar',
      T: 9,
      opt: true,
    },
    {
      no: 9,
      name: 'start_time',
      kind: 'scalar',
      T: 4,
      opt: true,
    },
    {
      no: 10,
      name: 'end_time',
      kind: 'scalar',
      T: 4,
      opt: true,
    },
    {
      no: 11,
      name: 'nonce',
      kind: 'scalar',
      T: 12,
      /* ScalarType.BYTES */
    },
  ]);
  const SipDTMF = /* @__PURE__ */ proto3.makeMessageType('livekit.SipDTMF', () => [
    {
      no: 3,
      name: 'code',
      kind: 'scalar',
      T: 13,
      /* ScalarType.UINT32 */
    },
    {
      no: 4,
      name: 'digit',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ]);
  const Transcription = /* @__PURE__ */ proto3.makeMessageType('livekit.Transcription', () => [
    {
      no: 2,
      name: 'transcribed_participant_identity',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: 'track_id',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: 'segments',
      kind: 'message',
      T: TranscriptionSegment,
      repeated: true,
    },
  ]);
  const TranscriptionSegment = /* @__PURE__ */ proto3.makeMessageType(
    'livekit.TranscriptionSegment',
    () => [
      {
        no: 1,
        name: 'id',
        kind: 'scalar',
        T: 9,
        /* ScalarType.STRING */
      },
      {
        no: 2,
        name: 'text',
        kind: 'scalar',
        T: 9,
        /* ScalarType.STRING */
      },
      {
        no: 3,
        name: 'start_time',
        kind: 'scalar',
        T: 4,
        /* ScalarType.UINT64 */
      },
      {
        no: 4,
        name: 'end_time',
        kind: 'scalar',
        T: 4,
        /* ScalarType.UINT64 */
      },
      {
        no: 5,
        name: 'final',
        kind: 'scalar',
        T: 8,
        /* ScalarType.BOOL */
      },
      {
        no: 6,
        name: 'language',
        kind: 'scalar',
        T: 9,
        /* ScalarType.STRING */
      },
    ]
  );
  const ChatMessage = /* @__PURE__ */ proto3.makeMessageType('livekit.ChatMessage', () => [
    {
      no: 1,
      name: 'id',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'timestamp',
      kind: 'scalar',
      T: 3,
      /* ScalarType.INT64 */
    },
    {
      no: 3,
      name: 'edit_timestamp',
      kind: 'scalar',
      T: 3,
      opt: true,
    },
    {
      no: 4,
      name: 'message',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 5,
      name: 'deleted',
      kind: 'scalar',
      T: 8,
      /* ScalarType.BOOL */
    },
    {
      no: 6,
      name: 'generated',
      kind: 'scalar',
      T: 8,
      /* ScalarType.BOOL */
    },
  ]);
  const RpcRequest = /* @__PURE__ */ proto3.makeMessageType('livekit.RpcRequest', () => [
    {
      no: 1,
      name: 'id',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'method',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: 'payload',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: 'response_timeout_ms',
      kind: 'scalar',
      T: 13,
      /* ScalarType.UINT32 */
    },
    {
      no: 5,
      name: 'version',
      kind: 'scalar',
      T: 13,
      /* ScalarType.UINT32 */
    },
  ]);
  const RpcAck = /* @__PURE__ */ proto3.makeMessageType('livekit.RpcAck', () => [
    {
      no: 1,
      name: 'request_id',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ]);
  const RpcResponse = /* @__PURE__ */ proto3.makeMessageType('livekit.RpcResponse', () => [
    {
      no: 1,
      name: 'request_id',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'payload',
      kind: 'scalar',
      T: 9,
      oneof: 'value',
    },
    {
      no: 3,
      name: 'error',
      kind: 'message',
      T: RpcError$1,
      oneof: 'value',
    },
  ]);
  const RpcError$1 = /* @__PURE__ */ proto3.makeMessageType('livekit.RpcError', () => [
    {
      no: 1,
      name: 'code',
      kind: 'scalar',
      T: 13,
      /* ScalarType.UINT32 */
    },
    {
      no: 2,
      name: 'message',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: 'data',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ]);
  const ParticipantTracks = /* @__PURE__ */ proto3.makeMessageType(
    'livekit.ParticipantTracks',
    () => [
      {
        no: 1,
        name: 'participant_sid',
        kind: 'scalar',
        T: 9,
        /* ScalarType.STRING */
      },
      {
        no: 2,
        name: 'track_sids',
        kind: 'scalar',
        T: 9,
        repeated: true,
      },
    ]
  );
  const ServerInfo = /* @__PURE__ */ proto3.makeMessageType('livekit.ServerInfo', () => [
    {
      no: 1,
      name: 'edition',
      kind: 'enum',
      T: proto3.getEnumType(ServerInfo_Edition),
    },
    {
      no: 2,
      name: 'version',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: 'protocol',
      kind: 'scalar',
      T: 5,
      /* ScalarType.INT32 */
    },
    {
      no: 4,
      name: 'region',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 5,
      name: 'node_id',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 6,
      name: 'debug_info',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 7,
      name: 'agent_protocol',
      kind: 'scalar',
      T: 5,
      /* ScalarType.INT32 */
    },
  ]);
  const ServerInfo_Edition = /* @__PURE__ */ proto3.makeEnum('livekit.ServerInfo.Edition', [
    {
      no: 0,
      name: 'Standard',
    },
    {
      no: 1,
      name: 'Cloud',
    },
  ]);
  const ClientInfo = /* @__PURE__ */ proto3.makeMessageType('livekit.ClientInfo', () => [
    {
      no: 1,
      name: 'sdk',
      kind: 'enum',
      T: proto3.getEnumType(ClientInfo_SDK),
    },
    {
      no: 2,
      name: 'version',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: 'protocol',
      kind: 'scalar',
      T: 5,
      /* ScalarType.INT32 */
    },
    {
      no: 4,
      name: 'os',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 5,
      name: 'os_version',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 6,
      name: 'device_model',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 7,
      name: 'browser',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 8,
      name: 'browser_version',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 9,
      name: 'address',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 10,
      name: 'network',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 11,
      name: 'other_sdks',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ]);
  const ClientInfo_SDK = /* @__PURE__ */ proto3.makeEnum('livekit.ClientInfo.SDK', [
    {
      no: 0,
      name: 'UNKNOWN',
    },
    {
      no: 1,
      name: 'JS',
    },
    {
      no: 2,
      name: 'SWIFT',
    },
    {
      no: 3,
      name: 'ANDROID',
    },
    {
      no: 4,
      name: 'FLUTTER',
    },
    {
      no: 5,
      name: 'GO',
    },
    {
      no: 6,
      name: 'UNITY',
    },
    {
      no: 7,
      name: 'REACT_NATIVE',
    },
    {
      no: 8,
      name: 'RUST',
    },
    {
      no: 9,
      name: 'PYTHON',
    },
    {
      no: 10,
      name: 'CPP',
    },
    {
      no: 11,
      name: 'UNITY_WEB',
    },
    {
      no: 12,
      name: 'NODE',
    },
    {
      no: 13,
      name: 'UNREAL',
    },
    {
      no: 14,
      name: 'ESP32',
    },
  ]);
  const ClientConfiguration = /* @__PURE__ */ proto3.makeMessageType(
    'livekit.ClientConfiguration',
    () => [
      {
        no: 1,
        name: 'video',
        kind: 'message',
        T: VideoConfiguration,
      },
      {
        no: 2,
        name: 'screen',
        kind: 'message',
        T: VideoConfiguration,
      },
      {
        no: 3,
        name: 'resume_connection',
        kind: 'enum',
        T: proto3.getEnumType(ClientConfigSetting),
      },
      {
        no: 4,
        name: 'disabled_codecs',
        kind: 'message',
        T: DisabledCodecs,
      },
      {
        no: 5,
        name: 'force_relay',
        kind: 'enum',
        T: proto3.getEnumType(ClientConfigSetting),
      },
    ]
  );
  const VideoConfiguration = /* @__PURE__ */ proto3.makeMessageType(
    'livekit.VideoConfiguration',
    () => [
      {
        no: 1,
        name: 'hardware_encoder',
        kind: 'enum',
        T: proto3.getEnumType(ClientConfigSetting),
      },
    ]
  );
  const DisabledCodecs = /* @__PURE__ */ proto3.makeMessageType('livekit.DisabledCodecs', () => [
    {
      no: 1,
      name: 'codecs',
      kind: 'message',
      T: Codec,
      repeated: true,
    },
    {
      no: 2,
      name: 'publish',
      kind: 'message',
      T: Codec,
      repeated: true,
    },
  ]);
  const TimedVersion = /* @__PURE__ */ proto3.makeMessageType('livekit.TimedVersion', () => [
    {
      no: 1,
      name: 'unix_micro',
      kind: 'scalar',
      T: 3,
      /* ScalarType.INT64 */
    },
    {
      no: 2,
      name: 'ticks',
      kind: 'scalar',
      T: 5,
      /* ScalarType.INT32 */
    },
  ]);
  const DataStream_OperationType = /* @__PURE__ */ proto3.makeEnum(
    'livekit.DataStream.OperationType',
    [
      {
        no: 0,
        name: 'CREATE',
      },
      {
        no: 1,
        name: 'UPDATE',
      },
      {
        no: 2,
        name: 'DELETE',
      },
      {
        no: 3,
        name: 'REACTION',
      },
    ]
  );
  const DataStream_TextHeader = /* @__PURE__ */ proto3.makeMessageType(
    'livekit.DataStream.TextHeader',
    () => [
      {
        no: 1,
        name: 'operation_type',
        kind: 'enum',
        T: proto3.getEnumType(DataStream_OperationType),
      },
      {
        no: 2,
        name: 'version',
        kind: 'scalar',
        T: 5,
        /* ScalarType.INT32 */
      },
      {
        no: 3,
        name: 'reply_to_stream_id',
        kind: 'scalar',
        T: 9,
        /* ScalarType.STRING */
      },
      {
        no: 4,
        name: 'attached_stream_ids',
        kind: 'scalar',
        T: 9,
        repeated: true,
      },
      {
        no: 5,
        name: 'generated',
        kind: 'scalar',
        T: 8,
        /* ScalarType.BOOL */
      },
    ],
    {
      localName: 'DataStream_TextHeader',
    }
  );
  const DataStream_ByteHeader = /* @__PURE__ */ proto3.makeMessageType(
    'livekit.DataStream.ByteHeader',
    () => [
      {
        no: 1,
        name: 'name',
        kind: 'scalar',
        T: 9,
        /* ScalarType.STRING */
      },
    ],
    {
      localName: 'DataStream_ByteHeader',
    }
  );
  const DataStream_Header = /* @__PURE__ */ proto3.makeMessageType(
    'livekit.DataStream.Header',
    () => [
      {
        no: 1,
        name: 'stream_id',
        kind: 'scalar',
        T: 9,
        /* ScalarType.STRING */
      },
      {
        no: 2,
        name: 'timestamp',
        kind: 'scalar',
        T: 3,
        /* ScalarType.INT64 */
      },
      {
        no: 3,
        name: 'topic',
        kind: 'scalar',
        T: 9,
        /* ScalarType.STRING */
      },
      {
        no: 4,
        name: 'mime_type',
        kind: 'scalar',
        T: 9,
        /* ScalarType.STRING */
      },
      {
        no: 5,
        name: 'total_length',
        kind: 'scalar',
        T: 4,
        opt: true,
      },
      {
        no: 7,
        name: 'encryption_type',
        kind: 'enum',
        T: proto3.getEnumType(Encryption_Type),
      },
      {
        no: 8,
        name: 'attributes',
        kind: 'map',
        K: 9,
        V: {
          kind: 'scalar',
          T: 9,
          /* ScalarType.STRING */
        },
      },
      {
        no: 9,
        name: 'text_header',
        kind: 'message',
        T: DataStream_TextHeader,
        oneof: 'content_header',
      },
      {
        no: 10,
        name: 'byte_header',
        kind: 'message',
        T: DataStream_ByteHeader,
        oneof: 'content_header',
      },
    ],
    {
      localName: 'DataStream_Header',
    }
  );
  const DataStream_Chunk = /* @__PURE__ */ proto3.makeMessageType(
    'livekit.DataStream.Chunk',
    () => [
      {
        no: 1,
        name: 'stream_id',
        kind: 'scalar',
        T: 9,
        /* ScalarType.STRING */
      },
      {
        no: 2,
        name: 'chunk_index',
        kind: 'scalar',
        T: 4,
        /* ScalarType.UINT64 */
      },
      {
        no: 3,
        name: 'content',
        kind: 'scalar',
        T: 12,
        /* ScalarType.BYTES */
      },
      {
        no: 4,
        name: 'version',
        kind: 'scalar',
        T: 5,
        /* ScalarType.INT32 */
      },
      {
        no: 5,
        name: 'iv',
        kind: 'scalar',
        T: 12,
        opt: true,
      },
    ],
    {
      localName: 'DataStream_Chunk',
    }
  );
  const DataStream_Trailer = /* @__PURE__ */ proto3.makeMessageType(
    'livekit.DataStream.Trailer',
    () => [
      {
        no: 1,
        name: 'stream_id',
        kind: 'scalar',
        T: 9,
        /* ScalarType.STRING */
      },
      {
        no: 2,
        name: 'reason',
        kind: 'scalar',
        T: 9,
        /* ScalarType.STRING */
      },
      {
        no: 3,
        name: 'attributes',
        kind: 'map',
        K: 9,
        V: {
          kind: 'scalar',
          T: 9,
          /* ScalarType.STRING */
        },
      },
    ],
    {
      localName: 'DataStream_Trailer',
    }
  );
  const WebhookConfig = /* @__PURE__ */ proto3.makeMessageType('livekit.WebhookConfig', () => [
    {
      no: 1,
      name: 'url',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'signing_key',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ]);
  const SubscribedAudioCodec = /* @__PURE__ */ proto3.makeMessageType(
    'livekit.SubscribedAudioCodec',
    () => [
      {
        no: 1,
        name: 'codec',
        kind: 'scalar',
        T: 9,
        /* ScalarType.STRING */
      },
      {
        no: 2,
        name: 'enabled',
        kind: 'scalar',
        T: 8,
        /* ScalarType.BOOL */
      },
    ]
  );
  const RoomAgentDispatch = /* @__PURE__ */ proto3.makeMessageType(
    'livekit.RoomAgentDispatch',
    () => [
      {
        no: 1,
        name: 'agent_name',
        kind: 'scalar',
        T: 9,
        /* ScalarType.STRING */
      },
      {
        no: 2,
        name: 'metadata',
        kind: 'scalar',
        T: 9,
        /* ScalarType.STRING */
      },
    ]
  );
  const EncodedFileType = /* @__PURE__ */ proto3.makeEnum('livekit.EncodedFileType', [
    {
      no: 0,
      name: 'DEFAULT_FILETYPE',
    },
    {
      no: 1,
      name: 'MP4',
    },
    {
      no: 2,
      name: 'OGG',
    },
    {
      no: 3,
      name: 'MP3',
    },
  ]);
  const SegmentedFileProtocol = /* @__PURE__ */ proto3.makeEnum('livekit.SegmentedFileProtocol', [
    {
      no: 0,
      name: 'DEFAULT_SEGMENTED_FILE_PROTOCOL',
    },
    {
      no: 1,
      name: 'HLS_PROTOCOL',
    },
  ]);
  const SegmentedFileSuffix = /* @__PURE__ */ proto3.makeEnum('livekit.SegmentedFileSuffix', [
    {
      no: 0,
      name: 'INDEX',
    },
    {
      no: 1,
      name: 'TIMESTAMP',
    },
  ]);
  const ImageFileSuffix = /* @__PURE__ */ proto3.makeEnum('livekit.ImageFileSuffix', [
    {
      no: 0,
      name: 'IMAGE_SUFFIX_INDEX',
    },
    {
      no: 1,
      name: 'IMAGE_SUFFIX_TIMESTAMP',
    },
    {
      no: 2,
      name: 'IMAGE_SUFFIX_NONE_OVERWRITE',
    },
  ]);
  const StreamProtocol = /* @__PURE__ */ proto3.makeEnum('livekit.StreamProtocol', [
    {
      no: 0,
      name: 'DEFAULT_PROTOCOL',
    },
    {
      no: 1,
      name: 'RTMP',
    },
    {
      no: 2,
      name: 'SRT',
    },
  ]);
  const AudioMixing = /* @__PURE__ */ proto3.makeEnum('livekit.AudioMixing', [
    {
      no: 0,
      name: 'DEFAULT_MIXING',
    },
    {
      no: 1,
      name: 'DUAL_CHANNEL_AGENT',
    },
    {
      no: 2,
      name: 'DUAL_CHANNEL_ALTERNATE',
    },
  ]);
  const EncodingOptionsPreset = /* @__PURE__ */ proto3.makeEnum('livekit.EncodingOptionsPreset', [
    {
      no: 0,
      name: 'H264_720P_30',
    },
    {
      no: 1,
      name: 'H264_720P_60',
    },
    {
      no: 2,
      name: 'H264_1080P_30',
    },
    {
      no: 3,
      name: 'H264_1080P_60',
    },
    {
      no: 4,
      name: 'PORTRAIT_H264_720P_30',
    },
    {
      no: 5,
      name: 'PORTRAIT_H264_720P_60',
    },
    {
      no: 6,
      name: 'PORTRAIT_H264_1080P_30',
    },
    {
      no: 7,
      name: 'PORTRAIT_H264_1080P_60',
    },
  ]);
  const RoomCompositeEgressRequest = /* @__PURE__ */ proto3.makeMessageType(
    'livekit.RoomCompositeEgressRequest',
    () => [
      {
        no: 1,
        name: 'room_name',
        kind: 'scalar',
        T: 9,
        /* ScalarType.STRING */
      },
      {
        no: 2,
        name: 'layout',
        kind: 'scalar',
        T: 9,
        /* ScalarType.STRING */
      },
      {
        no: 3,
        name: 'audio_only',
        kind: 'scalar',
        T: 8,
        /* ScalarType.BOOL */
      },
      {
        no: 15,
        name: 'audio_mixing',
        kind: 'enum',
        T: proto3.getEnumType(AudioMixing),
      },
      {
        no: 4,
        name: 'video_only',
        kind: 'scalar',
        T: 8,
        /* ScalarType.BOOL */
      },
      {
        no: 5,
        name: 'custom_base_url',
        kind: 'scalar',
        T: 9,
        /* ScalarType.STRING */
      },
      {
        no: 6,
        name: 'file',
        kind: 'message',
        T: EncodedFileOutput,
        oneof: 'output',
      },
      {
        no: 7,
        name: 'stream',
        kind: 'message',
        T: StreamOutput,
        oneof: 'output',
      },
      {
        no: 10,
        name: 'segments',
        kind: 'message',
        T: SegmentedFileOutput,
        oneof: 'output',
      },
      {
        no: 8,
        name: 'preset',
        kind: 'enum',
        T: proto3.getEnumType(EncodingOptionsPreset),
        oneof: 'options',
      },
      {
        no: 9,
        name: 'advanced',
        kind: 'message',
        T: EncodingOptions,
        oneof: 'options',
      },
      {
        no: 11,
        name: 'file_outputs',
        kind: 'message',
        T: EncodedFileOutput,
        repeated: true,
      },
      {
        no: 12,
        name: 'stream_outputs',
        kind: 'message',
        T: StreamOutput,
        repeated: true,
      },
      {
        no: 13,
        name: 'segment_outputs',
        kind: 'message',
        T: SegmentedFileOutput,
        repeated: true,
      },
      {
        no: 14,
        name: 'image_outputs',
        kind: 'message',
        T: ImageOutput,
        repeated: true,
      },
      {
        no: 16,
        name: 'webhooks',
        kind: 'message',
        T: WebhookConfig,
        repeated: true,
      },
    ]
  );
  const EncodedFileOutput = /* @__PURE__ */ proto3.makeMessageType(
    'livekit.EncodedFileOutput',
    () => [
      {
        no: 1,
        name: 'file_type',
        kind: 'enum',
        T: proto3.getEnumType(EncodedFileType),
      },
      {
        no: 2,
        name: 'filepath',
        kind: 'scalar',
        T: 9,
        /* ScalarType.STRING */
      },
      {
        no: 6,
        name: 'disable_manifest',
        kind: 'scalar',
        T: 8,
        /* ScalarType.BOOL */
      },
      {
        no: 3,
        name: 's3',
        kind: 'message',
        T: S3Upload,
        oneof: 'output',
      },
      {
        no: 4,
        name: 'gcp',
        kind: 'message',
        T: GCPUpload,
        oneof: 'output',
      },
      {
        no: 5,
        name: 'azure',
        kind: 'message',
        T: AzureBlobUpload,
        oneof: 'output',
      },
      {
        no: 7,
        name: 'aliOSS',
        kind: 'message',
        T: AliOSSUpload,
        oneof: 'output',
      },
    ]
  );
  const SegmentedFileOutput = /* @__PURE__ */ proto3.makeMessageType(
    'livekit.SegmentedFileOutput',
    () => [
      {
        no: 1,
        name: 'protocol',
        kind: 'enum',
        T: proto3.getEnumType(SegmentedFileProtocol),
      },
      {
        no: 2,
        name: 'filename_prefix',
        kind: 'scalar',
        T: 9,
        /* ScalarType.STRING */
      },
      {
        no: 3,
        name: 'playlist_name',
        kind: 'scalar',
        T: 9,
        /* ScalarType.STRING */
      },
      {
        no: 11,
        name: 'live_playlist_name',
        kind: 'scalar',
        T: 9,
        /* ScalarType.STRING */
      },
      {
        no: 4,
        name: 'segment_duration',
        kind: 'scalar',
        T: 13,
        /* ScalarType.UINT32 */
      },
      {
        no: 10,
        name: 'filename_suffix',
        kind: 'enum',
        T: proto3.getEnumType(SegmentedFileSuffix),
      },
      {
        no: 8,
        name: 'disable_manifest',
        kind: 'scalar',
        T: 8,
        /* ScalarType.BOOL */
      },
      {
        no: 5,
        name: 's3',
        kind: 'message',
        T: S3Upload,
        oneof: 'output',
      },
      {
        no: 6,
        name: 'gcp',
        kind: 'message',
        T: GCPUpload,
        oneof: 'output',
      },
      {
        no: 7,
        name: 'azure',
        kind: 'message',
        T: AzureBlobUpload,
        oneof: 'output',
      },
      {
        no: 9,
        name: 'aliOSS',
        kind: 'message',
        T: AliOSSUpload,
        oneof: 'output',
      },
    ]
  );
  const ImageOutput = /* @__PURE__ */ proto3.makeMessageType('livekit.ImageOutput', () => [
    {
      no: 1,
      name: 'capture_interval',
      kind: 'scalar',
      T: 13,
      /* ScalarType.UINT32 */
    },
    {
      no: 2,
      name: 'width',
      kind: 'scalar',
      T: 5,
      /* ScalarType.INT32 */
    },
    {
      no: 3,
      name: 'height',
      kind: 'scalar',
      T: 5,
      /* ScalarType.INT32 */
    },
    {
      no: 4,
      name: 'filename_prefix',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 5,
      name: 'filename_suffix',
      kind: 'enum',
      T: proto3.getEnumType(ImageFileSuffix),
    },
    {
      no: 6,
      name: 'image_codec',
      kind: 'enum',
      T: proto3.getEnumType(ImageCodec),
    },
    {
      no: 7,
      name: 'disable_manifest',
      kind: 'scalar',
      T: 8,
      /* ScalarType.BOOL */
    },
    {
      no: 8,
      name: 's3',
      kind: 'message',
      T: S3Upload,
      oneof: 'output',
    },
    {
      no: 9,
      name: 'gcp',
      kind: 'message',
      T: GCPUpload,
      oneof: 'output',
    },
    {
      no: 10,
      name: 'azure',
      kind: 'message',
      T: AzureBlobUpload,
      oneof: 'output',
    },
    {
      no: 11,
      name: 'aliOSS',
      kind: 'message',
      T: AliOSSUpload,
      oneof: 'output',
    },
  ]);
  const S3Upload = /* @__PURE__ */ proto3.makeMessageType('livekit.S3Upload', () => [
    {
      no: 1,
      name: 'access_key',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'secret',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 11,
      name: 'session_token',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 12,
      name: 'assume_role_arn',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 13,
      name: 'assume_role_external_id',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: 'region',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: 'endpoint',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 5,
      name: 'bucket',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 6,
      name: 'force_path_style',
      kind: 'scalar',
      T: 8,
      /* ScalarType.BOOL */
    },
    {
      no: 7,
      name: 'metadata',
      kind: 'map',
      K: 9,
      V: {
        kind: 'scalar',
        T: 9,
        /* ScalarType.STRING */
      },
    },
    {
      no: 8,
      name: 'tagging',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 9,
      name: 'content_disposition',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 10,
      name: 'proxy',
      kind: 'message',
      T: ProxyConfig,
    },
  ]);
  const GCPUpload = /* @__PURE__ */ proto3.makeMessageType('livekit.GCPUpload', () => [
    {
      no: 1,
      name: 'credentials',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'bucket',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: 'proxy',
      kind: 'message',
      T: ProxyConfig,
    },
  ]);
  const AzureBlobUpload = /* @__PURE__ */ proto3.makeMessageType('livekit.AzureBlobUpload', () => [
    {
      no: 1,
      name: 'account_name',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'account_key',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: 'container_name',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ]);
  const AliOSSUpload = /* @__PURE__ */ proto3.makeMessageType('livekit.AliOSSUpload', () => [
    {
      no: 1,
      name: 'access_key',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'secret',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: 'region',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: 'endpoint',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 5,
      name: 'bucket',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ]);
  const ProxyConfig = /* @__PURE__ */ proto3.makeMessageType('livekit.ProxyConfig', () => [
    {
      no: 1,
      name: 'url',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'username',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: 'password',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ]);
  const StreamOutput = /* @__PURE__ */ proto3.makeMessageType('livekit.StreamOutput', () => [
    {
      no: 1,
      name: 'protocol',
      kind: 'enum',
      T: proto3.getEnumType(StreamProtocol),
    },
    {
      no: 2,
      name: 'urls',
      kind: 'scalar',
      T: 9,
      repeated: true,
    },
  ]);
  const EncodingOptions = /* @__PURE__ */ proto3.makeMessageType('livekit.EncodingOptions', () => [
    {
      no: 1,
      name: 'width',
      kind: 'scalar',
      T: 5,
      /* ScalarType.INT32 */
    },
    {
      no: 2,
      name: 'height',
      kind: 'scalar',
      T: 5,
      /* ScalarType.INT32 */
    },
    {
      no: 3,
      name: 'depth',
      kind: 'scalar',
      T: 5,
      /* ScalarType.INT32 */
    },
    {
      no: 4,
      name: 'framerate',
      kind: 'scalar',
      T: 5,
      /* ScalarType.INT32 */
    },
    {
      no: 5,
      name: 'audio_codec',
      kind: 'enum',
      T: proto3.getEnumType(AudioCodec),
    },
    {
      no: 6,
      name: 'audio_bitrate',
      kind: 'scalar',
      T: 5,
      /* ScalarType.INT32 */
    },
    {
      no: 11,
      name: 'audio_quality',
      kind: 'scalar',
      T: 5,
      /* ScalarType.INT32 */
    },
    {
      no: 7,
      name: 'audio_frequency',
      kind: 'scalar',
      T: 5,
      /* ScalarType.INT32 */
    },
    {
      no: 8,
      name: 'video_codec',
      kind: 'enum',
      T: proto3.getEnumType(VideoCodec),
    },
    {
      no: 9,
      name: 'video_bitrate',
      kind: 'scalar',
      T: 5,
      /* ScalarType.INT32 */
    },
    {
      no: 12,
      name: 'video_quality',
      kind: 'scalar',
      T: 5,
      /* ScalarType.INT32 */
    },
    {
      no: 10,
      name: 'key_frame_interval',
      kind: 'scalar',
      T: 1,
      /* ScalarType.DOUBLE */
    },
  ]);
  const AutoParticipantEgress = /* @__PURE__ */ proto3.makeMessageType(
    'livekit.AutoParticipantEgress',
    () => [
      {
        no: 1,
        name: 'preset',
        kind: 'enum',
        T: proto3.getEnumType(EncodingOptionsPreset),
        oneof: 'options',
      },
      {
        no: 2,
        name: 'advanced',
        kind: 'message',
        T: EncodingOptions,
        oneof: 'options',
      },
      {
        no: 3,
        name: 'file_outputs',
        kind: 'message',
        T: EncodedFileOutput,
        repeated: true,
      },
      {
        no: 4,
        name: 'segment_outputs',
        kind: 'message',
        T: SegmentedFileOutput,
        repeated: true,
      },
    ]
  );
  const AutoTrackEgress = /* @__PURE__ */ proto3.makeMessageType('livekit.AutoTrackEgress', () => [
    {
      no: 1,
      name: 'filepath',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 5,
      name: 'disable_manifest',
      kind: 'scalar',
      T: 8,
      /* ScalarType.BOOL */
    },
    {
      no: 2,
      name: 's3',
      kind: 'message',
      T: S3Upload,
      oneof: 'output',
    },
    {
      no: 3,
      name: 'gcp',
      kind: 'message',
      T: GCPUpload,
      oneof: 'output',
    },
    {
      no: 4,
      name: 'azure',
      kind: 'message',
      T: AzureBlobUpload,
      oneof: 'output',
    },
    {
      no: 6,
      name: 'aliOSS',
      kind: 'message',
      T: AliOSSUpload,
      oneof: 'output',
    },
  ]);
  const RoomEgress = /* @__PURE__ */ proto3.makeMessageType('livekit.RoomEgress', () => [
    {
      no: 1,
      name: 'room',
      kind: 'message',
      T: RoomCompositeEgressRequest,
    },
    {
      no: 3,
      name: 'participant',
      kind: 'message',
      T: AutoParticipantEgress,
    },
    {
      no: 2,
      name: 'tracks',
      kind: 'message',
      T: AutoTrackEgress,
    },
  ]);
  const RoomConfiguration = /* @__PURE__ */ proto3.makeMessageType(
    'livekit.RoomConfiguration',
    () => [
      {
        no: 1,
        name: 'name',
        kind: 'scalar',
        T: 9,
        /* ScalarType.STRING */
      },
      {
        no: 2,
        name: 'empty_timeout',
        kind: 'scalar',
        T: 13,
        /* ScalarType.UINT32 */
      },
      {
        no: 3,
        name: 'departure_timeout',
        kind: 'scalar',
        T: 13,
        /* ScalarType.UINT32 */
      },
      {
        no: 4,
        name: 'max_participants',
        kind: 'scalar',
        T: 13,
        /* ScalarType.UINT32 */
      },
      {
        no: 11,
        name: 'metadata',
        kind: 'scalar',
        T: 9,
        /* ScalarType.STRING */
      },
      {
        no: 5,
        name: 'egress',
        kind: 'message',
        T: RoomEgress,
      },
      {
        no: 7,
        name: 'min_playout_delay',
        kind: 'scalar',
        T: 13,
        /* ScalarType.UINT32 */
      },
      {
        no: 8,
        name: 'max_playout_delay',
        kind: 'scalar',
        T: 13,
        /* ScalarType.UINT32 */
      },
      {
        no: 9,
        name: 'sync_streams',
        kind: 'scalar',
        T: 8,
        /* ScalarType.BOOL */
      },
      {
        no: 10,
        name: 'agents',
        kind: 'message',
        T: RoomAgentDispatch,
        repeated: true,
      },
    ]
  );
  const SignalTarget = /* @__PURE__ */ proto3.makeEnum('livekit.SignalTarget', [
    {
      no: 0,
      name: 'PUBLISHER',
    },
    {
      no: 1,
      name: 'SUBSCRIBER',
    },
  ]);
  const StreamState = /* @__PURE__ */ proto3.makeEnum('livekit.StreamState', [
    {
      no: 0,
      name: 'ACTIVE',
    },
    {
      no: 1,
      name: 'PAUSED',
    },
  ]);
  const CandidateProtocol = /* @__PURE__ */ proto3.makeEnum('livekit.CandidateProtocol', [
    {
      no: 0,
      name: 'UDP',
    },
    {
      no: 1,
      name: 'TCP',
    },
    {
      no: 2,
      name: 'TLS',
    },
  ]);
  const SignalRequest = /* @__PURE__ */ proto3.makeMessageType('livekit.SignalRequest', () => [
    {
      no: 1,
      name: 'offer',
      kind: 'message',
      T: SessionDescription,
      oneof: 'message',
    },
    {
      no: 2,
      name: 'answer',
      kind: 'message',
      T: SessionDescription,
      oneof: 'message',
    },
    {
      no: 3,
      name: 'trickle',
      kind: 'message',
      T: TrickleRequest,
      oneof: 'message',
    },
    {
      no: 4,
      name: 'add_track',
      kind: 'message',
      T: AddTrackRequest,
      oneof: 'message',
    },
    {
      no: 5,
      name: 'mute',
      kind: 'message',
      T: MuteTrackRequest,
      oneof: 'message',
    },
    {
      no: 6,
      name: 'subscription',
      kind: 'message',
      T: UpdateSubscription,
      oneof: 'message',
    },
    {
      no: 7,
      name: 'track_setting',
      kind: 'message',
      T: UpdateTrackSettings,
      oneof: 'message',
    },
    {
      no: 8,
      name: 'leave',
      kind: 'message',
      T: LeaveRequest,
      oneof: 'message',
    },
    {
      no: 10,
      name: 'update_layers',
      kind: 'message',
      T: UpdateVideoLayers,
      oneof: 'message',
    },
    {
      no: 11,
      name: 'subscription_permission',
      kind: 'message',
      T: SubscriptionPermission,
      oneof: 'message',
    },
    {
      no: 12,
      name: 'sync_state',
      kind: 'message',
      T: SyncState,
      oneof: 'message',
    },
    {
      no: 13,
      name: 'simulate',
      kind: 'message',
      T: SimulateScenario,
      oneof: 'message',
    },
    {
      no: 14,
      name: 'ping',
      kind: 'scalar',
      T: 3,
      oneof: 'message',
    },
    {
      no: 15,
      name: 'update_metadata',
      kind: 'message',
      T: UpdateParticipantMetadata,
      oneof: 'message',
    },
    {
      no: 16,
      name: 'ping_req',
      kind: 'message',
      T: Ping,
      oneof: 'message',
    },
    {
      no: 17,
      name: 'update_audio_track',
      kind: 'message',
      T: UpdateLocalAudioTrack,
      oneof: 'message',
    },
    {
      no: 18,
      name: 'update_video_track',
      kind: 'message',
      T: UpdateLocalVideoTrack,
      oneof: 'message',
    },
  ]);
  const SignalResponse = /* @__PURE__ */ proto3.makeMessageType('livekit.SignalResponse', () => [
    {
      no: 1,
      name: 'join',
      kind: 'message',
      T: JoinResponse,
      oneof: 'message',
    },
    {
      no: 2,
      name: 'answer',
      kind: 'message',
      T: SessionDescription,
      oneof: 'message',
    },
    {
      no: 3,
      name: 'offer',
      kind: 'message',
      T: SessionDescription,
      oneof: 'message',
    },
    {
      no: 4,
      name: 'trickle',
      kind: 'message',
      T: TrickleRequest,
      oneof: 'message',
    },
    {
      no: 5,
      name: 'update',
      kind: 'message',
      T: ParticipantUpdate,
      oneof: 'message',
    },
    {
      no: 6,
      name: 'track_published',
      kind: 'message',
      T: TrackPublishedResponse,
      oneof: 'message',
    },
    {
      no: 8,
      name: 'leave',
      kind: 'message',
      T: LeaveRequest,
      oneof: 'message',
    },
    {
      no: 9,
      name: 'mute',
      kind: 'message',
      T: MuteTrackRequest,
      oneof: 'message',
    },
    {
      no: 10,
      name: 'speakers_changed',
      kind: 'message',
      T: SpeakersChanged,
      oneof: 'message',
    },
    {
      no: 11,
      name: 'room_update',
      kind: 'message',
      T: RoomUpdate,
      oneof: 'message',
    },
    {
      no: 12,
      name: 'connection_quality',
      kind: 'message',
      T: ConnectionQualityUpdate,
      oneof: 'message',
    },
    {
      no: 13,
      name: 'stream_state_update',
      kind: 'message',
      T: StreamStateUpdate,
      oneof: 'message',
    },
    {
      no: 14,
      name: 'subscribed_quality_update',
      kind: 'message',
      T: SubscribedQualityUpdate,
      oneof: 'message',
    },
    {
      no: 15,
      name: 'subscription_permission_update',
      kind: 'message',
      T: SubscriptionPermissionUpdate,
      oneof: 'message',
    },
    {
      no: 16,
      name: 'refresh_token',
      kind: 'scalar',
      T: 9,
      oneof: 'message',
    },
    {
      no: 17,
      name: 'track_unpublished',
      kind: 'message',
      T: TrackUnpublishedResponse,
      oneof: 'message',
    },
    {
      no: 18,
      name: 'pong',
      kind: 'scalar',
      T: 3,
      oneof: 'message',
    },
    {
      no: 19,
      name: 'reconnect',
      kind: 'message',
      T: ReconnectResponse,
      oneof: 'message',
    },
    {
      no: 20,
      name: 'pong_resp',
      kind: 'message',
      T: Pong,
      oneof: 'message',
    },
    {
      no: 21,
      name: 'subscription_response',
      kind: 'message',
      T: SubscriptionResponse,
      oneof: 'message',
    },
    {
      no: 22,
      name: 'request_response',
      kind: 'message',
      T: RequestResponse,
      oneof: 'message',
    },
    {
      no: 23,
      name: 'track_subscribed',
      kind: 'message',
      T: TrackSubscribed,
      oneof: 'message',
    },
    {
      no: 24,
      name: 'room_moved',
      kind: 'message',
      T: RoomMovedResponse,
      oneof: 'message',
    },
    {
      no: 25,
      name: 'media_sections_requirement',
      kind: 'message',
      T: MediaSectionsRequirement,
      oneof: 'message',
    },
    {
      no: 26,
      name: 'subscribed_audio_codec_update',
      kind: 'message',
      T: SubscribedAudioCodecUpdate,
      oneof: 'message',
    },
  ]);
  const SimulcastCodec = /* @__PURE__ */ proto3.makeMessageType('livekit.SimulcastCodec', () => [
    {
      no: 1,
      name: 'codec',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'cid',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: 'layers',
      kind: 'message',
      T: VideoLayer,
      repeated: true,
    },
    {
      no: 5,
      name: 'video_layer_mode',
      kind: 'enum',
      T: proto3.getEnumType(VideoLayer_Mode),
    },
  ]);
  const AddTrackRequest = /* @__PURE__ */ proto3.makeMessageType('livekit.AddTrackRequest', () => [
    {
      no: 1,
      name: 'cid',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'name',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: 'type',
      kind: 'enum',
      T: proto3.getEnumType(TrackType),
    },
    {
      no: 4,
      name: 'width',
      kind: 'scalar',
      T: 13,
      /* ScalarType.UINT32 */
    },
    {
      no: 5,
      name: 'height',
      kind: 'scalar',
      T: 13,
      /* ScalarType.UINT32 */
    },
    {
      no: 6,
      name: 'muted',
      kind: 'scalar',
      T: 8,
      /* ScalarType.BOOL */
    },
    {
      no: 7,
      name: 'disable_dtx',
      kind: 'scalar',
      T: 8,
      /* ScalarType.BOOL */
    },
    {
      no: 8,
      name: 'source',
      kind: 'enum',
      T: proto3.getEnumType(TrackSource),
    },
    {
      no: 9,
      name: 'layers',
      kind: 'message',
      T: VideoLayer,
      repeated: true,
    },
    {
      no: 10,
      name: 'simulcast_codecs',
      kind: 'message',
      T: SimulcastCodec,
      repeated: true,
    },
    {
      no: 11,
      name: 'sid',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 12,
      name: 'stereo',
      kind: 'scalar',
      T: 8,
      /* ScalarType.BOOL */
    },
    {
      no: 13,
      name: 'disable_red',
      kind: 'scalar',
      T: 8,
      /* ScalarType.BOOL */
    },
    {
      no: 14,
      name: 'encryption',
      kind: 'enum',
      T: proto3.getEnumType(Encryption_Type),
    },
    {
      no: 15,
      name: 'stream',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 16,
      name: 'backup_codec_policy',
      kind: 'enum',
      T: proto3.getEnumType(BackupCodecPolicy$1),
    },
    {
      no: 17,
      name: 'audio_features',
      kind: 'enum',
      T: proto3.getEnumType(AudioTrackFeature),
      repeated: true,
    },
  ]);
  const TrickleRequest = /* @__PURE__ */ proto3.makeMessageType('livekit.TrickleRequest', () => [
    {
      no: 1,
      name: 'candidateInit',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'target',
      kind: 'enum',
      T: proto3.getEnumType(SignalTarget),
    },
    {
      no: 3,
      name: 'final',
      kind: 'scalar',
      T: 8,
      /* ScalarType.BOOL */
    },
  ]);
  const MuteTrackRequest = /* @__PURE__ */ proto3.makeMessageType(
    'livekit.MuteTrackRequest',
    () => [
      {
        no: 1,
        name: 'sid',
        kind: 'scalar',
        T: 9,
        /* ScalarType.STRING */
      },
      {
        no: 2,
        name: 'muted',
        kind: 'scalar',
        T: 8,
        /* ScalarType.BOOL */
      },
    ]
  );
  const JoinResponse = /* @__PURE__ */ proto3.makeMessageType('livekit.JoinResponse', () => [
    {
      no: 1,
      name: 'room',
      kind: 'message',
      T: Room$1,
    },
    {
      no: 2,
      name: 'participant',
      kind: 'message',
      T: ParticipantInfo,
    },
    {
      no: 3,
      name: 'other_participants',
      kind: 'message',
      T: ParticipantInfo,
      repeated: true,
    },
    {
      no: 4,
      name: 'server_version',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 5,
      name: 'ice_servers',
      kind: 'message',
      T: ICEServer,
      repeated: true,
    },
    {
      no: 6,
      name: 'subscriber_primary',
      kind: 'scalar',
      T: 8,
      /* ScalarType.BOOL */
    },
    {
      no: 7,
      name: 'alternative_url',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 8,
      name: 'client_configuration',
      kind: 'message',
      T: ClientConfiguration,
    },
    {
      no: 9,
      name: 'server_region',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 10,
      name: 'ping_timeout',
      kind: 'scalar',
      T: 5,
      /* ScalarType.INT32 */
    },
    {
      no: 11,
      name: 'ping_interval',
      kind: 'scalar',
      T: 5,
      /* ScalarType.INT32 */
    },
    {
      no: 12,
      name: 'server_info',
      kind: 'message',
      T: ServerInfo,
    },
    {
      no: 13,
      name: 'sif_trailer',
      kind: 'scalar',
      T: 12,
      /* ScalarType.BYTES */
    },
    {
      no: 14,
      name: 'enabled_publish_codecs',
      kind: 'message',
      T: Codec,
      repeated: true,
    },
    {
      no: 15,
      name: 'fast_publish',
      kind: 'scalar',
      T: 8,
      /* ScalarType.BOOL */
    },
  ]);
  const ReconnectResponse = /* @__PURE__ */ proto3.makeMessageType(
    'livekit.ReconnectResponse',
    () => [
      {
        no: 1,
        name: 'ice_servers',
        kind: 'message',
        T: ICEServer,
        repeated: true,
      },
      {
        no: 2,
        name: 'client_configuration',
        kind: 'message',
        T: ClientConfiguration,
      },
      {
        no: 3,
        name: 'server_info',
        kind: 'message',
        T: ServerInfo,
      },
      {
        no: 4,
        name: 'last_message_seq',
        kind: 'scalar',
        T: 13,
        /* ScalarType.UINT32 */
      },
    ]
  );
  const TrackPublishedResponse = /* @__PURE__ */ proto3.makeMessageType(
    'livekit.TrackPublishedResponse',
    () => [
      {
        no: 1,
        name: 'cid',
        kind: 'scalar',
        T: 9,
        /* ScalarType.STRING */
      },
      {
        no: 2,
        name: 'track',
        kind: 'message',
        T: TrackInfo,
      },
    ]
  );
  const TrackUnpublishedResponse = /* @__PURE__ */ proto3.makeMessageType(
    'livekit.TrackUnpublishedResponse',
    () => [
      {
        no: 1,
        name: 'track_sid',
        kind: 'scalar',
        T: 9,
        /* ScalarType.STRING */
      },
    ]
  );
  const SessionDescription = /* @__PURE__ */ proto3.makeMessageType(
    'livekit.SessionDescription',
    () => [
      {
        no: 1,
        name: 'type',
        kind: 'scalar',
        T: 9,
        /* ScalarType.STRING */
      },
      {
        no: 2,
        name: 'sdp',
        kind: 'scalar',
        T: 9,
        /* ScalarType.STRING */
      },
      {
        no: 3,
        name: 'id',
        kind: 'scalar',
        T: 13,
        /* ScalarType.UINT32 */
      },
    ]
  );
  const ParticipantUpdate = /* @__PURE__ */ proto3.makeMessageType(
    'livekit.ParticipantUpdate',
    () => [
      {
        no: 1,
        name: 'participants',
        kind: 'message',
        T: ParticipantInfo,
        repeated: true,
      },
    ]
  );
  const UpdateSubscription = /* @__PURE__ */ proto3.makeMessageType(
    'livekit.UpdateSubscription',
    () => [
      {
        no: 1,
        name: 'track_sids',
        kind: 'scalar',
        T: 9,
        repeated: true,
      },
      {
        no: 2,
        name: 'subscribe',
        kind: 'scalar',
        T: 8,
        /* ScalarType.BOOL */
      },
      {
        no: 3,
        name: 'participant_tracks',
        kind: 'message',
        T: ParticipantTracks,
        repeated: true,
      },
    ]
  );
  const UpdateTrackSettings = /* @__PURE__ */ proto3.makeMessageType(
    'livekit.UpdateTrackSettings',
    () => [
      {
        no: 1,
        name: 'track_sids',
        kind: 'scalar',
        T: 9,
        repeated: true,
      },
      {
        no: 3,
        name: 'disabled',
        kind: 'scalar',
        T: 8,
        /* ScalarType.BOOL */
      },
      {
        no: 4,
        name: 'quality',
        kind: 'enum',
        T: proto3.getEnumType(VideoQuality$1),
      },
      {
        no: 5,
        name: 'width',
        kind: 'scalar',
        T: 13,
        /* ScalarType.UINT32 */
      },
      {
        no: 6,
        name: 'height',
        kind: 'scalar',
        T: 13,
        /* ScalarType.UINT32 */
      },
      {
        no: 7,
        name: 'fps',
        kind: 'scalar',
        T: 13,
        /* ScalarType.UINT32 */
      },
      {
        no: 8,
        name: 'priority',
        kind: 'scalar',
        T: 13,
        /* ScalarType.UINT32 */
      },
    ]
  );
  const UpdateLocalAudioTrack = /* @__PURE__ */ proto3.makeMessageType(
    'livekit.UpdateLocalAudioTrack',
    () => [
      {
        no: 1,
        name: 'track_sid',
        kind: 'scalar',
        T: 9,
        /* ScalarType.STRING */
      },
      {
        no: 2,
        name: 'features',
        kind: 'enum',
        T: proto3.getEnumType(AudioTrackFeature),
        repeated: true,
      },
    ]
  );
  const UpdateLocalVideoTrack = /* @__PURE__ */ proto3.makeMessageType(
    'livekit.UpdateLocalVideoTrack',
    () => [
      {
        no: 1,
        name: 'track_sid',
        kind: 'scalar',
        T: 9,
        /* ScalarType.STRING */
      },
      {
        no: 2,
        name: 'width',
        kind: 'scalar',
        T: 13,
        /* ScalarType.UINT32 */
      },
      {
        no: 3,
        name: 'height',
        kind: 'scalar',
        T: 13,
        /* ScalarType.UINT32 */
      },
    ]
  );
  const LeaveRequest = /* @__PURE__ */ proto3.makeMessageType('livekit.LeaveRequest', () => [
    {
      no: 1,
      name: 'can_reconnect',
      kind: 'scalar',
      T: 8,
      /* ScalarType.BOOL */
    },
    {
      no: 2,
      name: 'reason',
      kind: 'enum',
      T: proto3.getEnumType(DisconnectReason),
    },
    {
      no: 3,
      name: 'action',
      kind: 'enum',
      T: proto3.getEnumType(LeaveRequest_Action),
    },
    {
      no: 4,
      name: 'regions',
      kind: 'message',
      T: RegionSettings,
    },
  ]);
  const LeaveRequest_Action = /* @__PURE__ */ proto3.makeEnum('livekit.LeaveRequest.Action', [
    {
      no: 0,
      name: 'DISCONNECT',
    },
    {
      no: 1,
      name: 'RESUME',
    },
    {
      no: 2,
      name: 'RECONNECT',
    },
  ]);
  const UpdateVideoLayers = /* @__PURE__ */ proto3.makeMessageType(
    'livekit.UpdateVideoLayers',
    () => [
      {
        no: 1,
        name: 'track_sid',
        kind: 'scalar',
        T: 9,
        /* ScalarType.STRING */
      },
      {
        no: 2,
        name: 'layers',
        kind: 'message',
        T: VideoLayer,
        repeated: true,
      },
    ]
  );
  const UpdateParticipantMetadata = /* @__PURE__ */ proto3.makeMessageType(
    'livekit.UpdateParticipantMetadata',
    () => [
      {
        no: 1,
        name: 'metadata',
        kind: 'scalar',
        T: 9,
        /* ScalarType.STRING */
      },
      {
        no: 2,
        name: 'name',
        kind: 'scalar',
        T: 9,
        /* ScalarType.STRING */
      },
      {
        no: 3,
        name: 'attributes',
        kind: 'map',
        K: 9,
        V: {
          kind: 'scalar',
          T: 9,
          /* ScalarType.STRING */
        },
      },
      {
        no: 4,
        name: 'request_id',
        kind: 'scalar',
        T: 13,
        /* ScalarType.UINT32 */
      },
    ]
  );
  const ICEServer = /* @__PURE__ */ proto3.makeMessageType('livekit.ICEServer', () => [
    {
      no: 1,
      name: 'urls',
      kind: 'scalar',
      T: 9,
      repeated: true,
    },
    {
      no: 2,
      name: 'username',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: 'credential',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ]);
  const SpeakersChanged = /* @__PURE__ */ proto3.makeMessageType('livekit.SpeakersChanged', () => [
    {
      no: 1,
      name: 'speakers',
      kind: 'message',
      T: SpeakerInfo,
      repeated: true,
    },
  ]);
  const RoomUpdate = /* @__PURE__ */ proto3.makeMessageType('livekit.RoomUpdate', () => [
    {
      no: 1,
      name: 'room',
      kind: 'message',
      T: Room$1,
    },
  ]);
  const ConnectionQualityInfo = /* @__PURE__ */ proto3.makeMessageType(
    'livekit.ConnectionQualityInfo',
    () => [
      {
        no: 1,
        name: 'participant_sid',
        kind: 'scalar',
        T: 9,
        /* ScalarType.STRING */
      },
      {
        no: 2,
        name: 'quality',
        kind: 'enum',
        T: proto3.getEnumType(ConnectionQuality$1),
      },
      {
        no: 3,
        name: 'score',
        kind: 'scalar',
        T: 2,
        /* ScalarType.FLOAT */
      },
    ]
  );
  const ConnectionQualityUpdate = /* @__PURE__ */ proto3.makeMessageType(
    'livekit.ConnectionQualityUpdate',
    () => [
      {
        no: 1,
        name: 'updates',
        kind: 'message',
        T: ConnectionQualityInfo,
        repeated: true,
      },
    ]
  );
  const StreamStateInfo = /* @__PURE__ */ proto3.makeMessageType('livekit.StreamStateInfo', () => [
    {
      no: 1,
      name: 'participant_sid',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'track_sid',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: 'state',
      kind: 'enum',
      T: proto3.getEnumType(StreamState),
    },
  ]);
  const StreamStateUpdate = /* @__PURE__ */ proto3.makeMessageType(
    'livekit.StreamStateUpdate',
    () => [
      {
        no: 1,
        name: 'stream_states',
        kind: 'message',
        T: StreamStateInfo,
        repeated: true,
      },
    ]
  );
  const SubscribedQuality = /* @__PURE__ */ proto3.makeMessageType(
    'livekit.SubscribedQuality',
    () => [
      {
        no: 1,
        name: 'quality',
        kind: 'enum',
        T: proto3.getEnumType(VideoQuality$1),
      },
      {
        no: 2,
        name: 'enabled',
        kind: 'scalar',
        T: 8,
        /* ScalarType.BOOL */
      },
    ]
  );
  const SubscribedCodec = /* @__PURE__ */ proto3.makeMessageType('livekit.SubscribedCodec', () => [
    {
      no: 1,
      name: 'codec',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'qualities',
      kind: 'message',
      T: SubscribedQuality,
      repeated: true,
    },
  ]);
  const SubscribedQualityUpdate = /* @__PURE__ */ proto3.makeMessageType(
    'livekit.SubscribedQualityUpdate',
    () => [
      {
        no: 1,
        name: 'track_sid',
        kind: 'scalar',
        T: 9,
        /* ScalarType.STRING */
      },
      {
        no: 2,
        name: 'subscribed_qualities',
        kind: 'message',
        T: SubscribedQuality,
        repeated: true,
      },
      {
        no: 3,
        name: 'subscribed_codecs',
        kind: 'message',
        T: SubscribedCodec,
        repeated: true,
      },
    ]
  );
  const SubscribedAudioCodecUpdate = /* @__PURE__ */ proto3.makeMessageType(
    'livekit.SubscribedAudioCodecUpdate',
    () => [
      {
        no: 1,
        name: 'track_sid',
        kind: 'scalar',
        T: 9,
        /* ScalarType.STRING */
      },
      {
        no: 2,
        name: 'subscribed_audio_codecs',
        kind: 'message',
        T: SubscribedAudioCodec,
        repeated: true,
      },
    ]
  );
  const TrackPermission = /* @__PURE__ */ proto3.makeMessageType('livekit.TrackPermission', () => [
    {
      no: 1,
      name: 'participant_sid',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'all_tracks',
      kind: 'scalar',
      T: 8,
      /* ScalarType.BOOL */
    },
    {
      no: 3,
      name: 'track_sids',
      kind: 'scalar',
      T: 9,
      repeated: true,
    },
    {
      no: 4,
      name: 'participant_identity',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ]);
  const SubscriptionPermission = /* @__PURE__ */ proto3.makeMessageType(
    'livekit.SubscriptionPermission',
    () => [
      {
        no: 1,
        name: 'all_participants',
        kind: 'scalar',
        T: 8,
        /* ScalarType.BOOL */
      },
      {
        no: 2,
        name: 'track_permissions',
        kind: 'message',
        T: TrackPermission,
        repeated: true,
      },
    ]
  );
  const SubscriptionPermissionUpdate = /* @__PURE__ */ proto3.makeMessageType(
    'livekit.SubscriptionPermissionUpdate',
    () => [
      {
        no: 1,
        name: 'participant_sid',
        kind: 'scalar',
        T: 9,
        /* ScalarType.STRING */
      },
      {
        no: 2,
        name: 'track_sid',
        kind: 'scalar',
        T: 9,
        /* ScalarType.STRING */
      },
      {
        no: 3,
        name: 'allowed',
        kind: 'scalar',
        T: 8,
        /* ScalarType.BOOL */
      },
    ]
  );
  const RoomMovedResponse = /* @__PURE__ */ proto3.makeMessageType(
    'livekit.RoomMovedResponse',
    () => [
      {
        no: 1,
        name: 'room',
        kind: 'message',
        T: Room$1,
      },
      {
        no: 2,
        name: 'token',
        kind: 'scalar',
        T: 9,
        /* ScalarType.STRING */
      },
      {
        no: 3,
        name: 'participant',
        kind: 'message',
        T: ParticipantInfo,
      },
      {
        no: 4,
        name: 'other_participants',
        kind: 'message',
        T: ParticipantInfo,
        repeated: true,
      },
    ]
  );
  const SyncState = /* @__PURE__ */ proto3.makeMessageType('livekit.SyncState', () => [
    {
      no: 1,
      name: 'answer',
      kind: 'message',
      T: SessionDescription,
    },
    {
      no: 2,
      name: 'subscription',
      kind: 'message',
      T: UpdateSubscription,
    },
    {
      no: 3,
      name: 'publish_tracks',
      kind: 'message',
      T: TrackPublishedResponse,
      repeated: true,
    },
    {
      no: 4,
      name: 'data_channels',
      kind: 'message',
      T: DataChannelInfo,
      repeated: true,
    },
    {
      no: 5,
      name: 'offer',
      kind: 'message',
      T: SessionDescription,
    },
    {
      no: 6,
      name: 'track_sids_disabled',
      kind: 'scalar',
      T: 9,
      repeated: true,
    },
    {
      no: 7,
      name: 'datachannel_receive_states',
      kind: 'message',
      T: DataChannelReceiveState,
      repeated: true,
    },
  ]);
  const DataChannelReceiveState = /* @__PURE__ */ proto3.makeMessageType(
    'livekit.DataChannelReceiveState',
    () => [
      {
        no: 1,
        name: 'publisher_sid',
        kind: 'scalar',
        T: 9,
        /* ScalarType.STRING */
      },
      {
        no: 2,
        name: 'last_seq',
        kind: 'scalar',
        T: 13,
        /* ScalarType.UINT32 */
      },
    ]
  );
  const DataChannelInfo = /* @__PURE__ */ proto3.makeMessageType('livekit.DataChannelInfo', () => [
    {
      no: 1,
      name: 'label',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'id',
      kind: 'scalar',
      T: 13,
      /* ScalarType.UINT32 */
    },
    {
      no: 3,
      name: 'target',
      kind: 'enum',
      T: proto3.getEnumType(SignalTarget),
    },
  ]);
  const SimulateScenario = /* @__PURE__ */ proto3.makeMessageType(
    'livekit.SimulateScenario',
    () => [
      {
        no: 1,
        name: 'speaker_update',
        kind: 'scalar',
        T: 5,
        oneof: 'scenario',
      },
      {
        no: 2,
        name: 'node_failure',
        kind: 'scalar',
        T: 8,
        oneof: 'scenario',
      },
      {
        no: 3,
        name: 'migration',
        kind: 'scalar',
        T: 8,
        oneof: 'scenario',
      },
      {
        no: 4,
        name: 'server_leave',
        kind: 'scalar',
        T: 8,
        oneof: 'scenario',
      },
      {
        no: 5,
        name: 'switch_candidate_protocol',
        kind: 'enum',
        T: proto3.getEnumType(CandidateProtocol),
        oneof: 'scenario',
      },
      {
        no: 6,
        name: 'subscriber_bandwidth',
        kind: 'scalar',
        T: 3,
        oneof: 'scenario',
      },
      {
        no: 7,
        name: 'disconnect_signal_on_resume',
        kind: 'scalar',
        T: 8,
        oneof: 'scenario',
      },
      {
        no: 8,
        name: 'disconnect_signal_on_resume_no_messages',
        kind: 'scalar',
        T: 8,
        oneof: 'scenario',
      },
      {
        no: 9,
        name: 'leave_request_full_reconnect',
        kind: 'scalar',
        T: 8,
        oneof: 'scenario',
      },
    ]
  );
  const Ping = /* @__PURE__ */ proto3.makeMessageType('livekit.Ping', () => [
    {
      no: 1,
      name: 'timestamp',
      kind: 'scalar',
      T: 3,
      /* ScalarType.INT64 */
    },
    {
      no: 2,
      name: 'rtt',
      kind: 'scalar',
      T: 3,
      /* ScalarType.INT64 */
    },
  ]);
  const Pong = /* @__PURE__ */ proto3.makeMessageType('livekit.Pong', () => [
    {
      no: 1,
      name: 'last_ping_timestamp',
      kind: 'scalar',
      T: 3,
      /* ScalarType.INT64 */
    },
    {
      no: 2,
      name: 'timestamp',
      kind: 'scalar',
      T: 3,
      /* ScalarType.INT64 */
    },
  ]);
  const RegionSettings = /* @__PURE__ */ proto3.makeMessageType('livekit.RegionSettings', () => [
    {
      no: 1,
      name: 'regions',
      kind: 'message',
      T: RegionInfo,
      repeated: true,
    },
  ]);
  const RegionInfo = /* @__PURE__ */ proto3.makeMessageType('livekit.RegionInfo', () => [
    {
      no: 1,
      name: 'region',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: 'url',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: 'distance',
      kind: 'scalar',
      T: 3,
      /* ScalarType.INT64 */
    },
  ]);
  const SubscriptionResponse = /* @__PURE__ */ proto3.makeMessageType(
    'livekit.SubscriptionResponse',
    () => [
      {
        no: 1,
        name: 'track_sid',
        kind: 'scalar',
        T: 9,
        /* ScalarType.STRING */
      },
      {
        no: 2,
        name: 'err',
        kind: 'enum',
        T: proto3.getEnumType(SubscriptionError),
      },
    ]
  );
  const RequestResponse = /* @__PURE__ */ proto3.makeMessageType('livekit.RequestResponse', () => [
    {
      no: 1,
      name: 'request_id',
      kind: 'scalar',
      T: 13,
      /* ScalarType.UINT32 */
    },
    {
      no: 2,
      name: 'reason',
      kind: 'enum',
      T: proto3.getEnumType(RequestResponse_Reason),
    },
    {
      no: 3,
      name: 'message',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: 'trickle',
      kind: 'message',
      T: TrickleRequest,
      oneof: 'request',
    },
    {
      no: 5,
      name: 'add_track',
      kind: 'message',
      T: AddTrackRequest,
      oneof: 'request',
    },
    {
      no: 6,
      name: 'mute',
      kind: 'message',
      T: MuteTrackRequest,
      oneof: 'request',
    },
    {
      no: 7,
      name: 'update_metadata',
      kind: 'message',
      T: UpdateParticipantMetadata,
      oneof: 'request',
    },
    {
      no: 8,
      name: 'update_audio_track',
      kind: 'message',
      T: UpdateLocalAudioTrack,
      oneof: 'request',
    },
    {
      no: 9,
      name: 'update_video_track',
      kind: 'message',
      T: UpdateLocalVideoTrack,
      oneof: 'request',
    },
  ]);
  const RequestResponse_Reason = /* @__PURE__ */ proto3.makeEnum('livekit.RequestResponse.Reason', [
    {
      no: 0,
      name: 'OK',
    },
    {
      no: 1,
      name: 'NOT_FOUND',
    },
    {
      no: 2,
      name: 'NOT_ALLOWED',
    },
    {
      no: 3,
      name: 'LIMIT_EXCEEDED',
    },
    {
      no: 4,
      name: 'QUEUED',
    },
    {
      no: 5,
      name: 'UNSUPPORTED_TYPE',
    },
    {
      no: 6,
      name: 'UNCLASSIFIED_ERROR',
    },
  ]);
  const TrackSubscribed = /* @__PURE__ */ proto3.makeMessageType('livekit.TrackSubscribed', () => [
    {
      no: 1,
      name: 'track_sid',
      kind: 'scalar',
      T: 9,
      /* ScalarType.STRING */
    },
  ]);
  const MediaSectionsRequirement = /* @__PURE__ */ proto3.makeMessageType(
    'livekit.MediaSectionsRequirement',
    () => [
      {
        no: 1,
        name: 'num_audios',
        kind: 'scalar',
        T: 13,
        /* ScalarType.UINT32 */
      },
      {
        no: 2,
        name: 'num_videos',
        kind: 'scalar',
        T: 13,
        /* ScalarType.UINT32 */
      },
    ]
  );
  const TokenSourceRequest = /* @__PURE__ */ proto3.makeMessageType(
    'livekit.TokenSourceRequest',
    () => [
      {
        no: 1,
        name: 'room_name',
        kind: 'scalar',
        T: 9,
        opt: true,
      },
      {
        no: 2,
        name: 'participant_name',
        kind: 'scalar',
        T: 9,
        opt: true,
      },
      {
        no: 3,
        name: 'participant_identity',
        kind: 'scalar',
        T: 9,
        opt: true,
      },
      {
        no: 4,
        name: 'participant_metadata',
        kind: 'scalar',
        T: 9,
        opt: true,
      },
      {
        no: 5,
        name: 'participant_attributes',
        kind: 'map',
        K: 9,
        V: {
          kind: 'scalar',
          T: 9,
          /* ScalarType.STRING */
        },
      },
      {
        no: 6,
        name: 'room_config',
        kind: 'message',
        T: RoomConfiguration,
        opt: true,
      },
    ]
  );
  const TokenSourceResponse = /* @__PURE__ */ proto3.makeMessageType(
    'livekit.TokenSourceResponse',
    () => [
      {
        no: 1,
        name: 'server_url',
        kind: 'scalar',
        T: 9,
        /* ScalarType.STRING */
      },
      {
        no: 2,
        name: 'participant_token',
        kind: 'scalar',
        T: 9,
        /* ScalarType.STRING */
      },
    ]
  );

  function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default')
      ? x['default']
      : x;
  }

  var loglevel$1 = { exports: {} };

  /*
   * loglevel - https://github.com/pimterry/loglevel
   *
   * Copyright (c) 2013 Tim Perry
   * Licensed under the MIT license.
   */
  var loglevel = loglevel$1.exports;
  var hasRequiredLoglevel;
  function requireLoglevel() {
    if (hasRequiredLoglevel) return loglevel$1.exports;
    hasRequiredLoglevel = 1;
    (function (module) {
      (function (root, definition) {
        if (module.exports) {
          module.exports = definition();
        } else {
          root.log = definition();
        }
      })(loglevel, function () {
        // Slightly dubious tricks to cut down minimized file size
        var noop = function () {};
        var undefinedType = 'undefined';
        var isIE =
          typeof window !== undefinedType &&
          typeof window.navigator !== undefinedType &&
          /Trident\/|MSIE /.test(window.navigator.userAgent);
        var logMethods = ['trace', 'debug', 'info', 'warn', 'error'];
        var _loggersByName = {};
        var defaultLogger = null;

        // Cross-browser bind equivalent that works at least back to IE6
        function bindMethod(obj, methodName) {
          var method = obj[methodName];
          if (typeof method.bind === 'function') {
            return method.bind(obj);
          } else {
            try {
              return Function.prototype.bind.call(method, obj);
            } catch (e) {
              // Missing bind shim or IE8 + Modernizr, fallback to wrapping
              return function () {
                return Function.prototype.apply.apply(method, [obj, arguments]);
              };
            }
          }
        }

        // Trace() doesn't print the message in IE, so for that case we need to wrap it
        function traceForIE() {
          if (console.log) {
            if (console.log.apply) {
              console.log.apply(console, arguments);
            } else {
              // In old IE, native console methods themselves don't have apply().
              Function.prototype.apply.apply(console.log, [console, arguments]);
            }
          }
          if (console.trace) console.trace();
        }

        // Build the best logging method possible for this env
        // Wherever possible we want to bind, not wrap, to preserve stack traces
        function realMethod(methodName) {
          if (methodName === 'debug') {
            methodName = 'log';
          }
          if (typeof console === undefinedType) {
            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives
          } else if (methodName === 'trace' && isIE) {
            return traceForIE;
          } else if (console[methodName] !== undefined) {
            return bindMethod(console, methodName);
          } else if (console.log !== undefined) {
            return bindMethod(console, 'log');
          } else {
            return noop;
          }
        }

        // These private functions always need `this` to be set properly

        function replaceLoggingMethods() {
          /*jshint validthis:true */
          var level = this.getLevel();

          // Replace the actual methods.
          for (var i = 0; i < logMethods.length; i++) {
            var methodName = logMethods[i];
            this[methodName] = i < level ? noop : this.methodFactory(methodName, level, this.name);
          }

          // Define log.log as an alias for log.debug
          this.log = this.debug;

          // Return any important warnings.
          if (typeof console === undefinedType && level < this.levels.SILENT) {
            return 'No console available for logging';
          }
        }

        // In old IE versions, the console isn't present until you first open it.
        // We build realMethod() replacements here that regenerate logging methods
        function enableLoggingWhenConsoleArrives(methodName) {
          return function () {
            if (typeof console !== undefinedType) {
              replaceLoggingMethods.call(this);
              this[methodName].apply(this, arguments);
            }
          };
        }

        // By default, we use closely bound real methods wherever possible, and
        // otherwise we wait for a console to appear, and then try again.
        function defaultMethodFactory(methodName, _level, _loggerName) {
          /*jshint validthis:true */
          return realMethod(methodName) || enableLoggingWhenConsoleArrives.apply(this, arguments);
        }
        function Logger(name, factory) {
          // Private instance variables.
          var self = this;
          /**
           * The level inherited from a parent logger (or a global default). We
           * cache this here rather than delegating to the parent so that it stays
           * in sync with the actual logging methods that we have installed (the
           * parent could change levels but we might not have rebuilt the loggers
           * in this child yet).
           * @type {number}
           */
          var inheritedLevel;
          /**
           * The default level for this logger, if any. If set, this overrides
           * `inheritedLevel`.
           * @type {number|null}
           */
          var defaultLevel;
          /**
           * A user-specific level for this logger. If set, this overrides
           * `defaultLevel`.
           * @type {number|null}
           */
          var userLevel;
          var storageKey = 'loglevel';
          if (typeof name === 'string') {
            storageKey += ':' + name;
          } else if (typeof name === 'symbol') {
            storageKey = undefined;
          }
          function persistLevelIfPossible(levelNum) {
            var levelName = (logMethods[levelNum] || 'silent').toUpperCase();
            if (typeof window === undefinedType || !storageKey) return;

            // Use localStorage if available
            try {
              window.localStorage[storageKey] = levelName;
              return;
            } catch (ignore) {}

            // Use session cookie as fallback
            try {
              window.document.cookie = encodeURIComponent(storageKey) + '=' + levelName + ';';
            } catch (ignore) {}
          }
          function getPersistedLevel() {
            var storedLevel;
            if (typeof window === undefinedType || !storageKey) return;
            try {
              storedLevel = window.localStorage[storageKey];
            } catch (ignore) {}

            // Fallback to cookies if local storage gives us nothing
            if (typeof storedLevel === undefinedType) {
              try {
                var cookie = window.document.cookie;
                var cookieName = encodeURIComponent(storageKey);
                var location = cookie.indexOf(cookieName + '=');
                if (location !== -1) {
                  storedLevel = /^([^;]+)/.exec(cookie.slice(location + cookieName.length + 1))[1];
                }
              } catch (ignore) {}
            }

            // If the stored level is not valid, treat it as if nothing was stored.
            if (self.levels[storedLevel] === undefined) {
              storedLevel = undefined;
            }
            return storedLevel;
          }
          function clearPersistedLevel() {
            if (typeof window === undefinedType || !storageKey) return;

            // Use localStorage if available
            try {
              window.localStorage.removeItem(storageKey);
            } catch (ignore) {}

            // Use session cookie as fallback
            try {
              window.document.cookie =
                encodeURIComponent(storageKey) + '=; expires=Thu, 01 Jan 1970 00:00:00 UTC';
            } catch (ignore) {}
          }
          function normalizeLevel(input) {
            var level = input;
            if (typeof level === 'string' && self.levels[level.toUpperCase()] !== undefined) {
              level = self.levels[level.toUpperCase()];
            }
            if (typeof level === 'number' && level >= 0 && level <= self.levels.SILENT) {
              return level;
            } else {
              throw new TypeError('log.setLevel() called with invalid level: ' + input);
            }
          }

          /*
           *
           * Public logger API - see https://github.com/pimterry/loglevel for details
           *
           */

          self.name = name;
          self.levels = {
            TRACE: 0,
            DEBUG: 1,
            INFO: 2,
            WARN: 3,
            ERROR: 4,
            SILENT: 5,
          };
          self.methodFactory = factory || defaultMethodFactory;
          self.getLevel = function () {
            if (userLevel != null) {
              return userLevel;
            } else if (defaultLevel != null) {
              return defaultLevel;
            } else {
              return inheritedLevel;
            }
          };
          self.setLevel = function (level, persist) {
            userLevel = normalizeLevel(level);
            if (persist !== false) {
              // defaults to true
              persistLevelIfPossible(userLevel);
            }

            // NOTE: in v2, this should call rebuild(), which updates children.
            return replaceLoggingMethods.call(self);
          };
          self.setDefaultLevel = function (level) {
            defaultLevel = normalizeLevel(level);
            if (!getPersistedLevel()) {
              self.setLevel(level, false);
            }
          };
          self.resetLevel = function () {
            userLevel = null;
            clearPersistedLevel();
            replaceLoggingMethods.call(self);
          };
          self.enableAll = function (persist) {
            self.setLevel(self.levels.TRACE, persist);
          };
          self.disableAll = function (persist) {
            self.setLevel(self.levels.SILENT, persist);
          };
          self.rebuild = function () {
            if (defaultLogger !== self) {
              inheritedLevel = normalizeLevel(defaultLogger.getLevel());
            }
            replaceLoggingMethods.call(self);
            if (defaultLogger === self) {
              for (var childName in _loggersByName) {
                _loggersByName[childName].rebuild();
              }
            }
          };

          // Initialize all the internal levels.
          inheritedLevel = normalizeLevel(defaultLogger ? defaultLogger.getLevel() : 'WARN');
          var initialLevel = getPersistedLevel();
          if (initialLevel != null) {
            userLevel = normalizeLevel(initialLevel);
          }
          replaceLoggingMethods.call(self);
        }

        /*
         *
         * Top-level API
         *
         */

        defaultLogger = new Logger();
        defaultLogger.getLogger = function getLogger(name) {
          if ((typeof name !== 'symbol' && typeof name !== 'string') || name === '') {
            throw new TypeError('You must supply a name when creating a logger.');
          }
          var logger = _loggersByName[name];
          if (!logger) {
            logger = _loggersByName[name] = new Logger(name, defaultLogger.methodFactory);
          }
          return logger;
        };

        // Grab the current global log variable in case of overwrite
        var _log = typeof window !== undefinedType ? window.log : undefined;
        defaultLogger.noConflict = function () {
          if (typeof window !== undefinedType && window.log === defaultLogger) {
            window.log = _log;
          }
          return defaultLogger;
        };
        defaultLogger.getLoggers = function getLoggers() {
          return _loggersByName;
        };

        // ES6 default export, for compatibility
        defaultLogger['default'] = defaultLogger;
        return defaultLogger;
      });
    })(loglevel$1);
    return loglevel$1.exports;
  }

  var loglevelExports = requireLoglevel();

  var LogLevel;
  (function (LogLevel) {
    LogLevel[(LogLevel['trace'] = 0)] = 'trace';
    LogLevel[(LogLevel['debug'] = 1)] = 'debug';
    LogLevel[(LogLevel['info'] = 2)] = 'info';
    LogLevel[(LogLevel['warn'] = 3)] = 'warn';
    LogLevel[(LogLevel['error'] = 4)] = 'error';
    LogLevel[(LogLevel['silent'] = 5)] = 'silent';
  })(LogLevel || (LogLevel = {}));
  var LoggerNames;
  (function (LoggerNames) {
    LoggerNames['Default'] = 'livekit';
    LoggerNames['Room'] = 'livekit-room';
    LoggerNames['TokenSource'] = 'livekit-token-source';
    LoggerNames['Participant'] = 'livekit-participant';
    LoggerNames['Track'] = 'livekit-track';
    LoggerNames['Publication'] = 'livekit-track-publication';
    LoggerNames['Engine'] = 'livekit-engine';
    LoggerNames['Signal'] = 'livekit-signal';
    LoggerNames['PCManager'] = 'livekit-pc-manager';
    LoggerNames['PCTransport'] = 'livekit-pc-transport';
    LoggerNames['E2EE'] = 'lk-e2ee';
  })(LoggerNames || (LoggerNames = {}));
  let livekitLogger = loglevelExports.getLogger('livekit');
  const livekitLoggers = Object.values(LoggerNames).map((name) => loglevelExports.getLogger(name));
  livekitLogger.setDefaultLevel(LogLevel.info);
  /**
   * @internal
   */
  function getLogger(name) {
    const logger = loglevelExports.getLogger(name);
    logger.setDefaultLevel(livekitLogger.getLevel());
    return logger;
  }
  function setLogLevel(level, loggerName) {
    if (loggerName) {
      loglevelExports.getLogger(loggerName).setLevel(level);
    } else {
      for (const logger of livekitLoggers) {
        logger.setLevel(level);
      }
    }
  }
  /**
   * use this to hook into the logging function to allow sending internal livekit logs to third party services
   * if set, the browser logs will lose their stacktrace information (see https://github.com/pimterry/loglevel#writing-plugins)
   */
  function setLogExtension(extension, logger) {
    const loggers = logger ? [logger] : livekitLoggers;
    loggers.forEach((logR) => {
      const originalFactory = logR.methodFactory;
      logR.methodFactory = (methodName, configLevel, loggerName) => {
        const rawMethod = originalFactory(methodName, configLevel, loggerName);
        const logLevel = LogLevel[methodName];
        const needLog = logLevel >= configLevel && logLevel < LogLevel.silent;
        return (msg, context) => {
          if (context) rawMethod(msg, context);
          else rawMethod(msg);
          if (needLog) {
            extension(logLevel, msg, context);
          }
        };
      };
      logR.setLevel(logR.getLevel());
    });
  }
  const workerLogger = loglevelExports.getLogger('lk-e2ee');

  const maxRetryDelay = 7000;
  const DEFAULT_RETRY_DELAYS_IN_MS = [
    0,
    300,
    2 * 2 * 300,
    3 * 3 * 300,
    4 * 4 * 300,
    maxRetryDelay,
    maxRetryDelay,
    maxRetryDelay,
    maxRetryDelay,
    maxRetryDelay,
  ];
  class DefaultReconnectPolicy {
    constructor(retryDelays) {
      this._retryDelays = retryDelays !== undefined ? [...retryDelays] : DEFAULT_RETRY_DELAYS_IN_MS;
    }
    nextRetryDelayInMs(context) {
      if (context.retryCount >= this._retryDelays.length) return null;
      const retryDelay = this._retryDelays[context.retryCount];
      if (context.retryCount <= 1) return retryDelay;
      return retryDelay + Math.random() * 1000;
    }
  }

  /******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
  /* global Reflect, Promise, SuppressedError, Symbol, Iterator */

  function __rest(s, e) {
    var t = {};
    for (var p in s)
      if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === 'function')
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
          t[p[i]] = s[p[i]];
      }
    return t;
  }

  function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P
        ? value
        : new P(function (resolve) {
            resolve(value);
          });
    }
    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator['throw'](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }

  function __values(o) {
    var s = typeof Symbol === 'function' && Symbol.iterator,
      m = s && o[s],
      i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === 'number')
      return {
        next: function () {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
        },
      };
    throw new TypeError(s ? 'Object is not iterable.' : 'Symbol.iterator is not defined.');
  }

  function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError('Symbol.asyncIterator is not defined.');
    var m = o[Symbol.asyncIterator],
      i;
    return m
      ? m.call(o)
      : ((o = typeof __values === 'function' ? __values(o) : o[Symbol.iterator]()),
        (i = {}),
        verb('next'),
        verb('throw'),
        verb('return'),
        (i[Symbol.asyncIterator] = function () {
          return this;
        }),
        i);
    function verb(n) {
      i[n] =
        o[n] &&
        function (v) {
          return new Promise(function (resolve, reject) {
            ((v = o[n](v)), settle(resolve, reject, v.done, v.value));
          });
        };
    }
    function settle(resolve, reject, d, v) {
      Promise.resolve(v).then(function (v) {
        resolve({ value: v, done: d });
      }, reject);
    }
  }

  typeof SuppressedError === 'function'
    ? SuppressedError
    : function (error, suppressed, message) {
        var e = new Error(message);
        return ((e.name = 'SuppressedError'), (e.error = error), (e.suppressed = suppressed), e);
      };

  var events = { exports: {} };

  var hasRequiredEvents;
  function requireEvents() {
    if (hasRequiredEvents) return events.exports;
    hasRequiredEvents = 1;
    var R = typeof Reflect === 'object' ? Reflect : null;
    var ReflectApply =
      R && typeof R.apply === 'function'
        ? R.apply
        : function ReflectApply(target, receiver, args) {
            return Function.prototype.apply.call(target, receiver, args);
          };
    var ReflectOwnKeys;
    if (R && typeof R.ownKeys === 'function') {
      ReflectOwnKeys = R.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn) console.warn(warning);
    }
    var NumberIsNaN =
      Number.isNaN ||
      function NumberIsNaN(value) {
        return value !== value;
      };
    function EventEmitter() {
      EventEmitter.init.call(this);
    }
    events.exports = EventEmitter;
    events.exports.once = once;

    // Backwards-compat with node 0.10.x
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.prototype._events = undefined;
    EventEmitter.prototype._eventsCount = 0;
    EventEmitter.prototype._maxListeners = undefined;

    // By default EventEmitters will print a warning if more than 10 listeners are
    // added to it. This is a useful default which helps finding memory leaks.
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== 'function') {
        throw new TypeError(
          'The "listener" argument must be of type Function. Received type ' + typeof listener
        );
      }
    }
    Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
      enumerable: true,
      get: function () {
        return defaultMaxListeners;
      },
      set: function (arg) {
        if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError(
            'The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' +
              arg +
              '.'
          );
        }
        defaultMaxListeners = arg;
      },
    });
    EventEmitter.init = function () {
      if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
        this._events = Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || undefined;
    };

    // Obviously not all Emitters should be limited to 10. This function allows
    // that to be increased. Set to zero for unlimited.
    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
        throw new RangeError(
          'The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.'
        );
      }
      this._maxListeners = n;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter.prototype.emit = function emit(type) {
      var args = [];
      for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
      var doError = type === 'error';
      var events = this._events;
      if (events !== undefined) doError = doError && events.error === undefined;
      else if (!doError) return false;

      // If there is no 'error' event listener then throw.
      if (doError) {
        var er;
        if (args.length > 0) er = args[0];
        if (er instanceof Error) {
          // Note: The comments on the `throw` lines are intentional, they show
          // up in Node's output if this results in an unhandled exception.
          throw er; // Unhandled 'error' event
        }
        // At least give some kind of context to the user
        var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
        err.context = er;
        throw err; // Unhandled 'error' event
      }
      var handler = events[type];
      if (handler === undefined) return false;
      if (typeof handler === 'function') {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i) ReflectApply(listeners[i], this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m;
      var events;
      var existing;
      checkListener(listener);
      events = target._events;
      if (events === undefined) {
        events = target._events = Object.create(null);
        target._eventsCount = 0;
      } else {
        // To avoid recursion in the case that type === "newListener"! Before
        // adding it to the listeners, first emit "newListener".
        if (events.newListener !== undefined) {
          target.emit('newListener', type, listener.listener ? listener.listener : listener);

          // Re-assign `events` because a newListener handler could have caused the
          // this._events to be assigned to a new object
          events = target._events;
        }
        existing = events[type];
      }
      if (existing === undefined) {
        // Optimize the case of one listener. Don't need the extra array object.
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === 'function') {
          // Adding the second element, need to change to array.
          existing = events[type] = prepend ? [listener, existing] : [existing, listener];
          // If we've already got an array, just append.
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }

        // Check for listener leak
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
          existing.warned = true;
          // No error code for this since it is a Warning
          // eslint-disable-next-line no-restricted-syntax
          var w = new Error(
            'Possible EventEmitter memory leak detected. ' +
              existing.length +
              ' ' +
              String(type) +
              ' listeners ' +
              'added. Use emitter.setMaxListeners() to ' +
              'increase limit'
          );
          w.name = 'MaxListenersExceededWarning';
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          ProcessEmitWarning(w);
        }
      }
      return target;
    }
    EventEmitter.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0) return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type, listener) {
      var state = {
        fired: false,
        wrapFn: undefined,
        target: target,
        type: type,
        listener: listener,
      };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter.prototype.once = function once(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

    // Emits a 'removeListener' event if and only if the listener was removed.
    EventEmitter.prototype.removeListener = function removeListener(type, listener) {
      var list, events, position, i, originalListener;
      checkListener(listener);
      events = this._events;
      if (events === undefined) return this;
      list = events[type];
      if (list === undefined) return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0) this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;
        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0) return this;
        if (position === 0) list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1) events[type] = list[0];
        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }
      return this;
    };
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners, events, i;
      events = this._events;
      if (events === undefined) return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0) this._events = Object.create(null);
          else delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners = events[type];
      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }
      return this;
    };
    function _listeners(target, type, unwrap) {
      var events = target._events;
      if (events === undefined) return [];
      var evlistener = events[type];
      if (evlistener === undefined) return [];
      if (typeof evlistener === 'function')
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    EventEmitter.prototype.listeners = function listeners(type) {
      return _listeners(this, type, true);
    };
    EventEmitter.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };
    EventEmitter.listenerCount = function (emitter, type) {
      if (typeof emitter.listenerCount === 'function') {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events = this._events;
      if (events !== undefined) {
        var evlistener = events[type];
        if (typeof evlistener === 'function') {
          return 1;
        } else if (evlistener !== undefined) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone(arr, n) {
      var copy = new Array(n);
      for (var i = 0; i < n; ++i) copy[i] = arr[i];
      return copy;
    }
    function spliceOne(list, index) {
      for (; index + 1 < list.length; index++) list[index] = list[index + 1];
      list.pop();
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }
    function once(emitter, name) {
      return new Promise(function (resolve, reject) {
        function errorListener(err) {
          emitter.removeListener(name, resolver);
          reject(err);
        }
        function resolver() {
          if (typeof emitter.removeListener === 'function') {
            emitter.removeListener('error', errorListener);
          }
          resolve([].slice.call(arguments));
        }
        eventTargetAgnosticAddListener(emitter, name, resolver, {
          once: true,
        });
        if (name !== 'error') {
          addErrorHandlerIfEventEmitter(emitter, errorListener, {
            once: true,
          });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === 'function') {
        eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
      if (typeof emitter.on === 'function') {
        if (flags.once) {
          emitter.once(name, listener);
        } else {
          emitter.on(name, listener);
        }
      } else if (typeof emitter.addEventListener === 'function') {
        // EventTarget does not have `error` event semantics like Node
        // EventEmitters, we do not listen for `error` events here.
        emitter.addEventListener(name, function wrapListener(arg) {
          // IE does not have builtin `{ once: true }` support so we
          // have to do it manually.
          if (flags.once) {
            emitter.removeEventListener(name, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError(
          'The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter
        );
      }
    }
    return events.exports;
  }

  var eventsExports = requireEvents();

  /*
   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */
  /* eslint-env node */

  let logDisabled_ = true;
  let deprecationWarnings_ = true;

  /**
   * Extract browser version out of the provided user agent string.
   *
   * @param {!string} uastring userAgent string.
   * @param {!string} expr Regular expression used as match criteria.
   * @param {!number} pos position in the version string to be returned.
   * @return {!number} browser version.
   */
  function extractVersion(uastring, expr, pos) {
    const match = uastring.match(expr);
    return match && match.length >= pos && parseFloat(match[pos], 10);
  }

  // Wraps the peerconnection event eventNameToWrap in a function
  // which returns the modified event object (or false to prevent
  // the event).
  function wrapPeerConnectionEvent(window, eventNameToWrap, wrapper) {
    if (!window.RTCPeerConnection) {
      return;
    }
    const proto = window.RTCPeerConnection.prototype;
    const nativeAddEventListener = proto.addEventListener;
    proto.addEventListener = function (nativeEventName, cb) {
      if (nativeEventName !== eventNameToWrap) {
        return nativeAddEventListener.apply(this, arguments);
      }
      const wrappedCallback = (e) => {
        const modifiedEvent = wrapper(e);
        if (modifiedEvent) {
          if (cb.handleEvent) {
            cb.handleEvent(modifiedEvent);
          } else {
            cb(modifiedEvent);
          }
        }
      };
      this._eventMap = this._eventMap || {};
      if (!this._eventMap[eventNameToWrap]) {
        this._eventMap[eventNameToWrap] = new Map();
      }
      this._eventMap[eventNameToWrap].set(cb, wrappedCallback);
      return nativeAddEventListener.apply(this, [nativeEventName, wrappedCallback]);
    };
    const nativeRemoveEventListener = proto.removeEventListener;
    proto.removeEventListener = function (nativeEventName, cb) {
      if (
        nativeEventName !== eventNameToWrap ||
        !this._eventMap ||
        !this._eventMap[eventNameToWrap]
      ) {
        return nativeRemoveEventListener.apply(this, arguments);
      }
      if (!this._eventMap[eventNameToWrap].has(cb)) {
        return nativeRemoveEventListener.apply(this, arguments);
      }
      const unwrappedCb = this._eventMap[eventNameToWrap].get(cb);
      this._eventMap[eventNameToWrap].delete(cb);
      if (this._eventMap[eventNameToWrap].size === 0) {
        delete this._eventMap[eventNameToWrap];
      }
      if (Object.keys(this._eventMap).length === 0) {
        delete this._eventMap;
      }
      return nativeRemoveEventListener.apply(this, [nativeEventName, unwrappedCb]);
    };
    Object.defineProperty(proto, 'on' + eventNameToWrap, {
      get() {
        return this['_on' + eventNameToWrap];
      },
      set(cb) {
        if (this['_on' + eventNameToWrap]) {
          this.removeEventListener(eventNameToWrap, this['_on' + eventNameToWrap]);
          delete this['_on' + eventNameToWrap];
        }
        if (cb) {
          this.addEventListener(eventNameToWrap, (this['_on' + eventNameToWrap] = cb));
        }
      },
      enumerable: true,
      configurable: true,
    });
  }
  function disableLog(bool) {
    if (typeof bool !== 'boolean') {
      return new Error('Argument type: ' + typeof bool + '. Please use a boolean.');
    }
    logDisabled_ = bool;
    return bool ? 'adapter.js logging disabled' : 'adapter.js logging enabled';
  }

  /**
   * Disable or enable deprecation warnings
   * @param {!boolean} bool set to true to disable warnings.
   */
  function disableWarnings(bool) {
    if (typeof bool !== 'boolean') {
      return new Error('Argument type: ' + typeof bool + '. Please use a boolean.');
    }
    deprecationWarnings_ = !bool;
    return 'adapter.js deprecation warnings ' + (bool ? 'disabled' : 'enabled');
  }
  function log() {
    if (typeof window === 'object') {
      if (logDisabled_) {
        return;
      }
      if (typeof console !== 'undefined' && typeof console.log === 'function') {
        console.log.apply(console, arguments);
      }
    }
  }

  /**
   * Shows a deprecation warning suggesting the modern and spec-compatible API.
   */
  function deprecated(oldMethod, newMethod) {
    if (!deprecationWarnings_) {
      return;
    }
    console.warn(oldMethod + ' is deprecated, please use ' + newMethod + ' instead.');
  }

  /**
   * Browser detector.
   *
   * @return {object} result containing browser and version
   *     properties.
   */
  function detectBrowser(window) {
    // Returned result object.
    const result = {
      browser: null,
      version: null,
    };

    // Fail early if it's not a browser
    if (typeof window === 'undefined' || !window.navigator || !window.navigator.userAgent) {
      result.browser = 'Not a browser.';
      return result;
    }
    const { navigator } = window;

    // Prefer navigator.userAgentData.
    if (navigator.userAgentData && navigator.userAgentData.brands) {
      const chromium = navigator.userAgentData.brands.find((brand) => {
        return brand.brand === 'Chromium';
      });
      if (chromium) {
        return {
          browser: 'chrome',
          version: parseInt(chromium.version, 10),
        };
      }
    }
    if (navigator.mozGetUserMedia) {
      // Firefox.
      result.browser = 'firefox';
      result.version = parseInt(extractVersion(navigator.userAgent, /Firefox\/(\d+)\./, 1));
    } else if (
      navigator.webkitGetUserMedia ||
      (window.isSecureContext === false && window.webkitRTCPeerConnection)
    ) {
      // Chrome, Chromium, Webview, Opera.
      // Version matches Chrome/WebRTC version.
      // Chrome 74 removed webkitGetUserMedia on http as well so we need the
      // more complicated fallback to webkitRTCPeerConnection.
      result.browser = 'chrome';
      result.version = parseInt(extractVersion(navigator.userAgent, /Chrom(e|ium)\/(\d+)\./, 2));
    } else if (window.RTCPeerConnection && navigator.userAgent.match(/AppleWebKit\/(\d+)\./)) {
      // Safari.
      result.browser = 'safari';
      result.version = parseInt(extractVersion(navigator.userAgent, /AppleWebKit\/(\d+)\./, 1));
      result.supportsUnifiedPlan =
        window.RTCRtpTransceiver && 'currentDirection' in window.RTCRtpTransceiver.prototype;
      // Only for internal usage.
      result._safariVersion = extractVersion(navigator.userAgent, /Version\/(\d+(\.?\d+))/, 1);
    } else {
      // Default fallthrough: not supported.
      result.browser = 'Not a supported browser.';
      return result;
    }
    return result;
  }

  /**
   * Checks if something is an object.
   *
   * @param {*} val The something you want to check.
   * @return true if val is an object, false otherwise.
   */
  function isObject$1(val) {
    return Object.prototype.toString.call(val) === '[object Object]';
  }

  /**
   * Remove all empty objects and undefined values
   * from a nested object -- an enhanced and vanilla version
   * of Lodash's `compact`.
   */
  function compactObject(data) {
    if (!isObject$1(data)) {
      return data;
    }
    return Object.keys(data).reduce(function (accumulator, key) {
      const isObj = isObject$1(data[key]);
      const value = isObj ? compactObject(data[key]) : data[key];
      const isEmptyObject = isObj && !Object.keys(value).length;
      if (value === undefined || isEmptyObject) {
        return accumulator;
      }
      return Object.assign(accumulator, {
        [key]: value,
      });
    }, {});
  }

  /* iterates the stats graph recursively. */
  function walkStats(stats, base, resultSet) {
    if (!base || resultSet.has(base.id)) {
      return;
    }
    resultSet.set(base.id, base);
    Object.keys(base).forEach((name) => {
      if (name.endsWith('Id')) {
        walkStats(stats, stats.get(base[name]), resultSet);
      } else if (name.endsWith('Ids')) {
        base[name].forEach((id) => {
          walkStats(stats, stats.get(id), resultSet);
        });
      }
    });
  }

  /* filter getStats for a sender/receiver track. */
  function filterStats(result, track, outbound) {
    const streamStatsType = outbound ? 'outbound-rtp' : 'inbound-rtp';
    const filteredResult = new Map();
    if (track === null) {
      return filteredResult;
    }
    const trackStats = [];
    result.forEach((value) => {
      if (value.type === 'track' && value.trackIdentifier === track.id) {
        trackStats.push(value);
      }
    });
    trackStats.forEach((trackStat) => {
      result.forEach((stats) => {
        if (stats.type === streamStatsType && stats.trackId === trackStat.id) {
          walkStats(result, stats, filteredResult);
        }
      });
    });
    return filteredResult;
  }

  /*
   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */
  /* eslint-env node */
  const logging = log;
  function shimGetUserMedia$2(window, browserDetails) {
    const navigator = window && window.navigator;
    if (!navigator.mediaDevices) {
      return;
    }
    const constraintsToChrome_ = function (c) {
      if (typeof c !== 'object' || c.mandatory || c.optional) {
        return c;
      }
      const cc = {};
      Object.keys(c).forEach((key) => {
        if (key === 'require' || key === 'advanced' || key === 'mediaSource') {
          return;
        }
        const r =
          typeof c[key] === 'object'
            ? c[key]
            : {
                ideal: c[key],
              };
        if (r.exact !== undefined && typeof r.exact === 'number') {
          r.min = r.max = r.exact;
        }
        const oldname_ = function (prefix, name) {
          if (prefix) {
            return prefix + name.charAt(0).toUpperCase() + name.slice(1);
          }
          return name === 'deviceId' ? 'sourceId' : name;
        };
        if (r.ideal !== undefined) {
          cc.optional = cc.optional || [];
          let oc = {};
          if (typeof r.ideal === 'number') {
            oc[oldname_('min', key)] = r.ideal;
            cc.optional.push(oc);
            oc = {};
            oc[oldname_('max', key)] = r.ideal;
            cc.optional.push(oc);
          } else {
            oc[oldname_('', key)] = r.ideal;
            cc.optional.push(oc);
          }
        }
        if (r.exact !== undefined && typeof r.exact !== 'number') {
          cc.mandatory = cc.mandatory || {};
          cc.mandatory[oldname_('', key)] = r.exact;
        } else {
          ['min', 'max'].forEach((mix) => {
            if (r[mix] !== undefined) {
              cc.mandatory = cc.mandatory || {};
              cc.mandatory[oldname_(mix, key)] = r[mix];
            }
          });
        }
      });
      if (c.advanced) {
        cc.optional = (cc.optional || []).concat(c.advanced);
      }
      return cc;
    };
    const shimConstraints_ = function (constraints, func) {
      if (browserDetails.version >= 61) {
        return func(constraints);
      }
      constraints = JSON.parse(JSON.stringify(constraints));
      if (constraints && typeof constraints.audio === 'object') {
        const remap = function (obj, a, b) {
          if (a in obj && !(b in obj)) {
            obj[b] = obj[a];
            delete obj[a];
          }
        };
        constraints = JSON.parse(JSON.stringify(constraints));
        remap(constraints.audio, 'autoGainControl', 'googAutoGainControl');
        remap(constraints.audio, 'noiseSuppression', 'googNoiseSuppression');
        constraints.audio = constraintsToChrome_(constraints.audio);
      }
      if (constraints && typeof constraints.video === 'object') {
        // Shim facingMode for mobile & surface pro.
        let face = constraints.video.facingMode;
        face =
          face &&
          (typeof face === 'object'
            ? face
            : {
                ideal: face,
              });
        const getSupportedFacingModeLies = browserDetails.version < 66;
        if (
          face &&
          (face.exact === 'user' ||
            face.exact === 'environment' ||
            face.ideal === 'user' ||
            face.ideal === 'environment') &&
          !(
            navigator.mediaDevices.getSupportedConstraints &&
            navigator.mediaDevices.getSupportedConstraints().facingMode &&
            !getSupportedFacingModeLies
          )
        ) {
          delete constraints.video.facingMode;
          let matches;
          if (face.exact === 'environment' || face.ideal === 'environment') {
            matches = ['back', 'rear'];
          } else if (face.exact === 'user' || face.ideal === 'user') {
            matches = ['front'];
          }
          if (matches) {
            // Look for matches in label, or use last cam for back (typical).
            return navigator.mediaDevices.enumerateDevices().then((devices) => {
              devices = devices.filter((d) => d.kind === 'videoinput');
              let dev = devices.find((d) =>
                matches.some((match) => d.label.toLowerCase().includes(match))
              );
              if (!dev && devices.length && matches.includes('back')) {
                dev = devices[devices.length - 1]; // more likely the back cam
              }
              if (dev) {
                constraints.video.deviceId = face.exact
                  ? {
                      exact: dev.deviceId,
                    }
                  : {
                      ideal: dev.deviceId,
                    };
              }
              constraints.video = constraintsToChrome_(constraints.video);
              logging('chrome: ' + JSON.stringify(constraints));
              return func(constraints);
            });
          }
        }
        constraints.video = constraintsToChrome_(constraints.video);
      }
      logging('chrome: ' + JSON.stringify(constraints));
      return func(constraints);
    };
    const shimError_ = function (e) {
      if (browserDetails.version >= 64) {
        return e;
      }
      return {
        name:
          {
            PermissionDeniedError: 'NotAllowedError',
            PermissionDismissedError: 'NotAllowedError',
            InvalidStateError: 'NotAllowedError',
            DevicesNotFoundError: 'NotFoundError',
            ConstraintNotSatisfiedError: 'OverconstrainedError',
            TrackStartError: 'NotReadableError',
            MediaDeviceFailedDueToShutdown: 'NotAllowedError',
            MediaDeviceKillSwitchOn: 'NotAllowedError',
            TabCaptureError: 'AbortError',
            ScreenCaptureError: 'AbortError',
            DeviceCaptureError: 'AbortError',
          }[e.name] || e.name,
        message: e.message,
        constraint: e.constraint || e.constraintName,
        toString() {
          return this.name + (this.message && ': ') + this.message;
        },
      };
    };
    const getUserMedia_ = function (constraints, onSuccess, onError) {
      shimConstraints_(constraints, (c) => {
        navigator.webkitGetUserMedia(c, onSuccess, (e) => {
          if (onError) {
            onError(shimError_(e));
          }
        });
      });
    };
    navigator.getUserMedia = getUserMedia_.bind(navigator);

    // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia
    // function which returns a Promise, it does not accept spec-style
    // constraints.
    if (navigator.mediaDevices.getUserMedia) {
      const origGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
      navigator.mediaDevices.getUserMedia = function (cs) {
        return shimConstraints_(cs, (c) =>
          origGetUserMedia(c).then(
            (stream) => {
              if (
                (c.audio && !stream.getAudioTracks().length) ||
                (c.video && !stream.getVideoTracks().length)
              ) {
                stream.getTracks().forEach((track) => {
                  track.stop();
                });
                throw new DOMException('', 'NotFoundError');
              }
              return stream;
            },
            (e) => Promise.reject(shimError_(e))
          )
        );
      };
    }
  }

  /*
   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */
  /* eslint-env node */
  function shimMediaStream(window) {
    window.MediaStream = window.MediaStream || window.webkitMediaStream;
  }
  function shimOnTrack$1(window) {
    if (
      typeof window === 'object' &&
      window.RTCPeerConnection &&
      !('ontrack' in window.RTCPeerConnection.prototype)
    ) {
      Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {
        get() {
          return this._ontrack;
        },
        set(f) {
          if (this._ontrack) {
            this.removeEventListener('track', this._ontrack);
          }
          this.addEventListener('track', (this._ontrack = f));
        },
        enumerable: true,
        configurable: true,
      });
      const origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;
      window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
        if (!this._ontrackpoly) {
          this._ontrackpoly = (e) => {
            // onaddstream does not fire when a track is added to an existing
            // stream. But stream.onaddtrack is implemented so we use that.
            e.stream.addEventListener('addtrack', (te) => {
              let receiver;
              if (window.RTCPeerConnection.prototype.getReceivers) {
                receiver = this.getReceivers().find((r) => r.track && r.track.id === te.track.id);
              } else {
                receiver = {
                  track: te.track,
                };
              }
              const event = new Event('track');
              event.track = te.track;
              event.receiver = receiver;
              event.transceiver = {
                receiver,
              };
              event.streams = [e.stream];
              this.dispatchEvent(event);
            });
            e.stream.getTracks().forEach((track) => {
              let receiver;
              if (window.RTCPeerConnection.prototype.getReceivers) {
                receiver = this.getReceivers().find((r) => r.track && r.track.id === track.id);
              } else {
                receiver = {
                  track,
                };
              }
              const event = new Event('track');
              event.track = track;
              event.receiver = receiver;
              event.transceiver = {
                receiver,
              };
              event.streams = [e.stream];
              this.dispatchEvent(event);
            });
          };
          this.addEventListener('addstream', this._ontrackpoly);
        }
        return origSetRemoteDescription.apply(this, arguments);
      };
    } else {
      // even if RTCRtpTransceiver is in window, it is only used and
      // emitted in unified-plan. Unfortunately this means we need
      // to unconditionally wrap the event.
      wrapPeerConnectionEvent(window, 'track', (e) => {
        if (!e.transceiver) {
          Object.defineProperty(e, 'transceiver', {
            value: {
              receiver: e.receiver,
            },
          });
        }
        return e;
      });
    }
  }
  function shimGetSendersWithDtmf(window) {
    // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.
    if (
      typeof window === 'object' &&
      window.RTCPeerConnection &&
      !('getSenders' in window.RTCPeerConnection.prototype) &&
      'createDTMFSender' in window.RTCPeerConnection.prototype
    ) {
      const shimSenderWithDtmf = function (pc, track) {
        return {
          track,
          get dtmf() {
            if (this._dtmf === undefined) {
              if (track.kind === 'audio') {
                this._dtmf = pc.createDTMFSender(track);
              } else {
                this._dtmf = null;
              }
            }
            return this._dtmf;
          },
          _pc: pc,
        };
      };

      // augment addTrack when getSenders is not available.
      if (!window.RTCPeerConnection.prototype.getSenders) {
        window.RTCPeerConnection.prototype.getSenders = function getSenders() {
          this._senders = this._senders || [];
          return this._senders.slice(); // return a copy of the internal state.
        };
        const origAddTrack = window.RTCPeerConnection.prototype.addTrack;
        window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
          let sender = origAddTrack.apply(this, arguments);
          if (!sender) {
            sender = shimSenderWithDtmf(this, track);
            this._senders.push(sender);
          }
          return sender;
        };
        const origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;
        window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
          origRemoveTrack.apply(this, arguments);
          const idx = this._senders.indexOf(sender);
          if (idx !== -1) {
            this._senders.splice(idx, 1);
          }
        };
      }
      const origAddStream = window.RTCPeerConnection.prototype.addStream;
      window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
        this._senders = this._senders || [];
        origAddStream.apply(this, [stream]);
        stream.getTracks().forEach((track) => {
          this._senders.push(shimSenderWithDtmf(this, track));
        });
      };
      const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
      window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
        this._senders = this._senders || [];
        origRemoveStream.apply(this, [stream]);
        stream.getTracks().forEach((track) => {
          const sender = this._senders.find((s) => s.track === track);
          if (sender) {
            // remove sender
            this._senders.splice(this._senders.indexOf(sender), 1);
          }
        });
      };
    } else if (
      typeof window === 'object' &&
      window.RTCPeerConnection &&
      'getSenders' in window.RTCPeerConnection.prototype &&
      'createDTMFSender' in window.RTCPeerConnection.prototype &&
      window.RTCRtpSender &&
      !('dtmf' in window.RTCRtpSender.prototype)
    ) {
      const origGetSenders = window.RTCPeerConnection.prototype.getSenders;
      window.RTCPeerConnection.prototype.getSenders = function getSenders() {
        const senders = origGetSenders.apply(this, []);
        senders.forEach((sender) => (sender._pc = this));
        return senders;
      };
      Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {
        get() {
          if (this._dtmf === undefined) {
            if (this.track.kind === 'audio') {
              this._dtmf = this._pc.createDTMFSender(this.track);
            } else {
              this._dtmf = null;
            }
          }
          return this._dtmf;
        },
      });
    }
  }
  function shimSenderReceiverGetStats(window) {
    if (
      !(
        typeof window === 'object' &&
        window.RTCPeerConnection &&
        window.RTCRtpSender &&
        window.RTCRtpReceiver
      )
    ) {
      return;
    }

    // shim sender stats.
    if (!('getStats' in window.RTCRtpSender.prototype)) {
      const origGetSenders = window.RTCPeerConnection.prototype.getSenders;
      if (origGetSenders) {
        window.RTCPeerConnection.prototype.getSenders = function getSenders() {
          const senders = origGetSenders.apply(this, []);
          senders.forEach((sender) => (sender._pc = this));
          return senders;
        };
      }
      const origAddTrack = window.RTCPeerConnection.prototype.addTrack;
      if (origAddTrack) {
        window.RTCPeerConnection.prototype.addTrack = function addTrack() {
          const sender = origAddTrack.apply(this, arguments);
          sender._pc = this;
          return sender;
        };
      }
      window.RTCRtpSender.prototype.getStats = function getStats() {
        const sender = this;
        return this._pc.getStats().then((result) =>
          /* Note: this will include stats of all senders that
           *   send a track with the same id as sender.track as
           *   it is not possible to identify the RTCRtpSender.
           */
          filterStats(result, sender.track, true)
        );
      };
    }

    // shim receiver stats.
    if (!('getStats' in window.RTCRtpReceiver.prototype)) {
      const origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;
      if (origGetReceivers) {
        window.RTCPeerConnection.prototype.getReceivers = function getReceivers() {
          const receivers = origGetReceivers.apply(this, []);
          receivers.forEach((receiver) => (receiver._pc = this));
          return receivers;
        };
      }
      wrapPeerConnectionEvent(window, 'track', (e) => {
        e.receiver._pc = e.srcElement;
        return e;
      });
      window.RTCRtpReceiver.prototype.getStats = function getStats() {
        const receiver = this;
        return this._pc.getStats().then((result) => filterStats(result, receiver.track, false));
      };
    }
    if (
      !(
        'getStats' in window.RTCRtpSender.prototype && 'getStats' in window.RTCRtpReceiver.prototype
      )
    ) {
      return;
    }

    // shim RTCPeerConnection.getStats(track).
    const origGetStats = window.RTCPeerConnection.prototype.getStats;
    window.RTCPeerConnection.prototype.getStats = function getStats() {
      if (arguments.length > 0 && arguments[0] instanceof window.MediaStreamTrack) {
        const track = arguments[0];
        let sender;
        let receiver;
        let err;
        this.getSenders().forEach((s) => {
          if (s.track === track) {
            if (sender) {
              err = true;
            } else {
              sender = s;
            }
          }
        });
        this.getReceivers().forEach((r) => {
          if (r.track === track) {
            if (receiver) {
              err = true;
            } else {
              receiver = r;
            }
          }
          return r.track === track;
        });
        if (err || (sender && receiver)) {
          return Promise.reject(
            new DOMException(
              'There are more than one sender or receiver for the track.',
              'InvalidAccessError'
            )
          );
        } else if (sender) {
          return sender.getStats();
        } else if (receiver) {
          return receiver.getStats();
        }
        return Promise.reject(
          new DOMException('There is no sender or receiver for the track.', 'InvalidAccessError')
        );
      }
      return origGetStats.apply(this, arguments);
    };
  }
  function shimAddTrackRemoveTrackWithNative(window) {
    // shim addTrack/removeTrack with native variants in order to make
    // the interactions with legacy getLocalStreams behave as in other browsers.
    // Keeps a mapping stream.id => [stream, rtpsenders...]
    window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};
      return Object.keys(this._shimmedLocalStreams).map(
        (streamId) => this._shimmedLocalStreams[streamId][0]
      );
    };
    const origAddTrack = window.RTCPeerConnection.prototype.addTrack;
    window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
      if (!stream) {
        return origAddTrack.apply(this, arguments);
      }
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};
      const sender = origAddTrack.apply(this, arguments);
      if (!this._shimmedLocalStreams[stream.id]) {
        this._shimmedLocalStreams[stream.id] = [stream, sender];
      } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {
        this._shimmedLocalStreams[stream.id].push(sender);
      }
      return sender;
    };
    const origAddStream = window.RTCPeerConnection.prototype.addStream;
    window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};
      stream.getTracks().forEach((track) => {
        const alreadyExists = this.getSenders().find((s) => s.track === track);
        if (alreadyExists) {
          throw new DOMException('Track already exists.', 'InvalidAccessError');
        }
      });
      const existingSenders = this.getSenders();
      origAddStream.apply(this, arguments);
      const newSenders = this.getSenders().filter(
        (newSender) => existingSenders.indexOf(newSender) === -1
      );
      this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);
    };
    const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
    window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};
      delete this._shimmedLocalStreams[stream.id];
      return origRemoveStream.apply(this, arguments);
    };
    const origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;
    window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};
      if (sender) {
        Object.keys(this._shimmedLocalStreams).forEach((streamId) => {
          const idx = this._shimmedLocalStreams[streamId].indexOf(sender);
          if (idx !== -1) {
            this._shimmedLocalStreams[streamId].splice(idx, 1);
          }
          if (this._shimmedLocalStreams[streamId].length === 1) {
            delete this._shimmedLocalStreams[streamId];
          }
        });
      }
      return origRemoveTrack.apply(this, arguments);
    };
  }
  function shimAddTrackRemoveTrack(window, browserDetails) {
    if (!window.RTCPeerConnection) {
      return;
    }
    // shim addTrack and removeTrack.
    if (window.RTCPeerConnection.prototype.addTrack && browserDetails.version >= 65) {
      return shimAddTrackRemoveTrackWithNative(window);
    }

    // also shim pc.getLocalStreams when addTrack is shimmed
    // to return the original streams.
    const origGetLocalStreams = window.RTCPeerConnection.prototype.getLocalStreams;
    window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
      const nativeStreams = origGetLocalStreams.apply(this);
      this._reverseStreams = this._reverseStreams || {};
      return nativeStreams.map((stream) => this._reverseStreams[stream.id]);
    };
    const origAddStream = window.RTCPeerConnection.prototype.addStream;
    window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
      this._streams = this._streams || {};
      this._reverseStreams = this._reverseStreams || {};
      stream.getTracks().forEach((track) => {
        const alreadyExists = this.getSenders().find((s) => s.track === track);
        if (alreadyExists) {
          throw new DOMException('Track already exists.', 'InvalidAccessError');
        }
      });
      // Add identity mapping for consistency with addTrack.
      // Unless this is being used with a stream from addTrack.
      if (!this._reverseStreams[stream.id]) {
        const newStream = new window.MediaStream(stream.getTracks());
        this._streams[stream.id] = newStream;
        this._reverseStreams[newStream.id] = stream;
        stream = newStream;
      }
      origAddStream.apply(this, [stream]);
    };
    const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
    window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
      this._streams = this._streams || {};
      this._reverseStreams = this._reverseStreams || {};
      origRemoveStream.apply(this, [this._streams[stream.id] || stream]);
      delete this._reverseStreams[
        this._streams[stream.id] ? this._streams[stream.id].id : stream.id
      ];
      delete this._streams[stream.id];
    };
    window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
      if (this.signalingState === 'closed') {
        throw new DOMException(
          "The RTCPeerConnection's signalingState is 'closed'.",
          'InvalidStateError'
        );
      }
      const streams = [].slice.call(arguments, 1);
      if (streams.length !== 1 || !streams[0].getTracks().find((t) => t === track)) {
        // this is not fully correct but all we can manage without
        // [[associated MediaStreams]] internal slot.
        throw new DOMException(
          'The adapter.js addTrack polyfill only supports a single ' +
            ' stream which is associated with the specified track.',
          'NotSupportedError'
        );
      }
      const alreadyExists = this.getSenders().find((s) => s.track === track);
      if (alreadyExists) {
        throw new DOMException('Track already exists.', 'InvalidAccessError');
      }
      this._streams = this._streams || {};
      this._reverseStreams = this._reverseStreams || {};
      const oldStream = this._streams[stream.id];
      if (oldStream) {
        // this is using odd Chrome behaviour, use with caution:
        // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815
        // Note: we rely on the high-level addTrack/dtmf shim to
        // create the sender with a dtmf sender.
        oldStream.addTrack(track);

        // Trigger ONN async.
        Promise.resolve().then(() => {
          this.dispatchEvent(new Event('negotiationneeded'));
        });
      } else {
        const newStream = new window.MediaStream([track]);
        this._streams[stream.id] = newStream;
        this._reverseStreams[newStream.id] = stream;
        this.addStream(newStream);
      }
      return this.getSenders().find((s) => s.track === track);
    };

    // replace the internal stream id with the external one and
    // vice versa.
    function replaceInternalStreamId(pc, description) {
      let sdp = description.sdp;
      Object.keys(pc._reverseStreams || []).forEach((internalId) => {
        const externalStream = pc._reverseStreams[internalId];
        const internalStream = pc._streams[externalStream.id];
        sdp = sdp.replace(new RegExp(internalStream.id, 'g'), externalStream.id);
      });
      return new RTCSessionDescription({
        type: description.type,
        sdp,
      });
    }
    function replaceExternalStreamId(pc, description) {
      let sdp = description.sdp;
      Object.keys(pc._reverseStreams || []).forEach((internalId) => {
        const externalStream = pc._reverseStreams[internalId];
        const internalStream = pc._streams[externalStream.id];
        sdp = sdp.replace(new RegExp(externalStream.id, 'g'), internalStream.id);
      });
      return new RTCSessionDescription({
        type: description.type,
        sdp,
      });
    }
    ['createOffer', 'createAnswer'].forEach(function (method) {
      const nativeMethod = window.RTCPeerConnection.prototype[method];
      const methodObj = {
        [method]() {
          const args = arguments;
          const isLegacyCall = arguments.length && typeof arguments[0] === 'function';
          if (isLegacyCall) {
            return nativeMethod.apply(this, [
              (description) => {
                const desc = replaceInternalStreamId(this, description);
                args[0].apply(null, [desc]);
              },
              (err) => {
                if (args[1]) {
                  args[1].apply(null, err);
                }
              },
              arguments[2],
            ]);
          }
          return nativeMethod
            .apply(this, arguments)
            .then((description) => replaceInternalStreamId(this, description));
        },
      };
      window.RTCPeerConnection.prototype[method] = methodObj[method];
    });
    const origSetLocalDescription = window.RTCPeerConnection.prototype.setLocalDescription;
    window.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {
      if (!arguments.length || !arguments[0].type) {
        return origSetLocalDescription.apply(this, arguments);
      }
      arguments[0] = replaceExternalStreamId(this, arguments[0]);
      return origSetLocalDescription.apply(this, arguments);
    };

    // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier

    const origLocalDescription = Object.getOwnPropertyDescriptor(
      window.RTCPeerConnection.prototype,
      'localDescription'
    );
    Object.defineProperty(window.RTCPeerConnection.prototype, 'localDescription', {
      get() {
        const description = origLocalDescription.get.apply(this);
        if (description.type === '') {
          return description;
        }
        return replaceInternalStreamId(this, description);
      },
    });
    window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
      if (this.signalingState === 'closed') {
        throw new DOMException(
          "The RTCPeerConnection's signalingState is 'closed'.",
          'InvalidStateError'
        );
      }
      // We can not yet check for sender instanceof RTCRtpSender
      // since we shim RTPSender. So we check if sender._pc is set.
      if (!sender._pc) {
        throw new DOMException(
          'Argument 1 of RTCPeerConnection.removeTrack ' +
            'does not implement interface RTCRtpSender.',
          'TypeError'
        );
      }
      const isLocal = sender._pc === this;
      if (!isLocal) {
        throw new DOMException('Sender was not created by this connection.', 'InvalidAccessError');
      }

      // Search for the native stream the senders track belongs to.
      this._streams = this._streams || {};
      let stream;
      Object.keys(this._streams).forEach((streamid) => {
        const hasTrack = this._streams[streamid]
          .getTracks()
          .find((track) => sender.track === track);
        if (hasTrack) {
          stream = this._streams[streamid];
        }
      });
      if (stream) {
        if (stream.getTracks().length === 1) {
          // if this is the last track of the stream, remove the stream. This
          // takes care of any shimmed _senders.
          this.removeStream(this._reverseStreams[stream.id]);
        } else {
          // relying on the same odd chrome behaviour as above.
          stream.removeTrack(sender.track);
        }
        this.dispatchEvent(new Event('negotiationneeded'));
      }
    };
  }
  function shimPeerConnection$1(window, browserDetails) {
    if (!window.RTCPeerConnection && window.webkitRTCPeerConnection) {
      // very basic support for old versions.
      window.RTCPeerConnection = window.webkitRTCPeerConnection;
    }
    if (!window.RTCPeerConnection) {
      return;
    }

    // shim implicit creation of RTCSessionDescription/RTCIceCandidate
    if (browserDetails.version < 53) {
      ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function (method) {
        const nativeMethod = window.RTCPeerConnection.prototype[method];
        const methodObj = {
          [method]() {
            arguments[0] = new (
              method === 'addIceCandidate' ? window.RTCIceCandidate : window.RTCSessionDescription
            )(arguments[0]);
            return nativeMethod.apply(this, arguments);
          },
        };
        window.RTCPeerConnection.prototype[method] = methodObj[method];
      });
    }
  }

  // Attempt to fix ONN in plan-b mode.
  function fixNegotiationNeeded(window, browserDetails) {
    wrapPeerConnectionEvent(window, 'negotiationneeded', (e) => {
      const pc = e.target;
      if (
        browserDetails.version < 72 ||
        (pc.getConfiguration && pc.getConfiguration().sdpSemantics === 'plan-b')
      ) {
        if (pc.signalingState !== 'stable') {
          return;
        }
      }
      return e;
    });
  }

  var chromeShim = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    fixNegotiationNeeded: fixNegotiationNeeded,
    shimAddTrackRemoveTrack: shimAddTrackRemoveTrack,
    shimAddTrackRemoveTrackWithNative: shimAddTrackRemoveTrackWithNative,
    shimGetSendersWithDtmf: shimGetSendersWithDtmf,
    shimGetUserMedia: shimGetUserMedia$2,
    shimMediaStream: shimMediaStream,
    shimOnTrack: shimOnTrack$1,
    shimPeerConnection: shimPeerConnection$1,
    shimSenderReceiverGetStats: shimSenderReceiverGetStats,
  });

  /*
   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */
  /* eslint-env node */
  function shimGetUserMedia$1(window, browserDetails) {
    const navigator = window && window.navigator;
    const MediaStreamTrack = window && window.MediaStreamTrack;
    navigator.getUserMedia = function (constraints, onSuccess, onError) {
      // Replace Firefox 44+'s deprecation warning with unprefixed version.
      deprecated('navigator.getUserMedia', 'navigator.mediaDevices.getUserMedia');
      navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);
    };
    if (
      !(
        browserDetails.version > 55 &&
        'autoGainControl' in navigator.mediaDevices.getSupportedConstraints()
      )
    ) {
      const remap = function (obj, a, b) {
        if (a in obj && !(b in obj)) {
          obj[b] = obj[a];
          delete obj[a];
        }
      };
      const nativeGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
      navigator.mediaDevices.getUserMedia = function (c) {
        if (typeof c === 'object' && typeof c.audio === 'object') {
          c = JSON.parse(JSON.stringify(c));
          remap(c.audio, 'autoGainControl', 'mozAutoGainControl');
          remap(c.audio, 'noiseSuppression', 'mozNoiseSuppression');
        }
        return nativeGetUserMedia(c);
      };
      if (MediaStreamTrack && MediaStreamTrack.prototype.getSettings) {
        const nativeGetSettings = MediaStreamTrack.prototype.getSettings;
        MediaStreamTrack.prototype.getSettings = function () {
          const obj = nativeGetSettings.apply(this, arguments);
          remap(obj, 'mozAutoGainControl', 'autoGainControl');
          remap(obj, 'mozNoiseSuppression', 'noiseSuppression');
          return obj;
        };
      }
      if (MediaStreamTrack && MediaStreamTrack.prototype.applyConstraints) {
        const nativeApplyConstraints = MediaStreamTrack.prototype.applyConstraints;
        MediaStreamTrack.prototype.applyConstraints = function (c) {
          if (this.kind === 'audio' && typeof c === 'object') {
            c = JSON.parse(JSON.stringify(c));
            remap(c, 'autoGainControl', 'mozAutoGainControl');
            remap(c, 'noiseSuppression', 'mozNoiseSuppression');
          }
          return nativeApplyConstraints.apply(this, [c]);
        };
      }
    }
  }

  /*
   *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */
  /* eslint-env node */

  function shimGetDisplayMedia(window, preferredMediaSource) {
    if (window.navigator.mediaDevices && 'getDisplayMedia' in window.navigator.mediaDevices) {
      return;
    }
    if (!window.navigator.mediaDevices) {
      return;
    }
    window.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {
      if (!(constraints && constraints.video)) {
        const err = new DOMException('getDisplayMedia without video ' + 'constraints is undefined');
        err.name = 'NotFoundError';
        // from https://heycam.github.io/webidl/#idl-DOMException-error-names
        err.code = 8;
        return Promise.reject(err);
      }
      if (constraints.video === true) {
        constraints.video = {
          mediaSource: preferredMediaSource,
        };
      } else {
        constraints.video.mediaSource = preferredMediaSource;
      }
      return window.navigator.mediaDevices.getUserMedia(constraints);
    };
  }

  /*
   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */
  /* eslint-env node */
  function shimOnTrack(window) {
    if (
      typeof window === 'object' &&
      window.RTCTrackEvent &&
      'receiver' in window.RTCTrackEvent.prototype &&
      !('transceiver' in window.RTCTrackEvent.prototype)
    ) {
      Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {
        get() {
          return {
            receiver: this.receiver,
          };
        },
      });
    }
  }
  function shimPeerConnection(window, browserDetails) {
    if (typeof window !== 'object' || !(window.RTCPeerConnection || window.mozRTCPeerConnection)) {
      return; // probably media.peerconnection.enabled=false in about:config
    }
    if (!window.RTCPeerConnection && window.mozRTCPeerConnection) {
      // very basic support for old versions.
      window.RTCPeerConnection = window.mozRTCPeerConnection;
    }
    if (browserDetails.version < 53) {
      // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.
      ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function (method) {
        const nativeMethod = window.RTCPeerConnection.prototype[method];
        const methodObj = {
          [method]() {
            arguments[0] = new (
              method === 'addIceCandidate' ? window.RTCIceCandidate : window.RTCSessionDescription
            )(arguments[0]);
            return nativeMethod.apply(this, arguments);
          },
        };
        window.RTCPeerConnection.prototype[method] = methodObj[method];
      });
    }
    const modernStatsTypes = {
      inboundrtp: 'inbound-rtp',
      outboundrtp: 'outbound-rtp',
      candidatepair: 'candidate-pair',
      localcandidate: 'local-candidate',
      remotecandidate: 'remote-candidate',
    };
    const nativeGetStats = window.RTCPeerConnection.prototype.getStats;
    window.RTCPeerConnection.prototype.getStats = function getStats() {
      const [selector, onSucc, onErr] = arguments;
      return nativeGetStats
        .apply(this, [selector || null])
        .then((stats) => {
          if (browserDetails.version < 53 && !onSucc) {
            // Shim only promise getStats with spec-hyphens in type names
            // Leave callback version alone; misc old uses of forEach before Map
            try {
              stats.forEach((stat) => {
                stat.type = modernStatsTypes[stat.type] || stat.type;
              });
            } catch (e) {
              if (e.name !== 'TypeError') {
                throw e;
              }
              // Avoid TypeError: "type" is read-only, in old versions. 34-43ish
              stats.forEach((stat, i) => {
                stats.set(
                  i,
                  Object.assign({}, stat, {
                    type: modernStatsTypes[stat.type] || stat.type,
                  })
                );
              });
            }
          }
          return stats;
        })
        .then(onSucc, onErr);
    };
  }
  function shimSenderGetStats(window) {
    if (!(typeof window === 'object' && window.RTCPeerConnection && window.RTCRtpSender)) {
      return;
    }
    if (window.RTCRtpSender && 'getStats' in window.RTCRtpSender.prototype) {
      return;
    }
    const origGetSenders = window.RTCPeerConnection.prototype.getSenders;
    if (origGetSenders) {
      window.RTCPeerConnection.prototype.getSenders = function getSenders() {
        const senders = origGetSenders.apply(this, []);
        senders.forEach((sender) => (sender._pc = this));
        return senders;
      };
    }
    const origAddTrack = window.RTCPeerConnection.prototype.addTrack;
    if (origAddTrack) {
      window.RTCPeerConnection.prototype.addTrack = function addTrack() {
        const sender = origAddTrack.apply(this, arguments);
        sender._pc = this;
        return sender;
      };
    }
    window.RTCRtpSender.prototype.getStats = function getStats() {
      return this.track ? this._pc.getStats(this.track) : Promise.resolve(new Map());
    };
  }
  function shimReceiverGetStats(window) {
    if (!(typeof window === 'object' && window.RTCPeerConnection && window.RTCRtpSender)) {
      return;
    }
    if (window.RTCRtpSender && 'getStats' in window.RTCRtpReceiver.prototype) {
      return;
    }
    const origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;
    if (origGetReceivers) {
      window.RTCPeerConnection.prototype.getReceivers = function getReceivers() {
        const receivers = origGetReceivers.apply(this, []);
        receivers.forEach((receiver) => (receiver._pc = this));
        return receivers;
      };
    }
    wrapPeerConnectionEvent(window, 'track', (e) => {
      e.receiver._pc = e.srcElement;
      return e;
    });
    window.RTCRtpReceiver.prototype.getStats = function getStats() {
      return this._pc.getStats(this.track);
    };
  }
  function shimRemoveStream(window) {
    if (!window.RTCPeerConnection || 'removeStream' in window.RTCPeerConnection.prototype) {
      return;
    }
    window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
      deprecated('removeStream', 'removeTrack');
      this.getSenders().forEach((sender) => {
        if (sender.track && stream.getTracks().includes(sender.track)) {
          this.removeTrack(sender);
        }
      });
    };
  }
  function shimRTCDataChannel(window) {
    // rename DataChannel to RTCDataChannel (native fix in FF60):
    // https://bugzilla.mozilla.org/show_bug.cgi?id=1173851
    if (window.DataChannel && !window.RTCDataChannel) {
      window.RTCDataChannel = window.DataChannel;
    }
  }
  function shimAddTransceiver(window) {
    // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647
    // Firefox ignores the init sendEncodings options passed to addTransceiver
    // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918
    if (!(typeof window === 'object' && window.RTCPeerConnection)) {
      return;
    }
    const origAddTransceiver = window.RTCPeerConnection.prototype.addTransceiver;
    if (origAddTransceiver) {
      window.RTCPeerConnection.prototype.addTransceiver = function addTransceiver() {
        this.setParametersPromises = [];
        // WebIDL input coercion and validation
        let sendEncodings = arguments[1] && arguments[1].sendEncodings;
        if (sendEncodings === undefined) {
          sendEncodings = [];
        }
        sendEncodings = [...sendEncodings];
        const shouldPerformCheck = sendEncodings.length > 0;
        if (shouldPerformCheck) {
          // If sendEncodings params are provided, validate grammar
          sendEncodings.forEach((encodingParam) => {
            if ('rid' in encodingParam) {
              const ridRegex = /^[a-z0-9]{0,16}$/i;
              if (!ridRegex.test(encodingParam.rid)) {
                throw new TypeError('Invalid RID value provided.');
              }
            }
            if ('scaleResolutionDownBy' in encodingParam) {
              if (!(parseFloat(encodingParam.scaleResolutionDownBy) >= 1.0)) {
                throw new RangeError('scale_resolution_down_by must be >= 1.0');
              }
            }
            if ('maxFramerate' in encodingParam) {
              if (!(parseFloat(encodingParam.maxFramerate) >= 0)) {
                throw new RangeError('max_framerate must be >= 0.0');
              }
            }
          });
        }
        const transceiver = origAddTransceiver.apply(this, arguments);
        if (shouldPerformCheck) {
          // Check if the init options were applied. If not we do this in an
          // asynchronous way and save the promise reference in a global object.
          // This is an ugly hack, but at the same time is way more robust than
          // checking the sender parameters before and after the createOffer
          // Also note that after the createoffer we are not 100% sure that
          // the params were asynchronously applied so we might miss the
          // opportunity to recreate offer.
          const { sender } = transceiver;
          const params = sender.getParameters();
          if (
            !('encodings' in params) ||
            // Avoid being fooled by patched getParameters() below.
            (params.encodings.length === 1 && Object.keys(params.encodings[0]).length === 0)
          ) {
            params.encodings = sendEncodings;
            sender.sendEncodings = sendEncodings;
            this.setParametersPromises.push(
              sender
                .setParameters(params)
                .then(() => {
                  delete sender.sendEncodings;
                })
                .catch(() => {
                  delete sender.sendEncodings;
                })
            );
          }
        }
        return transceiver;
      };
    }
  }
  function shimGetParameters(window) {
    if (!(typeof window === 'object' && window.RTCRtpSender)) {
      return;
    }
    const origGetParameters = window.RTCRtpSender.prototype.getParameters;
    if (origGetParameters) {
      window.RTCRtpSender.prototype.getParameters = function getParameters() {
        const params = origGetParameters.apply(this, arguments);
        if (!('encodings' in params)) {
          params.encodings = [].concat(this.sendEncodings || [{}]);
        }
        return params;
      };
    }
  }
  function shimCreateOffer(window) {
    // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647
    // Firefox ignores the init sendEncodings options passed to addTransceiver
    // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918
    if (!(typeof window === 'object' && window.RTCPeerConnection)) {
      return;
    }
    const origCreateOffer = window.RTCPeerConnection.prototype.createOffer;
    window.RTCPeerConnection.prototype.createOffer = function createOffer() {
      if (this.setParametersPromises && this.setParametersPromises.length) {
        return Promise.all(this.setParametersPromises)
          .then(() => {
            return origCreateOffer.apply(this, arguments);
          })
          .finally(() => {
            this.setParametersPromises = [];
          });
      }
      return origCreateOffer.apply(this, arguments);
    };
  }
  function shimCreateAnswer(window) {
    // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647
    // Firefox ignores the init sendEncodings options passed to addTransceiver
    // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918
    if (!(typeof window === 'object' && window.RTCPeerConnection)) {
      return;
    }
    const origCreateAnswer = window.RTCPeerConnection.prototype.createAnswer;
    window.RTCPeerConnection.prototype.createAnswer = function createAnswer() {
      if (this.setParametersPromises && this.setParametersPromises.length) {
        return Promise.all(this.setParametersPromises)
          .then(() => {
            return origCreateAnswer.apply(this, arguments);
          })
          .finally(() => {
            this.setParametersPromises = [];
          });
      }
      return origCreateAnswer.apply(this, arguments);
    };
  }

  var firefoxShim = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    shimAddTransceiver: shimAddTransceiver,
    shimCreateAnswer: shimCreateAnswer,
    shimCreateOffer: shimCreateOffer,
    shimGetDisplayMedia: shimGetDisplayMedia,
    shimGetParameters: shimGetParameters,
    shimGetUserMedia: shimGetUserMedia$1,
    shimOnTrack: shimOnTrack,
    shimPeerConnection: shimPeerConnection,
    shimRTCDataChannel: shimRTCDataChannel,
    shimReceiverGetStats: shimReceiverGetStats,
    shimRemoveStream: shimRemoveStream,
    shimSenderGetStats: shimSenderGetStats,
  });

  /*
   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */
  function shimLocalStreamsAPI(window) {
    if (typeof window !== 'object' || !window.RTCPeerConnection) {
      return;
    }
    if (!('getLocalStreams' in window.RTCPeerConnection.prototype)) {
      window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
        if (!this._localStreams) {
          this._localStreams = [];
        }
        return this._localStreams;
      };
    }
    if (!('addStream' in window.RTCPeerConnection.prototype)) {
      const _addTrack = window.RTCPeerConnection.prototype.addTrack;
      window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
        if (!this._localStreams) {
          this._localStreams = [];
        }
        if (!this._localStreams.includes(stream)) {
          this._localStreams.push(stream);
        }
        // Try to emulate Chrome's behaviour of adding in audio-video order.
        // Safari orders by track id.
        stream.getAudioTracks().forEach((track) => _addTrack.call(this, track, stream));
        stream.getVideoTracks().forEach((track) => _addTrack.call(this, track, stream));
      };
      window.RTCPeerConnection.prototype.addTrack = function addTrack(track) {
        for (
          var _len = arguments.length, streams = new Array(_len > 1 ? _len - 1 : 0), _key = 1;
          _key < _len;
          _key++
        ) {
          streams[_key - 1] = arguments[_key];
        }
        if (streams) {
          streams.forEach((stream) => {
            if (!this._localStreams) {
              this._localStreams = [stream];
            } else if (!this._localStreams.includes(stream)) {
              this._localStreams.push(stream);
            }
          });
        }
        return _addTrack.apply(this, arguments);
      };
    }
    if (!('removeStream' in window.RTCPeerConnection.prototype)) {
      window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
        if (!this._localStreams) {
          this._localStreams = [];
        }
        const index = this._localStreams.indexOf(stream);
        if (index === -1) {
          return;
        }
        this._localStreams.splice(index, 1);
        const tracks = stream.getTracks();
        this.getSenders().forEach((sender) => {
          if (tracks.includes(sender.track)) {
            this.removeTrack(sender);
          }
        });
      };
    }
  }
  function shimRemoteStreamsAPI(window) {
    if (typeof window !== 'object' || !window.RTCPeerConnection) {
      return;
    }
    if (!('getRemoteStreams' in window.RTCPeerConnection.prototype)) {
      window.RTCPeerConnection.prototype.getRemoteStreams = function getRemoteStreams() {
        return this._remoteStreams ? this._remoteStreams : [];
      };
    }
    if (!('onaddstream' in window.RTCPeerConnection.prototype)) {
      Object.defineProperty(window.RTCPeerConnection.prototype, 'onaddstream', {
        get() {
          return this._onaddstream;
        },
        set(f) {
          if (this._onaddstream) {
            this.removeEventListener('addstream', this._onaddstream);
            this.removeEventListener('track', this._onaddstreampoly);
          }
          this.addEventListener('addstream', (this._onaddstream = f));
          this.addEventListener(
            'track',
            (this._onaddstreampoly = (e) => {
              e.streams.forEach((stream) => {
                if (!this._remoteStreams) {
                  this._remoteStreams = [];
                }
                if (this._remoteStreams.includes(stream)) {
                  return;
                }
                this._remoteStreams.push(stream);
                const event = new Event('addstream');
                event.stream = stream;
                this.dispatchEvent(event);
              });
            })
          );
        },
      });
      const origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;
      window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
        const pc = this;
        if (!this._onaddstreampoly) {
          this.addEventListener(
            'track',
            (this._onaddstreampoly = function (e) {
              e.streams.forEach((stream) => {
                if (!pc._remoteStreams) {
                  pc._remoteStreams = [];
                }
                if (pc._remoteStreams.indexOf(stream) >= 0) {
                  return;
                }
                pc._remoteStreams.push(stream);
                const event = new Event('addstream');
                event.stream = stream;
                pc.dispatchEvent(event);
              });
            })
          );
        }
        return origSetRemoteDescription.apply(pc, arguments);
      };
    }
  }
  function shimCallbacksAPI(window) {
    if (typeof window !== 'object' || !window.RTCPeerConnection) {
      return;
    }
    const prototype = window.RTCPeerConnection.prototype;
    const origCreateOffer = prototype.createOffer;
    const origCreateAnswer = prototype.createAnswer;
    const setLocalDescription = prototype.setLocalDescription;
    const setRemoteDescription = prototype.setRemoteDescription;
    const addIceCandidate = prototype.addIceCandidate;
    prototype.createOffer = function createOffer(successCallback, failureCallback) {
      const options = arguments.length >= 2 ? arguments[2] : arguments[0];
      const promise = origCreateOffer.apply(this, [options]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };
    prototype.createAnswer = function createAnswer(successCallback, failureCallback) {
      const options = arguments.length >= 2 ? arguments[2] : arguments[0];
      const promise = origCreateAnswer.apply(this, [options]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };
    let withCallback = function (description, successCallback, failureCallback) {
      const promise = setLocalDescription.apply(this, [description]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };
    prototype.setLocalDescription = withCallback;
    withCallback = function (description, successCallback, failureCallback) {
      const promise = setRemoteDescription.apply(this, [description]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };
    prototype.setRemoteDescription = withCallback;
    withCallback = function (candidate, successCallback, failureCallback) {
      const promise = addIceCandidate.apply(this, [candidate]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };
    prototype.addIceCandidate = withCallback;
  }
  function shimGetUserMedia(window) {
    const navigator = window && window.navigator;
    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
      // shim not needed in Safari 12.1
      const mediaDevices = navigator.mediaDevices;
      const _getUserMedia = mediaDevices.getUserMedia.bind(mediaDevices);
      navigator.mediaDevices.getUserMedia = (constraints) => {
        return _getUserMedia(shimConstraints(constraints));
      };
    }
    if (!navigator.getUserMedia && navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
      navigator.getUserMedia = function getUserMedia(constraints, cb, errcb) {
        navigator.mediaDevices.getUserMedia(constraints).then(cb, errcb);
      }.bind(navigator);
    }
  }
  function shimConstraints(constraints) {
    if (constraints && constraints.video !== undefined) {
      return Object.assign({}, constraints, {
        video: compactObject(constraints.video),
      });
    }
    return constraints;
  }
  function shimRTCIceServerUrls(window) {
    if (!window.RTCPeerConnection) {
      return;
    }
    // migrate from non-spec RTCIceServer.url to RTCIceServer.urls
    const OrigPeerConnection = window.RTCPeerConnection;
    window.RTCPeerConnection = function RTCPeerConnection(pcConfig, pcConstraints) {
      if (pcConfig && pcConfig.iceServers) {
        const newIceServers = [];
        for (let i = 0; i < pcConfig.iceServers.length; i++) {
          let server = pcConfig.iceServers[i];
          if (server.urls === undefined && server.url) {
            deprecated('RTCIceServer.url', 'RTCIceServer.urls');
            server = JSON.parse(JSON.stringify(server));
            server.urls = server.url;
            delete server.url;
            newIceServers.push(server);
          } else {
            newIceServers.push(pcConfig.iceServers[i]);
          }
        }
        pcConfig.iceServers = newIceServers;
      }
      return new OrigPeerConnection(pcConfig, pcConstraints);
    };
    window.RTCPeerConnection.prototype = OrigPeerConnection.prototype;
    // wrap static methods. Currently just generateCertificate.
    if ('generateCertificate' in OrigPeerConnection) {
      Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
        get() {
          return OrigPeerConnection.generateCertificate;
        },
      });
    }
  }
  function shimTrackEventTransceiver(window) {
    // Add event.transceiver member over deprecated event.receiver
    if (
      typeof window === 'object' &&
      window.RTCTrackEvent &&
      'receiver' in window.RTCTrackEvent.prototype &&
      !('transceiver' in window.RTCTrackEvent.prototype)
    ) {
      Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {
        get() {
          return {
            receiver: this.receiver,
          };
        },
      });
    }
  }
  function shimCreateOfferLegacy(window) {
    const origCreateOffer = window.RTCPeerConnection.prototype.createOffer;
    window.RTCPeerConnection.prototype.createOffer = function createOffer(offerOptions) {
      if (offerOptions) {
        if (typeof offerOptions.offerToReceiveAudio !== 'undefined') {
          // support bit values
          offerOptions.offerToReceiveAudio = !!offerOptions.offerToReceiveAudio;
        }
        const audioTransceiver = this.getTransceivers().find(
          (transceiver) => transceiver.receiver.track.kind === 'audio'
        );
        if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {
          if (audioTransceiver.direction === 'sendrecv') {
            if (audioTransceiver.setDirection) {
              audioTransceiver.setDirection('sendonly');
            } else {
              audioTransceiver.direction = 'sendonly';
            }
          } else if (audioTransceiver.direction === 'recvonly') {
            if (audioTransceiver.setDirection) {
              audioTransceiver.setDirection('inactive');
            } else {
              audioTransceiver.direction = 'inactive';
            }
          }
        } else if (offerOptions.offerToReceiveAudio === true && !audioTransceiver) {
          this.addTransceiver('audio', {
            direction: 'recvonly',
          });
        }
        if (typeof offerOptions.offerToReceiveVideo !== 'undefined') {
          // support bit values
          offerOptions.offerToReceiveVideo = !!offerOptions.offerToReceiveVideo;
        }
        const videoTransceiver = this.getTransceivers().find(
          (transceiver) => transceiver.receiver.track.kind === 'video'
        );
        if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {
          if (videoTransceiver.direction === 'sendrecv') {
            if (videoTransceiver.setDirection) {
              videoTransceiver.setDirection('sendonly');
            } else {
              videoTransceiver.direction = 'sendonly';
            }
          } else if (videoTransceiver.direction === 'recvonly') {
            if (videoTransceiver.setDirection) {
              videoTransceiver.setDirection('inactive');
            } else {
              videoTransceiver.direction = 'inactive';
            }
          }
        } else if (offerOptions.offerToReceiveVideo === true && !videoTransceiver) {
          this.addTransceiver('video', {
            direction: 'recvonly',
          });
        }
      }
      return origCreateOffer.apply(this, arguments);
    };
  }
  function shimAudioContext(window) {
    if (typeof window !== 'object' || window.AudioContext) {
      return;
    }
    window.AudioContext = window.webkitAudioContext;
  }

  var safariShim = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    shimAudioContext: shimAudioContext,
    shimCallbacksAPI: shimCallbacksAPI,
    shimConstraints: shimConstraints,
    shimCreateOfferLegacy: shimCreateOfferLegacy,
    shimGetUserMedia: shimGetUserMedia,
    shimLocalStreamsAPI: shimLocalStreamsAPI,
    shimRTCIceServerUrls: shimRTCIceServerUrls,
    shimRemoteStreamsAPI: shimRemoteStreamsAPI,
    shimTrackEventTransceiver: shimTrackEventTransceiver,
  });

  var sdp$1 = { exports: {} };

  /* eslint-env node */
  var hasRequiredSdp;
  function requireSdp() {
    if (hasRequiredSdp) return sdp$1.exports;
    hasRequiredSdp = 1;
    (function (module) {
      // SDP helpers.
      const SDPUtils = {};

      // Generate an alphanumeric identifier for cname or mids.
      // TODO: use UUIDs instead? https://gist.github.com/jed/982883
      SDPUtils.generateIdentifier = function () {
        return Math.random().toString(36).substring(2, 12);
      };

      // The RTCP CNAME used by all peerconnections from the same JS.
      SDPUtils.localCName = SDPUtils.generateIdentifier();

      // Splits SDP into lines, dealing with both CRLF and LF.
      SDPUtils.splitLines = function (blob) {
        return blob
          .trim()
          .split('\n')
          .map((line) => line.trim());
      };
      // Splits SDP into sessionpart and mediasections. Ensures CRLF.
      SDPUtils.splitSections = function (blob) {
        const parts = blob.split('\nm=');
        return parts.map((part, index) => (index > 0 ? 'm=' + part : part).trim() + '\r\n');
      };

      // Returns the session description.
      SDPUtils.getDescription = function (blob) {
        const sections = SDPUtils.splitSections(blob);
        return sections && sections[0];
      };

      // Returns the individual media sections.
      SDPUtils.getMediaSections = function (blob) {
        const sections = SDPUtils.splitSections(blob);
        sections.shift();
        return sections;
      };

      // Returns lines that start with a certain prefix.
      SDPUtils.matchPrefix = function (blob, prefix) {
        return SDPUtils.splitLines(blob).filter((line) => line.indexOf(prefix) === 0);
      };

      // Parses an ICE candidate line. Sample input:
      // candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8
      // rport 55996"
      // Input can be prefixed with a=.
      SDPUtils.parseCandidate = function (line) {
        let parts;
        // Parse both variants.
        if (line.indexOf('a=candidate:') === 0) {
          parts = line.substring(12).split(' ');
        } else {
          parts = line.substring(10).split(' ');
        }
        const candidate = {
          foundation: parts[0],
          component:
            {
              1: 'rtp',
              2: 'rtcp',
            }[parts[1]] || parts[1],
          protocol: parts[2].toLowerCase(),
          priority: parseInt(parts[3], 10),
          ip: parts[4],
          address: parts[4],
          // address is an alias for ip.
          port: parseInt(parts[5], 10),
          // skip parts[6] == 'typ'
          type: parts[7],
        };
        for (let i = 8; i < parts.length; i += 2) {
          switch (parts[i]) {
            case 'raddr':
              candidate.relatedAddress = parts[i + 1];
              break;
            case 'rport':
              candidate.relatedPort = parseInt(parts[i + 1], 10);
              break;
            case 'tcptype':
              candidate.tcpType = parts[i + 1];
              break;
            case 'ufrag':
              candidate.ufrag = parts[i + 1]; // for backward compatibility.
              candidate.usernameFragment = parts[i + 1];
              break;
            default:
              // extension handling, in particular ufrag. Don't overwrite.
              if (candidate[parts[i]] === undefined) {
                candidate[parts[i]] = parts[i + 1];
              }
              break;
          }
        }
        return candidate;
      };

      // Translates a candidate object into SDP candidate attribute.
      // This does not include the a= prefix!
      SDPUtils.writeCandidate = function (candidate) {
        const sdp = [];
        sdp.push(candidate.foundation);
        const component = candidate.component;
        if (component === 'rtp') {
          sdp.push(1);
        } else if (component === 'rtcp') {
          sdp.push(2);
        } else {
          sdp.push(component);
        }
        sdp.push(candidate.protocol.toUpperCase());
        sdp.push(candidate.priority);
        sdp.push(candidate.address || candidate.ip);
        sdp.push(candidate.port);
        const type = candidate.type;
        sdp.push('typ');
        sdp.push(type);
        if (type !== 'host' && candidate.relatedAddress && candidate.relatedPort) {
          sdp.push('raddr');
          sdp.push(candidate.relatedAddress);
          sdp.push('rport');
          sdp.push(candidate.relatedPort);
        }
        if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {
          sdp.push('tcptype');
          sdp.push(candidate.tcpType);
        }
        if (candidate.usernameFragment || candidate.ufrag) {
          sdp.push('ufrag');
          sdp.push(candidate.usernameFragment || candidate.ufrag);
        }
        return 'candidate:' + sdp.join(' ');
      };

      // Parses an ice-options line, returns an array of option tags.
      // Sample input:
      // a=ice-options:foo bar
      SDPUtils.parseIceOptions = function (line) {
        return line.substring(14).split(' ');
      };

      // Parses a rtpmap line, returns RTCRtpCoddecParameters. Sample input:
      // a=rtpmap:111 opus/48000/2
      SDPUtils.parseRtpMap = function (line) {
        let parts = line.substring(9).split(' ');
        const parsed = {
          payloadType: parseInt(parts.shift(), 10), // was: id
        };
        parts = parts[0].split('/');
        parsed.name = parts[0];
        parsed.clockRate = parseInt(parts[1], 10); // was: clockrate
        parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;
        // legacy alias, got renamed back to channels in ORTC.
        parsed.numChannels = parsed.channels;
        return parsed;
      };

      // Generates a rtpmap line from RTCRtpCodecCapability or
      // RTCRtpCodecParameters.
      SDPUtils.writeRtpMap = function (codec) {
        let pt = codec.payloadType;
        if (codec.preferredPayloadType !== undefined) {
          pt = codec.preferredPayloadType;
        }
        const channels = codec.channels || codec.numChannels || 1;
        return (
          'a=rtpmap:' +
          pt +
          ' ' +
          codec.name +
          '/' +
          codec.clockRate +
          (channels !== 1 ? '/' + channels : '') +
          '\r\n'
        );
      };

      // Parses a extmap line (headerextension from RFC 5285). Sample input:
      // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
      // a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset
      SDPUtils.parseExtmap = function (line) {
        const parts = line.substring(9).split(' ');
        return {
          id: parseInt(parts[0], 10),
          direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',
          uri: parts[1],
          attributes: parts.slice(2).join(' '),
        };
      };

      // Generates an extmap line from RTCRtpHeaderExtensionParameters or
      // RTCRtpHeaderExtension.
      SDPUtils.writeExtmap = function (headerExtension) {
        return (
          'a=extmap:' +
          (headerExtension.id || headerExtension.preferredId) +
          (headerExtension.direction && headerExtension.direction !== 'sendrecv'
            ? '/' + headerExtension.direction
            : '') +
          ' ' +
          headerExtension.uri +
          (headerExtension.attributes ? ' ' + headerExtension.attributes : '') +
          '\r\n'
        );
      };

      // Parses a fmtp line, returns dictionary. Sample input:
      // a=fmtp:96 vbr=on;cng=on
      // Also deals with vbr=on; cng=on
      SDPUtils.parseFmtp = function (line) {
        const parsed = {};
        let kv;
        const parts = line.substring(line.indexOf(' ') + 1).split(';');
        for (let j = 0; j < parts.length; j++) {
          kv = parts[j].trim().split('=');
          parsed[kv[0].trim()] = kv[1];
        }
        return parsed;
      };

      // Generates a fmtp line from RTCRtpCodecCapability or RTCRtpCodecParameters.
      SDPUtils.writeFmtp = function (codec) {
        let line = '';
        let pt = codec.payloadType;
        if (codec.preferredPayloadType !== undefined) {
          pt = codec.preferredPayloadType;
        }
        if (codec.parameters && Object.keys(codec.parameters).length) {
          const params = [];
          Object.keys(codec.parameters).forEach((param) => {
            if (codec.parameters[param] !== undefined) {
              params.push(param + '=' + codec.parameters[param]);
            } else {
              params.push(param);
            }
          });
          line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\r\n';
        }
        return line;
      };

      // Parses a rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:
      // a=rtcp-fb:98 nack rpsi
      SDPUtils.parseRtcpFb = function (line) {
        const parts = line.substring(line.indexOf(' ') + 1).split(' ');
        return {
          type: parts.shift(),
          parameter: parts.join(' '),
        };
      };

      // Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.
      SDPUtils.writeRtcpFb = function (codec) {
        let lines = '';
        let pt = codec.payloadType;
        if (codec.preferredPayloadType !== undefined) {
          pt = codec.preferredPayloadType;
        }
        if (codec.rtcpFeedback && codec.rtcpFeedback.length) {
          // FIXME: special handling for trr-int?
          codec.rtcpFeedback.forEach((fb) => {
            lines +=
              'a=rtcp-fb:' +
              pt +
              ' ' +
              fb.type +
              (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') +
              '\r\n';
          });
        }
        return lines;
      };

      // Parses a RFC 5576 ssrc media attribute. Sample input:
      // a=ssrc:3735928559 cname:something
      SDPUtils.parseSsrcMedia = function (line) {
        const sp = line.indexOf(' ');
        const parts = {
          ssrc: parseInt(line.substring(7, sp), 10),
        };
        const colon = line.indexOf(':', sp);
        if (colon > -1) {
          parts.attribute = line.substring(sp + 1, colon);
          parts.value = line.substring(colon + 1);
        } else {
          parts.attribute = line.substring(sp + 1);
        }
        return parts;
      };

      // Parse a ssrc-group line (see RFC 5576). Sample input:
      // a=ssrc-group:semantics 12 34
      SDPUtils.parseSsrcGroup = function (line) {
        const parts = line.substring(13).split(' ');
        return {
          semantics: parts.shift(),
          ssrcs: parts.map((ssrc) => parseInt(ssrc, 10)),
        };
      };

      // Extracts the MID (RFC 5888) from a media section.
      // Returns the MID or undefined if no mid line was found.
      SDPUtils.getMid = function (mediaSection) {
        const mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];
        if (mid) {
          return mid.substring(6);
        }
      };

      // Parses a fingerprint line for DTLS-SRTP.
      SDPUtils.parseFingerprint = function (line) {
        const parts = line.substring(14).split(' ');
        return {
          algorithm: parts[0].toLowerCase(),
          // algorithm is case-sensitive in Edge.
          value: parts[1].toUpperCase(), // the definition is upper-case in RFC 4572.
        };
      };

      // Extracts DTLS parameters from SDP media section or sessionpart.
      // FIXME: for consistency with other functions this should only
      //   get the fingerprint line as input. See also getIceParameters.
      SDPUtils.getDtlsParameters = function (mediaSection, sessionpart) {
        const lines = SDPUtils.matchPrefix(mediaSection + sessionpart, 'a=fingerprint:');
        // Note: a=setup line is ignored since we use the 'auto' role in Edge.
        return {
          role: 'auto',
          fingerprints: lines.map(SDPUtils.parseFingerprint),
        };
      };

      // Serializes DTLS parameters to SDP.
      SDPUtils.writeDtlsParameters = function (params, setupType) {
        let sdp = 'a=setup:' + setupType + '\r\n';
        params.fingerprints.forEach((fp) => {
          sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\r\n';
        });
        return sdp;
      };

      // Parses a=crypto lines into
      //   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#dictionary-rtcsrtpsdesparameters-members
      SDPUtils.parseCryptoLine = function (line) {
        const parts = line.substring(9).split(' ');
        return {
          tag: parseInt(parts[0], 10),
          cryptoSuite: parts[1],
          keyParams: parts[2],
          sessionParams: parts.slice(3),
        };
      };
      SDPUtils.writeCryptoLine = function (parameters) {
        return (
          'a=crypto:' +
          parameters.tag +
          ' ' +
          parameters.cryptoSuite +
          ' ' +
          (typeof parameters.keyParams === 'object'
            ? SDPUtils.writeCryptoKeyParams(parameters.keyParams)
            : parameters.keyParams) +
          (parameters.sessionParams ? ' ' + parameters.sessionParams.join(' ') : '') +
          '\r\n'
        );
      };

      // Parses the crypto key parameters into
      //   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#rtcsrtpkeyparam*
      SDPUtils.parseCryptoKeyParams = function (keyParams) {
        if (keyParams.indexOf('inline:') !== 0) {
          return null;
        }
        const parts = keyParams.substring(7).split('|');
        return {
          keyMethod: 'inline',
          keySalt: parts[0],
          lifeTime: parts[1],
          mkiValue: parts[2] ? parts[2].split(':')[0] : undefined,
          mkiLength: parts[2] ? parts[2].split(':')[1] : undefined,
        };
      };
      SDPUtils.writeCryptoKeyParams = function (keyParams) {
        return (
          keyParams.keyMethod +
          ':' +
          keyParams.keySalt +
          (keyParams.lifeTime ? '|' + keyParams.lifeTime : '') +
          (keyParams.mkiValue && keyParams.mkiLength
            ? '|' + keyParams.mkiValue + ':' + keyParams.mkiLength
            : '')
        );
      };

      // Extracts all SDES parameters.
      SDPUtils.getCryptoParameters = function (mediaSection, sessionpart) {
        const lines = SDPUtils.matchPrefix(mediaSection + sessionpart, 'a=crypto:');
        return lines.map(SDPUtils.parseCryptoLine);
      };

      // Parses ICE information from SDP media section or sessionpart.
      // FIXME: for consistency with other functions this should only
      //   get the ice-ufrag and ice-pwd lines as input.
      SDPUtils.getIceParameters = function (mediaSection, sessionpart) {
        const ufrag = SDPUtils.matchPrefix(mediaSection + sessionpart, 'a=ice-ufrag:')[0];
        const pwd = SDPUtils.matchPrefix(mediaSection + sessionpart, 'a=ice-pwd:')[0];
        if (!(ufrag && pwd)) {
          return null;
        }
        return {
          usernameFragment: ufrag.substring(12),
          password: pwd.substring(10),
        };
      };

      // Serializes ICE parameters to SDP.
      SDPUtils.writeIceParameters = function (params) {
        let sdp =
          'a=ice-ufrag:' +
          params.usernameFragment +
          '\r\n' +
          'a=ice-pwd:' +
          params.password +
          '\r\n';
        if (params.iceLite) {
          sdp += 'a=ice-lite\r\n';
        }
        return sdp;
      };

      // Parses the SDP media section and returns RTCRtpParameters.
      SDPUtils.parseRtpParameters = function (mediaSection) {
        const description = {
          codecs: [],
          headerExtensions: [],
          fecMechanisms: [],
          rtcp: [],
        };
        const lines = SDPUtils.splitLines(mediaSection);
        const mline = lines[0].split(' ');
        description.profile = mline[2];
        for (let i = 3; i < mline.length; i++) {
          // find all codecs from mline[3..]
          const pt = mline[i];
          const rtpmapline = SDPUtils.matchPrefix(mediaSection, 'a=rtpmap:' + pt + ' ')[0];
          if (rtpmapline) {
            const codec = SDPUtils.parseRtpMap(rtpmapline);
            const fmtps = SDPUtils.matchPrefix(mediaSection, 'a=fmtp:' + pt + ' ');
            // Only the first a=fmtp:<pt> is considered.
            codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};
            codec.rtcpFeedback = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-fb:' + pt + ' ').map(
              SDPUtils.parseRtcpFb
            );
            description.codecs.push(codec);
            // parse FEC mechanisms from rtpmap lines.
            switch (codec.name.toUpperCase()) {
              case 'RED':
              case 'ULPFEC':
                description.fecMechanisms.push(codec.name.toUpperCase());
                break;
            }
          }
        }
        SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach((line) => {
          description.headerExtensions.push(SDPUtils.parseExtmap(line));
        });
        const wildcardRtcpFb = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-fb:* ').map(
          SDPUtils.parseRtcpFb
        );
        description.codecs.forEach((codec) => {
          wildcardRtcpFb.forEach((fb) => {
            const duplicate = codec.rtcpFeedback.find((existingFeedback) => {
              return (
                existingFeedback.type === fb.type && existingFeedback.parameter === fb.parameter
              );
            });
            if (!duplicate) {
              codec.rtcpFeedback.push(fb);
            }
          });
        });
        // FIXME: parse rtcp.
        return description;
      };

      // Generates parts of the SDP media section describing the capabilities /
      // parameters.
      SDPUtils.writeRtpDescription = function (kind, caps) {
        let sdp = '';

        // Build the mline.
        sdp += 'm=' + kind + ' ';
        sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.
        sdp += ' ' + (caps.profile || 'UDP/TLS/RTP/SAVPF') + ' ';
        sdp +=
          caps.codecs
            .map((codec) => {
              if (codec.preferredPayloadType !== undefined) {
                return codec.preferredPayloadType;
              }
              return codec.payloadType;
            })
            .join(' ') + '\r\n';
        sdp += 'c=IN IP4 0.0.0.0\r\n';
        sdp += 'a=rtcp:9 IN IP4 0.0.0.0\r\n';

        // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.
        caps.codecs.forEach((codec) => {
          sdp += SDPUtils.writeRtpMap(codec);
          sdp += SDPUtils.writeFmtp(codec);
          sdp += SDPUtils.writeRtcpFb(codec);
        });
        let maxptime = 0;
        caps.codecs.forEach((codec) => {
          if (codec.maxptime > maxptime) {
            maxptime = codec.maxptime;
          }
        });
        if (maxptime > 0) {
          sdp += 'a=maxptime:' + maxptime + '\r\n';
        }
        if (caps.headerExtensions) {
          caps.headerExtensions.forEach((extension) => {
            sdp += SDPUtils.writeExtmap(extension);
          });
        }
        // FIXME: write fecMechanisms.
        return sdp;
      };

      // Parses the SDP media section and returns an array of
      // RTCRtpEncodingParameters.
      SDPUtils.parseRtpEncodingParameters = function (mediaSection) {
        const encodingParameters = [];
        const description = SDPUtils.parseRtpParameters(mediaSection);
        const hasRed = description.fecMechanisms.indexOf('RED') !== -1;
        const hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;

        // filter a=ssrc:... cname:, ignore PlanB-msid
        const ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
          .map((line) => SDPUtils.parseSsrcMedia(line))
          .filter((parts) => parts.attribute === 'cname');
        const primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;
        let secondarySsrc;
        const flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID').map((line) => {
          const parts = line.substring(17).split(' ');
          return parts.map((part) => parseInt(part, 10));
        });
        if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {
          secondarySsrc = flows[0][1];
        }
        description.codecs.forEach((codec) => {
          if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {
            let encParam = {
              ssrc: primarySsrc,
              codecPayloadType: parseInt(codec.parameters.apt, 10),
            };
            if (primarySsrc && secondarySsrc) {
              encParam.rtx = {
                ssrc: secondarySsrc,
              };
            }
            encodingParameters.push(encParam);
            if (hasRed) {
              encParam = JSON.parse(JSON.stringify(encParam));
              encParam.fec = {
                ssrc: primarySsrc,
                mechanism: hasUlpfec ? 'red+ulpfec' : 'red',
              };
              encodingParameters.push(encParam);
            }
          }
        });
        if (encodingParameters.length === 0 && primarySsrc) {
          encodingParameters.push({
            ssrc: primarySsrc,
          });
        }

        // we support both b=AS and b=TIAS but interpret AS as TIAS.
        let bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');
        if (bandwidth.length) {
          if (bandwidth[0].indexOf('b=TIAS:') === 0) {
            bandwidth = parseInt(bandwidth[0].substring(7), 10);
          } else if (bandwidth[0].indexOf('b=AS:') === 0) {
            // use formula from JSEP to convert b=AS to TIAS value.
            bandwidth = parseInt(bandwidth[0].substring(5), 10) * 1000 * 0.95 - 50 * 40 * 8;
          } else {
            bandwidth = undefined;
          }
          encodingParameters.forEach((params) => {
            params.maxBitrate = bandwidth;
          });
        }
        return encodingParameters;
      };

      // parses http://draft.ortc.org/#rtcrtcpparameters*
      SDPUtils.parseRtcpParameters = function (mediaSection) {
        const rtcpParameters = {};

        // Gets the first SSRC. Note that with RTX there might be multiple
        // SSRCs.
        const remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
          .map((line) => SDPUtils.parseSsrcMedia(line))
          .filter((obj) => obj.attribute === 'cname')[0];
        if (remoteSsrc) {
          rtcpParameters.cname = remoteSsrc.value;
          rtcpParameters.ssrc = remoteSsrc.ssrc;
        }

        // Edge uses the compound attribute instead of reducedSize
        // compound is !reducedSize
        const rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');
        rtcpParameters.reducedSize = rsize.length > 0;
        rtcpParameters.compound = rsize.length === 0;

        // parses the rtcp-mux attrbute.
        // Note that Edge does not support unmuxed RTCP.
        const mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');
        rtcpParameters.mux = mux.length > 0;
        return rtcpParameters;
      };
      SDPUtils.writeRtcpParameters = function (rtcpParameters) {
        let sdp = '';
        if (rtcpParameters.reducedSize) {
          sdp += 'a=rtcp-rsize\r\n';
        }
        if (rtcpParameters.mux) {
          sdp += 'a=rtcp-mux\r\n';
        }
        if (rtcpParameters.ssrc !== undefined && rtcpParameters.cname) {
          sdp += 'a=ssrc:' + rtcpParameters.ssrc + ' cname:' + rtcpParameters.cname + '\r\n';
        }
        return sdp;
      };

      // parses either a=msid: or a=ssrc:... msid lines and returns
      // the id of the MediaStream and MediaStreamTrack.
      SDPUtils.parseMsid = function (mediaSection) {
        let parts;
        const spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');
        if (spec.length === 1) {
          parts = spec[0].substring(7).split(' ');
          return {
            stream: parts[0],
            track: parts[1],
          };
        }
        const planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
          .map((line) => SDPUtils.parseSsrcMedia(line))
          .filter((msidParts) => msidParts.attribute === 'msid');
        if (planB.length > 0) {
          parts = planB[0].value.split(' ');
          return {
            stream: parts[0],
            track: parts[1],
          };
        }
      };

      // SCTP
      // parses draft-ietf-mmusic-sctp-sdp-26 first and falls back
      // to draft-ietf-mmusic-sctp-sdp-05
      SDPUtils.parseSctpDescription = function (mediaSection) {
        const mline = SDPUtils.parseMLine(mediaSection);
        const maxSizeLine = SDPUtils.matchPrefix(mediaSection, 'a=max-message-size:');
        let maxMessageSize;
        if (maxSizeLine.length > 0) {
          maxMessageSize = parseInt(maxSizeLine[0].substring(19), 10);
        }
        if (isNaN(maxMessageSize)) {
          maxMessageSize = 65536;
        }
        const sctpPort = SDPUtils.matchPrefix(mediaSection, 'a=sctp-port:');
        if (sctpPort.length > 0) {
          return {
            port: parseInt(sctpPort[0].substring(12), 10),
            protocol: mline.fmt,
            maxMessageSize,
          };
        }
        const sctpMapLines = SDPUtils.matchPrefix(mediaSection, 'a=sctpmap:');
        if (sctpMapLines.length > 0) {
          const parts = sctpMapLines[0].substring(10).split(' ');
          return {
            port: parseInt(parts[0], 10),
            protocol: parts[1],
            maxMessageSize,
          };
        }
      };

      // SCTP
      // outputs the draft-ietf-mmusic-sctp-sdp-26 version that all browsers
      // support by now receiving in this format, unless we originally parsed
      // as the draft-ietf-mmusic-sctp-sdp-05 format (indicated by the m-line
      // protocol of DTLS/SCTP -- without UDP/ or TCP/)
      SDPUtils.writeSctpDescription = function (media, sctp) {
        let output = [];
        if (media.protocol !== 'DTLS/SCTP') {
          output = [
            'm=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.protocol + '\r\n',
            'c=IN IP4 0.0.0.0\r\n',
            'a=sctp-port:' + sctp.port + '\r\n',
          ];
        } else {
          output = [
            'm=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.port + '\r\n',
            'c=IN IP4 0.0.0.0\r\n',
            'a=sctpmap:' + sctp.port + ' ' + sctp.protocol + ' 65535\r\n',
          ];
        }
        if (sctp.maxMessageSize !== undefined) {
          output.push('a=max-message-size:' + sctp.maxMessageSize + '\r\n');
        }
        return output.join('');
      };

      // Generate a session ID for SDP.
      // https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1
      // recommends using a cryptographically random +ve 64-bit value
      // but right now this should be acceptable and within the right range
      SDPUtils.generateSessionId = function () {
        return Math.random().toString().substr(2, 22);
      };

      // Write boiler plate for start of SDP
      // sessId argument is optional - if not supplied it will
      // be generated randomly
      // sessVersion is optional and defaults to 2
      // sessUser is optional and defaults to 'thisisadapterortc'
      SDPUtils.writeSessionBoilerplate = function (sessId, sessVer, sessUser) {
        let sessionId;
        const version = sessVer !== undefined ? sessVer : 2;
        if (sessId) {
          sessionId = sessId;
        } else {
          sessionId = SDPUtils.generateSessionId();
        }
        const user = sessUser || 'thisisadapterortc';
        // FIXME: sess-id should be an NTP timestamp.
        return (
          'v=0\r\n' +
          'o=' +
          user +
          ' ' +
          sessionId +
          ' ' +
          version +
          ' IN IP4 127.0.0.1\r\n' +
          's=-\r\n' +
          't=0 0\r\n'
        );
      };

      // Gets the direction from the mediaSection or the sessionpart.
      SDPUtils.getDirection = function (mediaSection, sessionpart) {
        // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.
        const lines = SDPUtils.splitLines(mediaSection);
        for (let i = 0; i < lines.length; i++) {
          switch (lines[i]) {
            case 'a=sendrecv':
            case 'a=sendonly':
            case 'a=recvonly':
            case 'a=inactive':
              return lines[i].substring(2);
            // FIXME: What should happen here?
          }
        }
        if (sessionpart) {
          return SDPUtils.getDirection(sessionpart);
        }
        return 'sendrecv';
      };
      SDPUtils.getKind = function (mediaSection) {
        const lines = SDPUtils.splitLines(mediaSection);
        const mline = lines[0].split(' ');
        return mline[0].substring(2);
      };
      SDPUtils.isRejected = function (mediaSection) {
        return mediaSection.split(' ', 2)[1] === '0';
      };
      SDPUtils.parseMLine = function (mediaSection) {
        const lines = SDPUtils.splitLines(mediaSection);
        const parts = lines[0].substring(2).split(' ');
        return {
          kind: parts[0],
          port: parseInt(parts[1], 10),
          protocol: parts[2],
          fmt: parts.slice(3).join(' '),
        };
      };
      SDPUtils.parseOLine = function (mediaSection) {
        const line = SDPUtils.matchPrefix(mediaSection, 'o=')[0];
        const parts = line.substring(2).split(' ');
        return {
          username: parts[0],
          sessionId: parts[1],
          sessionVersion: parseInt(parts[2], 10),
          netType: parts[3],
          addressType: parts[4],
          address: parts[5],
        };
      };

      // a very naive interpretation of a valid SDP.
      SDPUtils.isValidSDP = function (blob) {
        if (typeof blob !== 'string' || blob.length === 0) {
          return false;
        }
        const lines = SDPUtils.splitLines(blob);
        for (let i = 0; i < lines.length; i++) {
          if (lines[i].length < 2 || lines[i].charAt(1) !== '=') {
            return false;
          }
          // TODO: check the modifier a bit more.
        }
        return true;
      };

      // Expose public methods.
      {
        module.exports = SDPUtils;
      }
    })(sdp$1);
    return sdp$1.exports;
  }

  var sdpExports = requireSdp();
  var SDPUtils = /*@__PURE__*/ getDefaultExportFromCjs(sdpExports);

  var sdp = /*#__PURE__*/ _mergeNamespaces(
    {
      __proto__: null,
      default: SDPUtils,
    },
    [sdpExports]
  );

  /*
   *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */
  /* eslint-env node */
  function shimRTCIceCandidate(window) {
    // foundation is arbitrarily chosen as an indicator for full support for
    // https://w3c.github.io/webrtc-pc/#rtcicecandidate-interface
    if (
      !window.RTCIceCandidate ||
      (window.RTCIceCandidate && 'foundation' in window.RTCIceCandidate.prototype)
    ) {
      return;
    }
    const NativeRTCIceCandidate = window.RTCIceCandidate;
    window.RTCIceCandidate = function RTCIceCandidate(args) {
      // Remove the a= which shouldn't be part of the candidate string.
      if (typeof args === 'object' && args.candidate && args.candidate.indexOf('a=') === 0) {
        args = JSON.parse(JSON.stringify(args));
        args.candidate = args.candidate.substring(2);
      }
      if (args.candidate && args.candidate.length) {
        // Augment the native candidate with the parsed fields.
        const nativeCandidate = new NativeRTCIceCandidate(args);
        const parsedCandidate = SDPUtils.parseCandidate(args.candidate);
        for (const key in parsedCandidate) {
          if (!(key in nativeCandidate)) {
            Object.defineProperty(nativeCandidate, key, {
              value: parsedCandidate[key],
            });
          }
        }

        // Override serializer to not serialize the extra attributes.
        nativeCandidate.toJSON = function toJSON() {
          return {
            candidate: nativeCandidate.candidate,
            sdpMid: nativeCandidate.sdpMid,
            sdpMLineIndex: nativeCandidate.sdpMLineIndex,
            usernameFragment: nativeCandidate.usernameFragment,
          };
        };
        return nativeCandidate;
      }
      return new NativeRTCIceCandidate(args);
    };
    window.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype;

    // Hook up the augmented candidate in onicecandidate and
    // addEventListener('icecandidate', ...)
    wrapPeerConnectionEvent(window, 'icecandidate', (e) => {
      if (e.candidate) {
        Object.defineProperty(e, 'candidate', {
          value: new window.RTCIceCandidate(e.candidate),
          writable: 'false',
        });
      }
      return e;
    });
  }
  function shimRTCIceCandidateRelayProtocol(window) {
    if (
      !window.RTCIceCandidate ||
      (window.RTCIceCandidate && 'relayProtocol' in window.RTCIceCandidate.prototype)
    ) {
      return;
    }

    // Hook up the augmented candidate in onicecandidate and
    // addEventListener('icecandidate', ...)
    wrapPeerConnectionEvent(window, 'icecandidate', (e) => {
      if (e.candidate) {
        const parsedCandidate = SDPUtils.parseCandidate(e.candidate.candidate);
        if (parsedCandidate.type === 'relay') {
          // This is a libwebrtc-specific mapping of local type preference
          // to relayProtocol.
          e.candidate.relayProtocol = {
            0: 'tls',
            1: 'tcp',
            2: 'udp',
          }[parsedCandidate.priority >> 24];
        }
      }
      return e;
    });
  }
  function shimMaxMessageSize(window, browserDetails) {
    if (!window.RTCPeerConnection) {
      return;
    }
    if (!('sctp' in window.RTCPeerConnection.prototype)) {
      Object.defineProperty(window.RTCPeerConnection.prototype, 'sctp', {
        get() {
          return typeof this._sctp === 'undefined' ? null : this._sctp;
        },
      });
    }
    const sctpInDescription = function (description) {
      if (!description || !description.sdp) {
        return false;
      }
      const sections = SDPUtils.splitSections(description.sdp);
      sections.shift();
      return sections.some((mediaSection) => {
        const mLine = SDPUtils.parseMLine(mediaSection);
        return mLine && mLine.kind === 'application' && mLine.protocol.indexOf('SCTP') !== -1;
      });
    };
    const getRemoteFirefoxVersion = function (description) {
      // TODO: Is there a better solution for detecting Firefox?
      const match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
      if (match === null || match.length < 2) {
        return -1;
      }
      const version = parseInt(match[1], 10);
      // Test for NaN (yes, this is ugly)
      return version !== version ? -1 : version;
    };
    const getCanSendMaxMessageSize = function (remoteIsFirefox) {
      // Every implementation we know can send at least 64 KiB.
      // Note: Although Chrome is technically able to send up to 256 KiB, the
      //       data does not reach the other peer reliably.
      //       See: https://bugs.chromium.org/p/webrtc/issues/detail?id=8419
      let canSendMaxMessageSize = 65536;
      if (browserDetails.browser === 'firefox') {
        if (browserDetails.version < 57) {
          if (remoteIsFirefox === -1) {
            // FF < 57 will send in 16 KiB chunks using the deprecated PPID
            // fragmentation.
            canSendMaxMessageSize = 16384;
          } else {
            // However, other FF (and RAWRTC) can reassemble PPID-fragmented
            // messages. Thus, supporting ~2 GiB when sending.
            canSendMaxMessageSize = 2147483637;
          }
        } else if (browserDetails.version < 60) {
          // Currently, all FF >= 57 will reset the remote maximum message size
          // to the default value when a data channel is created at a later
          // stage. :(
          // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831
          canSendMaxMessageSize = browserDetails.version === 57 ? 65535 : 65536;
        } else {
          // FF >= 60 supports sending ~2 GiB
          canSendMaxMessageSize = 2147483637;
        }
      }
      return canSendMaxMessageSize;
    };
    const getMaxMessageSize = function (description, remoteIsFirefox) {
      // Note: 65536 bytes is the default value from the SDP spec. Also,
      //       every implementation we know supports receiving 65536 bytes.
      let maxMessageSize = 65536;

      // FF 57 has a slightly incorrect default remote max message size, so
      // we need to adjust it here to avoid a failure when sending.
      // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1425697
      if (browserDetails.browser === 'firefox' && browserDetails.version === 57) {
        maxMessageSize = 65535;
      }
      const match = SDPUtils.matchPrefix(description.sdp, 'a=max-message-size:');
      if (match.length > 0) {
        maxMessageSize = parseInt(match[0].substring(19), 10);
      } else if (browserDetails.browser === 'firefox' && remoteIsFirefox !== -1) {
        // If the maximum message size is not present in the remote SDP and
        // both local and remote are Firefox, the remote peer can receive
        // ~2 GiB.
        maxMessageSize = 2147483637;
      }
      return maxMessageSize;
    };
    const origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;
    window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
      this._sctp = null;
      // Chrome decided to not expose .sctp in plan-b mode.
      // As usual, adapter.js has to do an 'ugly worakaround'
      // to cover up the mess.
      if (browserDetails.browser === 'chrome' && browserDetails.version >= 76) {
        const { sdpSemantics } = this.getConfiguration();
        if (sdpSemantics === 'plan-b') {
          Object.defineProperty(this, 'sctp', {
            get() {
              return typeof this._sctp === 'undefined' ? null : this._sctp;
            },
            enumerable: true,
            configurable: true,
          });
        }
      }
      if (sctpInDescription(arguments[0])) {
        // Check if the remote is FF.
        const isFirefox = getRemoteFirefoxVersion(arguments[0]);

        // Get the maximum message size the local peer is capable of sending
        const canSendMMS = getCanSendMaxMessageSize(isFirefox);

        // Get the maximum message size of the remote peer.
        const remoteMMS = getMaxMessageSize(arguments[0], isFirefox);

        // Determine final maximum message size
        let maxMessageSize;
        if (canSendMMS === 0 && remoteMMS === 0) {
          maxMessageSize = Number.POSITIVE_INFINITY;
        } else if (canSendMMS === 0 || remoteMMS === 0) {
          maxMessageSize = Math.max(canSendMMS, remoteMMS);
        } else {
          maxMessageSize = Math.min(canSendMMS, remoteMMS);
        }

        // Create a dummy RTCSctpTransport object and the 'maxMessageSize'
        // attribute.
        const sctp = {};
        Object.defineProperty(sctp, 'maxMessageSize', {
          get() {
            return maxMessageSize;
          },
        });
        this._sctp = sctp;
      }
      return origSetRemoteDescription.apply(this, arguments);
    };
  }
  function shimSendThrowTypeError(window) {
    if (!(window.RTCPeerConnection && 'createDataChannel' in window.RTCPeerConnection.prototype)) {
      return;
    }

    // Note: Although Firefox >= 57 has a native implementation, the maximum
    //       message size can be reset for all data channels at a later stage.
    //       See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831

    function wrapDcSend(dc, pc) {
      const origDataChannelSend = dc.send;
      dc.send = function send() {
        const data = arguments[0];
        const length = data.length || data.size || data.byteLength;
        if (dc.readyState === 'open' && pc.sctp && length > pc.sctp.maxMessageSize) {
          throw new TypeError(
            'Message too large (can send a maximum of ' + pc.sctp.maxMessageSize + ' bytes)'
          );
        }
        return origDataChannelSend.apply(dc, arguments);
      };
    }
    const origCreateDataChannel = window.RTCPeerConnection.prototype.createDataChannel;
    window.RTCPeerConnection.prototype.createDataChannel = function createDataChannel() {
      const dataChannel = origCreateDataChannel.apply(this, arguments);
      wrapDcSend(dataChannel, this);
      return dataChannel;
    };
    wrapPeerConnectionEvent(window, 'datachannel', (e) => {
      wrapDcSend(e.channel, e.target);
      return e;
    });
  }

  /* shims RTCConnectionState by pretending it is the same as iceConnectionState.
   * See https://bugs.chromium.org/p/webrtc/issues/detail?id=6145#c12
   * for why this is a valid hack in Chrome. In Firefox it is slightly incorrect
   * since DTLS failures would be hidden. See
   * https://bugzilla.mozilla.org/show_bug.cgi?id=1265827
   * for the Firefox tracking bug.
   */
  function shimConnectionState(window) {
    if (!window.RTCPeerConnection || 'connectionState' in window.RTCPeerConnection.prototype) {
      return;
    }
    const proto = window.RTCPeerConnection.prototype;
    Object.defineProperty(proto, 'connectionState', {
      get() {
        return (
          {
            completed: 'connected',
            checking: 'connecting',
          }[this.iceConnectionState] || this.iceConnectionState
        );
      },
      enumerable: true,
      configurable: true,
    });
    Object.defineProperty(proto, 'onconnectionstatechange', {
      get() {
        return this._onconnectionstatechange || null;
      },
      set(cb) {
        if (this._onconnectionstatechange) {
          this.removeEventListener('connectionstatechange', this._onconnectionstatechange);
          delete this._onconnectionstatechange;
        }
        if (cb) {
          this.addEventListener('connectionstatechange', (this._onconnectionstatechange = cb));
        }
      },
      enumerable: true,
      configurable: true,
    });
    ['setLocalDescription', 'setRemoteDescription'].forEach((method) => {
      const origMethod = proto[method];
      proto[method] = function () {
        if (!this._connectionstatechangepoly) {
          this._connectionstatechangepoly = (e) => {
            const pc = e.target;
            if (pc._lastConnectionState !== pc.connectionState) {
              pc._lastConnectionState = pc.connectionState;
              const newEvent = new Event('connectionstatechange', e);
              pc.dispatchEvent(newEvent);
            }
            return e;
          };
          this.addEventListener('iceconnectionstatechange', this._connectionstatechangepoly);
        }
        return origMethod.apply(this, arguments);
      };
    });
  }
  function removeExtmapAllowMixed(window, browserDetails) {
    /* remove a=extmap-allow-mixed for webrtc.org < M71 */
    if (!window.RTCPeerConnection) {
      return;
    }
    if (browserDetails.browser === 'chrome' && browserDetails.version >= 71) {
      return;
    }
    if (browserDetails.browser === 'safari' && browserDetails._safariVersion >= 13.1) {
      return;
    }
    const nativeSRD = window.RTCPeerConnection.prototype.setRemoteDescription;
    window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription(desc) {
      if (desc && desc.sdp && desc.sdp.indexOf('\na=extmap-allow-mixed') !== -1) {
        const sdp = desc.sdp
          .split('\n')
          .filter((line) => {
            return line.trim() !== 'a=extmap-allow-mixed';
          })
          .join('\n');
        // Safari enforces read-only-ness of RTCSessionDescription fields.
        if (window.RTCSessionDescription && desc instanceof window.RTCSessionDescription) {
          arguments[0] = new window.RTCSessionDescription({
            type: desc.type,
            sdp,
          });
        } else {
          desc.sdp = sdp;
        }
      }
      return nativeSRD.apply(this, arguments);
    };
  }
  function shimAddIceCandidateNullOrEmpty(window, browserDetails) {
    // Support for addIceCandidate(null or undefined)
    // as well as addIceCandidate({candidate: "", ...})
    // https://bugs.chromium.org/p/chromium/issues/detail?id=978582
    // Note: must be called before other polyfills which change the signature.
    if (!(window.RTCPeerConnection && window.RTCPeerConnection.prototype)) {
      return;
    }
    const nativeAddIceCandidate = window.RTCPeerConnection.prototype.addIceCandidate;
    if (!nativeAddIceCandidate || nativeAddIceCandidate.length === 0) {
      return;
    }
    window.RTCPeerConnection.prototype.addIceCandidate = function addIceCandidate() {
      if (!arguments[0]) {
        if (arguments[1]) {
          arguments[1].apply(null);
        }
        return Promise.resolve();
      }
      // Firefox 68+ emits and processes {candidate: "", ...}, ignore
      // in older versions.
      // Native support for ignoring exists for Chrome M77+.
      // Safari ignores as well, exact version unknown but works in the same
      // version that also ignores addIceCandidate(null).
      if (
        ((browserDetails.browser === 'chrome' && browserDetails.version < 78) ||
          (browserDetails.browser === 'firefox' && browserDetails.version < 68) ||
          browserDetails.browser === 'safari') &&
        arguments[0] &&
        arguments[0].candidate === ''
      ) {
        return Promise.resolve();
      }
      return nativeAddIceCandidate.apply(this, arguments);
    };
  }

  // Note: Make sure to call this ahead of APIs that modify
  // setLocalDescription.length
  function shimParameterlessSetLocalDescription(window, browserDetails) {
    if (!(window.RTCPeerConnection && window.RTCPeerConnection.prototype)) {
      return;
    }
    const nativeSetLocalDescription = window.RTCPeerConnection.prototype.setLocalDescription;
    if (!nativeSetLocalDescription || nativeSetLocalDescription.length === 0) {
      return;
    }
    window.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {
      let desc = arguments[0] || {};
      if (typeof desc !== 'object' || (desc.type && desc.sdp)) {
        return nativeSetLocalDescription.apply(this, arguments);
      }
      // The remaining steps should technically happen when SLD comes off the
      // RTCPeerConnection's operations chain (not ahead of going on it), but
      // this is too difficult to shim. Instead, this shim only covers the
      // common case where the operations chain is empty. This is imperfect, but
      // should cover many cases. Rationale: Even if we can't reduce the glare
      // window to zero on imperfect implementations, there's value in tapping
      // into the perfect negotiation pattern that several browsers support.
      desc = {
        type: desc.type,
        sdp: desc.sdp,
      };
      if (!desc.type) {
        switch (this.signalingState) {
          case 'stable':
          case 'have-local-offer':
          case 'have-remote-pranswer':
            desc.type = 'offer';
            break;
          default:
            desc.type = 'answer';
            break;
        }
      }
      if (desc.sdp || (desc.type !== 'offer' && desc.type !== 'answer')) {
        return nativeSetLocalDescription.apply(this, [desc]);
      }
      const func = desc.type === 'offer' ? this.createOffer : this.createAnswer;
      return func.apply(this).then((d) => nativeSetLocalDescription.apply(this, [d]));
    };
  }

  var commonShim = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    removeExtmapAllowMixed: removeExtmapAllowMixed,
    shimAddIceCandidateNullOrEmpty: shimAddIceCandidateNullOrEmpty,
    shimConnectionState: shimConnectionState,
    shimMaxMessageSize: shimMaxMessageSize,
    shimParameterlessSetLocalDescription: shimParameterlessSetLocalDescription,
    shimRTCIceCandidate: shimRTCIceCandidate,
    shimRTCIceCandidateRelayProtocol: shimRTCIceCandidateRelayProtocol,
    shimSendThrowTypeError: shimSendThrowTypeError,
  });

  /*
   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */

  // Shimming starts here.
  function adapterFactory() {
    let { window } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let options =
      arguments.length > 1 && arguments[1] !== undefined
        ? arguments[1]
        : {
            shimChrome: true,
            shimFirefox: true,
            shimSafari: true,
          };
    // Utils.
    const logging = log;
    const browserDetails = detectBrowser(window);
    const adapter = {
      browserDetails,
      commonShim,
      extractVersion: extractVersion,
      disableLog: disableLog,
      disableWarnings: disableWarnings,
      // Expose sdp as a convenience. For production apps include directly.
      sdp,
    };

    // Shim browser if found.
    switch (browserDetails.browser) {
      case 'chrome':
        if (!chromeShim || !shimPeerConnection$1 || !options.shimChrome) {
          logging('Chrome shim is not included in this adapter release.');
          return adapter;
        }
        if (browserDetails.version === null) {
          logging('Chrome shim can not determine version, not shimming.');
          return adapter;
        }
        logging('adapter.js shimming chrome.');
        // Export to the adapter global object visible in the browser.
        adapter.browserShim = chromeShim;

        // Must be called before shimPeerConnection.
        shimAddIceCandidateNullOrEmpty(window, browserDetails);
        shimParameterlessSetLocalDescription(window);
        shimGetUserMedia$2(window, browserDetails);
        shimMediaStream(window);
        shimPeerConnection$1(window, browserDetails);
        shimOnTrack$1(window);
        shimAddTrackRemoveTrack(window, browserDetails);
        shimGetSendersWithDtmf(window);
        shimSenderReceiverGetStats(window);
        fixNegotiationNeeded(window, browserDetails);
        shimRTCIceCandidate(window);
        shimRTCIceCandidateRelayProtocol(window);
        shimConnectionState(window);
        shimMaxMessageSize(window, browserDetails);
        shimSendThrowTypeError(window);
        removeExtmapAllowMixed(window, browserDetails);
        break;
      case 'firefox':
        if (!firefoxShim || !shimPeerConnection || !options.shimFirefox) {
          logging('Firefox shim is not included in this adapter release.');
          return adapter;
        }
        logging('adapter.js shimming firefox.');
        // Export to the adapter global object visible in the browser.
        adapter.browserShim = firefoxShim;

        // Must be called before shimPeerConnection.
        shimAddIceCandidateNullOrEmpty(window, browserDetails);
        shimParameterlessSetLocalDescription(window);
        shimGetUserMedia$1(window, browserDetails);
        shimPeerConnection(window, browserDetails);
        shimOnTrack(window);
        shimRemoveStream(window);
        shimSenderGetStats(window);
        shimReceiverGetStats(window);
        shimRTCDataChannel(window);
        shimAddTransceiver(window);
        shimGetParameters(window);
        shimCreateOffer(window);
        shimCreateAnswer(window);
        shimRTCIceCandidate(window);
        shimConnectionState(window);
        shimMaxMessageSize(window, browserDetails);
        shimSendThrowTypeError(window);
        break;
      case 'safari':
        if (!safariShim || !options.shimSafari) {
          logging('Safari shim is not included in this adapter release.');
          return adapter;
        }
        logging('adapter.js shimming safari.');
        // Export to the adapter global object visible in the browser.
        adapter.browserShim = safariShim;

        // Must be called before shimCallbackAPI.
        shimAddIceCandidateNullOrEmpty(window, browserDetails);
        shimParameterlessSetLocalDescription(window);
        shimRTCIceServerUrls(window);
        shimCreateOfferLegacy(window);
        shimCallbacksAPI(window);
        shimLocalStreamsAPI(window);
        shimRemoteStreamsAPI(window);
        shimTrackEventTransceiver(window);
        shimGetUserMedia(window);
        shimAudioContext(window);
        shimRTCIceCandidate(window);
        shimRTCIceCandidateRelayProtocol(window);
        shimMaxMessageSize(window, browserDetails);
        shimSendThrowTypeError(window);
        removeExtmapAllowMixed(window, browserDetails);
        break;
      default:
        logging('Unsupported browser!');
        break;
    }
    return adapter;
  }

  /*
   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */
  /* eslint-env node */

  adapterFactory({
    window: typeof window === 'undefined' ? undefined : window,
  });

  const ENCRYPTION_ALGORITHM = 'AES-GCM';
  // How many consecutive frames can fail decrypting before a particular key gets marked as invalid
  const DECRYPTION_FAILURE_TOLERANCE = 10;
  // flag set to indicate that e2ee has been setup for sender/receiver;
  const E2EE_FLAG = 'lk_e2ee';
  const SALT = 'LKFrameEncryptionKey';
  const KEY_PROVIDER_DEFAULTS = {
    sharedKey: false,
    ratchetSalt: SALT,
    ratchetWindowSize: 8,
    failureTolerance: DECRYPTION_FAILURE_TOLERANCE,
    keyringSize: 16,
  };

  var KeyProviderEvent;
  (function (KeyProviderEvent) {
    KeyProviderEvent['SetKey'] = 'setKey';
    /** Event for requesting to ratchet the key used to encrypt the stream */
    KeyProviderEvent['RatchetRequest'] = 'ratchetRequest';
    /** Emitted when a key is ratcheted. Could be after auto-ratcheting on decryption failure or
     *  following a `RatchetRequest`, will contain the ratcheted key material */
    KeyProviderEvent['KeyRatcheted'] = 'keyRatcheted';
  })(KeyProviderEvent || (KeyProviderEvent = {}));
  var KeyHandlerEvent;
  (function (KeyHandlerEvent) {
    /** Emitted when a key has been ratcheted. Is emitted when any key has been ratcheted
     * i.e. when the FrameCryptor tried to ratchet when decryption is failing  */
    KeyHandlerEvent['KeyRatcheted'] = 'keyRatcheted';
  })(KeyHandlerEvent || (KeyHandlerEvent = {}));
  var EncryptionEvent;
  (function (EncryptionEvent) {
    EncryptionEvent['ParticipantEncryptionStatusChanged'] = 'participantEncryptionStatusChanged';
    EncryptionEvent['EncryptionError'] = 'encryptionError';
  })(EncryptionEvent || (EncryptionEvent = {}));
  var CryptorEvent;
  (function (CryptorEvent) {
    CryptorEvent['Error'] = 'cryptorError';
  })(CryptorEvent || (CryptorEvent = {}));

  function isE2EESupported() {
    return isInsertableStreamSupported() || isScriptTransformSupported();
  }
  function isScriptTransformSupported() {
    // @ts-ignore
    return typeof window.RTCRtpScriptTransform !== 'undefined';
  }
  function isInsertableStreamSupported() {
    return (
      typeof window.RTCRtpSender !== 'undefined' &&
      // @ts-ignore
      typeof window.RTCRtpSender.prototype.createEncodedStreams !== 'undefined'
    );
  }
  function isVideoFrame(frame) {
    return 'type' in frame;
  }
  function importKey(keyBytes_1) {
    return __awaiter(this, arguments, void 0, function (keyBytes) {
      let algorithm =
        arguments.length > 1 && arguments[1] !== undefined
          ? arguments[1]
          : {
              name: ENCRYPTION_ALGORITHM,
            };
      let usage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'encrypt';
      return (function* () {
        // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey
        return crypto.subtle.importKey(
          'raw',
          keyBytes,
          algorithm,
          false,
          usage === 'derive' ? ['deriveBits', 'deriveKey'] : ['encrypt', 'decrypt']
        );
      })();
    });
  }
  function createKeyMaterialFromString(password) {
    return __awaiter(this, void 0, void 0, function* () {
      let enc = new TextEncoder();
      const keyMaterial = yield crypto.subtle.importKey(
        'raw',
        enc.encode(password),
        {
          name: 'PBKDF2',
        },
        false,
        ['deriveBits', 'deriveKey']
      );
      return keyMaterial;
    });
  }
  function createKeyMaterialFromBuffer(cryptoBuffer) {
    return __awaiter(this, void 0, void 0, function* () {
      const keyMaterial = yield crypto.subtle.importKey('raw', cryptoBuffer, 'HKDF', false, [
        'deriveBits',
        'deriveKey',
      ]);
      return keyMaterial;
    });
  }
  function getAlgoOptions(algorithmName, salt) {
    const textEncoder = new TextEncoder();
    const encodedSalt = textEncoder.encode(salt);
    switch (algorithmName) {
      case 'HKDF':
        return {
          name: 'HKDF',
          salt: encodedSalt,
          hash: 'SHA-256',
          info: new ArrayBuffer(128),
        };
      case 'PBKDF2': {
        return {
          name: 'PBKDF2',
          salt: encodedSalt,
          hash: 'SHA-256',
          iterations: 100000,
        };
      }
      default:
        throw new Error('algorithm '.concat(algorithmName, ' is currently unsupported'));
    }
  }
  /**
   * Derives a set of keys from the master key.
   * See https://tools.ietf.org/html/draft-omara-sframe-00#section-4.3.1
   */
  function deriveKeys(material, salt) {
    return __awaiter(this, void 0, void 0, function* () {
      const algorithmOptions = getAlgoOptions(material.algorithm.name, salt);
      // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/deriveKey#HKDF
      // https://developer.mozilla.org/en-US/docs/Web/API/HkdfParams
      const encryptionKey = yield crypto.subtle.deriveKey(
        algorithmOptions,
        material,
        {
          name: ENCRYPTION_ALGORITHM,
          length: 128,
        },
        false,
        ['encrypt', 'decrypt']
      );
      return {
        material,
        encryptionKey,
      };
    });
  }
  function createE2EEKey() {
    return window.crypto.getRandomValues(new Uint8Array(32));
  }
  /**
   * Ratchets a key. See
   * https://tools.ietf.org/html/draft-omara-sframe-00#section-4.3.5.1
   */
  function ratchet(material, salt) {
    return __awaiter(this, void 0, void 0, function* () {
      const algorithmOptions = getAlgoOptions(material.algorithm.name, salt);
      // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/deriveBits
      return crypto.subtle.deriveBits(algorithmOptions, material, 256);
    });
  }
  function needsRbspUnescaping(frameData) {
    for (var i = 0; i < frameData.length - 3; i++) {
      if (frameData[i] == 0 && frameData[i + 1] == 0 && frameData[i + 2] == 3) return true;
    }
    return false;
  }
  function parseRbsp(stream) {
    const dataOut = [];
    var length = stream.length;
    for (var i = 0; i < stream.length; ) {
      // Be careful about over/underflow here. byte_length_ - 3 can underflow, and
      // i + 3 can overflow, but byte_length_ - i can't, because i < byte_length_
      // above, and that expression will produce the number of bytes left in
      // the stream including the byte at i.
      if (length - i >= 3 && !stream[i] && !stream[i + 1] && stream[i + 2] == 3) {
        // Two rbsp bytes.
        dataOut.push(stream[i++]);
        dataOut.push(stream[i++]);
        // Skip the emulation byte.
        i++;
      } else {
        // Single rbsp byte.
        dataOut.push(stream[i++]);
      }
    }
    return new Uint8Array(dataOut);
  }
  const kZerosInStartSequence = 2;
  const kEmulationByte = 3;
  function writeRbsp(data_in) {
    const dataOut = [];
    var numConsecutiveZeros = 0;
    for (var i = 0; i < data_in.length; ++i) {
      var byte = data_in[i];
      if (byte <= kEmulationByte && numConsecutiveZeros >= kZerosInStartSequence) {
        // Need to escape.
        dataOut.push(kEmulationByte);
        numConsecutiveZeros = 0;
      }
      dataOut.push(byte);
      if (byte == 0) {
        ++numConsecutiveZeros;
      } else {
        numConsecutiveZeros = 0;
      }
    }
    return new Uint8Array(dataOut);
  }
  function asEncryptablePacket(packet) {
    var _a, _b, _c, _d, _e;
    if (
      ((_a = packet.value) === null || _a === void 0 ? void 0 : _a.case) !== 'sipDtmf' &&
      ((_b = packet.value) === null || _b === void 0 ? void 0 : _b.case) !== 'metrics' &&
      ((_c = packet.value) === null || _c === void 0 ? void 0 : _c.case) !== 'speaker' &&
      ((_d = packet.value) === null || _d === void 0 ? void 0 : _d.case) !== 'transcription' &&
      ((_e = packet.value) === null || _e === void 0 ? void 0 : _e.case) !== 'encryptedPacket'
    ) {
      return new EncryptedPacketPayload({
        value: packet.value,
      });
    }
    return undefined;
  }

  /**
   * @experimental
   */
  class BaseKeyProvider extends eventsExports.EventEmitter {
    constructor() {
      let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      super();
      /**
       * Callback being invoked after a key has been ratcheted.
       * Can happen when:
       * - A decryption failure occurs and the key is auto-ratcheted
       * - A ratchet request is sent (see {@link ratchetKey()})
       * @param ratchetResult Contains the ratcheted chain key (exportable to other participants) and the derived new key material.
       * @param participantId
       * @param keyIndex
       */
      this.onKeyRatcheted = (ratchetResult, participantId, keyIndex) => {
        livekitLogger.debug('key ratcheted event received', {
          ratchetResult,
          participantId,
          keyIndex,
        });
      };
      this.keyInfoMap = new Map();
      this.options = Object.assign(Object.assign({}, KEY_PROVIDER_DEFAULTS), options);
      this.on(KeyProviderEvent.KeyRatcheted, this.onKeyRatcheted);
    }
    /**
     * callback to invoke once a key has been set for a participant
     * @param key
     * @param participantIdentity
     * @param keyIndex
     */
    onSetEncryptionKey(key, participantIdentity, keyIndex) {
      const keyInfo = {
        key,
        participantIdentity,
        keyIndex,
      };
      if (!this.options.sharedKey && !participantIdentity) {
        throw new Error(
          'participant identity needs to be passed for encryption key if sharedKey option is false'
        );
      }
      this.keyInfoMap.set(
        ''
          .concat(
            participantIdentity !== null && participantIdentity !== void 0
              ? participantIdentity
              : 'shared',
            '-'
          )
          .concat(keyIndex !== null && keyIndex !== void 0 ? keyIndex : 0),
        keyInfo
      );
      this.emit(KeyProviderEvent.SetKey, keyInfo);
    }
    getKeys() {
      return Array.from(this.keyInfoMap.values());
    }
    getOptions() {
      return this.options;
    }
    ratchetKey(participantIdentity, keyIndex) {
      this.emit(KeyProviderEvent.RatchetRequest, participantIdentity, keyIndex);
    }
  }
  /**
   * A basic KeyProvider implementation intended for a single shared
   * passphrase between all participants
   * @experimental
   */
  class ExternalE2EEKeyProvider extends BaseKeyProvider {
    constructor() {
      let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      const opts = Object.assign(Object.assign({}, options), {
        sharedKey: true,
        // for a shared key provider failing to decrypt for a specific participant
        // should not mark the key as invalid, so we accept wrong keys forever
        // and won't try to auto-ratchet
        ratchetWindowSize: 0,
        failureTolerance: -1,
      });
      super(opts);
    }
    /**
     * Accepts a passphrase that's used to create the crypto keys.
     * When passing in a string, PBKDF2 is used.
     * When passing in an Array buffer of cryptographically random numbers, HKDF is being used. (recommended)
     * @param key
     */
    setKey(key) {
      return __awaiter(this, void 0, void 0, function* () {
        const derivedKey =
          typeof key === 'string'
            ? yield createKeyMaterialFromString(key)
            : yield createKeyMaterialFromBuffer(key);
        this.onSetEncryptionKey(derivedKey);
      });
    }
  }

  class LivekitError extends Error {
    constructor(code, message) {
      super(message || 'an error has occured');
      this.name = 'LiveKitError';
      this.code = code;
    }
  }
  var ConnectionErrorReason;
  (function (ConnectionErrorReason) {
    ConnectionErrorReason[(ConnectionErrorReason['NotAllowed'] = 0)] = 'NotAllowed';
    ConnectionErrorReason[(ConnectionErrorReason['ServerUnreachable'] = 1)] = 'ServerUnreachable';
    ConnectionErrorReason[(ConnectionErrorReason['InternalError'] = 2)] = 'InternalError';
    ConnectionErrorReason[(ConnectionErrorReason['Cancelled'] = 3)] = 'Cancelled';
    ConnectionErrorReason[(ConnectionErrorReason['LeaveRequest'] = 4)] = 'LeaveRequest';
    ConnectionErrorReason[(ConnectionErrorReason['Timeout'] = 5)] = 'Timeout';
  })(ConnectionErrorReason || (ConnectionErrorReason = {}));
  class ConnectionError extends LivekitError {
    constructor(message, reason, status, context) {
      super(1, message);
      this.name = 'ConnectionError';
      this.status = status;
      this.reason = reason;
      this.context = context;
      this.reasonName = ConnectionErrorReason[reason];
    }
  }
  class DeviceUnsupportedError extends LivekitError {
    constructor(message) {
      super(21, message !== null && message !== void 0 ? message : 'device is unsupported');
      this.name = 'DeviceUnsupportedError';
    }
  }
  class TrackInvalidError extends LivekitError {
    constructor(message) {
      super(20, message !== null && message !== void 0 ? message : 'track is invalid');
      this.name = 'TrackInvalidError';
    }
  }
  class UnsupportedServer extends LivekitError {
    constructor(message) {
      super(10, message !== null && message !== void 0 ? message : 'unsupported server');
      this.name = 'UnsupportedServer';
    }
  }
  class UnexpectedConnectionState extends LivekitError {
    constructor(message) {
      super(12, message !== null && message !== void 0 ? message : 'unexpected connection state');
      this.name = 'UnexpectedConnectionState';
    }
  }
  class NegotiationError extends LivekitError {
    constructor(message) {
      super(13, message !== null && message !== void 0 ? message : 'unable to negotiate');
      this.name = 'NegotiationError';
    }
  }
  class PublishDataError extends LivekitError {
    constructor(message) {
      super(14, message !== null && message !== void 0 ? message : 'unable to publish data');
      this.name = 'PublishDataError';
    }
  }
  class PublishTrackError extends LivekitError {
    constructor(message, status) {
      super(15, message);
      this.name = 'PublishTrackError';
      this.status = status;
    }
  }
  class SignalRequestError extends LivekitError {
    constructor(message, reason) {
      super(15, message);
      this.reason = reason;
      this.reasonName = typeof reason === 'string' ? reason : RequestResponse_Reason[reason];
    }
  }
  // NOTE: matches with https://github.com/livekit/client-sdk-swift/blob/f37bbd260d61e165084962db822c79f995f1a113/Sources/LiveKit/DataStream/StreamError.swift#L17
  var DataStreamErrorReason;
  (function (DataStreamErrorReason) {
    // Unable to open a stream with the same ID more than once.
    DataStreamErrorReason[(DataStreamErrorReason['AlreadyOpened'] = 0)] = 'AlreadyOpened';
    // Stream closed abnormally by remote participant.
    DataStreamErrorReason[(DataStreamErrorReason['AbnormalEnd'] = 1)] = 'AbnormalEnd';
    // Incoming chunk data could not be decoded.
    DataStreamErrorReason[(DataStreamErrorReason['DecodeFailed'] = 2)] = 'DecodeFailed';
    // Read length exceeded total length specified in stream header.
    DataStreamErrorReason[(DataStreamErrorReason['LengthExceeded'] = 3)] = 'LengthExceeded';
    // Read length less than total length specified in stream header.
    DataStreamErrorReason[(DataStreamErrorReason['Incomplete'] = 4)] = 'Incomplete';
    // Unable to register a stream handler more than once.
    DataStreamErrorReason[(DataStreamErrorReason['HandlerAlreadyRegistered'] = 7)] =
      'HandlerAlreadyRegistered';
    // Encryption type mismatch.
    DataStreamErrorReason[(DataStreamErrorReason['EncryptionTypeMismatch'] = 8)] =
      'EncryptionTypeMismatch';
  })(DataStreamErrorReason || (DataStreamErrorReason = {}));
  class DataStreamError extends LivekitError {
    constructor(message, reason) {
      super(16, message);
      this.name = 'DataStreamError';
      this.reason = reason;
      this.reasonName = DataStreamErrorReason[reason];
    }
  }
  var MediaDeviceFailure;
  (function (MediaDeviceFailure) {
    // user rejected permissions
    MediaDeviceFailure['PermissionDenied'] = 'PermissionDenied';
    // device is not available
    MediaDeviceFailure['NotFound'] = 'NotFound';
    // device is in use. On Windows, only a single tab may get access to a device at a time.
    MediaDeviceFailure['DeviceInUse'] = 'DeviceInUse';
    MediaDeviceFailure['Other'] = 'Other';
  })(MediaDeviceFailure || (MediaDeviceFailure = {}));
  (function (MediaDeviceFailure) {
    function getFailure(error) {
      if (error && 'name' in error) {
        if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
          return MediaDeviceFailure.NotFound;
        }
        if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
          return MediaDeviceFailure.PermissionDenied;
        }
        if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
          return MediaDeviceFailure.DeviceInUse;
        }
        return MediaDeviceFailure.Other;
      }
    }
    MediaDeviceFailure.getFailure = getFailure;
  })(MediaDeviceFailure || (MediaDeviceFailure = {}));

  var CryptorErrorReason;
  (function (CryptorErrorReason) {
    CryptorErrorReason[(CryptorErrorReason['InvalidKey'] = 0)] = 'InvalidKey';
    CryptorErrorReason[(CryptorErrorReason['MissingKey'] = 1)] = 'MissingKey';
    CryptorErrorReason[(CryptorErrorReason['InternalError'] = 2)] = 'InternalError';
  })(CryptorErrorReason || (CryptorErrorReason = {}));
  class CryptorError extends LivekitError {
    constructor(message) {
      let reason =
        arguments.length > 1 && arguments[1] !== undefined
          ? arguments[1]
          : CryptorErrorReason.InternalError;
      let participantIdentity = arguments.length > 2 ? arguments[2] : undefined;
      super(40, message);
      this.reason = reason;
      this.participantIdentity = participantIdentity;
    }
  }

  /**
   * Events are the primary way LiveKit notifies your application of changes.
   *
   * The following are events emitted by [[Room]], listen to room events like
   *
   * ```typescript
   * room.on(RoomEvent.TrackPublished, (track, publication, participant) => {})
   * ```
   */
  var RoomEvent;
  (function (RoomEvent) {
    /**
     * When the connection to the server has been established
     */
    RoomEvent['Connected'] = 'connected';
    /**
     * When the connection to the server has been interrupted and it's attempting
     * to reconnect.
     */
    RoomEvent['Reconnecting'] = 'reconnecting';
    /**
     * When the signal connection to the server has been interrupted. This isn't noticeable to users most of the time.
     * It will resolve with a `RoomEvent.Reconnected` once the signal connection has been re-established.
     * If media fails additionally it an additional `RoomEvent.Reconnecting` will be emitted.
     */
    RoomEvent['SignalReconnecting'] = 'signalReconnecting';
    /**
     * Fires when a reconnection has been successful.
     */
    RoomEvent['Reconnected'] = 'reconnected';
    /**
     * When disconnected from room. This fires when room.disconnect() is called or
     * when an unrecoverable connection issue had occured.
     *
     * DisconnectReason can be used to determine why the participant was disconnected. Notable reasons are
     * - DUPLICATE_IDENTITY: another client with the same identity has joined the room
     * - PARTICIPANT_REMOVED: participant was removed by RemoveParticipant API
     * - ROOM_DELETED: the room has ended via DeleteRoom API
     *
     * args: ([[DisconnectReason]])
     */
    RoomEvent['Disconnected'] = 'disconnected';
    /**
     * Whenever the connection state of the room changes
     *
     * args: ([[ConnectionState]])
     */
    RoomEvent['ConnectionStateChanged'] = 'connectionStateChanged';
    /**
     * When participant has been moved to a different room by the service request.
     * The behavior looks like the participant has been disconnected and reconnected to a different room
     * seamlessly without connection state transition.
     * A new token will be provided for reconnecting to the new room if needed.
     *
     * args: ([[room: string, token: string]])
     */
    RoomEvent['Moved'] = 'moved';
    /**
     * When input or output devices on the machine have changed.
     */
    RoomEvent['MediaDevicesChanged'] = 'mediaDevicesChanged';
    /**
     * When a [[RemoteParticipant]] joins *after* the local
     * participant. It will not emit events for participants that are already
     * in the room
     *
     * args: ([[RemoteParticipant]])
     */
    RoomEvent['ParticipantConnected'] = 'participantConnected';
    /**
     * When a [[RemoteParticipant]] leaves *after* the local
     * participant has joined.
     *
     * args: ([[RemoteParticipant]])
     */
    RoomEvent['ParticipantDisconnected'] = 'participantDisconnected';
    /**
     * When a new track is published to room *after* the local
     * participant has joined. It will not fire for tracks that are already published.
     *
     * A track published doesn't mean the participant has subscribed to it. It's
     * simply reflecting the state of the room.
     *
     * args: ([[RemoteTrackPublication]], [[RemoteParticipant]])
     */
    RoomEvent['TrackPublished'] = 'trackPublished';
    /**
     * The [[LocalParticipant]] has subscribed to a new track. This event will **always**
     * fire as long as new tracks are ready for use.
     *
     * args: ([[RemoteTrack]], [[RemoteTrackPublication]], [[RemoteParticipant]])
     */
    RoomEvent['TrackSubscribed'] = 'trackSubscribed';
    /**
     * Could not subscribe to a track
     *
     * args: (track sid, [[RemoteParticipant]])
     */
    RoomEvent['TrackSubscriptionFailed'] = 'trackSubscriptionFailed';
    /**
     * A [[RemoteParticipant]] has unpublished a track
     *
     * args: ([[RemoteTrackPublication]], [[RemoteParticipant]])
     */
    RoomEvent['TrackUnpublished'] = 'trackUnpublished';
    /**
     * A subscribed track is no longer available. Clients should listen to this
     * event and ensure they detach tracks.
     *
     * args: ([[Track]], [[RemoteTrackPublication]], [[RemoteParticipant]])
     */
    RoomEvent['TrackUnsubscribed'] = 'trackUnsubscribed';
    /**
     * A track that was muted, fires on both [[RemoteParticipant]]s and [[LocalParticipant]]
     *
     * args: ([[TrackPublication]], [[Participant]])
     */
    RoomEvent['TrackMuted'] = 'trackMuted';
    /**
     * A track that was unmuted, fires on both [[RemoteParticipant]]s and [[LocalParticipant]]
     *
     * args: ([[TrackPublication]], [[Participant]])
     */
    RoomEvent['TrackUnmuted'] = 'trackUnmuted';
    /**
     * A local track was published successfully. This event is helpful to know
     * when to update your local UI with the newly published track.
     *
     * args: ([[LocalTrackPublication]], [[LocalParticipant]])
     */
    RoomEvent['LocalTrackPublished'] = 'localTrackPublished';
    /**
     * A local track was unpublished. This event is helpful to know when to remove
     * the local track from your UI.
     *
     * When a user stops sharing their screen by pressing "End" on the browser UI,
     * this event will also fire.
     *
     * args: ([[LocalTrackPublication]], [[LocalParticipant]])
     */
    RoomEvent['LocalTrackUnpublished'] = 'localTrackUnpublished';
    /**
     * When a local audio track is published the SDK checks whether there is complete silence
     * on that track and emits the LocalAudioSilenceDetected event in that case.
     * This allows for applications to show UI informing users that they might have to
     * reset their audio hardware or check for proper device connectivity.
     */
    RoomEvent['LocalAudioSilenceDetected'] = 'localAudioSilenceDetected';
    /**
     * Active speakers changed. List of speakers are ordered by their audio level.
     * loudest speakers first. This will include the LocalParticipant too.
     *
     * Speaker updates are sent only to the publishing participant and their subscribers.
     *
     * args: (Array<[[Participant]]>)
     */
    RoomEvent['ActiveSpeakersChanged'] = 'activeSpeakersChanged';
    /**
     * Participant metadata is a simple way for app-specific state to be pushed to
     * all users.
     * When RoomService.UpdateParticipantMetadata is called to change a participant's
     * state, *all*  participants in the room will fire this event.
     *
     * args: (prevMetadata: string, [[Participant]])
     *
     */
    RoomEvent['ParticipantMetadataChanged'] = 'participantMetadataChanged';
    /**
     * Participant's display name changed
     *
     * args: (name: string, [[Participant]])
     *
     */
    RoomEvent['ParticipantNameChanged'] = 'participantNameChanged';
    /**
     * Participant attributes is an app-specific key value state to be pushed to
     * all users.
     * When a participant's attributes changed, this event will be emitted with the changed attributes and the participant
     * args: (changedAttributes: [[Record<string, string]], participant: [[Participant]])
     */
    RoomEvent['ParticipantAttributesChanged'] = 'participantAttributesChanged';
    /**
     * Emitted when the participant's state changes to ACTIVE and is ready to send/receive data messages
     *
     * args: (participant: [[Participant]])
     */
    RoomEvent['ParticipantActive'] = 'participantActive';
    /**
     * Room metadata is a simple way for app-specific state to be pushed to
     * all users.
     * When RoomService.UpdateRoomMetadata is called to change a room's state,
     * *all*  participants in the room will fire this event.
     *
     * args: (string)
     */
    RoomEvent['RoomMetadataChanged'] = 'roomMetadataChanged';
    /**
     * Data received from another participant.
     * Data packets provides the ability to use LiveKit to send/receive arbitrary payloads.
     * All participants in the room will receive the messages sent to the room.
     *
     * args: (payload: Uint8Array, participant: [[Participant]], kind: [[DataPacket_Kind]], topic?: string)
     */
    RoomEvent['DataReceived'] = 'dataReceived';
    /**
     * SIP DTMF tones received from another participant.
     *
     * args: (participant: [[Participant]], dtmf: [[DataPacket_Kind]])
     */
    RoomEvent['SipDTMFReceived'] = 'sipDTMFReceived';
    /**
     * Transcription received from a participant's track.
     * @beta
     */
    RoomEvent['TranscriptionReceived'] = 'transcriptionReceived';
    /**
     * Connection quality was changed for a Participant. It'll receive updates
     * from the local participant, as well as any [[RemoteParticipant]]s that we are
     * subscribed to.
     *
     * args: (connectionQuality: [[ConnectionQuality]], participant: [[Participant]])
     */
    RoomEvent['ConnectionQualityChanged'] = 'connectionQualityChanged';
    /**
     * StreamState indicates if a subscribed (remote) track has been paused by the SFU
     * (typically this happens because of subscriber's bandwidth constraints)
     *
     * When bandwidth conditions allow, the track will be resumed automatically.
     * TrackStreamStateChanged will also be emitted when that happens.
     *
     * args: (pub: [[RemoteTrackPublication]], streamState: [[Track.StreamState]],
     *        participant: [[RemoteParticipant]])
     */
    RoomEvent['TrackStreamStateChanged'] = 'trackStreamStateChanged';
    /**
     * One of subscribed tracks have changed its permissions for the current
     * participant. If permission was revoked, then the track will no longer
     * be subscribed. If permission was granted, a TrackSubscribed event will
     * be emitted.
     *
     * args: (pub: [[RemoteTrackPublication]],
     *        status: [[TrackPublication.PermissionStatus]],
     *        participant: [[RemoteParticipant]])
     */
    RoomEvent['TrackSubscriptionPermissionChanged'] = 'trackSubscriptionPermissionChanged';
    /**
     * One of subscribed tracks have changed its status for the current
     * participant.
     *
     * args: (pub: [[RemoteTrackPublication]],
     *        status: [[TrackPublication.SubscriptionStatus]],
     *        participant: [[RemoteParticipant]])
     */
    RoomEvent['TrackSubscriptionStatusChanged'] = 'trackSubscriptionStatusChanged';
    /**
     * LiveKit will attempt to autoplay all audio tracks when you attach them to
     * audio elements. However, if that fails, we'll notify you via AudioPlaybackStatusChanged.
     * `Room.canPlaybackAudio` will indicate if audio playback is permitted.
     */
    RoomEvent['AudioPlaybackStatusChanged'] = 'audioPlaybackChanged';
    /**
     * LiveKit will attempt to autoplay all video tracks when you attach them to
     * a video element. However, if that fails, we'll notify you via VideoPlaybackStatusChanged.
     * Calling `room.startVideo()` in a user gesture event handler will resume the video playback.
     */
    RoomEvent['VideoPlaybackStatusChanged'] = 'videoPlaybackChanged';
    /**
     * When we have encountered an error while attempting to create a track.
     * The errors take place in getUserMedia().
     * Use MediaDeviceFailure.getFailure(error) to get the reason of failure.
     * [[LocalParticipant.lastCameraError]] and [[LocalParticipant.lastMicrophoneError]]
     * will indicate if it had an error while creating the audio or video track respectively.
     *
     * args: (error: Error)
     */
    RoomEvent['MediaDevicesError'] = 'mediaDevicesError';
    /**
     * A participant's permission has changed.
     * args: (prevPermissions: [[ParticipantPermission]], participant: [[Participant]])
     */
    RoomEvent['ParticipantPermissionsChanged'] = 'participantPermissionsChanged';
    /**
     * Signal connected, can publish tracks.
     */
    RoomEvent['SignalConnected'] = 'signalConnected';
    /**
     * Recording of a room has started/stopped. Room.isRecording will be updated too.
     * args: (isRecording: boolean)
     */
    RoomEvent['RecordingStatusChanged'] = 'recordingStatusChanged';
    RoomEvent['ParticipantEncryptionStatusChanged'] = 'participantEncryptionStatusChanged';
    RoomEvent['EncryptionError'] = 'encryptionError';
    /**
     * Emits whenever the current buffer status of a data channel changes
     * args: (isLow: boolean, kind: [[DataPacket_Kind]])
     */
    RoomEvent['DCBufferStatusChanged'] = 'dcBufferStatusChanged';
    /**
     * Triggered by a call to room.switchActiveDevice
     * args: (kind: MediaDeviceKind, deviceId: string)
     */
    RoomEvent['ActiveDeviceChanged'] = 'activeDeviceChanged';
    RoomEvent['ChatMessage'] = 'chatMessage';
    /**
     * fired when the first remote participant has subscribed to the localParticipant's track
     */
    RoomEvent['LocalTrackSubscribed'] = 'localTrackSubscribed';
    /**
     * fired when the client receives connection metrics from other participants
     */
    RoomEvent['MetricsReceived'] = 'metricsReceived';
  })(RoomEvent || (RoomEvent = {}));
  var ParticipantEvent;
  (function (ParticipantEvent) {
    /**
     * When a new track is published to room *after* the local
     * participant has joined. It will not fire for tracks that are already published.
     *
     * A track published doesn't mean the participant has subscribed to it. It's
     * simply reflecting the state of the room.
     *
     * args: ([[RemoteTrackPublication]])
     */
    ParticipantEvent['TrackPublished'] = 'trackPublished';
    /**
     * Successfully subscribed to the [[RemoteParticipant]]'s track.
     * This event will **always** fire as long as new tracks are ready for use.
     *
     * args: ([[RemoteTrack]], [[RemoteTrackPublication]])
     */
    ParticipantEvent['TrackSubscribed'] = 'trackSubscribed';
    /**
     * Could not subscribe to a track
     *
     * args: (track sid)
     */
    ParticipantEvent['TrackSubscriptionFailed'] = 'trackSubscriptionFailed';
    /**
     * A [[RemoteParticipant]] has unpublished a track
     *
     * args: ([[RemoteTrackPublication]])
     */
    ParticipantEvent['TrackUnpublished'] = 'trackUnpublished';
    /**
     * A subscribed track is no longer available. Clients should listen to this
     * event and ensure they detach tracks.
     *
     * args: ([[RemoteTrack]], [[RemoteTrackPublication]])
     */
    ParticipantEvent['TrackUnsubscribed'] = 'trackUnsubscribed';
    /**
     * A track that was muted, fires on both [[RemoteParticipant]]s and [[LocalParticipant]]
     *
     * args: ([[TrackPublication]])
     */
    ParticipantEvent['TrackMuted'] = 'trackMuted';
    /**
     * A track that was unmuted, fires on both [[RemoteParticipant]]s and [[LocalParticipant]]
     *
     * args: ([[TrackPublication]])
     */
    ParticipantEvent['TrackUnmuted'] = 'trackUnmuted';
    /**
     * A local track was published successfully. This event is helpful to know
     * when to update your local UI with the newly published track.
     *
     * args: ([[LocalTrackPublication]])
     */
    ParticipantEvent['LocalTrackPublished'] = 'localTrackPublished';
    /**
     * A local track was unpublished. This event is helpful to know when to remove
     * the local track from your UI.
     *
     * When a user stops sharing their screen by pressing "End" on the browser UI,
     * this event will also fire.
     *
     * args: ([[LocalTrackPublication]])
     */
    ParticipantEvent['LocalTrackUnpublished'] = 'localTrackUnpublished';
    /**
     * A local track has been constrained by cpu.
     * This event is useful to know when to reduce the capture resolution of the track.
     *
     * This event is emitted on the local participant.
     *
     * args: ([[LocalVideoTrack]], [[LocalTrackPublication]])
     */
    ParticipantEvent['LocalTrackCpuConstrained'] = 'localTrackCpuConstrained';
    /**
     * @internal
     */
    ParticipantEvent['LocalSenderCreated'] = 'localSenderCreated';
    /**
     * Participant metadata is a simple way for app-specific state to be pushed to
     * all users.
     * When RoomService.UpdateParticipantMetadata is called to change a participant's
     * state, *all*  participants in the room will fire this event.
     * To access the current metadata, see [[Participant.metadata]].
     *
     * args: (prevMetadata: string)
     *
     */
    ParticipantEvent['ParticipantMetadataChanged'] = 'participantMetadataChanged';
    /**
     * Participant's display name changed
     *
     * args: (name: string, [[Participant]])
     *
     */
    ParticipantEvent['ParticipantNameChanged'] = 'participantNameChanged';
    /**
     * Data received from this participant as sender.
     * Data packets provides the ability to use LiveKit to send/receive arbitrary payloads.
     * All participants in the room will receive the messages sent to the room.
     *
     * args: (payload: Uint8Array, kind: [[DataPacket_Kind]])
     */
    ParticipantEvent['DataReceived'] = 'dataReceived';
    /**
     * SIP DTMF tones received from this participant as sender.
     *
     * args: (dtmf: [[DataPacket_Kind]])
     */
    ParticipantEvent['SipDTMFReceived'] = 'sipDTMFReceived';
    /**
     * Transcription received from this participant as data source.
     * @beta
     */
    ParticipantEvent['TranscriptionReceived'] = 'transcriptionReceived';
    /**
     * Has speaking status changed for the current participant
     *
     * args: (speaking: boolean)
     */
    ParticipantEvent['IsSpeakingChanged'] = 'isSpeakingChanged';
    /**
     * Connection quality was changed for a Participant. It'll receive updates
     * from the local participant, as well as any [[RemoteParticipant]]s that we are
     * subscribed to.
     *
     * args: (connectionQuality: [[ConnectionQuality]])
     */
    ParticipantEvent['ConnectionQualityChanged'] = 'connectionQualityChanged';
    /**
     * StreamState indicates if a subscribed track has been paused by the SFU
     * (typically this happens because of subscriber's bandwidth constraints)
     *
     * When bandwidth conditions allow, the track will be resumed automatically.
     * TrackStreamStateChanged will also be emitted when that happens.
     *
     * args: (pub: [[RemoteTrackPublication]], streamState: [[Track.StreamState]])
     */
    ParticipantEvent['TrackStreamStateChanged'] = 'trackStreamStateChanged';
    /**
     * One of subscribed tracks have changed its permissions for the current
     * participant. If permission was revoked, then the track will no longer
     * be subscribed. If permission was granted, a TrackSubscribed event will
     * be emitted.
     *
     * args: (pub: [[RemoteTrackPublication]],
     *        status: [[TrackPublication.SubscriptionStatus]])
     */
    ParticipantEvent['TrackSubscriptionPermissionChanged'] = 'trackSubscriptionPermissionChanged';
    /**
     * One of the remote participants publications has changed its subscription status.
     *
     */
    ParticipantEvent['TrackSubscriptionStatusChanged'] = 'trackSubscriptionStatusChanged';
    /**
     * a local track has been constrained by cpu
     */
    ParticipantEvent['TrackCpuConstrained'] = 'trackCpuConstrained';
    // fired only on LocalParticipant
    /** @internal */
    ParticipantEvent['MediaDevicesError'] = 'mediaDevicesError';
    // fired only on LocalParticipant
    /** @internal */
    ParticipantEvent['AudioStreamAcquired'] = 'audioStreamAcquired';
    /**
     * A participant's permission has changed.
     * args: (prevPermissions: [[ParticipantPermission]])
     */
    ParticipantEvent['ParticipantPermissionsChanged'] = 'participantPermissionsChanged';
    /** @internal */
    ParticipantEvent['PCTrackAdded'] = 'pcTrackAdded';
    /**
     * Participant attributes is an app-specific key value state to be pushed to
     * all users.
     * When a participant's attributes changed, this event will be emitted with the changed attributes
     * args: (changedAttributes: [[Record<string, string]])
     */
    ParticipantEvent['AttributesChanged'] = 'attributesChanged';
    /**
     * fired on local participant only, when the first remote participant has subscribed to the track specified in the payload
     */
    ParticipantEvent['LocalTrackSubscribed'] = 'localTrackSubscribed';
    /** only emitted on local participant */
    ParticipantEvent['ChatMessage'] = 'chatMessage';
    /**
     * Emitted when the participant's state changes to ACTIVE and is ready to send/receive data messages
     */
    ParticipantEvent['Active'] = 'active';
  })(ParticipantEvent || (ParticipantEvent = {}));
  /** @internal */
  var EngineEvent;
  (function (EngineEvent) {
    EngineEvent['TransportsCreated'] = 'transportsCreated';
    EngineEvent['Connected'] = 'connected';
    EngineEvent['Disconnected'] = 'disconnected';
    EngineEvent['Resuming'] = 'resuming';
    EngineEvent['Resumed'] = 'resumed';
    EngineEvent['Restarting'] = 'restarting';
    EngineEvent['Restarted'] = 'restarted';
    EngineEvent['SignalResumed'] = 'signalResumed';
    EngineEvent['SignalRestarted'] = 'signalRestarted';
    EngineEvent['Closing'] = 'closing';
    EngineEvent['MediaTrackAdded'] = 'mediaTrackAdded';
    EngineEvent['ActiveSpeakersUpdate'] = 'activeSpeakersUpdate';
    EngineEvent['DataPacketReceived'] = 'dataPacketReceived';
    EngineEvent['RTPVideoMapUpdate'] = 'rtpVideoMapUpdate';
    EngineEvent['DCBufferStatusChanged'] = 'dcBufferStatusChanged';
    EngineEvent['ParticipantUpdate'] = 'participantUpdate';
    EngineEvent['RoomUpdate'] = 'roomUpdate';
    EngineEvent['SpeakersChanged'] = 'speakersChanged';
    EngineEvent['StreamStateChanged'] = 'streamStateChanged';
    EngineEvent['ConnectionQualityUpdate'] = 'connectionQualityUpdate';
    EngineEvent['SubscriptionError'] = 'subscriptionError';
    EngineEvent['SubscriptionPermissionUpdate'] = 'subscriptionPermissionUpdate';
    EngineEvent['RemoteMute'] = 'remoteMute';
    EngineEvent['SubscribedQualityUpdate'] = 'subscribedQualityUpdate';
    EngineEvent['LocalTrackUnpublished'] = 'localTrackUnpublished';
    EngineEvent['LocalTrackSubscribed'] = 'localTrackSubscribed';
    EngineEvent['Offline'] = 'offline';
    EngineEvent['SignalRequestResponse'] = 'signalRequestResponse';
    EngineEvent['SignalConnected'] = 'signalConnected';
    EngineEvent['RoomMoved'] = 'roomMoved';
  })(EngineEvent || (EngineEvent = {}));
  var TrackEvent;
  (function (TrackEvent) {
    TrackEvent['Message'] = 'message';
    TrackEvent['Muted'] = 'muted';
    TrackEvent['Unmuted'] = 'unmuted';
    /**
     * Only fires on LocalTracks
     */
    TrackEvent['Restarted'] = 'restarted';
    TrackEvent['Ended'] = 'ended';
    TrackEvent['Subscribed'] = 'subscribed';
    TrackEvent['Unsubscribed'] = 'unsubscribed';
    TrackEvent['CpuConstrained'] = 'cpuConstrained';
    /** @internal */
    TrackEvent['UpdateSettings'] = 'updateSettings';
    /** @internal */
    TrackEvent['UpdateSubscription'] = 'updateSubscription';
    /** @internal */
    TrackEvent['AudioPlaybackStarted'] = 'audioPlaybackStarted';
    /** @internal */
    TrackEvent['AudioPlaybackFailed'] = 'audioPlaybackFailed';
    /**
     * @internal
     * Only fires on LocalAudioTrack instances
     */
    TrackEvent['AudioSilenceDetected'] = 'audioSilenceDetected';
    /** @internal */
    TrackEvent['VisibilityChanged'] = 'visibilityChanged';
    /** @internal */
    TrackEvent['VideoDimensionsChanged'] = 'videoDimensionsChanged';
    /** @internal */
    TrackEvent['VideoPlaybackStarted'] = 'videoPlaybackStarted';
    /** @internal */
    TrackEvent['VideoPlaybackFailed'] = 'videoPlaybackFailed';
    /** @internal */
    TrackEvent['ElementAttached'] = 'elementAttached';
    /** @internal */
    TrackEvent['ElementDetached'] = 'elementDetached';
    /**
     * @internal
     * Only fires on LocalTracks
     */
    TrackEvent['UpstreamPaused'] = 'upstreamPaused';
    /**
     * @internal
     * Only fires on LocalTracks
     */
    TrackEvent['UpstreamResumed'] = 'upstreamResumed';
    /**
     * @internal
     * Fires on RemoteTrackPublication
     */
    TrackEvent['SubscriptionPermissionChanged'] = 'subscriptionPermissionChanged';
    /**
     * Fires on RemoteTrackPublication
     */
    TrackEvent['SubscriptionStatusChanged'] = 'subscriptionStatusChanged';
    /**
     * Fires on RemoteTrackPublication
     */
    TrackEvent['SubscriptionFailed'] = 'subscriptionFailed';
    /**
     * @internal
     */
    TrackEvent['TrackProcessorUpdate'] = 'trackProcessorUpdate';
    /**
     * @internal
     */
    TrackEvent['AudioTrackFeatureUpdate'] = 'audioTrackFeatureUpdate';
    /**
     * @beta
     */
    TrackEvent['TranscriptionReceived'] = 'transcriptionReceived';
    /**
     * @experimental
     */
    TrackEvent['TimeSyncUpdate'] = 'timeSyncUpdate';
    /**
     * @internal
     */
    TrackEvent['PreConnectBufferFlushed'] = 'preConnectBufferFlushed';
  })(TrackEvent || (TrackEvent = {}));

  function cloneDeep(value) {
    if (typeof value === 'undefined') {
      return value;
    }
    if (typeof structuredClone === 'function') {
      if (typeof value === 'object' && value !== null) {
        // ensure that the value is not a proxy by spreading it
        return structuredClone(Object.assign({}, value));
      }
      return structuredClone(value);
    } else {
      return JSON.parse(JSON.stringify(value));
    }
  }

  // tiny, simplified version of https://github.com/lancedikson/bowser/blob/master/src/parser-browsers.js
  // reduced to only differentiate Chrome(ium) based browsers / Firefox / Safari
  const commonVersionIdentifier = /version\/(\d+(\.?_?\d+)+)/i;
  let browserDetails;
  /**
   * @internal
   */
  function getBrowser(userAgent) {
    let force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    if (typeof userAgent === 'undefined' && typeof navigator === 'undefined') {
      return;
    }
    const ua = (
      userAgent !== null && userAgent !== void 0 ? userAgent : navigator.userAgent
    ).toLowerCase();
    if (browserDetails === undefined || force) {
      const browser = browsersList.find((_ref) => {
        let { test } = _ref;
        return test.test(ua);
      });
      browserDetails = browser === null || browser === void 0 ? void 0 : browser.describe(ua);
    }
    return browserDetails;
  }
  const browsersList = [
    {
      test: /firefox|iceweasel|fxios/i,
      describe(ua) {
        const browser = {
          name: 'Firefox',
          version: getMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, ua),
          os: ua.toLowerCase().includes('fxios') ? 'iOS' : undefined,
          osVersion: getOSVersion(ua),
        };
        return browser;
      },
    },
    {
      test: /chrom|crios|crmo/i,
      describe(ua) {
        const browser = {
          name: 'Chrome',
          version: getMatch(/(?:chrome|chromium|crios|crmo)\/(\d+(\.?_?\d+)+)/i, ua),
          os: ua.toLowerCase().includes('crios') ? 'iOS' : undefined,
          osVersion: getOSVersion(ua),
        };
        return browser;
      },
    } /* Safari */,
    {
      test: /safari|applewebkit/i,
      describe(ua) {
        const browser = {
          name: 'Safari',
          version: getMatch(commonVersionIdentifier, ua),
          os: ua.includes('mobile/') ? 'iOS' : 'macOS',
          osVersion: getOSVersion(ua),
        };
        return browser;
      },
    },
  ];
  function getMatch(exp, ua) {
    let id = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    const match = ua.match(exp);
    return (match && match.length >= id && match[id]) || '';
  }
  function getOSVersion(ua) {
    return ua.includes('mac os')
      ? getMatch(/\(.+?(\d+_\d+(:?_\d+)?)/, ua, 1).replace(/_/g, '.')
      : undefined;
  }

  var version$1 = '2.15.8';

  const version = version$1;
  const protocolVersion = 16;

  /**
   * Timers that can be overridden with platform specific implementations
   * that ensure that they are fired. These should be used when it is critical
   * that the timer fires on time.
   */
  class CriticalTimers {}
  CriticalTimers.setTimeout = function () {
    return setTimeout(...arguments);
  };
  CriticalTimers.setInterval =
    // eslint-disable-next-line @typescript-eslint/no-implied-eval
    function () {
      return setInterval(...arguments);
    };
  CriticalTimers.clearTimeout = function () {
    return clearTimeout(...arguments);
  };
  CriticalTimers.clearInterval = function () {
    return clearInterval(...arguments);
  };

  const BACKGROUND_REACTION_DELAY = 5000;
  // keep old audio elements when detached, we would re-use them since on iOS
  // Safari tracks which audio elements have been "blessed" by the user.
  const recycledElements = [];
  var VideoQuality;
  (function (VideoQuality) {
    VideoQuality[(VideoQuality['LOW'] = 0)] = 'LOW';
    VideoQuality[(VideoQuality['MEDIUM'] = 1)] = 'MEDIUM';
    VideoQuality[(VideoQuality['HIGH'] = 2)] = 'HIGH';
  })(VideoQuality || (VideoQuality = {}));
  class Track extends eventsExports.EventEmitter {
    /**
     * indicates current state of stream, it'll indicate `paused` if the track
     * has been paused by congestion controller
     */
    get streamState() {
      return this._streamState;
    }
    /** @internal */
    setStreamState(value) {
      this._streamState = value;
    }
    constructor(mediaTrack, kind) {
      let loggerOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var _a;
      super();
      this.attachedElements = [];
      this.isMuted = false;
      this._streamState = Track.StreamState.Active;
      this.isInBackground = false;
      this._currentBitrate = 0;
      this.log = livekitLogger;
      this.appVisibilityChangedListener = () => {
        if (this.backgroundTimeout) {
          clearTimeout(this.backgroundTimeout);
        }
        // delay app visibility update if it goes to hidden
        // update immediately if it comes back to focus
        if (document.visibilityState === 'hidden') {
          this.backgroundTimeout = setTimeout(
            () => this.handleAppVisibilityChanged(),
            BACKGROUND_REACTION_DELAY
          );
        } else {
          this.handleAppVisibilityChanged();
        }
      };
      this.log = getLogger(
        (_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Track
      );
      this.loggerContextCb = loggerOptions.loggerContextCb;
      this.setMaxListeners(100);
      this.kind = kind;
      this._mediaStreamTrack = mediaTrack;
      this._mediaStreamID = mediaTrack.id;
      this.source = Track.Source.Unknown;
    }
    get logContext() {
      var _a;
      return Object.assign(
        Object.assign(
          {},
          (_a = this.loggerContextCb) === null || _a === void 0 ? void 0 : _a.call(this)
        ),
        getLogContextFromTrack(this)
      );
    }
    /** current receive bits per second */
    get currentBitrate() {
      return this._currentBitrate;
    }
    get mediaStreamTrack() {
      return this._mediaStreamTrack;
    }
    /**
     * @internal
     * used for keep mediaStream's first id, since it's id might change
     * if we disable/enable a track
     */
    get mediaStreamID() {
      return this._mediaStreamID;
    }
    attach(element) {
      let elementType = 'audio';
      if (this.kind === Track.Kind.Video) {
        elementType = 'video';
      }
      if (this.attachedElements.length === 0 && this.kind === Track.Kind.Video) {
        this.addAppVisibilityListener();
      }
      if (!element) {
        if (elementType === 'audio') {
          recycledElements.forEach((e) => {
            if (e.parentElement === null && !element) {
              element = e;
            }
          });
          if (element) {
            // remove it from pool
            recycledElements.splice(recycledElements.indexOf(element), 1);
          }
        }
        if (!element) {
          element = document.createElement(elementType);
        }
      }
      if (!this.attachedElements.includes(element)) {
        this.attachedElements.push(element);
      }
      // even if we believe it's already attached to the element, it's possible
      // the element's srcObject was set to something else out of band.
      // we'll want to re-attach it in that case
      attachToElement(this.mediaStreamTrack, element);
      // handle auto playback failures
      const allMediaStreamTracks = element.srcObject.getTracks();
      const hasAudio = allMediaStreamTracks.some((tr) => tr.kind === 'audio');
      // manually play media to detect auto playback status
      element
        .play()
        .then(() => {
          this.emit(hasAudio ? TrackEvent.AudioPlaybackStarted : TrackEvent.VideoPlaybackStarted);
        })
        .catch((e) => {
          if (e.name === 'NotAllowedError') {
            this.emit(
              hasAudio ? TrackEvent.AudioPlaybackFailed : TrackEvent.VideoPlaybackFailed,
              e
            );
          } else if (e.name === 'AbortError') {
            // commonly triggered by another `play` request, only log for debugging purposes
            livekitLogger.debug(
              ''.concat(
                hasAudio ? 'audio' : 'video',
                ' playback aborted, likely due to new play request'
              )
            );
          } else {
            livekitLogger.warn('could not playback '.concat(hasAudio ? 'audio' : 'video'), e);
          }
          // If audio playback isn't allowed make sure we still play back the video
          if (
            hasAudio &&
            element &&
            allMediaStreamTracks.some((tr) => tr.kind === 'video') &&
            e.name === 'NotAllowedError'
          ) {
            element.muted = true;
            element.play().catch(() => {
              // catch for Safari, exceeded options at this point to automatically play the media element
            });
          }
        });
      this.emit(TrackEvent.ElementAttached, element);
      return element;
    }
    detach(element) {
      try {
        // detach from a single element
        if (element) {
          detachTrack(this.mediaStreamTrack, element);
          const idx = this.attachedElements.indexOf(element);
          if (idx >= 0) {
            this.attachedElements.splice(idx, 1);
            this.recycleElement(element);
            this.emit(TrackEvent.ElementDetached, element);
          }
          return element;
        }
        const detached = [];
        this.attachedElements.forEach((elm) => {
          detachTrack(this.mediaStreamTrack, elm);
          detached.push(elm);
          this.recycleElement(elm);
          this.emit(TrackEvent.ElementDetached, elm);
        });
        // remove all tracks
        this.attachedElements = [];
        return detached;
      } finally {
        if (this.attachedElements.length === 0) {
          this.removeAppVisibilityListener();
        }
      }
    }
    stop() {
      this.stopMonitor();
      this._mediaStreamTrack.stop();
    }
    enable() {
      this._mediaStreamTrack.enabled = true;
    }
    disable() {
      this._mediaStreamTrack.enabled = false;
    }
    /* @internal */
    stopMonitor() {
      if (this.monitorInterval) {
        clearInterval(this.monitorInterval);
      }
      if (this.timeSyncHandle) {
        cancelAnimationFrame(this.timeSyncHandle);
      }
    }
    /** @internal */
    updateLoggerOptions(loggerOptions) {
      if (loggerOptions.loggerName) {
        this.log = getLogger(loggerOptions.loggerName);
      }
      if (loggerOptions.loggerContextCb) {
        this.loggerContextCb = loggerOptions.loggerContextCb;
      }
    }
    recycleElement(element) {
      if (element instanceof HTMLAudioElement) {
        // we only need to re-use a single element
        let shouldCache = true;
        element.pause();
        recycledElements.forEach((e) => {
          if (!e.parentElement) {
            shouldCache = false;
          }
        });
        if (shouldCache) {
          recycledElements.push(element);
        }
      }
    }
    handleAppVisibilityChanged() {
      return __awaiter(this, void 0, void 0, function* () {
        this.isInBackground = document.visibilityState === 'hidden';
        if (!this.isInBackground && this.kind === Track.Kind.Video) {
          setTimeout(
            () =>
              this.attachedElements.forEach((el) =>
                el.play().catch(() => {
                  /** catch clause necessary for Safari */
                })
              ),
            0
          );
        }
      });
    }
    addAppVisibilityListener() {
      if (isWeb()) {
        this.isInBackground = document.visibilityState === 'hidden';
        document.addEventListener('visibilitychange', this.appVisibilityChangedListener);
      } else {
        this.isInBackground = false;
      }
    }
    removeAppVisibilityListener() {
      if (isWeb()) {
        document.removeEventListener('visibilitychange', this.appVisibilityChangedListener);
      }
    }
  }
  function attachToElement(track, element) {
    let mediaStream;
    if (element.srcObject instanceof MediaStream) {
      mediaStream = element.srcObject;
    } else {
      mediaStream = new MediaStream();
    }
    // check if track matches existing track
    let existingTracks;
    if (track.kind === 'audio') {
      existingTracks = mediaStream.getAudioTracks();
    } else {
      existingTracks = mediaStream.getVideoTracks();
    }
    if (!existingTracks.includes(track)) {
      existingTracks.forEach((et) => {
        mediaStream.removeTrack(et);
      });
      mediaStream.addTrack(track);
    }
    if (!isSafari() || !(element instanceof HTMLVideoElement)) {
      // when in low power mode (applies to both macOS and iOS), Safari will show a play/pause overlay
      // when a video starts that has the `autoplay` attribute is set.
      // we work around this by _not_ setting the autoplay attribute on safari and instead call `setTimeout(() => el.play(),0)` further down
      element.autoplay = true;
    }
    // In case there are no audio tracks present on the mediastream, we set the element as muted to ensure autoplay works
    element.muted = mediaStream.getAudioTracks().length === 0;
    if (element instanceof HTMLVideoElement) {
      element.playsInline = true;
    }
    // avoid flicker
    if (element.srcObject !== mediaStream) {
      element.srcObject = mediaStream;
      if ((isSafari() || isFireFox()) && element instanceof HTMLVideoElement) {
        // Firefox also has a timing issue where video doesn't actually get attached unless
        // performed out-of-band
        // Safari 15 has a bug where in certain layouts, video element renders
        // black until the page is resized or other changes take place.
        // Resetting the src triggers it to render.
        // https://developer.apple.com/forums/thread/690523
        setTimeout(() => {
          element.srcObject = mediaStream;
          // Safari 15 sometimes fails to start a video
          // when the window is backgrounded before the first frame is drawn
          // manually calling play here seems to fix that
          element.play().catch(() => {
            /** do nothing */
          });
        }, 0);
      }
    }
  }
  /** @internal */
  function detachTrack(track, element) {
    if (element.srcObject instanceof MediaStream) {
      const mediaStream = element.srcObject;
      mediaStream.removeTrack(track);
      if (mediaStream.getTracks().length > 0) {
        element.srcObject = mediaStream;
      } else {
        element.srcObject = null;
      }
    }
  }
  (function (Track) {
    let Kind;
    (function (Kind) {
      Kind['Audio'] = 'audio';
      Kind['Video'] = 'video';
      Kind['Unknown'] = 'unknown';
    })((Kind = Track.Kind || (Track.Kind = {})));
    let Source;
    (function (Source) {
      Source['Camera'] = 'camera';
      Source['Microphone'] = 'microphone';
      Source['ScreenShare'] = 'screen_share';
      Source['ScreenShareAudio'] = 'screen_share_audio';
      Source['Unknown'] = 'unknown';
    })((Source = Track.Source || (Track.Source = {})));
    let StreamState$1;
    (function (StreamState) {
      StreamState['Active'] = 'active';
      StreamState['Paused'] = 'paused';
      StreamState['Unknown'] = 'unknown';
    })((StreamState$1 = Track.StreamState || (Track.StreamState = {})));
    /** @internal */
    function kindToProto(k) {
      switch (k) {
        case Kind.Audio:
          return TrackType.AUDIO;
        case Kind.Video:
          return TrackType.VIDEO;
        default:
          // FIXME this was UNRECOGNIZED before
          return TrackType.DATA;
      }
    }
    Track.kindToProto = kindToProto;
    /** @internal */
    function kindFromProto(t) {
      switch (t) {
        case TrackType.AUDIO:
          return Kind.Audio;
        case TrackType.VIDEO:
          return Kind.Video;
        default:
          return Kind.Unknown;
      }
    }
    Track.kindFromProto = kindFromProto;
    /** @internal */
    function sourceToProto(s) {
      switch (s) {
        case Source.Camera:
          return TrackSource.CAMERA;
        case Source.Microphone:
          return TrackSource.MICROPHONE;
        case Source.ScreenShare:
          return TrackSource.SCREEN_SHARE;
        case Source.ScreenShareAudio:
          return TrackSource.SCREEN_SHARE_AUDIO;
        default:
          return TrackSource.UNKNOWN;
      }
    }
    Track.sourceToProto = sourceToProto;
    /** @internal */
    function sourceFromProto(s) {
      switch (s) {
        case TrackSource.CAMERA:
          return Source.Camera;
        case TrackSource.MICROPHONE:
          return Source.Microphone;
        case TrackSource.SCREEN_SHARE:
          return Source.ScreenShare;
        case TrackSource.SCREEN_SHARE_AUDIO:
          return Source.ScreenShareAudio;
        default:
          return Source.Unknown;
      }
    }
    Track.sourceFromProto = sourceFromProto;
    /** @internal */
    function streamStateFromProto(s) {
      switch (s) {
        case StreamState.ACTIVE:
          return StreamState$1.Active;
        case StreamState.PAUSED:
          return StreamState$1.Paused;
        default:
          return StreamState$1.Unknown;
      }
    }
    Track.streamStateFromProto = streamStateFromProto;
  })(Track || (Track = {}));

  class VideoPreset {
    constructor(widthOrOptions, height, maxBitrate, maxFramerate, priority) {
      if (typeof widthOrOptions === 'object') {
        this.width = widthOrOptions.width;
        this.height = widthOrOptions.height;
        this.aspectRatio = widthOrOptions.aspectRatio;
        this.encoding = {
          maxBitrate: widthOrOptions.maxBitrate,
          maxFramerate: widthOrOptions.maxFramerate,
          priority: widthOrOptions.priority,
        };
      } else if (height !== undefined && maxBitrate !== undefined) {
        this.width = widthOrOptions;
        this.height = height;
        this.aspectRatio = widthOrOptions / height;
        this.encoding = {
          maxBitrate,
          maxFramerate,
          priority,
        };
      } else {
        throw new TypeError('Unsupported options: provide at least width, height and maxBitrate');
      }
    }
    get resolution() {
      return {
        width: this.width,
        height: this.height,
        frameRate: this.encoding.maxFramerate,
        aspectRatio: this.aspectRatio,
      };
    }
  }
  // `red` is not technically a codec, but treated as one in signalling protocol
  const audioCodecs = /* unused pure expression or super */ null && ['opus', 'red'];
  const backupVideoCodecs = ['vp8', 'h264'];
  const videoCodecs = ['vp8', 'h264', 'vp9', 'av1', 'h265'];
  function isBackupVideoCodec(codec) {
    return !!backupVideoCodecs.find((backup) => backup === codec);
  }
  /** @deprecated Use {@link isBackupVideoCodec} instead */
  const isBackupCodec = isBackupVideoCodec;
  var BackupCodecPolicy;
  (function (BackupCodecPolicy) {
    // codec regression is preferred, the sfu will try to regress codec if possible but not guaranteed
    BackupCodecPolicy[(BackupCodecPolicy['PREFER_REGRESSION'] = 0)] = 'PREFER_REGRESSION';
    // multi-codec simulcast, publish both primary and backup codec at the same time
    BackupCodecPolicy[(BackupCodecPolicy['SIMULCAST'] = 1)] = 'SIMULCAST';
    // always use backup codec only
    BackupCodecPolicy[(BackupCodecPolicy['REGRESSION'] = 2)] = 'REGRESSION';
  })(BackupCodecPolicy || (BackupCodecPolicy = {}));
  var AudioPresets;
  (function (AudioPresets) {
    AudioPresets.telephone = {
      maxBitrate: 12000,
    };
    AudioPresets.speech = {
      maxBitrate: 24000,
    };
    AudioPresets.music = {
      maxBitrate: 48000,
    };
    AudioPresets.musicStereo = {
      maxBitrate: 64000,
    };
    AudioPresets.musicHighQuality = {
      maxBitrate: 96000,
    };
    AudioPresets.musicHighQualityStereo = {
      maxBitrate: 128000,
    };
  })(AudioPresets || (AudioPresets = {}));
  /**
   * Sane presets for video resolution/encoding
   */
  const VideoPresets = {
    h90: new VideoPreset(160, 90, 90000, 20),
    h180: new VideoPreset(320, 180, 160000, 20),
    h216: new VideoPreset(384, 216, 180000, 20),
    h360: new VideoPreset(640, 360, 450000, 20),
    h540: new VideoPreset(960, 540, 800000, 25),
    h720: new VideoPreset(1280, 720, 1700000, 30),
    h1080: new VideoPreset(1920, 1080, 3000000, 30),
    h1440: new VideoPreset(2560, 1440, 5000000, 30),
    h2160: new VideoPreset(3840, 2160, 8000000, 30),
  };
  /**
   * Four by three presets
   */
  const VideoPresets43 = {
    h120: new VideoPreset(160, 120, 70000, 20),
    h180: new VideoPreset(240, 180, 125000, 20),
    h240: new VideoPreset(320, 240, 140000, 20),
    h360: new VideoPreset(480, 360, 330000, 20),
    h480: new VideoPreset(640, 480, 500000, 20),
    h540: new VideoPreset(720, 540, 600000, 25),
    h720: new VideoPreset(960, 720, 1300000, 30),
    h1080: new VideoPreset(1440, 1080, 2300000, 30),
    h1440: new VideoPreset(1920, 1440, 3800000, 30),
  };
  const ScreenSharePresets = {
    h360fps3: new VideoPreset(640, 360, 200000, 3, 'medium'),
    h360fps15: new VideoPreset(640, 360, 400000, 15, 'medium'),
    h720fps5: new VideoPreset(1280, 720, 800000, 5, 'medium'),
    h720fps15: new VideoPreset(1280, 720, 1500000, 15, 'medium'),
    h720fps30: new VideoPreset(1280, 720, 2000000, 30, 'medium'),
    h1080fps15: new VideoPreset(1920, 1080, 2500000, 15, 'medium'),
    h1080fps30: new VideoPreset(1920, 1080, 5000000, 30, 'medium'),
    // original resolution, without resizing
    original: new VideoPreset(0, 0, 7000000, 30, 'medium'),
  };

  const separator = '|';
  const ddExtensionURI =
    'https://aomediacodec.github.io/av1-rtp-spec/#dependency-descriptor-rtp-header-extension';
  function unpackStreamId(packed) {
    const parts = packed.split(separator);
    if (parts.length > 1) {
      return [parts[0], packed.substr(parts[0].length + 1)];
    }
    return [packed, ''];
  }
  function sleep(duration) {
    return __awaiter(this, void 0, void 0, function* () {
      return new Promise((resolve) => CriticalTimers.setTimeout(resolve, duration));
    });
  }
  /** @internal */
  function supportsTransceiver() {
    return 'addTransceiver' in RTCPeerConnection.prototype;
  }
  /** @internal */
  function supportsAddTrack() {
    return 'addTrack' in RTCPeerConnection.prototype;
  }
  function supportsAdaptiveStream() {
    return typeof ResizeObserver !== undefined && typeof IntersectionObserver !== undefined;
  }
  function supportsDynacast() {
    return supportsTransceiver();
  }
  function supportsAV1() {
    if (!('getCapabilities' in RTCRtpSender)) {
      return false;
    }
    if (isSafari() || isFireFox()) {
      // Safari 17 on iPhone14 reports AV1 capability, but does not actually support it
      // Firefox does support AV1, but SVC publishing is not supported
      return false;
    }
    const capabilities = RTCRtpSender.getCapabilities('video');
    let hasAV1 = false;
    if (capabilities) {
      for (const codec of capabilities.codecs) {
        if (codec.mimeType.toLowerCase() === 'video/av1') {
          hasAV1 = true;
          break;
        }
      }
    }
    return hasAV1;
  }
  function supportsVP9() {
    if (!('getCapabilities' in RTCRtpSender)) {
      return false;
    }
    if (isFireFox()) {
      // technically speaking FireFox supports VP9, but SVC publishing is broken
      // https://bugzilla.mozilla.org/show_bug.cgi?id=1633876
      return false;
    }
    if (isSafari()) {
      const browser = getBrowser();
      if (
        (browser === null || browser === void 0 ? void 0 : browser.version) &&
        compareVersions(browser.version, '16') < 0
      ) {
        // Safari 16 and below does not support VP9
        return false;
      }
      if (
        (browser === null || browser === void 0 ? void 0 : browser.os) === 'iOS' &&
        (browser === null || browser === void 0 ? void 0 : browser.osVersion) &&
        compareVersions(browser.osVersion, '16') < 0
      ) {
        // Safari 16 and below on iOS does not support VP9 we need the iOS check to account for other browsers running webkit under the hood
        return false;
      }
    }
    const capabilities = RTCRtpSender.getCapabilities('video');
    let hasVP9 = false;
    if (capabilities) {
      for (const codec of capabilities.codecs) {
        if (codec.mimeType.toLowerCase() === 'video/vp9') {
          hasVP9 = true;
          break;
        }
      }
    }
    return hasVP9;
  }
  function isSVCCodec(codec) {
    return codec === 'av1' || codec === 'vp9';
  }
  function supportsSetSinkId(elm) {
    if (!document || isSafariBased()) {
      return false;
    }
    if (!elm) {
      elm = document.createElement('audio');
    }
    return 'setSinkId' in elm;
  }
  function isBrowserSupported() {
    if (typeof RTCPeerConnection === 'undefined') {
      return false;
    }
    return supportsTransceiver() || supportsAddTrack();
  }
  function isFireFox() {
    var _a;
    return ((_a = getBrowser()) === null || _a === void 0 ? void 0 : _a.name) === 'Firefox';
  }
  function isSafari() {
    var _a;
    return ((_a = getBrowser()) === null || _a === void 0 ? void 0 : _a.name) === 'Safari';
  }
  function isSafariBased() {
    const b = getBrowser();
    return (
      (b === null || b === void 0 ? void 0 : b.name) === 'Safari' ||
      (b === null || b === void 0 ? void 0 : b.os) === 'iOS'
    );
  }
  function isSafari17Based() {
    const b = getBrowser();
    return (
      ((b === null || b === void 0 ? void 0 : b.name) === 'Safari' &&
        b.version.startsWith('17.')) ||
      ((b === null || b === void 0 ? void 0 : b.os) === 'iOS' &&
        !!(b === null || b === void 0 ? void 0 : b.osVersion) &&
        compareVersions(b.osVersion, '17') >= 0)
    );
  }
  function isSafariSvcApi(browser) {
    if (!browser) {
      browser = getBrowser();
    }
    // Safari 18.4 requires legacy svc api and scaleResolutionDown to be set
    return (
      ((browser === null || browser === void 0 ? void 0 : browser.name) === 'Safari' &&
        compareVersions(browser.version, '18.3') > 0) ||
      ((browser === null || browser === void 0 ? void 0 : browser.os) === 'iOS' &&
        !!(browser === null || browser === void 0 ? void 0 : browser.osVersion) &&
        compareVersions(browser.osVersion, '18.3') > 0)
    );
  }
  function isMobile() {
    var _a, _b;
    if (!isWeb()) return false;
    return (
      // @ts-expect-error `userAgentData` is not yet part of typescript
      (_b = (_a = navigator.userAgentData) === null || _a === void 0 ? void 0 : _a.mobile) !==
        null && _b !== void 0
        ? _b
        : /Tablet|iPad|Mobile|Android|BlackBerry/.test(navigator.userAgent)
    );
  }
  function isE2EESimulcastSupported() {
    const browser = getBrowser();
    const supportedSafariVersion = '17.2'; // see https://bugs.webkit.org/show_bug.cgi?id=257803
    if (browser) {
      if (browser.name !== 'Safari' && browser.os !== 'iOS') {
        return true;
      } else if (
        browser.os === 'iOS' &&
        browser.osVersion &&
        compareVersions(browser.osVersion, supportedSafariVersion) >= 0
      ) {
        return true;
      } else if (
        browser.name === 'Safari' &&
        compareVersions(browser.version, supportedSafariVersion) >= 0
      ) {
        return true;
      } else {
        return false;
      }
    }
  }
  function isWeb() {
    return typeof document !== 'undefined';
  }
  function isReactNative() {
    // navigator.product is deprecated on browsers, but will be set appropriately for react-native.
    return navigator.product == 'ReactNative';
  }
  function isCloud(serverUrl) {
    return (
      serverUrl.hostname.endsWith('.livekit.cloud') || serverUrl.hostname.endsWith('.livekit.run')
    );
  }
  function getLKReactNativeInfo() {
    // global defined only for ReactNative.
    // @ts-ignore
    if (global && global.LiveKitReactNativeGlobal) {
      // @ts-ignore
      return global.LiveKitReactNativeGlobal;
    }
    return undefined;
  }
  function getReactNativeOs() {
    if (!isReactNative()) {
      return undefined;
    }
    let info = getLKReactNativeInfo();
    if (info) {
      return info.platform;
    }
    return undefined;
  }
  function getDevicePixelRatio() {
    if (isWeb()) {
      return window.devicePixelRatio;
    }
    if (isReactNative()) {
      let info = getLKReactNativeInfo();
      if (info) {
        return info.devicePixelRatio;
      }
    }
    return 1;
  }
  /**
   * @param v1 - The first version string to compare.
   * @param v2 - The second version string to compare.
   * @returns A number indicating the order of the versions:
   *   - 1 if v1 is greater than v2
   *   - -1 if v1 is less than v2
   *   - 0 if v1 and v2 are equal
   */
  function compareVersions(v1, v2) {
    const parts1 = v1.split('.');
    const parts2 = v2.split('.');
    const k = Math.min(parts1.length, parts2.length);
    for (let i = 0; i < k; ++i) {
      const p1 = parseInt(parts1[i], 10);
      const p2 = parseInt(parts2[i], 10);
      if (p1 > p2) return 1;
      if (p1 < p2) return -1;
      if (i === k - 1 && p1 === p2) return 0;
    }
    if (v1 === '' && v2 !== '') {
      return -1;
    } else if (v2 === '') {
      return 1;
    }
    return parts1.length == parts2.length ? 0 : parts1.length < parts2.length ? -1 : 1;
  }
  function roDispatchCallback(entries) {
    for (const entry of entries) {
      entry.target.handleResize(entry);
    }
  }
  function ioDispatchCallback(entries) {
    for (const entry of entries) {
      entry.target.handleVisibilityChanged(entry);
    }
  }
  let resizeObserver = null;
  const getResizeObserver = () => {
    if (!resizeObserver) resizeObserver = new ResizeObserver(roDispatchCallback);
    return resizeObserver;
  };
  let intersectionObserver = null;
  const getIntersectionObserver = () => {
    if (!intersectionObserver) {
      intersectionObserver = new IntersectionObserver(ioDispatchCallback, {
        root: null,
        rootMargin: '0px',
      });
    }
    return intersectionObserver;
  };
  function getClientInfo() {
    var _a;
    const info = new ClientInfo({
      sdk: ClientInfo_SDK.JS,
      protocol: protocolVersion,
      version,
    });
    if (isReactNative()) {
      info.os = (_a = getReactNativeOs()) !== null && _a !== void 0 ? _a : '';
    }
    return info;
  }
  let emptyVideoStreamTrack;
  function getEmptyVideoStreamTrack() {
    if (!emptyVideoStreamTrack) {
      emptyVideoStreamTrack = createDummyVideoStreamTrack();
    }
    return emptyVideoStreamTrack.clone();
  }
  function createDummyVideoStreamTrack() {
    let width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 16;
    let height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 16;
    let enabled = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    let paintContent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    const canvas = document.createElement('canvas');
    // the canvas size is set to 16 by default, because electron apps seem to fail with smaller values
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext('2d');
    ctx === null || ctx === void 0 ? void 0 : ctx.fillRect(0, 0, canvas.width, canvas.height);
    if (paintContent && ctx) {
      ctx.beginPath();
      ctx.arc(width / 2, height / 2, 50, 0, Math.PI * 2, true);
      ctx.closePath();
      ctx.fillStyle = 'grey';
      ctx.fill();
    }
    // @ts-ignore
    const dummyStream = canvas.captureStream();
    const [dummyTrack] = dummyStream.getTracks();
    if (!dummyTrack) {
      throw Error('Could not get empty media stream video track');
    }
    dummyTrack.enabled = enabled;
    return dummyTrack;
  }
  let emptyAudioStreamTrack;
  function getEmptyAudioStreamTrack() {
    if (!emptyAudioStreamTrack) {
      // implementation adapted from https://blog.mozilla.org/webrtc/warm-up-with-replacetrack/
      const ctx = new AudioContext();
      const oscillator = ctx.createOscillator();
      const gain = ctx.createGain();
      gain.gain.setValueAtTime(0, 0);
      const dst = ctx.createMediaStreamDestination();
      oscillator.connect(gain);
      gain.connect(dst);
      oscillator.start();
      [emptyAudioStreamTrack] = dst.stream.getAudioTracks();
      if (!emptyAudioStreamTrack) {
        throw Error('Could not get empty media stream audio track');
      }
      emptyAudioStreamTrack.enabled = false;
    }
    return emptyAudioStreamTrack.clone();
  }
  class Future {
    get isResolved() {
      return this._isResolved;
    }
    constructor(futureBase, onFinally) {
      this._isResolved = false;
      this.onFinally = onFinally;
      this.promise = new Promise((resolve, reject) =>
        __awaiter(this, void 0, void 0, function* () {
          this.resolve = resolve;
          this.reject = reject;
          if (futureBase) {
            yield futureBase(resolve, reject);
          }
        })
      ).finally(() => {
        var _a;
        this._isResolved = true;
        (_a = this.onFinally) === null || _a === void 0 ? void 0 : _a.call(this);
      });
    }
  }
  /**
   * Creates and returns an analyser web audio node that is attached to the provided track.
   * Additionally returns a convenience method `calculateVolume` to perform instant volume readings on that track.
   * Call the returned `cleanup` function to close the audioContext that has been created for the instance of this helper
   */
  function createAudioAnalyser(track, options) {
    const opts = Object.assign(
      {
        cloneTrack: false,
        fftSize: 2048,
        smoothingTimeConstant: 0.8,
        minDecibels: -100,
        maxDecibels: -80,
      },
      options
    );
    const audioContext = getNewAudioContext();
    if (!audioContext) {
      throw new Error('Audio Context not supported on this browser');
    }
    const streamTrack = opts.cloneTrack ? track.mediaStreamTrack.clone() : track.mediaStreamTrack;
    const mediaStreamSource = audioContext.createMediaStreamSource(new MediaStream([streamTrack]));
    const analyser = audioContext.createAnalyser();
    analyser.minDecibels = opts.minDecibels;
    analyser.maxDecibels = opts.maxDecibels;
    analyser.fftSize = opts.fftSize;
    analyser.smoothingTimeConstant = opts.smoothingTimeConstant;
    mediaStreamSource.connect(analyser);
    const dataArray = new Uint8Array(analyser.frequencyBinCount);
    /**
     * Calculates the current volume of the track in the range from 0 to 1
     */
    const calculateVolume = () => {
      analyser.getByteFrequencyData(dataArray);
      let sum = 0;
      for (const amplitude of dataArray) {
        sum += Math.pow(amplitude / 255, 2);
      }
      const volume = Math.sqrt(sum / dataArray.length);
      return volume;
    };
    const cleanup = () =>
      __awaiter(this, void 0, void 0, function* () {
        yield audioContext.close();
        if (opts.cloneTrack) {
          streamTrack.stop();
        }
      });
    return {
      calculateVolume,
      analyser,
      cleanup,
    };
  }
  function isAudioCodec(maybeCodec) {
    return audioCodecs.includes(maybeCodec);
  }
  function isVideoCodec(maybeCodec) {
    return videoCodecs.includes(maybeCodec);
  }
  function unwrapConstraint(constraint) {
    if (typeof constraint === 'string' || typeof constraint === 'number') {
      return constraint;
    }
    if (Array.isArray(constraint)) {
      return constraint[0];
    }
    if (constraint.exact !== undefined) {
      if (Array.isArray(constraint.exact)) {
        return constraint.exact[0];
      }
      return constraint.exact;
    }
    if (constraint.ideal !== undefined) {
      if (Array.isArray(constraint.ideal)) {
        return constraint.ideal[0];
      }
      return constraint.ideal;
    }
    throw Error('could not unwrap constraint');
  }
  function toWebsocketUrl(url) {
    if (url.startsWith('http')) {
      return url.replace(/^(http)/, 'ws');
    }
    return url;
  }
  function toHttpUrl(url) {
    if (url.startsWith('ws')) {
      return url.replace(/^(ws)/, 'http');
    }
    return url;
  }
  function extractTranscriptionSegments(transcription, firstReceivedTimesMap) {
    return transcription.segments.map((_ref) => {
      let { id, text, language, startTime, endTime, final } = _ref;
      var _a;
      const firstReceivedTime =
        (_a = firstReceivedTimesMap.get(id)) !== null && _a !== void 0 ? _a : Date.now();
      const lastReceivedTime = Date.now();
      if (final) {
        firstReceivedTimesMap.delete(id);
      } else {
        firstReceivedTimesMap.set(id, firstReceivedTime);
      }
      return {
        id,
        text,
        startTime: Number.parseInt(startTime.toString()),
        endTime: Number.parseInt(endTime.toString()),
        final,
        language,
        firstReceivedTime,
        lastReceivedTime,
      };
    });
  }
  function extractChatMessage(msg) {
    const { id, timestamp, message, editTimestamp } = msg;
    return {
      id,
      timestamp: Number.parseInt(timestamp.toString()),
      editTimestamp: editTimestamp ? Number.parseInt(editTimestamp.toString()) : undefined,
      message,
    };
  }
  function getDisconnectReasonFromConnectionError(e) {
    switch (e.reason) {
      case ConnectionErrorReason.LeaveRequest:
        return e.context;
      case ConnectionErrorReason.Cancelled:
        return DisconnectReason.CLIENT_INITIATED;
      case ConnectionErrorReason.NotAllowed:
        return DisconnectReason.USER_REJECTED;
      case ConnectionErrorReason.ServerUnreachable:
        return DisconnectReason.JOIN_FAILURE;
      default:
        return DisconnectReason.UNKNOWN_REASON;
    }
  }
  /** convert bigints to numbers preserving undefined values */
  function bigIntToNumber(value) {
    return value !== undefined ? Number(value) : undefined;
  }
  /** convert numbers to bigints preserving undefined values */
  function numberToBigInt(value) {
    return value !== undefined ? BigInt(value) : undefined;
  }
  function isLocalTrack(track) {
    return !!track && !(track instanceof MediaStreamTrack) && track.isLocal;
  }
  function isAudioTrack(track) {
    return !!track && track.kind == Track.Kind.Audio;
  }
  function isVideoTrack(track) {
    return !!track && track.kind == Track.Kind.Video;
  }
  function isLocalVideoTrack(track) {
    return isLocalTrack(track) && isVideoTrack(track);
  }
  function isLocalAudioTrack(track) {
    return isLocalTrack(track) && isAudioTrack(track);
  }
  function isRemoteTrack(track) {
    return !!track && !track.isLocal;
  }
  function isRemotePub(pub) {
    return !!pub && !pub.isLocal;
  }
  function isRemoteVideoTrack(track) {
    return isRemoteTrack(track) && isVideoTrack(track);
  }
  function isLocalParticipant(p) {
    return p.isLocal;
  }
  function isRemoteParticipant(p) {
    return !p.isLocal;
  }
  function splitUtf8(s, n) {
    // adapted from https://stackoverflow.com/a/6043797
    const result = [];
    let encoded = new TextEncoder().encode(s);
    while (encoded.length > n) {
      let k = n;
      while (k > 0) {
        const byte = encoded[k];
        if (byte !== undefined && (byte & 0xc0) !== 0x80) {
          break;
        }
        k--;
      }
      result.push(encoded.slice(0, k));
      encoded = encoded.slice(k);
    }
    if (encoded.length > 0) {
      result.push(encoded);
    }
    return result;
  }

  function mergeDefaultOptions(options, audioDefaults, videoDefaults) {
    var _a, _b;
    var _c, _d;
    const { optionsWithoutProcessor, audioProcessor, videoProcessor } =
      extractProcessorsFromOptions(options !== null && options !== void 0 ? options : {});
    const defaultAudioProcessor =
      audioDefaults === null || audioDefaults === void 0 ? void 0 : audioDefaults.processor;
    const defaultVideoProcessor =
      videoDefaults === null || videoDefaults === void 0 ? void 0 : videoDefaults.processor;
    const clonedOptions =
      optionsWithoutProcessor !== null && optionsWithoutProcessor !== void 0
        ? optionsWithoutProcessor
        : {};
    if (clonedOptions.audio === true) clonedOptions.audio = {};
    if (clonedOptions.video === true) clonedOptions.video = {};
    // use defaults
    if (clonedOptions.audio) {
      mergeObjectWithoutOverwriting(clonedOptions.audio, audioDefaults);
      (_a = (_c = clonedOptions.audio).deviceId) !== null && _a !== void 0
        ? _a
        : (_c.deviceId = {
            ideal: 'default',
          });
      if (audioProcessor || defaultAudioProcessor) {
        clonedOptions.audio.processor =
          audioProcessor !== null && audioProcessor !== void 0
            ? audioProcessor
            : defaultAudioProcessor;
      }
    }
    if (clonedOptions.video) {
      mergeObjectWithoutOverwriting(clonedOptions.video, videoDefaults);
      (_b = (_d = clonedOptions.video).deviceId) !== null && _b !== void 0
        ? _b
        : (_d.deviceId = {
            ideal: 'default',
          });
      if (videoProcessor || defaultVideoProcessor) {
        clonedOptions.video.processor =
          videoProcessor !== null && videoProcessor !== void 0
            ? videoProcessor
            : defaultVideoProcessor;
      }
    }
    return clonedOptions;
  }
  function mergeObjectWithoutOverwriting(mainObject, objectToMerge) {
    Object.keys(objectToMerge).forEach((key) => {
      if (mainObject[key] === undefined) mainObject[key] = objectToMerge[key];
    });
    return mainObject;
  }
  function constraintsForOptions(options) {
    var _a, _b;
    var _c, _d;
    const constraints = {};
    if (options.video) {
      // default video options
      if (typeof options.video === 'object') {
        const videoOptions = {};
        const target = videoOptions;
        const source = options.video;
        Object.keys(source).forEach((key) => {
          switch (key) {
            case 'resolution':
              // flatten VideoResolution fields
              mergeObjectWithoutOverwriting(target, source.resolution);
              break;
            default:
              target[key] = source[key];
          }
        });
        constraints.video = videoOptions;
        (_a = (_c = constraints.video).deviceId) !== null && _a !== void 0
          ? _a
          : (_c.deviceId = {
              ideal: 'default',
            });
      } else {
        constraints.video = options.video
          ? {
              deviceId: {
                ideal: 'default',
              },
            }
          : false;
      }
    } else {
      constraints.video = false;
    }
    if (options.audio) {
      if (typeof options.audio === 'object') {
        constraints.audio = options.audio;
        (_b = (_d = constraints.audio).deviceId) !== null && _b !== void 0
          ? _b
          : (_d.deviceId = {
              ideal: 'default',
            });
      } else {
        constraints.audio = {
          deviceId: {
            ideal: 'default',
          },
        };
      }
    } else {
      constraints.audio = false;
    }
    return constraints;
  }
  /**
   * This function detects silence on a given [[Track]] instance.
   * Returns true if the track seems to be entirely silent.
   */
  function detectSilence(track_1) {
    return __awaiter(this, arguments, void 0, function (track) {
      let timeOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 200;
      return (function* () {
        const ctx = getNewAudioContext();
        if (ctx) {
          const analyser = ctx.createAnalyser();
          analyser.fftSize = 2048;
          const bufferLength = analyser.frequencyBinCount;
          const dataArray = new Uint8Array(bufferLength);
          const source = ctx.createMediaStreamSource(new MediaStream([track.mediaStreamTrack]));
          source.connect(analyser);
          yield sleep(timeOffset);
          analyser.getByteTimeDomainData(dataArray);
          const someNoise = dataArray.some((sample) => sample !== 128 && sample !== 0);
          ctx.close();
          return !someNoise;
        }
        return false;
      })();
    });
  }
  /**
   * @internal
   */
  function getNewAudioContext() {
    var _a;
    const AudioContext =
      // @ts-ignore
      typeof window !== 'undefined' && (window.AudioContext || window.webkitAudioContext);
    if (AudioContext) {
      const audioContext = new AudioContext({
        latencyHint: 'interactive',
      });
      // If the audio context is suspended, we need to resume it when the user clicks on the page
      if (
        audioContext.state === 'suspended' &&
        typeof window !== 'undefined' &&
        ((_a = window.document) === null || _a === void 0 ? void 0 : _a.body)
      ) {
        const handleResume = () =>
          __awaiter(this, void 0, void 0, function* () {
            var _a;
            try {
              if (audioContext.state === 'suspended') {
                yield audioContext.resume();
              }
            } catch (e) {
              console.warn('Error trying to auto-resume audio context', e);
            } finally {
              (_a = window.document.body) === null || _a === void 0
                ? void 0
                : _a.removeEventListener('click', handleResume);
            }
          });
        // https://developer.mozilla.org/en-US/docs/Web/API/BaseAudioContext/statechange_event
        audioContext.addEventListener('statechange', () => {
          var _a;
          if (audioContext.state === 'closed') {
            (_a = window.document.body) === null || _a === void 0
              ? void 0
              : _a.removeEventListener('click', handleResume);
          }
        });
        window.document.body.addEventListener('click', handleResume);
      }
      return audioContext;
    }
  }
  /**
   * @internal
   */
  function kindToSource(kind) {
    if (kind === 'audioinput') {
      return Track.Source.Microphone;
    } else if (kind === 'videoinput') {
      return Track.Source.Camera;
    } else {
      return Track.Source.Unknown;
    }
  }
  /**
   * @internal
   */
  function sourceToKind(source) {
    if (source === Track.Source.Microphone) {
      return 'audioinput';
    } else if (source === Track.Source.Camera) {
      return 'videoinput';
    } else {
      return undefined;
    }
  }
  /**
   * @internal
   */
  function screenCaptureToDisplayMediaStreamOptions(options) {
    var _a, _b;
    let videoConstraints = (_a = options.video) !== null && _a !== void 0 ? _a : true;
    // treat 0 as uncapped
    if (options.resolution && options.resolution.width > 0 && options.resolution.height > 0) {
      videoConstraints = typeof videoConstraints === 'boolean' ? {} : videoConstraints;
      if (isSafari()) {
        videoConstraints = Object.assign(Object.assign({}, videoConstraints), {
          width: {
            max: options.resolution.width,
          },
          height: {
            max: options.resolution.height,
          },
          frameRate: options.resolution.frameRate,
        });
      } else {
        videoConstraints = Object.assign(Object.assign({}, videoConstraints), {
          width: {
            ideal: options.resolution.width,
          },
          height: {
            ideal: options.resolution.height,
          },
          frameRate: options.resolution.frameRate,
        });
      }
    }
    return {
      audio: (_b = options.audio) !== null && _b !== void 0 ? _b : false,
      video: videoConstraints,
      // @ts-expect-error support for experimental display media features
      controller: options.controller,
      selfBrowserSurface: options.selfBrowserSurface,
      surfaceSwitching: options.surfaceSwitching,
      systemAudio: options.systemAudio,
      preferCurrentTab: options.preferCurrentTab,
    };
  }
  function mimeTypeToVideoCodecString(mimeType) {
    return mimeType.split('/')[1].toLowerCase();
  }
  function getTrackPublicationInfo(tracks) {
    const infos = [];
    tracks.forEach((track) => {
      if (track.track !== undefined) {
        infos.push(
          new TrackPublishedResponse({
            cid: track.track.mediaStreamID,
            track: track.trackInfo,
          })
        );
      }
    });
    return infos;
  }
  function getLogContextFromTrack(track) {
    if ('mediaStreamTrack' in track) {
      return {
        trackID: track.sid,
        source: track.source,
        muted: track.isMuted,
        enabled: track.mediaStreamTrack.enabled,
        kind: track.kind,
        streamID: track.mediaStreamID,
        streamTrackID: track.mediaStreamTrack.id,
      };
    } else {
      return {
        trackID: track.trackSid,
        enabled: track.isEnabled,
        muted: track.isMuted,
        trackInfo: Object.assign(
          {
            mimeType: track.mimeType,
            name: track.trackName,
            encrypted: track.isEncrypted,
            kind: track.kind,
            source: track.source,
          },
          track.track ? getLogContextFromTrack(track.track) : {}
        ),
      };
    }
  }
  function supportsSynchronizationSources() {
    return typeof RTCRtpReceiver !== 'undefined' && 'getSynchronizationSources' in RTCRtpReceiver;
  }
  function diffAttributes(oldValues, newValues) {
    var _a;
    if (oldValues === undefined) {
      oldValues = {};
    }
    if (newValues === undefined) {
      newValues = {};
    }
    const allKeys = [...Object.keys(newValues), ...Object.keys(oldValues)];
    const diff = {};
    for (const key of allKeys) {
      if (oldValues[key] !== newValues[key]) {
        diff[key] = (_a = newValues[key]) !== null && _a !== void 0 ? _a : '';
      }
    }
    return diff;
  }
  /** @internal */
  function extractProcessorsFromOptions(options) {
    const newOptions = Object.assign({}, options);
    let audioProcessor;
    let videoProcessor;
    if (typeof newOptions.audio === 'object' && newOptions.audio.processor) {
      audioProcessor = newOptions.audio.processor;
      newOptions.audio = Object.assign(Object.assign({}, newOptions.audio), {
        processor: undefined,
      });
    }
    if (typeof newOptions.video === 'object' && newOptions.video.processor) {
      videoProcessor = newOptions.video.processor;
      newOptions.video = Object.assign(Object.assign({}, newOptions.video), {
        processor: undefined,
      });
    }
    return {
      audioProcessor,
      videoProcessor,
      optionsWithoutProcessor: cloneDeep(newOptions),
    };
  }
  function getTrackSourceFromProto(source) {
    switch (source) {
      case TrackSource.CAMERA:
        return Track.Source.Camera;
      case TrackSource.MICROPHONE:
        return Track.Source.Microphone;
      case TrackSource.SCREEN_SHARE:
        return Track.Source.ScreenShare;
      case TrackSource.SCREEN_SHARE_AUDIO:
        return Track.Source.ScreenShareAudio;
      default:
        return Track.Source.Unknown;
    }
  }
  function areDimensionsSmaller(a, b) {
    return a.width * a.height < b.width * b.height;
  }
  function layerDimensionsFor(trackInfo, quality) {
    var _a;
    return (_a = trackInfo.layers) === null || _a === void 0
      ? void 0
      : _a.find((l) => l.quality === quality);
  }

  /**
   * @experimental
   */
  class E2EEManager extends eventsExports.EventEmitter {
    constructor(options, dcEncryptionEnabled) {
      super();
      this.decryptDataRequests = new Map();
      this.encryptDataRequests = new Map();
      this.onWorkerMessage = (ev) => {
        var _a, _b;
        const { kind, data } = ev.data;
        switch (kind) {
          case 'error':
            livekitLogger.error(data.error.message);
            this.emit(EncryptionEvent.EncryptionError, data.error);
            break;
          case 'initAck':
            if (data.enabled) {
              this.keyProvider.getKeys().forEach((keyInfo) => {
                this.postKey(keyInfo);
              });
            }
            break;
          case 'enable':
            if (data.enabled) {
              this.keyProvider.getKeys().forEach((keyInfo) => {
                this.postKey(keyInfo);
              });
            }
            if (
              this.encryptionEnabled !== data.enabled &&
              data.participantIdentity ===
                ((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity)
            ) {
              this.emit(
                EncryptionEvent.ParticipantEncryptionStatusChanged,
                data.enabled,
                this.room.localParticipant
              );
              this.encryptionEnabled = data.enabled;
            } else if (data.participantIdentity) {
              const participant =
                (_b = this.room) === null || _b === void 0
                  ? void 0
                  : _b.getParticipantByIdentity(data.participantIdentity);
              if (!participant) {
                throw TypeError(
                  "couldn't set encryption status, participant not found".concat(
                    data.participantIdentity
                  )
                );
              }
              this.emit(
                EncryptionEvent.ParticipantEncryptionStatusChanged,
                data.enabled,
                participant
              );
            }
            break;
          case 'ratchetKey':
            this.keyProvider.emit(
              KeyProviderEvent.KeyRatcheted,
              data.ratchetResult,
              data.participantIdentity,
              data.keyIndex
            );
            break;
          case 'decryptDataResponse':
            const decryptFuture = this.decryptDataRequests.get(data.uuid);
            if (
              decryptFuture === null || decryptFuture === void 0 ? void 0 : decryptFuture.resolve
            ) {
              decryptFuture.resolve(data);
            }
            break;
          case 'encryptDataResponse':
            const encryptFuture = this.encryptDataRequests.get(data.uuid);
            if (
              encryptFuture === null || encryptFuture === void 0 ? void 0 : encryptFuture.resolve
            ) {
              encryptFuture.resolve(data);
            }
            break;
        }
      };
      this.onWorkerError = (ev) => {
        livekitLogger.error('e2ee worker encountered an error:', {
          error: ev.error,
        });
        this.emit(EncryptionEvent.EncryptionError, ev.error);
      };
      this.keyProvider = options.keyProvider;
      this.worker = options.worker;
      this.encryptionEnabled = false;
      this.dataChannelEncryptionEnabled = dcEncryptionEnabled;
    }
    get isEnabled() {
      return this.encryptionEnabled;
    }
    get isDataChannelEncryptionEnabled() {
      return this.isEnabled && this.dataChannelEncryptionEnabled;
    }
    /**
     * @internal
     */
    setup(room) {
      if (!isE2EESupported()) {
        throw new DeviceUnsupportedError(
          'tried to setup end-to-end encryption on an unsupported browser'
        );
      }
      livekitLogger.info('setting up e2ee');
      if (room !== this.room) {
        this.room = room;
        this.setupEventListeners(room, this.keyProvider);
        // this.worker = new Worker('');
        const msg = {
          kind: 'init',
          data: {
            keyProviderOptions: this.keyProvider.getOptions(),
            loglevel: workerLogger.getLevel(),
          },
        };
        if (this.worker) {
          livekitLogger.info('initializing worker', {
            worker: this.worker,
          });
          this.worker.onmessage = this.onWorkerMessage;
          this.worker.onerror = this.onWorkerError;
          this.worker.postMessage(msg);
        }
      }
    }
    /**
     * @internal
     */
    setParticipantCryptorEnabled(enabled, participantIdentity) {
      livekitLogger.debug(
        'set e2ee to '.concat(enabled, ' for participant ').concat(participantIdentity)
      );
      this.postEnable(enabled, participantIdentity);
    }
    /**
     * @internal
     */
    setSifTrailer(trailer) {
      if (!trailer || trailer.length === 0) {
        livekitLogger.warn("ignoring server sent trailer as it's empty");
      } else {
        this.postSifTrailer(trailer);
      }
    }
    setupEngine(engine) {
      engine.on(EngineEvent.RTPVideoMapUpdate, (rtpMap) => {
        this.postRTPMap(rtpMap);
      });
    }
    setupEventListeners(room, keyProvider) {
      room.on(RoomEvent.TrackPublished, (pub, participant) =>
        this.setParticipantCryptorEnabled(
          pub.trackInfo.encryption !== Encryption_Type.NONE,
          participant.identity
        )
      );
      room
        .on(RoomEvent.ConnectionStateChanged, (state) => {
          if (state === ConnectionState.Connected) {
            room.remoteParticipants.forEach((participant) => {
              participant.trackPublications.forEach((pub) => {
                this.setParticipantCryptorEnabled(
                  pub.trackInfo.encryption !== Encryption_Type.NONE,
                  participant.identity
                );
              });
            });
          }
        })
        .on(RoomEvent.TrackUnsubscribed, (track, _, participant) => {
          var _a;
          const msg = {
            kind: 'removeTransform',
            data: {
              participantIdentity: participant.identity,
              trackId: track.mediaStreamID,
            },
          };
          (_a = this.worker) === null || _a === void 0 ? void 0 : _a.postMessage(msg);
        })
        .on(RoomEvent.TrackSubscribed, (track, pub, participant) => {
          this.setupE2EEReceiver(track, participant.identity, pub.trackInfo);
        })
        .on(RoomEvent.SignalConnected, () => {
          if (!this.room) {
            throw new TypeError('expected room to be present on signal connect');
          }
          keyProvider.getKeys().forEach((keyInfo) => {
            this.postKey(keyInfo);
          });
          this.setParticipantCryptorEnabled(
            this.room.localParticipant.isE2EEEnabled,
            this.room.localParticipant.identity
          );
        });
      room.localParticipant.on(ParticipantEvent.LocalSenderCreated, (sender, track) =>
        __awaiter(this, void 0, void 0, function* () {
          this.setupE2EESender(track, sender);
        })
      );
      room.localParticipant.on(ParticipantEvent.LocalTrackPublished, (publication) => {
        // Safari doesn't support retrieving payload information on RTCEncodedVideoFrame, so we need to update the codec manually once we have the trackInfo from the server
        if (!isVideoTrack(publication.track) || !isSafariBased()) {
          return;
        }
        const msg = {
          kind: 'updateCodec',
          data: {
            trackId: publication.track.mediaStreamID,
            codec: mimeTypeToVideoCodecString(publication.trackInfo.codecs[0].mimeType),
            participantIdentity: this.room.localParticipant.identity,
          },
        };
        this.worker.postMessage(msg);
      });
      keyProvider
        .on(KeyProviderEvent.SetKey, (keyInfo) => this.postKey(keyInfo))
        .on(KeyProviderEvent.RatchetRequest, (participantId, keyIndex) =>
          this.postRatchetRequest(participantId, keyIndex)
        );
    }
    encryptData(data) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.worker) {
          throw Error('could not encrypt data, worker is missing');
        }
        const uuid = crypto.randomUUID();
        const msg = {
          kind: 'encryptDataRequest',
          data: {
            uuid,
            payload: data,
            participantIdentity: this.room.localParticipant.identity,
          },
        };
        const future = new Future();
        future.onFinally = () => {
          this.encryptDataRequests.delete(uuid);
        };
        this.encryptDataRequests.set(uuid, future);
        this.worker.postMessage(msg);
        return future.promise;
      });
    }
    handleEncryptedData(payload, iv, participantIdentity, keyIndex) {
      if (!this.worker) {
        throw Error('could not handle encrypted data, worker is missing');
      }
      const uuid = crypto.randomUUID();
      const msg = {
        kind: 'decryptDataRequest',
        data: {
          uuid,
          payload,
          iv,
          participantIdentity,
          keyIndex,
        },
      };
      const future = new Future();
      future.onFinally = () => {
        this.decryptDataRequests.delete(uuid);
      };
      this.decryptDataRequests.set(uuid, future);
      this.worker.postMessage(msg);
      return future.promise;
    }
    postRatchetRequest(participantIdentity, keyIndex) {
      if (!this.worker) {
        throw Error('could not ratchet key, worker is missing');
      }
      const msg = {
        kind: 'ratchetRequest',
        data: {
          participantIdentity: participantIdentity,
          keyIndex,
        },
      };
      this.worker.postMessage(msg);
    }
    postKey(_ref) {
      let { key, participantIdentity, keyIndex } = _ref;
      var _a;
      if (!this.worker) {
        throw Error('could not set key, worker is missing');
      }
      const msg = {
        kind: 'setKey',
        data: {
          participantIdentity: participantIdentity,
          isPublisher:
            participantIdentity ===
            ((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity),
          key,
          keyIndex,
        },
      };
      this.worker.postMessage(msg);
    }
    postEnable(enabled, participantIdentity) {
      if (this.worker) {
        const enableMsg = {
          kind: 'enable',
          data: {
            enabled,
            participantIdentity,
          },
        };
        this.worker.postMessage(enableMsg);
      } else {
        throw new ReferenceError('failed to enable e2ee, worker is not ready');
      }
    }
    postRTPMap(map) {
      var _a;
      if (!this.worker) {
        throw TypeError('could not post rtp map, worker is missing');
      }
      if (!((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity)) {
        throw TypeError('could not post rtp map, local participant identity is missing');
      }
      const msg = {
        kind: 'setRTPMap',
        data: {
          map,
          participantIdentity: this.room.localParticipant.identity,
        },
      };
      this.worker.postMessage(msg);
    }
    postSifTrailer(trailer) {
      if (!this.worker) {
        throw Error('could not post SIF trailer, worker is missing');
      }
      const msg = {
        kind: 'setSifTrailer',
        data: {
          trailer,
        },
      };
      this.worker.postMessage(msg);
    }
    setupE2EEReceiver(track, remoteId, trackInfo) {
      if (!track.receiver) {
        return;
      }
      if (
        !(trackInfo === null || trackInfo === void 0 ? void 0 : trackInfo.mimeType) ||
        trackInfo.mimeType === ''
      ) {
        throw new TypeError('MimeType missing from trackInfo, cannot set up E2EE cryptor');
      }
      this.handleReceiver(
        track.receiver,
        track.mediaStreamID,
        remoteId,
        track.kind === 'video' ? mimeTypeToVideoCodecString(trackInfo.mimeType) : undefined
      );
    }
    setupE2EESender(track, sender) {
      if (!isLocalTrack(track) || !sender) {
        if (!sender) livekitLogger.warn('early return because sender is not ready');
        return;
      }
      this.handleSender(sender, track.mediaStreamID, undefined);
    }
    /**
     * Handles the given {@code RTCRtpReceiver} by creating a {@code TransformStream} which will inject
     * a frame decoder.
     *
     */
    handleReceiver(receiver, trackId, participantIdentity, codec) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.worker) {
          return;
        }
        if (isScriptTransformSupported()) {
          const options = {
            kind: 'decode',
            participantIdentity,
            trackId,
            codec,
          };
          // @ts-ignore
          receiver.transform = new RTCRtpScriptTransform(this.worker, options);
        } else {
          if (E2EE_FLAG in receiver && codec) {
            // only update codec
            const msg = {
              kind: 'updateCodec',
              data: {
                trackId,
                codec,
                participantIdentity: participantIdentity,
              },
            };
            this.worker.postMessage(msg);
            return;
          }
          // @ts-ignore
          let writable = receiver.writableStream;
          // @ts-ignore
          let readable = receiver.readableStream;
          if (!writable || !readable) {
            // @ts-ignore
            const receiverStreams = receiver.createEncodedStreams();
            // @ts-ignore
            receiver.writableStream = receiverStreams.writable;
            writable = receiverStreams.writable;
            // @ts-ignore
            receiver.readableStream = receiverStreams.readable;
            readable = receiverStreams.readable;
          }
          const msg = {
            kind: 'decode',
            data: {
              readableStream: readable,
              writableStream: writable,
              trackId: trackId,
              codec,
              participantIdentity: participantIdentity,
              isReuse: E2EE_FLAG in receiver,
            },
          };
          this.worker.postMessage(msg, [readable, writable]);
        }
        // @ts-ignore
        receiver[E2EE_FLAG] = true;
      });
    }
    /**
     * Handles the given {@code RTCRtpSender} by creating a {@code TransformStream} which will inject
     * a frame encoder.
     *
     */
    handleSender(sender, trackId, codec) {
      var _a;
      if (E2EE_FLAG in sender || !this.worker) {
        return;
      }
      if (
        !((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity) ||
        this.room.localParticipant.identity === ''
      ) {
        throw TypeError('local identity needs to be known in order to set up encrypted sender');
      }
      if (isScriptTransformSupported()) {
        livekitLogger.info('initialize script transform');
        const options = {
          kind: 'encode',
          participantIdentity: this.room.localParticipant.identity,
          trackId,
          codec,
        };
        // @ts-ignore
        sender.transform = new RTCRtpScriptTransform(this.worker, options);
      } else {
        livekitLogger.info('initialize encoded streams');
        // @ts-ignore
        const senderStreams = sender.createEncodedStreams();
        const msg = {
          kind: 'encode',
          data: {
            readableStream: senderStreams.readable,
            writableStream: senderStreams.writable,
            codec,
            trackId,
            participantIdentity: this.room.localParticipant.identity,
            isReuse: false,
          },
        };
        this.worker.postMessage(msg, [senderStreams.readable, senderStreams.writable]);
      }
      // @ts-ignore
      sender[E2EE_FLAG] = true;
    }
  }

  const defaultId = 'default';
  class DeviceManager {
    constructor() {
      this._previousDevices = [];
    }
    static getInstance() {
      if (this.instance === undefined) {
        this.instance = new DeviceManager();
      }
      return this.instance;
    }
    get previousDevices() {
      return this._previousDevices;
    }
    getDevices(kind_1) {
      return __awaiter(this, arguments, void 0, function (kind) {
        var _this = this;
        let requestPermissions =
          arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        return (function* () {
          var _a;
          if (
            ((_a = DeviceManager.userMediaPromiseMap) === null || _a === void 0
              ? void 0
              : _a.size) > 0
          ) {
            livekitLogger.debug('awaiting getUserMedia promise');
            try {
              if (kind) {
                yield DeviceManager.userMediaPromiseMap.get(kind);
              } else {
                yield Promise.all(DeviceManager.userMediaPromiseMap.values());
              }
            } catch (e) {
              livekitLogger.warn('error waiting for media permissons');
            }
          }
          let devices = yield navigator.mediaDevices.enumerateDevices();
          if (
            requestPermissions &&
            // for safari we need to skip this check, as otherwise it will re-acquire user media and fail on iOS https://bugs.webkit.org/show_bug.cgi?id=179363
            !(isSafari() && _this.hasDeviceInUse(kind))
          ) {
            const isDummyDeviceOrEmpty =
              devices.filter((d) => d.kind === kind).length === 0 ||
              devices.some((device) => {
                const noLabel = device.label === '';
                const isRelevant = kind ? device.kind === kind : true;
                return noLabel && isRelevant;
              });
            if (isDummyDeviceOrEmpty) {
              const permissionsToAcquire = {
                video: kind !== 'audioinput' && kind !== 'audiooutput',
                audio: kind !== 'videoinput' && {
                  deviceId: {
                    ideal: 'default',
                  },
                },
              };
              const stream = yield navigator.mediaDevices.getUserMedia(permissionsToAcquire);
              devices = yield navigator.mediaDevices.enumerateDevices();
              stream.getTracks().forEach((track) => {
                track.stop();
              });
            }
          }
          _this._previousDevices = devices;
          if (kind) {
            devices = devices.filter((device) => device.kind === kind);
          }
          return devices;
        })();
      });
    }
    normalizeDeviceId(kind, deviceId, groupId) {
      return __awaiter(this, void 0, void 0, function* () {
        if (deviceId !== defaultId) {
          return deviceId;
        }
        // resolve actual device id if it's 'default': Chrome returns it when no
        // device has been chosen
        const devices = yield this.getDevices(kind);
        const defaultDevice = devices.find((d) => d.deviceId === defaultId);
        if (!defaultDevice) {
          livekitLogger.warn('could not reliably determine default device');
          return undefined;
        }
        const device = devices.find(
          (d) =>
            d.deviceId !== defaultId &&
            d.groupId === (groupId !== null && groupId !== void 0 ? groupId : defaultDevice.groupId)
        );
        if (!device) {
          livekitLogger.warn('could not reliably determine default device');
          return undefined;
        }
        return device === null || device === void 0 ? void 0 : device.deviceId;
      });
    }
    hasDeviceInUse(kind) {
      return kind
        ? DeviceManager.userMediaPromiseMap.has(kind)
        : DeviceManager.userMediaPromiseMap.size > 0;
    }
  }
  DeviceManager.mediaDeviceKinds = ['audioinput', 'audiooutput', 'videoinput'];
  DeviceManager.userMediaPromiseMap = new Map();

  var QueueTaskStatus;
  (function (QueueTaskStatus) {
    QueueTaskStatus[(QueueTaskStatus['WAITING'] = 0)] = 'WAITING';
    QueueTaskStatus[(QueueTaskStatus['RUNNING'] = 1)] = 'RUNNING';
    QueueTaskStatus[(QueueTaskStatus['COMPLETED'] = 2)] = 'COMPLETED';
  })(QueueTaskStatus || (QueueTaskStatus = {}));
  class AsyncQueue {
    constructor() {
      this.pendingTasks = new Map();
      this.taskMutex = new livekit_client_esm_();
      this.nextTaskIndex = 0;
    }
    run(task) {
      return __awaiter(this, void 0, void 0, function* () {
        const taskInfo = {
          id: this.nextTaskIndex++,
          enqueuedAt: Date.now(),
          status: QueueTaskStatus.WAITING,
        };
        this.pendingTasks.set(taskInfo.id, taskInfo);
        const unlock = yield this.taskMutex.lock();
        try {
          taskInfo.executedAt = Date.now();
          taskInfo.status = QueueTaskStatus.RUNNING;
          return yield task();
        } finally {
          taskInfo.status = QueueTaskStatus.COMPLETED;
          this.pendingTasks.delete(taskInfo.id);
          unlock();
        }
      });
    }
    flush() {
      return __awaiter(this, void 0, void 0, function* () {
        return this.run(() => __awaiter(this, void 0, void 0, function* () {}));
      });
    }
    snapshot() {
      return Array.from(this.pendingTasks.values());
    }
  }

  function createRtcUrl(url, searchParams) {
    const urlObj = new URL(toWebsocketUrl(url));
    searchParams.forEach((value, key) => {
      urlObj.searchParams.set(key, value);
    });
    return appendUrlPath(urlObj, 'rtc');
  }
  function createValidateUrl(rtcWsUrl) {
    const urlObj = new URL(toHttpUrl(rtcWsUrl));
    return appendUrlPath(urlObj, 'validate');
  }
  function ensureTrailingSlash(path) {
    return path.endsWith('/') ? path : ''.concat(path, '/');
  }
  function appendUrlPath(urlObj, path) {
    urlObj.pathname = ''.concat(ensureTrailingSlash(urlObj.pathname)).concat(path);
    return urlObj.toString();
  }

  const passThroughQueueSignals = ['syncState', 'trickle', 'offer', 'answer', 'simulate', 'leave'];
  function canPassThroughQueue(req) {
    const canPass = passThroughQueueSignals.indexOf(req.case) >= 0;
    livekitLogger.trace('request allowed to bypass queue:', {
      canPass,
      req,
    });
    return canPass;
  }
  var SignalConnectionState;
  (function (SignalConnectionState) {
    SignalConnectionState[(SignalConnectionState['CONNECTING'] = 0)] = 'CONNECTING';
    SignalConnectionState[(SignalConnectionState['CONNECTED'] = 1)] = 'CONNECTED';
    SignalConnectionState[(SignalConnectionState['RECONNECTING'] = 2)] = 'RECONNECTING';
    SignalConnectionState[(SignalConnectionState['DISCONNECTING'] = 3)] = 'DISCONNECTING';
    SignalConnectionState[(SignalConnectionState['DISCONNECTED'] = 4)] = 'DISCONNECTED';
  })(SignalConnectionState || (SignalConnectionState = {}));
  /** @internal */
  class SignalClient {
    get currentState() {
      return this.state;
    }
    get isDisconnected() {
      return (
        this.state === SignalConnectionState.DISCONNECTING ||
        this.state === SignalConnectionState.DISCONNECTED
      );
    }
    get isEstablishingConnection() {
      return (
        this.state === SignalConnectionState.CONNECTING ||
        this.state === SignalConnectionState.RECONNECTING
      );
    }
    getNextRequestId() {
      this._requestId += 1;
      return this._requestId;
    }
    constructor() {
      let useJSON = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      let loggerOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var _a;
      /** signal rtt in milliseconds */
      this.rtt = 0;
      this.state = SignalConnectionState.DISCONNECTED;
      this.log = livekitLogger;
      this._requestId = 0;
      /** @internal */
      this.resetCallbacks = () => {
        this.onAnswer = undefined;
        this.onLeave = undefined;
        this.onLocalTrackPublished = undefined;
        this.onLocalTrackUnpublished = undefined;
        this.onNegotiateRequested = undefined;
        this.onOffer = undefined;
        this.onRemoteMuteChanged = undefined;
        this.onSubscribedQualityUpdate = undefined;
        this.onTokenRefresh = undefined;
        this.onTrickle = undefined;
        this.onClose = undefined;
      };
      this.log = getLogger(
        (_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Signal
      );
      this.loggerContextCb = loggerOptions.loggerContextCb;
      this.useJSON = useJSON;
      this.requestQueue = new AsyncQueue();
      this.queuedRequests = [];
      this.closingLock = new livekit_client_esm_();
      this.connectionLock = new livekit_client_esm_();
      this.state = SignalConnectionState.DISCONNECTED;
    }
    get logContext() {
      var _a, _b;
      return (_b =
        (_a = this.loggerContextCb) === null || _a === void 0 ? void 0 : _a.call(this)) !== null &&
        _b !== void 0
        ? _b
        : {};
    }
    join(url, token, opts, abortSignal) {
      return __awaiter(this, void 0, void 0, function* () {
        // during a full reconnect, we'd want to start the sequence even if currently
        // connected
        this.state = SignalConnectionState.CONNECTING;
        this.options = opts;
        const res = yield this.connect(url, token, opts, abortSignal);
        return res;
      });
    }
    reconnect(url, token, sid, reason) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.options) {
          this.log.warn(
            'attempted to reconnect without signal options being set, ignoring',
            this.logContext
          );
          return;
        }
        this.state = SignalConnectionState.RECONNECTING;
        // clear ping interval and restart it once reconnected
        this.clearPingInterval();
        const res = yield this.connect(
          url,
          token,
          Object.assign(Object.assign({}, this.options), {
            reconnect: true,
            sid,
            reconnectReason: reason,
          })
        );
        return res;
      });
    }
    connect(url, token, opts, abortSignal) {
      this.connectOptions = opts;
      const clientInfo = getClientInfo();
      const params = createConnectionParams(token, clientInfo, opts);
      const rtcUrl = createRtcUrl(url, params);
      const validateUrl = createValidateUrl(rtcUrl);
      return new Promise((resolve, reject) =>
        __awaiter(this, void 0, void 0, function* () {
          const unlock = yield this.connectionLock.lock();
          try {
            const abortHandler = () =>
              __awaiter(this, void 0, void 0, function* () {
                this.close();
                clearTimeout(wsTimeout);
                reject(
                  new ConnectionError(
                    'room connection has been cancelled (signal)',
                    ConnectionErrorReason.Cancelled
                  )
                );
              });
            const wsTimeout = setTimeout(() => {
              this.close();
              reject(
                new ConnectionError(
                  'room connection has timed out (signal)',
                  ConnectionErrorReason.ServerUnreachable
                )
              );
            }, opts.websocketTimeout);
            if (abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted) {
              abortHandler();
            }
            abortSignal === null || abortSignal === void 0
              ? void 0
              : abortSignal.addEventListener('abort', abortHandler);
            const redactedUrl = new URL(rtcUrl);
            if (redactedUrl.searchParams.has('access_token')) {
              redactedUrl.searchParams.set('access_token', '<redacted>');
            }
            this.log.debug(
              'connecting to '.concat(redactedUrl),
              Object.assign(
                {
                  reconnect: opts.reconnect,
                  reconnectReason: opts.reconnectReason,
                },
                this.logContext
              )
            );
            if (this.ws) {
              yield this.close(false);
            }
            this.ws = new WebSocket(rtcUrl);
            this.ws.binaryType = 'arraybuffer';
            this.ws.onopen = () => {
              clearTimeout(wsTimeout);
            };
            this.ws.onerror = (ev) =>
              __awaiter(this, void 0, void 0, function* () {
                if (this.state !== SignalConnectionState.CONNECTED) {
                  this.state = SignalConnectionState.DISCONNECTED;
                  clearTimeout(wsTimeout);
                  try {
                    const resp = yield fetch(validateUrl);
                    if (resp.status.toFixed(0).startsWith('4')) {
                      const msg = yield resp.text();
                      reject(
                        new ConnectionError(msg, ConnectionErrorReason.NotAllowed, resp.status)
                      );
                    } else {
                      reject(
                        new ConnectionError(
                          'Encountered unknown websocket error during connection: '.concat(
                            ev.toString()
                          ),
                          ConnectionErrorReason.InternalError,
                          resp.status
                        )
                      );
                    }
                  } catch (e) {
                    reject(
                      new ConnectionError(
                        e instanceof Error ? e.message : 'server was not reachable',
                        ConnectionErrorReason.ServerUnreachable
                      )
                    );
                  }
                  return;
                }
                // other errors, handle
                this.handleWSError(ev);
              });
            this.ws.onmessage = (ev) =>
              __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                // not considered connected until JoinResponse is received
                let resp;
                if (typeof ev.data === 'string') {
                  const json = JSON.parse(ev.data);
                  resp = SignalResponse.fromJson(json, {
                    ignoreUnknownFields: true,
                  });
                } else if (ev.data instanceof ArrayBuffer) {
                  resp = SignalResponse.fromBinary(new Uint8Array(ev.data));
                } else {
                  this.log.error(
                    'could not decode websocket message: '.concat(typeof ev.data),
                    this.logContext
                  );
                  return;
                }
                if (this.state !== SignalConnectionState.CONNECTED) {
                  let shouldProcessMessage = false;
                  // handle join message only
                  if (
                    ((_a = resp.message) === null || _a === void 0 ? void 0 : _a.case) === 'join'
                  ) {
                    this.state = SignalConnectionState.CONNECTED;
                    abortSignal === null || abortSignal === void 0
                      ? void 0
                      : abortSignal.removeEventListener('abort', abortHandler);
                    this.pingTimeoutDuration = resp.message.value.pingTimeout;
                    this.pingIntervalDuration = resp.message.value.pingInterval;
                    if (this.pingTimeoutDuration && this.pingTimeoutDuration > 0) {
                      this.log.debug(
                        'ping config',
                        Object.assign(Object.assign({}, this.logContext), {
                          timeout: this.pingTimeoutDuration,
                          interval: this.pingIntervalDuration,
                        })
                      );
                      this.startPingInterval();
                    }
                    resolve(resp.message.value);
                  } else if (
                    this.state === SignalConnectionState.RECONNECTING &&
                    resp.message.case !== 'leave'
                  ) {
                    // in reconnecting, any message received means signal reconnected
                    this.state = SignalConnectionState.CONNECTED;
                    abortSignal === null || abortSignal === void 0
                      ? void 0
                      : abortSignal.removeEventListener('abort', abortHandler);
                    this.startPingInterval();
                    if (
                      ((_b = resp.message) === null || _b === void 0 ? void 0 : _b.case) ===
                      'reconnect'
                    ) {
                      resolve(resp.message.value);
                    } else {
                      this.log.debug(
                        'declaring signal reconnected without reconnect response received',
                        this.logContext
                      );
                      resolve(undefined);
                      shouldProcessMessage = true;
                    }
                  } else if (this.isEstablishingConnection && resp.message.case === 'leave') {
                    reject(
                      new ConnectionError(
                        'Received leave request while trying to (re)connect',
                        ConnectionErrorReason.LeaveRequest,
                        undefined,
                        resp.message.value.reason
                      )
                    );
                  } else if (!opts.reconnect) {
                    // non-reconnect case, should receive join response first
                    reject(
                      new ConnectionError(
                        'did not receive join response, got '.concat(
                          (_c = resp.message) === null || _c === void 0 ? void 0 : _c.case,
                          ' instead'
                        ),
                        ConnectionErrorReason.InternalError
                      )
                    );
                  }
                  if (!shouldProcessMessage) {
                    return;
                  }
                }
                if (this.signalLatency) {
                  yield sleep(this.signalLatency);
                }
                this.handleSignalResponse(resp);
              });
            this.ws.onclose = (ev) => {
              if (this.isEstablishingConnection) {
                reject(
                  new ConnectionError(
                    'Websocket got closed during a (re)connection attempt',
                    ConnectionErrorReason.InternalError
                  )
                );
              }
              this.log.warn(
                'websocket closed',
                Object.assign(Object.assign({}, this.logContext), {
                  reason: ev.reason,
                  code: ev.code,
                  wasClean: ev.wasClean,
                  state: this.state,
                })
              );
              this.handleOnClose(ev.reason);
            };
          } finally {
            unlock();
          }
        })
      );
    }
    close() {
      return __awaiter(this, arguments, void 0, function () {
        var _this = this;
        let updateState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        return (function* () {
          const unlock = yield _this.closingLock.lock();
          try {
            _this.clearPingInterval();
            if (updateState) {
              _this.state = SignalConnectionState.DISCONNECTING;
            }
            if (_this.ws) {
              _this.ws.onmessage = null;
              _this.ws.onopen = null;
              _this.ws.onclose = null;
              // calling `ws.close()` only starts the closing handshake (CLOSING state), prefer to wait until state is actually CLOSED
              const closePromise = new Promise((resolve) => {
                if (_this.ws) {
                  _this.ws.onclose = () => {
                    resolve();
                  };
                } else {
                  resolve();
                }
              });
              if (_this.ws.readyState < _this.ws.CLOSING) {
                _this.ws.close();
                // 250ms grace period for ws to close gracefully
                yield Promise.race([closePromise, sleep(250)]);
              }
              _this.ws = undefined;
            }
          } finally {
            if (updateState) {
              _this.state = SignalConnectionState.DISCONNECTED;
            }
            unlock();
          }
        })();
      });
    }
    // initial offer after joining
    sendOffer(offer, offerId) {
      this.log.debug(
        'sending offer',
        Object.assign(Object.assign({}, this.logContext), {
          offerSdp: offer.sdp,
        })
      );
      this.sendRequest({
        case: 'offer',
        value: toProtoSessionDescription(offer, offerId),
      });
    }
    // answer a server-initiated offer
    sendAnswer(answer, offerId) {
      this.log.debug(
        'sending answer',
        Object.assign(Object.assign({}, this.logContext), {
          answerSdp: answer.sdp,
        })
      );
      return this.sendRequest({
        case: 'answer',
        value: toProtoSessionDescription(answer, offerId),
      });
    }
    sendIceCandidate(candidate, target) {
      this.log.debug(
        'sending ice candidate',
        Object.assign(Object.assign({}, this.logContext), {
          candidate,
        })
      );
      return this.sendRequest({
        case: 'trickle',
        value: new TrickleRequest({
          candidateInit: JSON.stringify(candidate),
          target,
        }),
      });
    }
    sendMuteTrack(trackSid, muted) {
      return this.sendRequest({
        case: 'mute',
        value: new MuteTrackRequest({
          sid: trackSid,
          muted,
        }),
      });
    }
    sendAddTrack(req) {
      return this.sendRequest({
        case: 'addTrack',
        value: req,
      });
    }
    sendUpdateLocalMetadata(metadata_1, name_1) {
      return __awaiter(this, arguments, void 0, function (metadata, name) {
        var _this2 = this;
        let attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        return (function* () {
          const requestId = _this2.getNextRequestId();
          yield _this2.sendRequest({
            case: 'updateMetadata',
            value: new UpdateParticipantMetadata({
              requestId,
              metadata,
              name,
              attributes,
            }),
          });
          return requestId;
        })();
      });
    }
    sendUpdateTrackSettings(settings) {
      this.sendRequest({
        case: 'trackSetting',
        value: settings,
      });
    }
    sendUpdateSubscription(sub) {
      return this.sendRequest({
        case: 'subscription',
        value: sub,
      });
    }
    sendSyncState(sync) {
      return this.sendRequest({
        case: 'syncState',
        value: sync,
      });
    }
    sendUpdateVideoLayers(trackSid, layers) {
      return this.sendRequest({
        case: 'updateLayers',
        value: new UpdateVideoLayers({
          trackSid,
          layers,
        }),
      });
    }
    sendUpdateSubscriptionPermissions(allParticipants, trackPermissions) {
      return this.sendRequest({
        case: 'subscriptionPermission',
        value: new SubscriptionPermission({
          allParticipants,
          trackPermissions,
        }),
      });
    }
    sendSimulateScenario(scenario) {
      return this.sendRequest({
        case: 'simulate',
        value: scenario,
      });
    }
    sendPing() {
      /** send both of ping and pingReq for compatibility to old and new server */
      return Promise.all([
        this.sendRequest({
          case: 'ping',
          value: protoInt64.parse(Date.now()),
        }),
        this.sendRequest({
          case: 'pingReq',
          value: new Ping({
            timestamp: protoInt64.parse(Date.now()),
            rtt: protoInt64.parse(this.rtt),
          }),
        }),
      ]);
    }
    sendUpdateLocalAudioTrack(trackSid, features) {
      return this.sendRequest({
        case: 'updateAudioTrack',
        value: new UpdateLocalAudioTrack({
          trackSid,
          features,
        }),
      });
    }
    sendLeave() {
      return this.sendRequest({
        case: 'leave',
        value: new LeaveRequest({
          reason: DisconnectReason.CLIENT_INITIATED,
          // server doesn't process this field, keeping it here to indicate the intent of a full disconnect
          action: LeaveRequest_Action.DISCONNECT,
        }),
      });
    }
    sendRequest(message_1) {
      return __awaiter(this, arguments, void 0, function (message) {
        var _this3 = this;
        let fromQueue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        return (function* () {
          // capture all requests while reconnecting and put them in a queue
          // unless the request originates from the queue, then don't enqueue again
          const canQueue = !fromQueue && !canPassThroughQueue(message);
          if (canQueue && _this3.state === SignalConnectionState.RECONNECTING) {
            _this3.queuedRequests.push(() =>
              __awaiter(_this3, void 0, void 0, function* () {
                yield this.sendRequest(message, true);
              })
            );
            return;
          }
          // make sure previously queued requests are being sent first
          if (!fromQueue) {
            yield _this3.requestQueue.flush();
          }
          if (_this3.signalLatency) {
            yield sleep(_this3.signalLatency);
          }
          if (_this3.isDisconnected) {
            // Skip requests if the signal layer is disconnected
            // This can happen if an event is sent in the mist of room.connect() initializing
            _this3.log.debug(
              'skipping signal request (type: '.concat(
                message.case,
                ') - SignalClient disconnected'
              )
            );
            return;
          }
          if (!_this3.ws || _this3.ws.readyState !== _this3.ws.OPEN) {
            _this3.log.error(
              'cannot send signal request before connected, type: '.concat(
                message === null || message === void 0 ? void 0 : message.case
              ),
              _this3.logContext
            );
            return;
          }
          const req = new SignalRequest({
            message,
          });
          try {
            if (_this3.useJSON) {
              _this3.ws.send(req.toJsonString());
            } else {
              _this3.ws.send(req.toBinary());
            }
          } catch (e) {
            _this3.log.error(
              'error sending signal message',
              Object.assign(Object.assign({}, _this3.logContext), {
                error: e,
              })
            );
          }
        })();
      });
    }
    handleSignalResponse(res) {
      var _a, _b;
      const msg = res.message;
      if (msg == undefined) {
        this.log.debug('received unsupported message', this.logContext);
        return;
      }
      let pingHandled = false;
      if (msg.case === 'answer') {
        const sd = fromProtoSessionDescription(msg.value);
        if (this.onAnswer) {
          this.onAnswer(sd, msg.value.id);
        }
      } else if (msg.case === 'offer') {
        const sd = fromProtoSessionDescription(msg.value);
        if (this.onOffer) {
          this.onOffer(sd, msg.value.id);
        }
      } else if (msg.case === 'trickle') {
        const candidate = JSON.parse(msg.value.candidateInit);
        if (this.onTrickle) {
          this.onTrickle(candidate, msg.value.target);
        }
      } else if (msg.case === 'update') {
        if (this.onParticipantUpdate) {
          this.onParticipantUpdate(
            (_a = msg.value.participants) !== null && _a !== void 0 ? _a : []
          );
        }
      } else if (msg.case === 'trackPublished') {
        if (this.onLocalTrackPublished) {
          this.onLocalTrackPublished(msg.value);
        }
      } else if (msg.case === 'speakersChanged') {
        if (this.onSpeakersChanged) {
          this.onSpeakersChanged((_b = msg.value.speakers) !== null && _b !== void 0 ? _b : []);
        }
      } else if (msg.case === 'leave') {
        if (this.onLeave) {
          this.onLeave(msg.value);
        }
      } else if (msg.case === 'mute') {
        if (this.onRemoteMuteChanged) {
          this.onRemoteMuteChanged(msg.value.sid, msg.value.muted);
        }
      } else if (msg.case === 'roomUpdate') {
        if (this.onRoomUpdate && msg.value.room) {
          this.onRoomUpdate(msg.value.room);
        }
      } else if (msg.case === 'connectionQuality') {
        if (this.onConnectionQuality) {
          this.onConnectionQuality(msg.value);
        }
      } else if (msg.case === 'streamStateUpdate') {
        if (this.onStreamStateUpdate) {
          this.onStreamStateUpdate(msg.value);
        }
      } else if (msg.case === 'subscribedQualityUpdate') {
        if (this.onSubscribedQualityUpdate) {
          this.onSubscribedQualityUpdate(msg.value);
        }
      } else if (msg.case === 'subscriptionPermissionUpdate') {
        if (this.onSubscriptionPermissionUpdate) {
          this.onSubscriptionPermissionUpdate(msg.value);
        }
      } else if (msg.case === 'refreshToken') {
        if (this.onTokenRefresh) {
          this.onTokenRefresh(msg.value);
        }
      } else if (msg.case === 'trackUnpublished') {
        if (this.onLocalTrackUnpublished) {
          this.onLocalTrackUnpublished(msg.value);
        }
      } else if (msg.case === 'subscriptionResponse') {
        if (this.onSubscriptionError) {
          this.onSubscriptionError(msg.value);
        }
      } else if (msg.case === 'pong');
      else if (msg.case === 'pongResp') {
        this.rtt = Date.now() - Number.parseInt(msg.value.lastPingTimestamp.toString());
        this.resetPingTimeout();
        pingHandled = true;
      } else if (msg.case === 'requestResponse') {
        if (this.onRequestResponse) {
          this.onRequestResponse(msg.value);
        }
      } else if (msg.case === 'trackSubscribed') {
        if (this.onLocalTrackSubscribed) {
          this.onLocalTrackSubscribed(msg.value.trackSid);
        }
      } else if (msg.case === 'roomMoved') {
        if (this.onTokenRefresh) {
          this.onTokenRefresh(msg.value.token);
        }
        if (this.onRoomMoved) {
          this.onRoomMoved(msg.value);
        }
      } else {
        this.log.debug(
          'unsupported message',
          Object.assign(Object.assign({}, this.logContext), {
            msgCase: msg.case,
          })
        );
      }
      if (!pingHandled) {
        this.resetPingTimeout();
      }
    }
    setReconnected() {
      while (this.queuedRequests.length > 0) {
        const req = this.queuedRequests.shift();
        if (req) {
          this.requestQueue.run(req);
        }
      }
    }
    handleOnClose(reason) {
      return __awaiter(this, void 0, void 0, function* () {
        if (this.state === SignalConnectionState.DISCONNECTED) return;
        const onCloseCallback = this.onClose;
        yield this.close();
        this.log.debug(
          'websocket connection closed: '.concat(reason),
          Object.assign(Object.assign({}, this.logContext), {
            reason,
          })
        );
        if (onCloseCallback) {
          onCloseCallback(reason);
        }
      });
    }
    handleWSError(ev) {
      this.log.error(
        'websocket error',
        Object.assign(Object.assign({}, this.logContext), {
          error: ev,
        })
      );
    }
    /**
     * Resets the ping timeout and starts a new timeout.
     * Call this after receiving a pong message
     */
    resetPingTimeout() {
      this.clearPingTimeout();
      if (!this.pingTimeoutDuration) {
        this.log.warn('ping timeout duration not set', this.logContext);
        return;
      }
      this.pingTimeout = CriticalTimers.setTimeout(() => {
        this.log.warn(
          'ping timeout triggered. last pong received at: '.concat(
            new Date(Date.now() - this.pingTimeoutDuration * 1000).toUTCString()
          ),
          this.logContext
        );
        this.handleOnClose('ping timeout');
      }, this.pingTimeoutDuration * 1000);
    }
    /**
     * Clears ping timeout (does not start a new timeout)
     */
    clearPingTimeout() {
      if (this.pingTimeout) {
        CriticalTimers.clearTimeout(this.pingTimeout);
      }
    }
    startPingInterval() {
      this.clearPingInterval();
      this.resetPingTimeout();
      if (!this.pingIntervalDuration) {
        this.log.warn('ping interval duration not set', this.logContext);
        return;
      }
      this.log.debug('start ping interval', this.logContext);
      this.pingInterval = CriticalTimers.setInterval(() => {
        this.sendPing();
      }, this.pingIntervalDuration * 1000);
    }
    clearPingInterval() {
      this.log.debug('clearing ping interval', this.logContext);
      this.clearPingTimeout();
      if (this.pingInterval) {
        CriticalTimers.clearInterval(this.pingInterval);
      }
    }
  }
  function fromProtoSessionDescription(sd) {
    const rsd = {
      type: 'offer',
      sdp: sd.sdp,
    };
    switch (sd.type) {
      case 'answer':
      case 'offer':
      case 'pranswer':
      case 'rollback':
        rsd.type = sd.type;
        break;
    }
    return rsd;
  }
  function toProtoSessionDescription(rsd, id) {
    const sd = new SessionDescription({
      sdp: rsd.sdp,
      type: rsd.type,
      id,
    });
    return sd;
  }
  function createConnectionParams(token, info, opts) {
    var _a;
    const params = new URLSearchParams();
    params.set('access_token', token);
    // opts
    if (opts.reconnect) {
      params.set('reconnect', '1');
      if (opts.sid) {
        params.set('sid', opts.sid);
      }
    }
    params.set('auto_subscribe', opts.autoSubscribe ? '1' : '0');
    // ClientInfo
    params.set('sdk', isReactNative() ? 'reactnative' : 'js');
    params.set('version', info.version);
    params.set('protocol', info.protocol.toString());
    if (info.deviceModel) {
      params.set('device_model', info.deviceModel);
    }
    if (info.os) {
      params.set('os', info.os);
    }
    if (info.osVersion) {
      params.set('os_version', info.osVersion);
    }
    if (info.browser) {
      params.set('browser', info.browser);
    }
    if (info.browserVersion) {
      params.set('browser_version', info.browserVersion);
    }
    if (opts.adaptiveStream) {
      params.set('adaptive_stream', '1');
    }
    if (opts.reconnectReason) {
      params.set('reconnect_reason', opts.reconnectReason.toString());
    }
    // @ts-ignore
    if ((_a = navigator.connection) === null || _a === void 0 ? void 0 : _a.type) {
      // @ts-ignore
      params.set('network', navigator.connection.type);
    }
    return params;
  }

  class DataPacketBuffer {
    constructor() {
      this.buffer = [];
      this._totalSize = 0;
    }
    push(item) {
      this.buffer.push(item);
      this._totalSize += item.data.byteLength;
    }
    pop() {
      const item = this.buffer.shift();
      if (item) {
        this._totalSize -= item.data.byteLength;
      }
      return item;
    }
    getAll() {
      return this.buffer.slice();
    }
    popToSequence(sequence) {
      while (this.buffer.length > 0) {
        const first = this.buffer[0];
        if (first.sequence <= sequence) {
          this.pop();
        } else {
          break;
        }
      }
    }
    alignBufferedAmount(bufferedAmount) {
      while (this.buffer.length > 0) {
        const first = this.buffer[0];
        if (this._totalSize - first.data.byteLength <= bufferedAmount) {
          break;
        }
        this.pop();
      }
    }
    get length() {
      return this.buffer.length;
    }
  }

  class TTLMap {
    /**
     * @param ttl ttl of the key (ms)
     */
    constructor(ttl) {
      this._map = new Map();
      this._lastCleanup = 0;
      this.ttl = ttl;
    }
    set(key, value) {
      const now = Date.now();
      if (now - this._lastCleanup > this.ttl / 2) {
        this.cleanup();
      }
      const expiresAt = now + this.ttl;
      this._map.set(key, {
        value,
        expiresAt,
      });
      return this;
    }
    get(key) {
      const entry = this._map.get(key);
      if (!entry) return undefined;
      if (entry.expiresAt < Date.now()) {
        this._map.delete(key);
        return undefined;
      }
      return entry.value;
    }
    has(key) {
      const entry = this._map.get(key);
      if (!entry) return false;
      if (entry.expiresAt < Date.now()) {
        this._map.delete(key);
        return false;
      }
      return true;
    }
    delete(key) {
      return this._map.delete(key);
    }
    clear() {
      this._map.clear();
    }
    cleanup() {
      const now = Date.now();
      for (const [key, entry] of this._map.entries()) {
        if (entry.expiresAt < now) {
          this._map.delete(key);
        }
      }
      this._lastCleanup = now;
    }
    get size() {
      this.cleanup();
      return this._map.size;
    }
    forEach(callback) {
      this.cleanup();
      for (const [key, entry] of this._map.entries()) {
        if (entry.expiresAt >= Date.now()) {
          callback(entry.value, key, this.asValueMap());
        }
      }
    }
    map(callback) {
      this.cleanup();
      const result = [];
      const valueMap = this.asValueMap();
      for (const [key, value] of valueMap.entries()) {
        result.push(callback(value, key, valueMap));
      }
      return result;
    }
    asValueMap() {
      const result = new Map();
      for (const [key, entry] of this._map.entries()) {
        if (entry.expiresAt >= Date.now()) {
          result.set(key, entry.value);
        }
      }
      return result;
    }
  }

  var lib = {};

  var parser = {};

  var grammar = { exports: {} };

  var hasRequiredGrammar;
  function requireGrammar() {
    if (hasRequiredGrammar) return grammar.exports;
    hasRequiredGrammar = 1;
    var grammar$1 = (grammar.exports = {
      v: [
        {
          name: 'version',
          reg: /^(\d*)$/,
        },
      ],
      o: [
        {
          // o=- 20518 0 IN IP4 203.0.113.1
          // NB: sessionId will be a String in most cases because it is huge
          name: 'origin',
          reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
          names: ['username', 'sessionId', 'sessionVersion', 'netType', 'ipVer', 'address'],
          format: '%s %s %d %s IP%d %s',
        },
      ],
      // default parsing of these only (though some of these feel outdated)
      s: [
        {
          name: 'name',
        },
      ],
      i: [
        {
          name: 'description',
        },
      ],
      u: [
        {
          name: 'uri',
        },
      ],
      e: [
        {
          name: 'email',
        },
      ],
      p: [
        {
          name: 'phone',
        },
      ],
      z: [
        {
          name: 'timezones',
        },
      ],
      // TODO: this one can actually be parsed properly...
      r: [
        {
          name: 'repeats',
        },
      ],
      // TODO: this one can also be parsed properly
      // k: [{}], // outdated thing ignored
      t: [
        {
          // t=0 0
          name: 'timing',
          reg: /^(\d*) (\d*)/,
          names: ['start', 'stop'],
          format: '%d %d',
        },
      ],
      c: [
        {
          // c=IN IP4 10.47.197.26
          name: 'connection',
          reg: /^IN IP(\d) (\S*)/,
          names: ['version', 'ip'],
          format: 'IN IP%d %s',
        },
      ],
      b: [
        {
          // b=AS:4000
          push: 'bandwidth',
          reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
          names: ['type', 'limit'],
          format: '%s:%s',
        },
      ],
      m: [
        {
          // m=video 51744 RTP/AVP 126 97 98 34 31
          // NB: special - pushes to session
          // TODO: rtp/fmtp should be filtered by the payloads found here?
          reg: /^(\w*) (\d*) ([\w/]*)(?: (.*))?/,
          names: ['type', 'port', 'protocol', 'payloads'],
          format: '%s %d %s %s',
        },
      ],
      a: [
        {
          // a=rtpmap:110 opus/48000/2
          push: 'rtp',
          reg: /^rtpmap:(\d*) ([\w\-.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/,
          names: ['payload', 'codec', 'rate', 'encoding'],
          format: function (o) {
            return o.encoding ? 'rtpmap:%d %s/%s/%s' : o.rate ? 'rtpmap:%d %s/%s' : 'rtpmap:%d %s';
          },
        },
        {
          // a=fmtp:108 profile-level-id=24;object=23;bitrate=64000
          // a=fmtp:111 minptime=10; useinbandfec=1
          push: 'fmtp',
          reg: /^fmtp:(\d*) ([\S| ]*)/,
          names: ['payload', 'config'],
          format: 'fmtp:%d %s',
        },
        {
          // a=control:streamid=0
          name: 'control',
          reg: /^control:(.*)/,
          format: 'control:%s',
        },
        {
          // a=rtcp:65179 IN IP4 193.84.77.194
          name: 'rtcp',
          reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
          names: ['port', 'netType', 'ipVer', 'address'],
          format: function (o) {
            return o.address != null ? 'rtcp:%d %s IP%d %s' : 'rtcp:%d';
          },
        },
        {
          // a=rtcp-fb:98 trr-int 100
          push: 'rtcpFbTrrInt',
          reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
          names: ['payload', 'value'],
          format: 'rtcp-fb:%s trr-int %d',
        },
        {
          // a=rtcp-fb:98 nack rpsi
          push: 'rtcpFb',
          reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
          names: ['payload', 'type', 'subtype'],
          format: function (o) {
            return o.subtype != null ? 'rtcp-fb:%s %s %s' : 'rtcp-fb:%s %s';
          },
        },
        {
          // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
          // a=extmap:1/recvonly URI-gps-string
          // a=extmap:3 urn:ietf:params:rtp-hdrext:encrypt urn:ietf:params:rtp-hdrext:smpte-tc 25@600/24
          push: 'ext',
          reg: /^extmap:(\d+)(?:\/(\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\S*)(?: (\S*))?/,
          names: ['value', 'direction', 'encrypt-uri', 'uri', 'config'],
          format: function (o) {
            return (
              'extmap:%d' +
              (o.direction ? '/%s' : '%v') +
              (o['encrypt-uri'] ? ' %s' : '%v') +
              ' %s' +
              (o.config ? ' %s' : '')
            );
          },
        },
        {
          // a=extmap-allow-mixed
          name: 'extmapAllowMixed',
          reg: /^(extmap-allow-mixed)/,
        },
        {
          // a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32
          push: 'crypto',
          reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
          names: ['id', 'suite', 'config', 'sessionConfig'],
          format: function (o) {
            return o.sessionConfig != null ? 'crypto:%d %s %s %s' : 'crypto:%d %s %s';
          },
        },
        {
          // a=setup:actpass
          name: 'setup',
          reg: /^setup:(\w*)/,
          format: 'setup:%s',
        },
        {
          // a=connection:new
          name: 'connectionType',
          reg: /^connection:(new|existing)/,
          format: 'connection:%s',
        },
        {
          // a=mid:1
          name: 'mid',
          reg: /^mid:([^\s]*)/,
          format: 'mid:%s',
        },
        {
          // a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a
          name: 'msid',
          reg: /^msid:(.*)/,
          format: 'msid:%s',
        },
        {
          // a=ptime:20
          name: 'ptime',
          reg: /^ptime:(\d*(?:\.\d*)*)/,
          format: 'ptime:%d',
        },
        {
          // a=maxptime:60
          name: 'maxptime',
          reg: /^maxptime:(\d*(?:\.\d*)*)/,
          format: 'maxptime:%d',
        },
        {
          // a=sendrecv
          name: 'direction',
          reg: /^(sendrecv|recvonly|sendonly|inactive)/,
        },
        {
          // a=ice-lite
          name: 'icelite',
          reg: /^(ice-lite)/,
        },
        {
          // a=ice-ufrag:F7gI
          name: 'iceUfrag',
          reg: /^ice-ufrag:(\S*)/,
          format: 'ice-ufrag:%s',
        },
        {
          // a=ice-pwd:x9cml/YzichV2+XlhiMu8g
          name: 'icePwd',
          reg: /^ice-pwd:(\S*)/,
          format: 'ice-pwd:%s',
        },
        {
          // a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33
          name: 'fingerprint',
          reg: /^fingerprint:(\S*) (\S*)/,
          names: ['type', 'hash'],
          format: 'fingerprint:%s %s',
        },
        {
          // a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host
          // a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10
          // a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10
          // a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10
          // a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10
          push: 'candidates',
          reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/,
          names: [
            'foundation',
            'component',
            'transport',
            'priority',
            'ip',
            'port',
            'type',
            'raddr',
            'rport',
            'tcptype',
            'generation',
            'network-id',
            'network-cost',
          ],
          format: function (o) {
            var str = 'candidate:%s %d %s %d %s %d typ %s';
            str += o.raddr != null ? ' raddr %s rport %d' : '%v%v';

            // NB: candidate has three optional chunks, so %void middles one if it's missing
            str += o.tcptype != null ? ' tcptype %s' : '%v';
            if (o.generation != null) {
              str += ' generation %d';
            }
            str += o['network-id'] != null ? ' network-id %d' : '%v';
            str += o['network-cost'] != null ? ' network-cost %d' : '%v';
            return str;
          },
        },
        {
          // a=end-of-candidates (keep after the candidates line for readability)
          name: 'endOfCandidates',
          reg: /^(end-of-candidates)/,
        },
        {
          // a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...
          name: 'remoteCandidates',
          reg: /^remote-candidates:(.*)/,
          format: 'remote-candidates:%s',
        },
        {
          // a=ice-options:google-ice
          name: 'iceOptions',
          reg: /^ice-options:(\S*)/,
          format: 'ice-options:%s',
        },
        {
          // a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1
          push: 'ssrcs',
          reg: /^ssrc:(\d*) ([\w_-]*)(?::(.*))?/,
          names: ['id', 'attribute', 'value'],
          format: function (o) {
            var str = 'ssrc:%d';
            if (o.attribute != null) {
              str += ' %s';
              if (o.value != null) {
                str += ':%s';
              }
            }
            return str;
          },
        },
        {
          // a=ssrc-group:FEC 1 2
          // a=ssrc-group:FEC-FR 3004364195 1080772241
          push: 'ssrcGroups',
          // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E
          reg: /^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/,
          names: ['semantics', 'ssrcs'],
          format: 'ssrc-group:%s %s',
        },
        {
          // a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV
          name: 'msidSemantic',
          reg: /^msid-semantic:\s?(\w*) (\S*)/,
          names: ['semantic', 'token'],
          format: 'msid-semantic: %s %s', // space after ':' is not accidental
        },
        {
          // a=group:BUNDLE audio video
          push: 'groups',
          reg: /^group:(\w*) (.*)/,
          names: ['type', 'mids'],
          format: 'group:%s %s',
        },
        {
          // a=rtcp-mux
          name: 'rtcpMux',
          reg: /^(rtcp-mux)/,
        },
        {
          // a=rtcp-rsize
          name: 'rtcpRsize',
          reg: /^(rtcp-rsize)/,
        },
        {
          // a=sctpmap:5000 webrtc-datachannel 1024
          name: 'sctpmap',
          reg: /^sctpmap:([\w_/]*) (\S*)(?: (\S*))?/,
          names: ['sctpmapNumber', 'app', 'maxMessageSize'],
          format: function (o) {
            return o.maxMessageSize != null ? 'sctpmap:%s %s %s' : 'sctpmap:%s %s';
          },
        },
        {
          // a=x-google-flag:conference
          name: 'xGoogleFlag',
          reg: /^x-google-flag:([^\s]*)/,
          format: 'x-google-flag:%s',
        },
        {
          // a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0
          push: 'rids',
          reg: /^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/,
          names: ['id', 'direction', 'params'],
          format: function (o) {
            return o.params ? 'rid:%s %s %s' : 'rid:%s %s';
          },
        },
        {
          // a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]
          // a=imageattr:* send [x=800,y=640] recv *
          // a=imageattr:100 recv [x=320,y=240]
          push: 'imageattrs',
          reg: new RegExp(
            // a=imageattr:97
            '^imageattr:(\\d+|\\*)' +
              // send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320]
              '[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)' +
              // recv [x=330,y=250]
              '(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?'
          ),
          names: ['pt', 'dir1', 'attrs1', 'dir2', 'attrs2'],
          format: function (o) {
            return 'imageattr:%s %s %s' + (o.dir2 ? ' %s %s' : '');
          },
        },
        {
          // a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8
          // a=simulcast:recv 1;4,5 send 6;7
          name: 'simulcast',
          reg: new RegExp(
            // a=simulcast:
            '^simulcast:' +
              // send 1,2,3;~4,~5
              '(send|recv) ([a-zA-Z0-9\\-_~;,]+)' +
              // space + recv 6;~7,~8
              '(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?' +
              // end
              '$'
          ),
          names: ['dir1', 'list1', 'dir2', 'list2'],
          format: function (o) {
            return 'simulcast:%s %s' + (o.dir2 ? ' %s %s' : '');
          },
        },
        {
          // old simulcast draft 03 (implemented by Firefox)
          //   https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03
          // a=simulcast: recv pt=97;98 send pt=97
          // a=simulcast: send rid=5;6;7 paused=6,7
          name: 'simulcast_03',
          reg: /^simulcast:[\s\t]+([\S+\s\t]+)$/,
          names: ['value'],
          format: 'simulcast: %s',
        },
        {
          // a=framerate:25
          // a=framerate:29.97
          name: 'framerate',
          reg: /^framerate:(\d+(?:$|\.\d+))/,
          format: 'framerate:%s',
        },
        {
          // RFC4570
          // a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5
          name: 'sourceFilter',
          reg: /^source-filter: *(excl|incl) (\S*) (IP4|IP6|\*) (\S*) (.*)/,
          names: ['filterMode', 'netType', 'addressTypes', 'destAddress', 'srcList'],
          format: 'source-filter: %s %s %s %s %s',
        },
        {
          // a=bundle-only
          name: 'bundleOnly',
          reg: /^(bundle-only)/,
        },
        {
          // a=label:1
          name: 'label',
          reg: /^label:(.+)/,
          format: 'label:%s',
        },
        {
          // RFC version 26 for SCTP over DTLS
          // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-5
          name: 'sctpPort',
          reg: /^sctp-port:(\d+)$/,
          format: 'sctp-port:%s',
        },
        {
          // RFC version 26 for SCTP over DTLS
          // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-6
          name: 'maxMessageSize',
          reg: /^max-message-size:(\d+)$/,
          format: 'max-message-size:%s',
        },
        {
          // RFC7273
          // a=ts-refclk:ptp=IEEE1588-2008:39-A7-94-FF-FE-07-CB-D0:37
          push: 'tsRefClocks',
          reg: /^ts-refclk:([^\s=]*)(?:=(\S*))?/,
          names: ['clksrc', 'clksrcExt'],
          format: function (o) {
            return 'ts-refclk:%s' + (o.clksrcExt != null ? '=%s' : '');
          },
        },
        {
          // RFC7273
          // a=mediaclk:direct=963214424
          name: 'mediaClk',
          reg: /^mediaclk:(?:id=(\S*))? *([^\s=]*)(?:=(\S*))?(?: *rate=(\d+)\/(\d+))?/,
          names: ['id', 'mediaClockName', 'mediaClockValue', 'rateNumerator', 'rateDenominator'],
          format: function (o) {
            var str = 'mediaclk:';
            str += o.id != null ? 'id=%s %s' : '%v%s';
            str += o.mediaClockValue != null ? '=%s' : '';
            str += o.rateNumerator != null ? ' rate=%s' : '';
            str += o.rateDenominator != null ? '/%s' : '';
            return str;
          },
        },
        {
          // a=keywds:keywords
          name: 'keywords',
          reg: /^keywds:(.+)$/,
          format: 'keywds:%s',
        },
        {
          // a=content:main
          name: 'content',
          reg: /^content:(.+)/,
          format: 'content:%s',
        },
        // BFCP https://tools.ietf.org/html/rfc4583
        {
          // a=floorctrl:c-s
          name: 'bfcpFloorCtrl',
          reg: /^floorctrl:(c-only|s-only|c-s)/,
          format: 'floorctrl:%s',
        },
        {
          // a=confid:1
          name: 'bfcpConfId',
          reg: /^confid:(\d+)/,
          format: 'confid:%s',
        },
        {
          // a=userid:1
          name: 'bfcpUserId',
          reg: /^userid:(\d+)/,
          format: 'userid:%s',
        },
        {
          // a=floorid:1
          name: 'bfcpFloorId',
          reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,
          names: ['id', 'mStream'],
          format: 'floorid:%s mstrm:%s',
        },
        {
          // any a= that we don't understand is kept verbatim on media.invalid
          push: 'invalid',
          names: ['value'],
        },
      ],
    });

    // set sensible defaults to avoid polluting the grammar with boring details
    Object.keys(grammar$1).forEach(function (key) {
      var objs = grammar$1[key];
      objs.forEach(function (obj) {
        if (!obj.reg) {
          obj.reg = /(.*)/;
        }
        if (!obj.format) {
          obj.format = '%s';
        }
      });
    });
    return grammar.exports;
  }

  var hasRequiredParser;
  function requireParser() {
    if (hasRequiredParser) return parser;
    hasRequiredParser = 1;
    (function (exports) {
      var toIntIfInt = function (v) {
        return String(Number(v)) === v ? Number(v) : v;
      };
      var attachProperties = function (match, location, names, rawName) {
        if (rawName && !names) {
          location[rawName] = toIntIfInt(match[1]);
        } else {
          for (var i = 0; i < names.length; i += 1) {
            if (match[i + 1] != null) {
              location[names[i]] = toIntIfInt(match[i + 1]);
            }
          }
        }
      };
      var parseReg = function (obj, location, content) {
        var needsBlank = obj.name && obj.names;
        if (obj.push && !location[obj.push]) {
          location[obj.push] = [];
        } else if (needsBlank && !location[obj.name]) {
          location[obj.name] = {};
        }
        var keyLocation = obj.push
          ? {}
          : // blank object that will be pushed
            needsBlank
            ? location[obj.name]
            : location; // otherwise, named location or root

        attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);
        if (obj.push) {
          location[obj.push].push(keyLocation);
        }
      };
      var grammar = requireGrammar();
      var validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);
      exports.parse = function (sdp) {
        var session = {},
          media = [],
          location = session; // points at where properties go under (one of the above)

        // parse lines we understand
        sdp
          .split(/(\r\n|\r|\n)/)
          .filter(validLine)
          .forEach(function (l) {
            var type = l[0];
            var content = l.slice(2);
            if (type === 'm') {
              media.push({
                rtp: [],
                fmtp: [],
              });
              location = media[media.length - 1]; // point at latest media line
            }
            for (var j = 0; j < (grammar[type] || []).length; j += 1) {
              var obj = grammar[type][j];
              if (obj.reg.test(content)) {
                return parseReg(obj, location, content);
              }
            }
          });
        session.media = media; // link it up
        return session;
      };
      var paramReducer = function (acc, expr) {
        var s = expr.split(/=(.+)/, 2);
        if (s.length === 2) {
          acc[s[0]] = toIntIfInt(s[1]);
        } else if (s.length === 1 && expr.length > 1) {
          acc[s[0]] = undefined;
        }
        return acc;
      };
      exports.parseParams = function (str) {
        return str.split(/;\s?/).reduce(paramReducer, {});
      };

      // For backward compatibility - alias will be removed in 3.0.0
      exports.parseFmtpConfig = exports.parseParams;
      exports.parsePayloads = function (str) {
        return str.toString().split(' ').map(Number);
      };
      exports.parseRemoteCandidates = function (str) {
        var candidates = [];
        var parts = str.split(' ').map(toIntIfInt);
        for (var i = 0; i < parts.length; i += 3) {
          candidates.push({
            component: parts[i],
            ip: parts[i + 1],
            port: parts[i + 2],
          });
        }
        return candidates;
      };
      exports.parseImageAttributes = function (str) {
        return str.split(' ').map(function (item) {
          return item
            .substring(1, item.length - 1)
            .split(',')
            .reduce(paramReducer, {});
        });
      };
      exports.parseSimulcastStreamList = function (str) {
        return str.split(';').map(function (stream) {
          return stream.split(',').map(function (format) {
            var scid,
              paused = false;
            if (format[0] !== '~') {
              scid = toIntIfInt(format);
            } else {
              scid = toIntIfInt(format.substring(1, format.length));
              paused = true;
            }
            return {
              scid: scid,
              paused: paused,
            };
          });
        });
      };
    })(parser);
    return parser;
  }

  var writer;
  var hasRequiredWriter;
  function requireWriter() {
    if (hasRequiredWriter) return writer;
    hasRequiredWriter = 1;
    var grammar = requireGrammar();

    // customized util.format - discards excess arguments and can void middle ones
    var formatRegExp = /%[sdv%]/g;
    var format = function (formatStr) {
      var i = 1;
      var args = arguments;
      var len = args.length;
      return formatStr.replace(formatRegExp, function (x) {
        if (i >= len) {
          return x; // missing argument
        }
        var arg = args[i];
        i += 1;
        switch (x) {
          case '%%':
            return '%';
          case '%s':
            return String(arg);
          case '%d':
            return Number(arg);
          case '%v':
            return '';
        }
      });
      // NB: we discard excess arguments - they are typically undefined from makeLine
    };
    var makeLine = function (type, obj, location) {
      var str =
        obj.format instanceof Function
          ? obj.format(obj.push ? location : location[obj.name])
          : obj.format;
      var args = [type + '=' + str];
      if (obj.names) {
        for (var i = 0; i < obj.names.length; i += 1) {
          var n = obj.names[i];
          if (obj.name) {
            args.push(location[obj.name][n]);
          } else {
            // for mLine and push attributes
            args.push(location[obj.names[i]]);
          }
        }
      } else {
        args.push(location[obj.name]);
      }
      return format.apply(null, args);
    };

    // RFC specified order
    // TODO: extend this with all the rest
    var defaultOuterOrder = ['v', 'o', 's', 'i', 'u', 'e', 'p', 'c', 'b', 't', 'r', 'z', 'a'];
    var defaultInnerOrder = ['i', 'c', 'b', 'a'];
    writer = function (session, opts) {
      opts = opts || {};
      // ensure certain properties exist
      if (session.version == null) {
        session.version = 0; // 'v=0' must be there (only defined version atm)
      }
      if (session.name == null) {
        session.name = ' '; // 's= ' must be there if no meaningful name set
      }
      session.media.forEach(function (mLine) {
        if (mLine.payloads == null) {
          mLine.payloads = '';
        }
      });
      var outerOrder = opts.outerOrder || defaultOuterOrder;
      var innerOrder = opts.innerOrder || defaultInnerOrder;
      var sdp = [];

      // loop through outerOrder for matching properties on session
      outerOrder.forEach(function (type) {
        grammar[type].forEach(function (obj) {
          if (obj.name in session && session[obj.name] != null) {
            sdp.push(makeLine(type, obj, session));
          } else if (obj.push in session && session[obj.push] != null) {
            session[obj.push].forEach(function (el) {
              sdp.push(makeLine(type, obj, el));
            });
          }
        });
      });

      // then for each media line, follow the innerOrder
      session.media.forEach(function (mLine) {
        sdp.push(makeLine('m', grammar.m[0], mLine));
        innerOrder.forEach(function (type) {
          grammar[type].forEach(function (obj) {
            if (obj.name in mLine && mLine[obj.name] != null) {
              sdp.push(makeLine(type, obj, mLine));
            } else if (obj.push in mLine && mLine[obj.push] != null) {
              mLine[obj.push].forEach(function (el) {
                sdp.push(makeLine(type, obj, el));
              });
            }
          });
        });
      });
      return sdp.join('\r\n') + '\r\n';
    };
    return writer;
  }

  var hasRequiredLib;
  function requireLib() {
    if (hasRequiredLib) return lib;
    hasRequiredLib = 1;
    var parser = requireParser();
    var writer = requireWriter();
    var grammar = requireGrammar();
    lib.grammar = grammar;
    lib.write = writer;
    lib.parse = parser.parse;
    lib.parseParams = parser.parseParams;
    lib.parseFmtpConfig = parser.parseFmtpConfig; // Alias of parseParams().
    lib.parsePayloads = parser.parsePayloads;
    lib.parseRemoteCandidates = parser.parseRemoteCandidates;
    lib.parseImageAttributes = parser.parseImageAttributes;
    lib.parseSimulcastStreamList = parser.parseSimulcastStreamList;
    return lib;
  }

  var libExports = requireLib();

  function r(r, e, n) {
    var i, t, o;
    (void 0 === e && (e = 50), void 0 === n && (n = {}));
    var a = null != (i = n.isImmediate) && i,
      u = null != (t = n.callback) && t,
      c = n.maxWait,
      v = Date.now(),
      l = [];
    function f() {
      if (void 0 !== c) {
        var r = Date.now() - v;
        if (r + e >= c) return c - r;
      }
      return e;
    }
    var d = function () {
      var e = [].slice.call(arguments),
        n = this;
      return new Promise(function (i, t) {
        var c = a && void 0 === o;
        if (
          (void 0 !== o && clearTimeout(o),
          (o = setTimeout(function () {
            if (((o = void 0), (v = Date.now()), !a)) {
              var i = r.apply(n, e);
              (u && u(i),
                l.forEach(function (r) {
                  return (0, r.resolve)(i);
                }),
                (l = []));
            }
          }, f())),
          c)
        ) {
          var d = r.apply(n, e);
          return (u && u(d), i(d));
        }
        l.push({
          resolve: i,
          reject: t,
        });
      });
    };
    return (
      (d.cancel = function (r) {
        (void 0 !== o && clearTimeout(o),
          l.forEach(function (e) {
            return (0, e.reject)(r);
          }),
          (l = []));
      }),
      d
    );
  }

  /* The svc codec (av1/vp9) would use a very low bitrate at the begining and
increase slowly by the bandwidth estimator until it reach the target bitrate. The
process commonly cost more than 10 seconds cause subscriber will get blur video at
the first few seconds. So we use a 70% of target bitrate here as the start bitrate to
eliminate this issue.
*/
  const startBitrateForSVC = 0.7;
  const debounceInterval = 20;
  const PCEvents = {
    NegotiationStarted: 'negotiationStarted',
    NegotiationComplete: 'negotiationComplete',
    RTPVideoPayloadTypes: 'rtpVideoPayloadTypes',
  };
  /** @internal */
  class PCTransport extends eventsExports.EventEmitter {
    get pc() {
      if (!this._pc) {
        this._pc = this.createPC();
      }
      return this._pc;
    }
    constructor(config) {
      let loggerOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var _a;
      super();
      this.log = livekitLogger;
      this.ddExtID = 0;
      this.latestOfferId = 0;
      this.pendingCandidates = [];
      this.restartingIce = false;
      this.renegotiate = false;
      this.trackBitrates = [];
      this.remoteStereoMids = [];
      this.remoteNackMids = [];
      // debounced negotiate interface
      this.negotiate = r(
        (onError) =>
          __awaiter(this, void 0, void 0, function* () {
            this.emit(PCEvents.NegotiationStarted);
            try {
              yield this.createAndSendOffer();
            } catch (e) {
              if (onError) {
                onError(e);
              } else {
                throw e;
              }
            }
          }),
        debounceInterval
      );
      this.close = () => {
        if (!this._pc) {
          return;
        }
        this._pc.close();
        this._pc.onconnectionstatechange = null;
        this._pc.oniceconnectionstatechange = null;
        this._pc.onicegatheringstatechange = null;
        this._pc.ondatachannel = null;
        this._pc.onnegotiationneeded = null;
        this._pc.onsignalingstatechange = null;
        this._pc.onicecandidate = null;
        this._pc.ondatachannel = null;
        this._pc.ontrack = null;
        this._pc.onconnectionstatechange = null;
        this._pc.oniceconnectionstatechange = null;
        this._pc = null;
      };
      this.log = getLogger(
        (_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.PCTransport
      );
      this.loggerOptions = loggerOptions;
      this.config = config;
      this._pc = this.createPC();
      this.offerLock = new livekit_client_esm_();
    }
    createPC() {
      const pc = new RTCPeerConnection(this.config);
      pc.onicecandidate = (ev) => {
        var _a;
        if (!ev.candidate) return;
        (_a = this.onIceCandidate) === null || _a === void 0 ? void 0 : _a.call(this, ev.candidate);
      };
      pc.onicecandidateerror = (ev) => {
        var _a;
        (_a = this.onIceCandidateError) === null || _a === void 0 ? void 0 : _a.call(this, ev);
      };
      pc.oniceconnectionstatechange = () => {
        var _a;
        (_a = this.onIceConnectionStateChange) === null || _a === void 0
          ? void 0
          : _a.call(this, pc.iceConnectionState);
      };
      pc.onsignalingstatechange = () => {
        var _a;
        (_a = this.onSignalingStatechange) === null || _a === void 0
          ? void 0
          : _a.call(this, pc.signalingState);
      };
      pc.onconnectionstatechange = () => {
        var _a;
        (_a = this.onConnectionStateChange) === null || _a === void 0
          ? void 0
          : _a.call(this, pc.connectionState);
      };
      pc.ondatachannel = (ev) => {
        var _a;
        (_a = this.onDataChannel) === null || _a === void 0 ? void 0 : _a.call(this, ev);
      };
      pc.ontrack = (ev) => {
        var _a;
        (_a = this.onTrack) === null || _a === void 0 ? void 0 : _a.call(this, ev);
      };
      return pc;
    }
    get logContext() {
      var _a, _b;
      return Object.assign(
        {},
        (_b = (_a = this.loggerOptions).loggerContextCb) === null || _b === void 0
          ? void 0
          : _b.call(_a)
      );
    }
    get isICEConnected() {
      return (
        this._pc !== null &&
        (this.pc.iceConnectionState === 'connected' || this.pc.iceConnectionState === 'completed')
      );
    }
    addIceCandidate(candidate) {
      return __awaiter(this, void 0, void 0, function* () {
        if (this.pc.remoteDescription && !this.restartingIce) {
          return this.pc.addIceCandidate(candidate);
        }
        this.pendingCandidates.push(candidate);
      });
    }
    setRemoteDescription(sd, offerId) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        if (
          sd.type === 'answer' &&
          this.latestOfferId > 0 &&
          offerId > 0 &&
          offerId !== this.latestOfferId
        ) {
          this.log.warn(
            'ignoring answer for old offer',
            Object.assign(Object.assign({}, this.logContext), {
              offerId,
              latestOfferId: this.latestOfferId,
            })
          );
          return false;
        }
        let mungedSDP = undefined;
        if (sd.type === 'offer') {
          let { stereoMids, nackMids } = extractStereoAndNackAudioFromOffer(sd);
          this.remoteStereoMids = stereoMids;
          this.remoteNackMids = nackMids;
        } else if (sd.type === 'answer') {
          const sdpParsed = libExports.parse((_a = sd.sdp) !== null && _a !== void 0 ? _a : '');
          sdpParsed.media.forEach((media) => {
            const mid = getMidString(media.mid);
            if (media.type === 'audio') {
              // mung sdp for opus bitrate settings
              this.trackBitrates.some((trackbr) => {
                if (!trackbr.transceiver || mid != trackbr.transceiver.mid) {
                  return false;
                }
                let codecPayload = 0;
                media.rtp.some((rtp) => {
                  if (rtp.codec.toUpperCase() === trackbr.codec.toUpperCase()) {
                    codecPayload = rtp.payload;
                    return true;
                  }
                  return false;
                });
                if (codecPayload === 0) {
                  return true;
                }
                let fmtpFound = false;
                for (const fmtp of media.fmtp) {
                  if (fmtp.payload === codecPayload) {
                    fmtp.config = fmtp.config
                      .split(';')
                      .filter((attr) => !attr.includes('maxaveragebitrate'))
                      .join(';');
                    if (trackbr.maxbr > 0) {
                      fmtp.config += ';maxaveragebitrate='.concat(trackbr.maxbr * 1000);
                    }
                    fmtpFound = true;
                    break;
                  }
                }
                if (!fmtpFound) {
                  if (trackbr.maxbr > 0) {
                    media.fmtp.push({
                      payload: codecPayload,
                      config: 'maxaveragebitrate='.concat(trackbr.maxbr * 1000),
                    });
                  }
                }
                return true;
              });
            }
          });
          mungedSDP = libExports.write(sdpParsed);
        }
        yield this.setMungedSDP(sd, mungedSDP, true);
        this.pendingCandidates.forEach((candidate) => {
          this.pc.addIceCandidate(candidate);
        });
        this.pendingCandidates = [];
        this.restartingIce = false;
        if (this.renegotiate) {
          this.renegotiate = false;
          yield this.createAndSendOffer();
        } else if (sd.type === 'answer') {
          this.emit(PCEvents.NegotiationComplete);
          if (sd.sdp) {
            const sdpParsed = libExports.parse(sd.sdp);
            sdpParsed.media.forEach((media) => {
              if (media.type === 'video') {
                this.emit(PCEvents.RTPVideoPayloadTypes, media.rtp);
              }
            });
          }
        }
        return true;
      });
    }
    createAndSendOffer(options) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        const unlock = yield this.offerLock.lock();
        try {
          if (this.onOffer === undefined) {
            return;
          }
          if (options === null || options === void 0 ? void 0 : options.iceRestart) {
            this.log.debug('restarting ICE', this.logContext);
            this.restartingIce = true;
          }
          if (this._pc && this._pc.signalingState === 'have-local-offer') {
            // we're waiting for the peer to accept our offer, so we'll just wait
            // the only exception to this is when ICE restart is needed
            const currentSD = this._pc.remoteDescription;
            if (
              (options === null || options === void 0 ? void 0 : options.iceRestart) &&
              currentSD
            ) {
              // TODO: handle when ICE restart is needed but we don't have a remote description
              // the best thing to do is to recreate the peerconnection
              yield this._pc.setRemoteDescription(currentSD);
            } else {
              this.renegotiate = true;
              return;
            }
          } else if (!this._pc || this._pc.signalingState === 'closed') {
            this.log.warn('could not createOffer with closed peer connection', this.logContext);
            return;
          }
          // actually negotiate
          this.log.debug('starting to negotiate', this.logContext);
          // increase the offer id at the start to ensure the offer is always > 0 so that we can use 0 as a default value for legacy behavior
          const offerId = this.latestOfferId + 1;
          this.latestOfferId = offerId;
          const offer = yield this.pc.createOffer(options);
          this.log.debug(
            'original offer',
            Object.assign(
              {
                sdp: offer.sdp,
              },
              this.logContext
            )
          );
          const sdpParsed = libExports.parse((_a = offer.sdp) !== null && _a !== void 0 ? _a : '');
          sdpParsed.media.forEach((media) => {
            ensureIPAddrMatchVersion(media);
            if (media.type === 'audio') {
              ensureAudioNackAndStereo(media, [], []);
            } else if (media.type === 'video') {
              this.trackBitrates.some((trackbr) => {
                if (!media.msid || !trackbr.cid || !media.msid.includes(trackbr.cid)) {
                  return false;
                }
                let codecPayload = 0;
                media.rtp.some((rtp) => {
                  if (rtp.codec.toUpperCase() === trackbr.codec.toUpperCase()) {
                    codecPayload = rtp.payload;
                    return true;
                  }
                  return false;
                });
                if (codecPayload === 0) {
                  return true;
                }
                if (isSVCCodec(trackbr.codec) && !isSafari()) {
                  this.ensureVideoDDExtensionForSVC(media, sdpParsed);
                }
                // TODO: av1 slow starting issue already fixed in chrome 124, clean this after some versions
                // mung sdp for av1 bitrate setting that can't apply by sendEncoding
                if (trackbr.codec !== 'av1') {
                  return true;
                }
                const startBitrate = Math.round(trackbr.maxbr * startBitrateForSVC);
                for (const fmtp of media.fmtp) {
                  if (fmtp.payload === codecPayload) {
                    // if another track's fmtp already is set, we cannot override the bitrate
                    // this has the unfortunate consequence of being forced to use the
                    // initial track's bitrate for all tracks
                    if (!fmtp.config.includes('x-google-start-bitrate')) {
                      fmtp.config += ';x-google-start-bitrate='.concat(startBitrate);
                    }
                    break;
                  }
                }
                return true;
              });
            }
          });
          if (this.latestOfferId > offerId) {
            this.log.warn(
              'latestOfferId mismatch',
              Object.assign(Object.assign({}, this.logContext), {
                latestOfferId: this.latestOfferId,
                offerId,
              })
            );
            return;
          }
          yield this.setMungedSDP(offer, libExports.write(sdpParsed));
          this.onOffer(offer, this.latestOfferId);
        } finally {
          unlock();
        }
      });
    }
    createAndSetAnswer() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        const answer = yield this.pc.createAnswer();
        const sdpParsed = libExports.parse((_a = answer.sdp) !== null && _a !== void 0 ? _a : '');
        sdpParsed.media.forEach((media) => {
          ensureIPAddrMatchVersion(media);
          if (media.type === 'audio') {
            ensureAudioNackAndStereo(media, this.remoteStereoMids, this.remoteNackMids);
          }
        });
        yield this.setMungedSDP(answer, libExports.write(sdpParsed));
        return answer;
      });
    }
    createDataChannel(label, dataChannelDict) {
      return this.pc.createDataChannel(label, dataChannelDict);
    }
    addTransceiver(mediaStreamTrack, transceiverInit) {
      return this.pc.addTransceiver(mediaStreamTrack, transceiverInit);
    }
    addTrack(track) {
      if (!this._pc) {
        throw new UnexpectedConnectionState('PC closed, cannot add track');
      }
      return this._pc.addTrack(track);
    }
    setTrackCodecBitrate(info) {
      this.trackBitrates.push(info);
    }
    setConfiguration(rtcConfig) {
      var _a;
      if (!this._pc) {
        throw new UnexpectedConnectionState('PC closed, cannot configure');
      }
      return (_a = this._pc) === null || _a === void 0 ? void 0 : _a.setConfiguration(rtcConfig);
    }
    canRemoveTrack() {
      var _a;
      return !!((_a = this._pc) === null || _a === void 0 ? void 0 : _a.removeTrack);
    }
    removeTrack(sender) {
      var _a;
      return (_a = this._pc) === null || _a === void 0 ? void 0 : _a.removeTrack(sender);
    }
    getConnectionState() {
      var _a, _b;
      return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.connectionState) !==
        null && _b !== void 0
        ? _b
        : 'closed';
    }
    getICEConnectionState() {
      var _a, _b;
      return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.iceConnectionState) !==
        null && _b !== void 0
        ? _b
        : 'closed';
    }
    getSignallingState() {
      var _a, _b;
      return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.signalingState) !==
        null && _b !== void 0
        ? _b
        : 'closed';
    }
    getTransceivers() {
      var _a, _b;
      return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.getTransceivers()) !==
        null && _b !== void 0
        ? _b
        : [];
    }
    getSenders() {
      var _a, _b;
      return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.getSenders()) !== null &&
        _b !== void 0
        ? _b
        : [];
    }
    getLocalDescription() {
      var _a;
      return (_a = this._pc) === null || _a === void 0 ? void 0 : _a.localDescription;
    }
    getRemoteDescription() {
      var _a;
      return (_a = this.pc) === null || _a === void 0 ? void 0 : _a.remoteDescription;
    }
    getStats() {
      return this.pc.getStats();
    }
    getConnectedAddress() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        if (!this._pc) {
          return;
        }
        let selectedCandidatePairId = '';
        const candidatePairs = new Map();
        // id -> candidate ip
        const candidates = new Map();
        const stats = yield this._pc.getStats();
        stats.forEach((v) => {
          switch (v.type) {
            case 'transport':
              selectedCandidatePairId = v.selectedCandidatePairId;
              break;
            case 'candidate-pair':
              if (selectedCandidatePairId === '' && v.selected) {
                selectedCandidatePairId = v.id;
              }
              candidatePairs.set(v.id, v);
              break;
            case 'remote-candidate':
              candidates.set(v.id, ''.concat(v.address, ':').concat(v.port));
              break;
          }
        });
        if (selectedCandidatePairId === '') {
          return undefined;
        }
        const selectedID =
          (_a = candidatePairs.get(selectedCandidatePairId)) === null || _a === void 0
            ? void 0
            : _a.remoteCandidateId;
        if (selectedID === undefined) {
          return undefined;
        }
        return candidates.get(selectedID);
      });
    }
    setMungedSDP(sd, munged, remote) {
      return __awaiter(this, void 0, void 0, function* () {
        if (munged) {
          const originalSdp = sd.sdp;
          sd.sdp = munged;
          try {
            this.log.debug(
              'setting munged '.concat(remote ? 'remote' : 'local', ' description'),
              this.logContext
            );
            if (remote) {
              yield this.pc.setRemoteDescription(sd);
            } else {
              yield this.pc.setLocalDescription(sd);
            }
            return;
          } catch (e) {
            this.log.warn(
              'not able to set '.concat(sd.type, ', falling back to unmodified sdp'),
              Object.assign(Object.assign({}, this.logContext), {
                error: e,
                sdp: munged,
              })
            );
            sd.sdp = originalSdp;
          }
        }
        try {
          if (remote) {
            yield this.pc.setRemoteDescription(sd);
          } else {
            yield this.pc.setLocalDescription(sd);
          }
        } catch (e) {
          let msg = 'unknown error';
          if (e instanceof Error) {
            msg = e.message;
          } else if (typeof e === 'string') {
            msg = e;
          }
          const fields = {
            error: msg,
            sdp: sd.sdp,
          };
          if (!remote && this.pc.remoteDescription) {
            fields.remoteSdp = this.pc.remoteDescription;
          }
          this.log.error(
            'unable to set '.concat(sd.type),
            Object.assign(Object.assign({}, this.logContext), {
              fields,
            })
          );
          throw new NegotiationError(msg);
        }
      });
    }
    ensureVideoDDExtensionForSVC(media, sdp) {
      var _a, _b;
      const ddFound =
        (_a = media.ext) === null || _a === void 0
          ? void 0
          : _a.some((ext) => {
              if (ext.uri === ddExtensionURI) {
                return true;
              }
              return false;
            });
      if (!ddFound) {
        if (this.ddExtID === 0) {
          let maxID = 0;
          sdp.media.forEach((m) => {
            var _a;
            if (m.type !== 'video') {
              return;
            }
            (_a = m.ext) === null || _a === void 0
              ? void 0
              : _a.forEach((ext) => {
                  if (ext.value > maxID) {
                    maxID = ext.value;
                  }
                });
          });
          this.ddExtID = maxID + 1;
        }
        (_b = media.ext) === null || _b === void 0
          ? void 0
          : _b.push({
              value: this.ddExtID,
              uri: ddExtensionURI,
            });
      }
    }
  }
  function ensureAudioNackAndStereo(media, stereoMids, nackMids) {
    // sdp-transform types don't include number however the parser outputs mids as numbers in some cases
    const mid = getMidString(media.mid);
    // found opus codec to add nack fb
    let opusPayload = 0;
    media.rtp.some((rtp) => {
      if (rtp.codec === 'opus') {
        opusPayload = rtp.payload;
        return true;
      }
      return false;
    });
    // add nack rtcpfb if not exist
    if (opusPayload > 0) {
      if (!media.rtcpFb) {
        media.rtcpFb = [];
      }
      if (
        nackMids.includes(mid) &&
        !media.rtcpFb.some((fb) => fb.payload === opusPayload && fb.type === 'nack')
      ) {
        media.rtcpFb.push({
          payload: opusPayload,
          type: 'nack',
        });
      }
      if (stereoMids.includes(mid)) {
        media.fmtp.some((fmtp) => {
          if (fmtp.payload === opusPayload) {
            if (!fmtp.config.includes('stereo=1')) {
              fmtp.config += ';stereo=1';
            }
            return true;
          }
          return false;
        });
      }
    }
  }
  function extractStereoAndNackAudioFromOffer(offer) {
    var _a;
    const stereoMids = [];
    const nackMids = [];
    const sdpParsed = libExports.parse((_a = offer.sdp) !== null && _a !== void 0 ? _a : '');
    let opusPayload = 0;
    sdpParsed.media.forEach((media) => {
      var _a;
      const mid = getMidString(media.mid);
      if (media.type === 'audio') {
        media.rtp.some((rtp) => {
          if (rtp.codec === 'opus') {
            opusPayload = rtp.payload;
            return true;
          }
          return false;
        });
        if (
          (_a = media.rtcpFb) === null || _a === void 0
            ? void 0
            : _a.some((fb) => fb.payload === opusPayload && fb.type === 'nack')
        ) {
          nackMids.push(mid);
        }
        media.fmtp.some((fmtp) => {
          if (fmtp.payload === opusPayload) {
            if (fmtp.config.includes('sprop-stereo=1')) {
              stereoMids.push(mid);
            }
            return true;
          }
          return false;
        });
      }
    });
    return {
      stereoMids,
      nackMids,
    };
  }
  function ensureIPAddrMatchVersion(media) {
    // Chrome could generate sdp with c = IN IP4 <ipv6 addr>
    // in edge case and return error when set sdp.This is not a
    // sdk error but correct it if the issue detected.
    if (media.connection) {
      const isV6 = media.connection.ip.indexOf(':') >= 0;
      if ((media.connection.version === 4 && isV6) || (media.connection.version === 6 && !isV6)) {
        // fallback to dummy address
        media.connection.ip = '0.0.0.0';
        media.connection.version = 4;
      }
    }
  }
  function getMidString(mid) {
    return typeof mid === 'number' ? mid.toFixed(0) : mid;
  }

  const defaultVideoCodec = 'vp8';
  const publishDefaults = {
    audioPreset: AudioPresets.music,
    dtx: true,
    red: true,
    forceStereo: false,
    simulcast: true,
    screenShareEncoding: ScreenSharePresets.h1080fps15.encoding,
    stopMicTrackOnMute: false,
    videoCodec: defaultVideoCodec,
    backupCodec: true,
    preConnectBuffer: false,
  };
  const audioDefaults = {
    deviceId: {
      ideal: 'default',
    },
    autoGainControl: true,
    echoCancellation: true,
    noiseSuppression: true,
    voiceIsolation: true,
  };
  const videoDefaults = {
    deviceId: {
      ideal: 'default',
    },
    resolution: VideoPresets.h720.resolution,
  };
  const roomOptionDefaults = {
    adaptiveStream: false,
    dynacast: false,
    stopLocalTrackOnUnpublish: true,
    reconnectPolicy: new DefaultReconnectPolicy(),
    disconnectOnPageLeave: true,
    webAudioMix: false,
  };
  const roomConnectOptionDefaults = {
    autoSubscribe: true,
    maxRetries: 1,
    peerConnectionTimeout: 15000,
    websocketTimeout: 15000,
  };

  var PCTransportState;
  (function (PCTransportState) {
    PCTransportState[(PCTransportState['NEW'] = 0)] = 'NEW';
    PCTransportState[(PCTransportState['CONNECTING'] = 1)] = 'CONNECTING';
    PCTransportState[(PCTransportState['CONNECTED'] = 2)] = 'CONNECTED';
    PCTransportState[(PCTransportState['FAILED'] = 3)] = 'FAILED';
    PCTransportState[(PCTransportState['CLOSING'] = 4)] = 'CLOSING';
    PCTransportState[(PCTransportState['CLOSED'] = 5)] = 'CLOSED';
  })(PCTransportState || (PCTransportState = {}));
  class PCTransportManager {
    get needsPublisher() {
      return this.isPublisherConnectionRequired;
    }
    get needsSubscriber() {
      return this.isSubscriberConnectionRequired;
    }
    get currentState() {
      return this.state;
    }
    constructor(rtcConfig, subscriberPrimary, loggerOptions) {
      var _a;
      this.peerConnectionTimeout = roomConnectOptionDefaults.peerConnectionTimeout;
      this.log = livekitLogger;
      this.updateState = () => {
        var _a;
        const previousState = this.state;
        const connectionStates = this.requiredTransports.map((tr) => tr.getConnectionState());
        if (connectionStates.every((st) => st === 'connected')) {
          this.state = PCTransportState.CONNECTED;
        } else if (connectionStates.some((st) => st === 'failed')) {
          this.state = PCTransportState.FAILED;
        } else if (connectionStates.some((st) => st === 'connecting')) {
          this.state = PCTransportState.CONNECTING;
        } else if (connectionStates.every((st) => st === 'closed')) {
          this.state = PCTransportState.CLOSED;
        } else if (connectionStates.some((st) => st === 'closed')) {
          this.state = PCTransportState.CLOSING;
        } else if (connectionStates.every((st) => st === 'new')) {
          this.state = PCTransportState.NEW;
        }
        if (previousState !== this.state) {
          this.log.debug(
            'pc state change: from '
              .concat(PCTransportState[previousState], ' to ')
              .concat(PCTransportState[this.state]),
            this.logContext
          );
          (_a = this.onStateChange) === null || _a === void 0
            ? void 0
            : _a.call(
                this,
                this.state,
                this.publisher.getConnectionState(),
                this.subscriber.getConnectionState()
              );
        }
      };
      this.log = getLogger(
        (_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.PCManager
      );
      this.loggerOptions = loggerOptions;
      this.isPublisherConnectionRequired = !subscriberPrimary;
      this.isSubscriberConnectionRequired = subscriberPrimary;
      this.publisher = new PCTransport(rtcConfig, loggerOptions);
      this.subscriber = new PCTransport(rtcConfig, loggerOptions);
      this.publisher.onConnectionStateChange = this.updateState;
      this.subscriber.onConnectionStateChange = this.updateState;
      this.publisher.onIceConnectionStateChange = this.updateState;
      this.subscriber.onIceConnectionStateChange = this.updateState;
      this.publisher.onSignalingStatechange = this.updateState;
      this.subscriber.onSignalingStatechange = this.updateState;
      this.publisher.onIceCandidate = (candidate) => {
        var _a;
        (_a = this.onIceCandidate) === null || _a === void 0
          ? void 0
          : _a.call(this, candidate, SignalTarget.PUBLISHER);
      };
      this.subscriber.onIceCandidate = (candidate) => {
        var _a;
        (_a = this.onIceCandidate) === null || _a === void 0
          ? void 0
          : _a.call(this, candidate, SignalTarget.SUBSCRIBER);
      };
      // in subscriber primary mode, server side opens sub data channels.
      this.subscriber.onDataChannel = (ev) => {
        var _a;
        (_a = this.onDataChannel) === null || _a === void 0 ? void 0 : _a.call(this, ev);
      };
      this.subscriber.onTrack = (ev) => {
        var _a;
        (_a = this.onTrack) === null || _a === void 0 ? void 0 : _a.call(this, ev);
      };
      this.publisher.onOffer = (offer, offerId) => {
        var _a;
        (_a = this.onPublisherOffer) === null || _a === void 0
          ? void 0
          : _a.call(this, offer, offerId);
      };
      this.state = PCTransportState.NEW;
      this.connectionLock = new livekit_client_esm_();
      this.remoteOfferLock = new livekit_client_esm_();
    }
    get logContext() {
      var _a, _b;
      return Object.assign(
        {},
        (_b = (_a = this.loggerOptions).loggerContextCb) === null || _b === void 0
          ? void 0
          : _b.call(_a)
      );
    }
    requirePublisher() {
      let require = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      this.isPublisherConnectionRequired = require;
      this.updateState();
    }
    requireSubscriber() {
      let require = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      this.isSubscriberConnectionRequired = require;
      this.updateState();
    }
    createAndSendPublisherOffer(options) {
      return this.publisher.createAndSendOffer(options);
    }
    setPublisherAnswer(sd, offerId) {
      return this.publisher.setRemoteDescription(sd, offerId);
    }
    removeTrack(sender) {
      return this.publisher.removeTrack(sender);
    }
    close() {
      return __awaiter(this, void 0, void 0, function* () {
        if (this.publisher && this.publisher.getSignallingState() !== 'closed') {
          const publisher = this.publisher;
          for (const sender of publisher.getSenders()) {
            try {
              // TODO: react-native-webrtc doesn't have removeTrack yet.
              if (publisher.canRemoveTrack()) {
                publisher.removeTrack(sender);
              }
            } catch (e) {
              this.log.warn(
                'could not removeTrack',
                Object.assign(Object.assign({}, this.logContext), {
                  error: e,
                })
              );
            }
          }
        }
        yield Promise.all([this.publisher.close(), this.subscriber.close()]);
        this.updateState();
      });
    }
    triggerIceRestart() {
      return __awaiter(this, void 0, void 0, function* () {
        this.subscriber.restartingIce = true;
        // only restart publisher if it's needed
        if (this.needsPublisher) {
          yield this.createAndSendPublisherOffer({
            iceRestart: true,
          });
        }
      });
    }
    addIceCandidate(candidate, target) {
      return __awaiter(this, void 0, void 0, function* () {
        if (target === SignalTarget.PUBLISHER) {
          yield this.publisher.addIceCandidate(candidate);
        } else {
          yield this.subscriber.addIceCandidate(candidate);
        }
      });
    }
    createSubscriberAnswerFromOffer(sd, offerId) {
      return __awaiter(this, void 0, void 0, function* () {
        this.log.debug(
          'received server offer',
          Object.assign(Object.assign({}, this.logContext), {
            RTCSdpType: sd.type,
            sdp: sd.sdp,
            signalingState: this.subscriber.getSignallingState().toString(),
          })
        );
        const unlock = yield this.remoteOfferLock.lock();
        try {
          const success = yield this.subscriber.setRemoteDescription(sd, offerId);
          if (!success) {
            return undefined;
          }
          // answer the offer
          const answer = yield this.subscriber.createAndSetAnswer();
          return answer;
        } finally {
          unlock();
        }
      });
    }
    updateConfiguration(config, iceRestart) {
      this.publisher.setConfiguration(config);
      this.subscriber.setConfiguration(config);
      if (iceRestart) {
        this.triggerIceRestart();
      }
    }
    ensurePCTransportConnection(abortController, timeout) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        const unlock = yield this.connectionLock.lock();
        try {
          if (
            this.isPublisherConnectionRequired &&
            this.publisher.getConnectionState() !== 'connected' &&
            this.publisher.getConnectionState() !== 'connecting'
          ) {
            this.log.debug('negotiation required, start negotiating', this.logContext);
            this.publisher.negotiate();
          }
          yield Promise.all(
            (_a = this.requiredTransports) === null || _a === void 0
              ? void 0
              : _a.map((transport) =>
                  this.ensureTransportConnected(transport, abortController, timeout)
                )
          );
        } finally {
          unlock();
        }
      });
    }
    negotiate(abortController) {
      return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) =>
          __awaiter(this, void 0, void 0, function* () {
            const negotiationTimeout = setTimeout(() => {
              reject('negotiation timed out');
            }, this.peerConnectionTimeout);
            const abortHandler = () => {
              clearTimeout(negotiationTimeout);
              reject('negotiation aborted');
            };
            abortController.signal.addEventListener('abort', abortHandler);
            this.publisher.once(PCEvents.NegotiationStarted, () => {
              if (abortController.signal.aborted) {
                return;
              }
              this.publisher.once(PCEvents.NegotiationComplete, () => {
                clearTimeout(negotiationTimeout);
                resolve();
              });
            });
            yield this.publisher.negotiate((e) => {
              clearTimeout(negotiationTimeout);
              reject(e);
            });
          })
        );
      });
    }
    addPublisherTransceiver(track, transceiverInit) {
      return this.publisher.addTransceiver(track, transceiverInit);
    }
    addPublisherTrack(track) {
      return this.publisher.addTrack(track);
    }
    createPublisherDataChannel(label, dataChannelDict) {
      return this.publisher.createDataChannel(label, dataChannelDict);
    }
    /**
     * Returns the first required transport's address if no explicit target is specified
     */
    getConnectedAddress(target) {
      if (target === SignalTarget.PUBLISHER) {
        return this.publisher.getConnectedAddress();
      } else if (target === SignalTarget.SUBSCRIBER) {
        return this.publisher.getConnectedAddress();
      }
      return this.requiredTransports[0].getConnectedAddress();
    }
    get requiredTransports() {
      const transports = [];
      if (this.isPublisherConnectionRequired) {
        transports.push(this.publisher);
      }
      if (this.isSubscriberConnectionRequired) {
        transports.push(this.subscriber);
      }
      return transports;
    }
    ensureTransportConnected(pcTransport_1, abortController_1) {
      return __awaiter(this, arguments, void 0, function (pcTransport, abortController) {
        var _this = this;
        let timeout =
          arguments.length > 2 && arguments[2] !== undefined
            ? arguments[2]
            : this.peerConnectionTimeout;
        return (function* () {
          const connectionState = pcTransport.getConnectionState();
          if (connectionState === 'connected') {
            return;
          }
          return new Promise((resolve, reject) =>
            __awaiter(_this, void 0, void 0, function* () {
              const abortHandler = () => {
                this.log.warn('abort transport connection', this.logContext);
                CriticalTimers.clearTimeout(connectTimeout);
                reject(
                  new ConnectionError(
                    'room connection has been cancelled',
                    ConnectionErrorReason.Cancelled
                  )
                );
              };
              if (
                abortController === null || abortController === void 0
                  ? void 0
                  : abortController.signal.aborted
              ) {
                abortHandler();
              }
              abortController === null || abortController === void 0
                ? void 0
                : abortController.signal.addEventListener('abort', abortHandler);
              const connectTimeout = CriticalTimers.setTimeout(() => {
                abortController === null || abortController === void 0
                  ? void 0
                  : abortController.signal.removeEventListener('abort', abortHandler);
                reject(
                  new ConnectionError(
                    'could not establish pc connection',
                    ConnectionErrorReason.InternalError
                  )
                );
              }, timeout);
              while (this.state !== PCTransportState.CONNECTED) {
                yield sleep(50); // FIXME we shouldn't rely on `sleep` in the connection paths, as it invokes `setTimeout` which can be drastically throttled by browser implementations
                if (
                  abortController === null || abortController === void 0
                    ? void 0
                    : abortController.signal.aborted
                ) {
                  reject(
                    new ConnectionError(
                      'room connection has been cancelled',
                      ConnectionErrorReason.Cancelled
                    )
                  );
                  return;
                }
              }
              CriticalTimers.clearTimeout(connectTimeout);
              abortController === null || abortController === void 0
                ? void 0
                : abortController.signal.removeEventListener('abort', abortHandler);
              resolve();
            })
          );
        })();
      });
    }
  }

  // SPDX-FileCopyrightText: 2024 LiveKit, Inc.
  //
  // SPDX-License-Identifier: Apache-2.0
  /**
   * Specialized error handling for RPC methods.
   *
   * Instances of this type, when thrown in a method handler, will have their `message`
   * serialized and sent across the wire. The sender will receive an equivalent error on the other side.
   *
   * Built-in types are included but developers may use any string, with a max length of 256 bytes.
   */
  class RpcError extends Error {
    /**
     * Creates an error object with the given code and message, plus an optional data payload.
     *
     * If thrown in an RPC method handler, the error will be sent back to the caller.
     *
     * Error codes 1001-1999 are reserved for built-in errors (see RpcError.ErrorCode for their meanings).
     */
    constructor(code, message, data) {
      super(message);
      this.code = code;
      this.message = truncateBytes(message, RpcError.MAX_MESSAGE_BYTES);
      this.data = data ? truncateBytes(data, RpcError.MAX_DATA_BYTES) : undefined;
    }
    /**
     * @internal
     */
    static fromProto(proto) {
      return new RpcError(proto.code, proto.message, proto.data);
    }
    /**
     * @internal
     */
    toProto() {
      return new RpcError$1({
        code: this.code,
        message: this.message,
        data: this.data,
      });
    }
    /**
     * Creates an error object from the code, with an auto-populated message.
     *
     * @internal
     */
    static builtIn(key, data) {
      return new RpcError(RpcError.ErrorCode[key], RpcError.ErrorMessage[key], data);
    }
  }
  RpcError.MAX_MESSAGE_BYTES = 256;
  RpcError.MAX_DATA_BYTES = 15360; // 15 KB
  RpcError.ErrorCode = {
    APPLICATION_ERROR: 1500,
    CONNECTION_TIMEOUT: 1501,
    RESPONSE_TIMEOUT: 1502,
    RECIPIENT_DISCONNECTED: 1503,
    RESPONSE_PAYLOAD_TOO_LARGE: 1504,
    SEND_FAILED: 1505,
    UNSUPPORTED_METHOD: 1400,
    RECIPIENT_NOT_FOUND: 1401,
    REQUEST_PAYLOAD_TOO_LARGE: 1402,
    UNSUPPORTED_SERVER: 1403,
    UNSUPPORTED_VERSION: 1404,
  };
  /**
   * @internal
   */
  RpcError.ErrorMessage = {
    APPLICATION_ERROR: 'Application error in method handler',
    CONNECTION_TIMEOUT: 'Connection timeout',
    RESPONSE_TIMEOUT: 'Response timeout',
    RECIPIENT_DISCONNECTED: 'Recipient disconnected',
    RESPONSE_PAYLOAD_TOO_LARGE: 'Response payload too large',
    SEND_FAILED: 'Failed to send',
    UNSUPPORTED_METHOD: 'Method not supported at destination',
    RECIPIENT_NOT_FOUND: 'Recipient not found',
    REQUEST_PAYLOAD_TOO_LARGE: 'Request payload too large',
    UNSUPPORTED_SERVER: 'RPC not supported by server',
    UNSUPPORTED_VERSION: 'Unsupported RPC version',
  };
  /*
   * Maximum payload size for RPC requests and responses. If a payload exceeds this size,
   * the RPC call will fail with a REQUEST_PAYLOAD_TOO_LARGE(1402) or RESPONSE_PAYLOAD_TOO_LARGE(1504) error.
   */
  const MAX_PAYLOAD_BYTES = 15360; // 15 KB
  /**
   * @internal
   */
  function byteLength(str) {
    const encoder = new TextEncoder();
    return encoder.encode(str).length;
  }
  /**
   * @internal
   */
  function truncateBytes(str, maxBytes) {
    if (byteLength(str) <= maxBytes) {
      return str;
    }
    let low = 0;
    let high = str.length;
    const encoder = new TextEncoder();
    while (low < high) {
      const mid = Math.floor((low + high + 1) / 2);
      if (encoder.encode(str.slice(0, mid)).length <= maxBytes) {
        low = mid;
      } else {
        high = mid - 1;
      }
    }
    return str.slice(0, low);
  }

  const monitorFrequency = 2000;
  function computeBitrate(currentStats, prevStats) {
    if (!prevStats) {
      return 0;
    }
    let bytesNow;
    let bytesPrev;
    if ('bytesReceived' in currentStats) {
      bytesNow = currentStats.bytesReceived;
      bytesPrev = prevStats.bytesReceived;
    } else if ('bytesSent' in currentStats) {
      bytesNow = currentStats.bytesSent;
      bytesPrev = prevStats.bytesSent;
    }
    if (
      bytesNow === undefined ||
      bytesPrev === undefined ||
      currentStats.timestamp === undefined ||
      prevStats.timestamp === undefined
    ) {
      return 0;
    }
    return ((bytesNow - bytesPrev) * 8 * 1000) / (currentStats.timestamp - prevStats.timestamp);
  }

  // Check if MediaRecorder is available
  const isMediaRecorderAvailable = typeof MediaRecorder !== 'undefined';
  // Fallback class for environments without MediaRecorder
  class FallbackRecorder {
    constructor() {
      throw new Error('MediaRecorder is not available in this environment');
    }
  }
  // Use conditional inheritance to avoid parse-time errors
  const RecorderBase = isMediaRecorderAvailable ? MediaRecorder : FallbackRecorder;
  class LocalTrackRecorder extends RecorderBase {
    constructor(track, options) {
      if (!isMediaRecorderAvailable) {
        throw new Error('MediaRecorder is not available in this environment');
      }
      super(new MediaStream([track.mediaStreamTrack]), options);
      let dataListener;
      let streamController;
      const isClosed = () => streamController === undefined;
      const onStop = () => {
        this.removeEventListener('dataavailable', dataListener);
        this.removeEventListener('stop', onStop);
        this.removeEventListener('error', onError);
        streamController === null || streamController === void 0
          ? void 0
          : streamController.close();
        streamController = undefined;
      };
      const onError = (event) => {
        streamController === null || streamController === void 0
          ? void 0
          : streamController.error(event);
        this.removeEventListener('dataavailable', dataListener);
        this.removeEventListener('stop', onStop);
        this.removeEventListener('error', onError);
        streamController = undefined;
      };
      this.byteStream = new ReadableStream({
        start: (controller) => {
          streamController = controller;
          dataListener = (event) =>
            __awaiter(this, void 0, void 0, function* () {
              let data;
              if (event.data.arrayBuffer) {
                const arrayBuffer = yield event.data.arrayBuffer();
                data = new Uint8Array(arrayBuffer);
                // @ts-expect-error react-native passes over Uint8Arrays directly
              } else if (event.data.byteArray) {
                // @ts-expect-error
                data = event.data.byteArray;
              } else {
                throw new Error('no data available!');
              }
              if (isClosed()) {
                return;
              }
              controller.enqueue(data);
            });
          this.addEventListener('dataavailable', dataListener);
        },
        cancel: () => {
          onStop();
        },
      });
      this.addEventListener('stop', onStop);
      this.addEventListener('error', onError);
    }
  }
  // Helper function to check if recording is supported
  function isRecordingSupported() {
    return isMediaRecorderAvailable;
  }

  const DEFAULT_DIMENSIONS_TIMEOUT = 1000;
  const PRE_CONNECT_BUFFER_TIMEOUT = 10000;
  class LocalTrack extends Track {
    /** @internal */
    get sender() {
      return this._sender;
    }
    /** @internal */
    set sender(sender) {
      this._sender = sender;
    }
    get constraints() {
      return this._constraints;
    }
    get hasPreConnectBuffer() {
      return !!this.localTrackRecorder;
    }
    /**
     *
     * @param mediaTrack
     * @param kind
     * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks
     * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK
     */
    constructor(mediaTrack, kind, constraints) {
      let userProvidedTrack =
        arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      let loggerOptions = arguments.length > 4 ? arguments[4] : undefined;
      super(mediaTrack, kind, loggerOptions);
      this.manuallyStopped = false;
      this._isUpstreamPaused = false;
      this.handleTrackMuteEvent = () =>
        this.debouncedTrackMuteHandler().catch(() =>
          this.log.debug('track mute bounce got cancelled by an unmute event', this.logContext)
        );
      this.debouncedTrackMuteHandler = r(
        () =>
          __awaiter(this, void 0, void 0, function* () {
            yield this.pauseUpstream();
          }),
        5000
      );
      this.handleTrackUnmuteEvent = () =>
        __awaiter(this, void 0, void 0, function* () {
          this.debouncedTrackMuteHandler.cancel('unmute');
          yield this.resumeUpstream();
        });
      this.handleEnded = () => {
        if (this.isInBackground) {
          this.reacquireTrack = true;
        }
        this._mediaStreamTrack.removeEventListener('mute', this.handleTrackMuteEvent);
        this._mediaStreamTrack.removeEventListener('unmute', this.handleTrackUnmuteEvent);
        this.emit(TrackEvent.Ended, this);
      };
      this.reacquireTrack = false;
      this.providedByUser = userProvidedTrack;
      this.muteLock = new livekit_client_esm_();
      this.pauseUpstreamLock = new livekit_client_esm_();
      this.trackChangeLock = new livekit_client_esm_();
      this.trackChangeLock.lock().then((unlock) =>
        __awaiter(this, void 0, void 0, function* () {
          try {
            yield this.setMediaStreamTrack(mediaTrack, true);
          } finally {
            unlock();
          }
        })
      );
      // added to satisfy TS compiler, constraints are synced with MediaStreamTrack
      this._constraints = mediaTrack.getConstraints();
      if (constraints) {
        this._constraints = constraints;
      }
    }
    get id() {
      return this._mediaStreamTrack.id;
    }
    get dimensions() {
      if (this.kind !== Track.Kind.Video) {
        return undefined;
      }
      const { width, height } = this._mediaStreamTrack.getSettings();
      if (width && height) {
        return {
          width,
          height,
        };
      }
      return undefined;
    }
    get isUpstreamPaused() {
      return this._isUpstreamPaused;
    }
    get isUserProvided() {
      return this.providedByUser;
    }
    get mediaStreamTrack() {
      var _a, _b;
      return (_b = (_a = this.processor) === null || _a === void 0 ? void 0 : _a.processedTrack) !==
        null && _b !== void 0
        ? _b
        : this._mediaStreamTrack;
    }
    get isLocal() {
      return true;
    }
    /**
     * @internal
     * returns mediaStreamTrack settings of the capturing mediastreamtrack source - ignoring processors
     */
    getSourceTrackSettings() {
      return this._mediaStreamTrack.getSettings();
    }
    setMediaStreamTrack(newTrack, force) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        if (newTrack === this._mediaStreamTrack && !force) {
          return;
        }
        if (this._mediaStreamTrack) {
          // detach
          this.attachedElements.forEach((el) => {
            detachTrack(this._mediaStreamTrack, el);
          });
          this.debouncedTrackMuteHandler.cancel('new-track');
          this._mediaStreamTrack.removeEventListener('ended', this.handleEnded);
          this._mediaStreamTrack.removeEventListener('mute', this.handleTrackMuteEvent);
          this._mediaStreamTrack.removeEventListener('unmute', this.handleTrackUnmuteEvent);
        }
        this.mediaStream = new MediaStream([newTrack]);
        if (newTrack) {
          newTrack.addEventListener('ended', this.handleEnded);
          // when underlying track emits mute, it indicates that the device is unable
          // to produce media. In this case we'll need to signal with remote that
          // the track is "muted"
          // note this is different from LocalTrack.mute because we do not want to
          // touch MediaStreamTrack.enabled
          newTrack.addEventListener('mute', this.handleTrackMuteEvent);
          newTrack.addEventListener('unmute', this.handleTrackUnmuteEvent);
          this._constraints = newTrack.getConstraints();
        }
        let processedTrack;
        if (this.processor && newTrack) {
          this.log.debug('restarting processor', this.logContext);
          if (this.kind === 'unknown') {
            throw TypeError('cannot set processor on track of unknown kind');
          }
          if (this.processorElement) {
            attachToElement(newTrack, this.processorElement);
            // ensure the processorElement itself stays muted
            this.processorElement.muted = true;
          }
          yield this.processor.restart({
            track: newTrack,
            kind: this.kind,
            element: this.processorElement,
          });
          processedTrack = this.processor.processedTrack;
        }
        if (
          this.sender &&
          ((_a = this.sender.transport) === null || _a === void 0 ? void 0 : _a.state) !== 'closed'
        ) {
          yield this.sender.replaceTrack(
            processedTrack !== null && processedTrack !== void 0 ? processedTrack : newTrack
          );
        }
        // if `newTrack` is different from the existing track, stop the
        // older track just before replacing it
        if (!this.providedByUser && this._mediaStreamTrack !== newTrack) {
          this._mediaStreamTrack.stop();
        }
        this._mediaStreamTrack = newTrack;
        if (newTrack) {
          // sync muted state with the enabled state of the newly provided track
          this._mediaStreamTrack.enabled = !this.isMuted;
          // when a valid track is replace, we'd want to start producing
          yield this.resumeUpstream();
          this.attachedElements.forEach((el) => {
            attachToElement(
              processedTrack !== null && processedTrack !== void 0 ? processedTrack : newTrack,
              el
            );
          });
        }
      });
    }
    waitForDimensions() {
      return __awaiter(this, arguments, void 0, function () {
        var _this = this;
        let timeout =
          arguments.length > 0 && arguments[0] !== undefined
            ? arguments[0]
            : DEFAULT_DIMENSIONS_TIMEOUT;
        return (function* () {
          var _a;
          if (_this.kind === Track.Kind.Audio) {
            throw new Error('cannot get dimensions for audio tracks');
          }
          if (((_a = getBrowser()) === null || _a === void 0 ? void 0 : _a.os) === 'iOS') {
            // browsers report wrong initial resolution on iOS.
            // when slightly delaying the call to .getSettings(), the correct resolution is being reported
            yield sleep(10);
          }
          const started = Date.now();
          while (Date.now() - started < timeout) {
            const dims = _this.dimensions;
            if (dims) {
              return dims;
            }
            yield sleep(50);
          }
          throw new TrackInvalidError('unable to get track dimensions after timeout');
        })();
      });
    }
    setDeviceId(deviceId) {
      return __awaiter(this, void 0, void 0, function* () {
        if (
          this._constraints.deviceId === deviceId &&
          this._mediaStreamTrack.getSettings().deviceId === unwrapConstraint(deviceId)
        ) {
          return true;
        }
        this._constraints.deviceId = deviceId;
        // when track is muted, underlying media stream track is stopped and
        // will be restarted later
        if (this.isMuted) {
          return true;
        }
        yield this.restartTrack();
        return unwrapConstraint(deviceId) === this._mediaStreamTrack.getSettings().deviceId;
      });
    }
    /**
     * @returns DeviceID of the device that is currently being used for this track
     */
    getDeviceId() {
      return __awaiter(this, arguments, void 0, function () {
        var _this2 = this;
        let normalize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        return (function* () {
          // screen share doesn't have a usable device id
          if (_this2.source === Track.Source.ScreenShare) {
            return;
          }
          const { deviceId, groupId } = _this2._mediaStreamTrack.getSettings();
          const kind = _this2.kind === Track.Kind.Audio ? 'audioinput' : 'videoinput';
          return normalize
            ? DeviceManager.getInstance().normalizeDeviceId(kind, deviceId, groupId)
            : deviceId;
        })();
      });
    }
    mute() {
      return __awaiter(this, void 0, void 0, function* () {
        this.setTrackMuted(true);
        return this;
      });
    }
    unmute() {
      return __awaiter(this, void 0, void 0, function* () {
        this.setTrackMuted(false);
        return this;
      });
    }
    replaceTrack(track, userProvidedOrOptions) {
      return __awaiter(this, void 0, void 0, function* () {
        const unlock = yield this.trackChangeLock.lock();
        try {
          if (!this.sender) {
            throw new TrackInvalidError('unable to replace an unpublished track');
          }
          let userProvidedTrack;
          let stopProcessor;
          if (typeof userProvidedOrOptions === 'boolean') {
            userProvidedTrack = userProvidedOrOptions;
          } else if (userProvidedOrOptions !== undefined) {
            userProvidedTrack = userProvidedOrOptions.userProvidedTrack;
            stopProcessor = userProvidedOrOptions.stopProcessor;
          }
          this.providedByUser =
            userProvidedTrack !== null && userProvidedTrack !== void 0 ? userProvidedTrack : true;
          this.log.debug('replace MediaStreamTrack', this.logContext);
          yield this.setMediaStreamTrack(track);
          // this must be synced *after* setting mediaStreamTrack above, since it relies
          // on the previous state in order to cleanup
          if (stopProcessor && this.processor) {
            yield this.internalStopProcessor();
          }
          return this;
        } finally {
          unlock();
        }
      });
    }
    restart(constraints) {
      return __awaiter(this, void 0, void 0, function* () {
        this.manuallyStopped = false;
        const unlock = yield this.trackChangeLock.lock();
        try {
          if (!constraints) {
            constraints = this._constraints;
          }
          const { deviceId, facingMode } = constraints,
            otherConstraints = __rest(constraints, ['deviceId', 'facingMode']);
          this.log.debug(
            'restarting track with constraints',
            Object.assign(Object.assign({}, this.logContext), {
              constraints,
            })
          );
          const streamConstraints = {
            audio: false,
            video: false,
          };
          if (this.kind === Track.Kind.Video) {
            streamConstraints.video =
              deviceId || facingMode
                ? {
                    deviceId,
                    facingMode,
                  }
                : true;
          } else {
            streamConstraints.audio = deviceId
              ? Object.assign(
                  {
                    deviceId,
                  },
                  otherConstraints
                )
              : true;
          }
          // these steps are duplicated from setMediaStreamTrack because we must stop
          // the previous tracks before new tracks can be acquired
          this.attachedElements.forEach((el) => {
            detachTrack(this.mediaStreamTrack, el);
          });
          this._mediaStreamTrack.removeEventListener('ended', this.handleEnded);
          // on Safari, the old audio track must be stopped before attempting to acquire
          // the new track, otherwise the new track will stop with
          // 'A MediaStreamTrack ended due to a capture failure`
          this._mediaStreamTrack.stop();
          // create new track and attach
          const mediaStream = yield navigator.mediaDevices.getUserMedia(streamConstraints);
          const newTrack = mediaStream.getTracks()[0];
          if (this.kind === Track.Kind.Video) {
            // we already captured the audio track with the constraints, so we only need to apply the video constraints
            yield newTrack.applyConstraints(otherConstraints);
          }
          newTrack.addEventListener('ended', this.handleEnded);
          this.log.debug('re-acquired MediaStreamTrack', this.logContext);
          yield this.setMediaStreamTrack(newTrack);
          this._constraints = constraints;
          this.emit(TrackEvent.Restarted, this);
          if (this.manuallyStopped) {
            this.log.warn(
              'track was stopped during a restart, stopping restarted track',
              this.logContext
            );
            this.stop();
          }
          return this;
        } finally {
          unlock();
        }
      });
    }
    setTrackMuted(muted) {
      this.log.debug(
        'setting '.concat(this.kind, ' track ').concat(muted ? 'muted' : 'unmuted'),
        this.logContext
      );
      if (this.isMuted === muted && this._mediaStreamTrack.enabled !== muted) {
        return;
      }
      this.isMuted = muted;
      this._mediaStreamTrack.enabled = !muted;
      this.emit(muted ? TrackEvent.Muted : TrackEvent.Unmuted, this);
    }
    get needsReAcquisition() {
      return (
        this._mediaStreamTrack.readyState !== 'live' ||
        this._mediaStreamTrack.muted ||
        !this._mediaStreamTrack.enabled ||
        this.reacquireTrack
      );
    }
    handleAppVisibilityChanged() {
      const _super = Object.create(null, {
        handleAppVisibilityChanged: {
          get: () => super.handleAppVisibilityChanged,
        },
      });
      return __awaiter(this, void 0, void 0, function* () {
        yield _super.handleAppVisibilityChanged.call(this);
        if (!isMobile()) return;
        this.log.debug(
          'visibility changed, is in Background: '.concat(this.isInBackground),
          this.logContext
        );
        if (
          !this.isInBackground &&
          this.needsReAcquisition &&
          !this.isUserProvided &&
          !this.isMuted
        ) {
          this.log.debug(
            'track needs to be reacquired, restarting '.concat(this.source),
            this.logContext
          );
          yield this.restart();
          this.reacquireTrack = false;
        }
      });
    }
    stop() {
      var _a;
      this.manuallyStopped = true;
      super.stop();
      this._mediaStreamTrack.removeEventListener('ended', this.handleEnded);
      this._mediaStreamTrack.removeEventListener('mute', this.handleTrackMuteEvent);
      this._mediaStreamTrack.removeEventListener('unmute', this.handleTrackUnmuteEvent);
      (_a = this.processor) === null || _a === void 0 ? void 0 : _a.destroy();
      this.processor = undefined;
    }
    /**
     * pauses publishing to the server without disabling the local MediaStreamTrack
     * this is used to display a user's own video locally while pausing publishing to
     * the server.
     * this API is unsupported on Safari < 12 due to a bug
     **/
    pauseUpstream() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        const unlock = yield this.pauseUpstreamLock.lock();
        try {
          if (this._isUpstreamPaused === true) {
            return;
          }
          if (!this.sender) {
            this.log.warn('unable to pause upstream for an unpublished track', this.logContext);
            return;
          }
          this._isUpstreamPaused = true;
          this.emit(TrackEvent.UpstreamPaused, this);
          const browser = getBrowser();
          if (
            (browser === null || browser === void 0 ? void 0 : browser.name) === 'Safari' &&
            compareVersions(browser.version, '12.0') < 0
          ) {
            // https://bugs.webkit.org/show_bug.cgi?id=184911
            throw new DeviceUnsupportedError('pauseUpstream is not supported on Safari < 12.');
          }
          if (
            ((_a = this.sender.transport) === null || _a === void 0 ? void 0 : _a.state) !==
            'closed'
          ) {
            yield this.sender.replaceTrack(null);
          }
        } finally {
          unlock();
        }
      });
    }
    resumeUpstream() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        const unlock = yield this.pauseUpstreamLock.lock();
        try {
          if (this._isUpstreamPaused === false) {
            return;
          }
          if (!this.sender) {
            this.log.warn('unable to resume upstream for an unpublished track', this.logContext);
            return;
          }
          this._isUpstreamPaused = false;
          this.emit(TrackEvent.UpstreamResumed, this);
          if (
            ((_a = this.sender.transport) === null || _a === void 0 ? void 0 : _a.state) !==
            'closed'
          ) {
            // this operation is noop if mediastreamtrack is already being sent
            yield this.sender.replaceTrack(this.mediaStreamTrack);
          }
        } finally {
          unlock();
        }
      });
    }
    /**
     * Gets the RTCStatsReport for the LocalTrack's underlying RTCRtpSender
     * See https://developer.mozilla.org/en-US/docs/Web/API/RTCStatsReport
     *
     * @returns Promise<RTCStatsReport> | undefined
     */
    getRTCStatsReport() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        if (!((_a = this.sender) === null || _a === void 0 ? void 0 : _a.getStats)) {
          return;
        }
        const statsReport = yield this.sender.getStats();
        return statsReport;
      });
    }
    /**
     * Sets a processor on this track.
     * See https://github.com/livekit/track-processors-js for example usage
     *
     * @experimental
     *
     * @param processor
     * @param showProcessedStreamLocally
     * @returns
     */
    setProcessor(processor_1) {
      return __awaiter(this, arguments, void 0, function (processor) {
        var _this3 = this;
        let showProcessedStreamLocally =
          arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        return (function* () {
          var _a;
          const unlock = yield _this3.trackChangeLock.lock();
          try {
            _this3.log.debug('setting up processor', _this3.logContext);
            const processorElement = document.createElement(_this3.kind);
            const processorOptions = {
              kind: _this3.kind,
              track: _this3._mediaStreamTrack,
              element: processorElement,
              audioContext: _this3.audioContext,
            };
            yield processor.init(processorOptions);
            _this3.log.debug('processor initialized', _this3.logContext);
            if (_this3.processor) {
              yield _this3.internalStopProcessor();
            }
            if (_this3.kind === 'unknown') {
              throw TypeError('cannot set processor on track of unknown kind');
            }
            attachToElement(_this3._mediaStreamTrack, processorElement);
            processorElement.muted = true;
            processorElement.play().catch((error) => {
              if (error instanceof DOMException && error.name === 'AbortError') {
                // This happens on Safari when the processor is restarted, try again after a delay
                _this3.log.warn(
                  'failed to play processor element, retrying',
                  Object.assign(Object.assign({}, _this3.logContext), {
                    error,
                  })
                );
                setTimeout(() => {
                  processorElement.play().catch((err) => {
                    _this3.log.error(
                      'failed to play processor element',
                      Object.assign(Object.assign({}, _this3.logContext), {
                        err,
                      })
                    );
                  });
                }, 100);
              } else {
                _this3.log.error(
                  'failed to play processor element',
                  Object.assign(Object.assign({}, _this3.logContext), {
                    error,
                  })
                );
              }
            });
            _this3.processor = processor;
            _this3.processorElement = processorElement;
            if (_this3.processor.processedTrack) {
              for (const el of _this3.attachedElements) {
                if (el !== _this3.processorElement && showProcessedStreamLocally) {
                  detachTrack(_this3._mediaStreamTrack, el);
                  attachToElement(_this3.processor.processedTrack, el);
                }
              }
              yield (_a = _this3.sender) === null || _a === void 0
                ? void 0
                : _a.replaceTrack(_this3.processor.processedTrack);
            }
            _this3.emit(TrackEvent.TrackProcessorUpdate, _this3.processor);
          } finally {
            unlock();
          }
        })();
      });
    }
    getProcessor() {
      return this.processor;
    }
    /**
     * Stops the track processor
     * See https://github.com/livekit/track-processors-js for example usage
     *
     * @experimental
     * @returns
     */
    stopProcessor() {
      return __awaiter(this, arguments, void 0, function () {
        var _this4 = this;
        let keepElement = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        return (function* () {
          const unlock = yield _this4.trackChangeLock.lock();
          try {
            yield _this4.internalStopProcessor(keepElement);
          } finally {
            unlock();
          }
        })();
      });
    }
    /**
     * @internal
     * This method assumes the caller has acquired a trackChangeLock already.
     * The public facing method for stopping the processor is `stopProcessor` and it wraps this method in the trackChangeLock.
     */
    internalStopProcessor() {
      return __awaiter(this, arguments, void 0, function () {
        var _this5 = this;
        let keepElement = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        return (function* () {
          var _a, _b;
          if (!_this5.processor) return;
          _this5.log.debug('stopping processor', _this5.logContext);
          (_a = _this5.processor.processedTrack) === null || _a === void 0 ? void 0 : _a.stop();
          yield _this5.processor.destroy();
          _this5.processor = undefined;
          if (!keepElement) {
            (_b = _this5.processorElement) === null || _b === void 0 ? void 0 : _b.remove();
            _this5.processorElement = undefined;
          }
          // apply original track constraints in case the processor changed them
          yield _this5._mediaStreamTrack.applyConstraints(_this5._constraints);
          // force re-setting of the mediaStreamTrack on the sender
          yield _this5.setMediaStreamTrack(_this5._mediaStreamTrack, true);
          _this5.emit(TrackEvent.TrackProcessorUpdate);
        })();
      });
    }
    /** @internal */
    startPreConnectBuffer() {
      let timeslice = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;
      if (!isRecordingSupported()) {
        this.log.warn(
          'MediaRecorder is not available, cannot start preconnect buffer',
          this.logContext
        );
        return;
      }
      if (!this.localTrackRecorder) {
        let mimeType = 'audio/webm;codecs=opus';
        if (!MediaRecorder.isTypeSupported(mimeType)) {
          // iOS currently only supports video/mp4 as a mime type - even for audio.
          mimeType = 'video/mp4';
        }
        this.localTrackRecorder = new LocalTrackRecorder(this, {
          mimeType,
        });
      } else {
        this.log.warn('preconnect buffer already started');
        return;
      }
      this.localTrackRecorder.start(timeslice);
      this.autoStopPreConnectBuffer = setTimeout(() => {
        this.log.warn(
          'preconnect buffer timed out, stopping recording automatically',
          this.logContext
        );
        this.stopPreConnectBuffer();
      }, PRE_CONNECT_BUFFER_TIMEOUT);
    }
    /** @internal */
    stopPreConnectBuffer() {
      clearTimeout(this.autoStopPreConnectBuffer);
      if (this.localTrackRecorder) {
        this.localTrackRecorder.stop();
        this.localTrackRecorder = undefined;
      }
    }
    /** @internal */
    getPreConnectBuffer() {
      var _a;
      return (_a = this.localTrackRecorder) === null || _a === void 0 ? void 0 : _a.byteStream;
    }
    getPreConnectBufferMimeType() {
      var _a;
      return (_a = this.localTrackRecorder) === null || _a === void 0 ? void 0 : _a.mimeType;
    }
  }

  class LocalAudioTrack extends LocalTrack {
    /**
     * boolean indicating whether enhanced noise cancellation is currently being used on this track
     */
    get enhancedNoiseCancellation() {
      return this.isKrispNoiseFilterEnabled;
    }
    /**
     *
     * @param mediaTrack
     * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks
     * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK
     */
    constructor(mediaTrack, constraints) {
      let userProvidedTrack =
        arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      let audioContext = arguments.length > 3 ? arguments[3] : undefined;
      let loggerOptions = arguments.length > 4 ? arguments[4] : undefined;
      super(mediaTrack, Track.Kind.Audio, constraints, userProvidedTrack, loggerOptions);
      /** @internal */
      this.stopOnMute = false;
      this.isKrispNoiseFilterEnabled = false;
      this.monitorSender = () =>
        __awaiter(this, void 0, void 0, function* () {
          if (!this.sender) {
            this._currentBitrate = 0;
            return;
          }
          let stats;
          try {
            stats = yield this.getSenderStats();
          } catch (e) {
            this.log.error(
              'could not get audio sender stats',
              Object.assign(Object.assign({}, this.logContext), {
                error: e,
              })
            );
            return;
          }
          if (stats && this.prevStats) {
            this._currentBitrate = computeBitrate(stats, this.prevStats);
          }
          this.prevStats = stats;
        });
      this.handleKrispNoiseFilterEnable = () => {
        this.isKrispNoiseFilterEnabled = true;
        this.log.debug('Krisp noise filter enabled', this.logContext);
        this.emit(
          TrackEvent.AudioTrackFeatureUpdate,
          this,
          AudioTrackFeature.TF_ENHANCED_NOISE_CANCELLATION,
          true
        );
      };
      this.handleKrispNoiseFilterDisable = () => {
        this.isKrispNoiseFilterEnabled = false;
        this.log.debug('Krisp noise filter disabled', this.logContext);
        this.emit(
          TrackEvent.AudioTrackFeatureUpdate,
          this,
          AudioTrackFeature.TF_ENHANCED_NOISE_CANCELLATION,
          false
        );
      };
      this.audioContext = audioContext;
      this.checkForSilence();
    }
    mute() {
      const _super = Object.create(null, {
        mute: {
          get: () => super.mute,
        },
      });
      return __awaiter(this, void 0, void 0, function* () {
        const unlock = yield this.muteLock.lock();
        try {
          if (this.isMuted) {
            this.log.debug('Track already muted', this.logContext);
            return this;
          }
          // disabled special handling as it will cause BT headsets to switch communication modes
          if (this.source === Track.Source.Microphone && this.stopOnMute && !this.isUserProvided) {
            this.log.debug('stopping mic track', this.logContext);
            // also stop the track, so that microphone indicator is turned off
            this._mediaStreamTrack.stop();
          }
          yield _super.mute.call(this);
          return this;
        } finally {
          unlock();
        }
      });
    }
    unmute() {
      const _super = Object.create(null, {
        unmute: {
          get: () => super.unmute,
        },
      });
      return __awaiter(this, void 0, void 0, function* () {
        const unlock = yield this.muteLock.lock();
        try {
          if (!this.isMuted) {
            this.log.debug('Track already unmuted', this.logContext);
            return this;
          }
          const deviceHasChanged =
            this._constraints.deviceId &&
            this._mediaStreamTrack.getSettings().deviceId !==
              unwrapConstraint(this._constraints.deviceId);
          if (
            this.source === Track.Source.Microphone &&
            (this.stopOnMute ||
              this._mediaStreamTrack.readyState === 'ended' ||
              deviceHasChanged) &&
            !this.isUserProvided
          ) {
            this.log.debug('reacquiring mic track', this.logContext);
            yield this.restartTrack();
          }
          yield _super.unmute.call(this);
          return this;
        } finally {
          unlock();
        }
      });
    }
    restartTrack(options) {
      return __awaiter(this, void 0, void 0, function* () {
        let constraints;
        if (options) {
          const streamConstraints = constraintsForOptions({
            audio: options,
          });
          if (typeof streamConstraints.audio !== 'boolean') {
            constraints = streamConstraints.audio;
          }
        }
        yield this.restart(constraints);
      });
    }
    restart(constraints) {
      const _super = Object.create(null, {
        restart: {
          get: () => super.restart,
        },
      });
      return __awaiter(this, void 0, void 0, function* () {
        const track = yield _super.restart.call(this, constraints);
        this.checkForSilence();
        return track;
      });
    }
    /* @internal */
    startMonitor() {
      if (!isWeb()) {
        return;
      }
      if (this.monitorInterval) {
        return;
      }
      this.monitorInterval = setInterval(() => {
        this.monitorSender();
      }, monitorFrequency);
    }
    setProcessor(processor) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        const unlock = yield this.trackChangeLock.lock();
        try {
          if (!isReactNative() && !this.audioContext) {
            throw Error(
              'Audio context needs to be set on LocalAudioTrack in order to enable processors'
            );
          }
          if (this.processor) {
            yield this.internalStopProcessor();
          }
          const processorOptions = {
            kind: this.kind,
            track: this._mediaStreamTrack,
            // RN won't have or use AudioContext
            audioContext: this.audioContext,
          };
          this.log.debug('setting up audio processor '.concat(processor.name), this.logContext);
          yield processor.init(processorOptions);
          this.processor = processor;
          if (this.processor.processedTrack) {
            yield (_a = this.sender) === null || _a === void 0
              ? void 0
              : _a.replaceTrack(this.processor.processedTrack);
            this.processor.processedTrack.addEventListener(
              'enable-lk-krisp-noise-filter',
              this.handleKrispNoiseFilterEnable
            );
            this.processor.processedTrack.addEventListener(
              'disable-lk-krisp-noise-filter',
              this.handleKrispNoiseFilterDisable
            );
          }
          this.emit(TrackEvent.TrackProcessorUpdate, this.processor);
        } finally {
          unlock();
        }
      });
    }
    /**
     * @internal
     * @experimental
     */
    setAudioContext(audioContext) {
      this.audioContext = audioContext;
    }
    getSenderStats() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        if (!((_a = this.sender) === null || _a === void 0 ? void 0 : _a.getStats)) {
          return undefined;
        }
        const stats = yield this.sender.getStats();
        let audioStats;
        stats.forEach((v) => {
          if (v.type === 'outbound-rtp') {
            audioStats = {
              type: 'audio',
              streamId: v.id,
              packetsSent: v.packetsSent,
              packetsLost: v.packetsLost,
              bytesSent: v.bytesSent,
              timestamp: v.timestamp,
              roundTripTime: v.roundTripTime,
              jitter: v.jitter,
            };
          }
        });
        return audioStats;
      });
    }
    checkForSilence() {
      return __awaiter(this, void 0, void 0, function* () {
        const trackIsSilent = yield detectSilence(this);
        if (trackIsSilent) {
          if (!this.isMuted) {
            this.log.debug('silence detected on local audio track', this.logContext);
          }
          this.emit(TrackEvent.AudioSilenceDetected);
        }
        return trackIsSilent;
      });
    }
  }

  /** @internal */
  function mediaTrackToLocalTrack(mediaStreamTrack, constraints, loggerOptions) {
    switch (mediaStreamTrack.kind) {
      case 'audio':
        return new LocalAudioTrack(mediaStreamTrack, constraints, false, undefined, loggerOptions);
      case 'video':
        return new LocalVideoTrack(mediaStreamTrack, constraints, false, loggerOptions);
      default:
        throw new TrackInvalidError('unsupported track type: '.concat(mediaStreamTrack.kind));
    }
  }
  /* @internal */
  const presets169 = Object.values(VideoPresets);
  /* @internal */
  const presets43 = Object.values(VideoPresets43);
  /* @internal */
  const presetsScreenShare = Object.values(ScreenSharePresets);
  /* @internal */
  const defaultSimulcastPresets169 = [VideoPresets.h180, VideoPresets.h360];
  /* @internal */
  const defaultSimulcastPresets43 = [VideoPresets43.h180, VideoPresets43.h360];
  /* @internal */
  const computeDefaultScreenShareSimulcastPresets = (fromPreset) => {
    const layers = [
      {
        scaleResolutionDownBy: 2,
        fps: fromPreset.encoding.maxFramerate,
      },
    ];
    return layers.map((t) => {
      var _a, _b;
      return new VideoPreset(
        Math.floor(fromPreset.width / t.scaleResolutionDownBy),
        Math.floor(fromPreset.height / t.scaleResolutionDownBy),
        Math.max(
          150000,
          Math.floor(
            fromPreset.encoding.maxBitrate /
              (Math.pow(t.scaleResolutionDownBy, 2) *
                (((_a = fromPreset.encoding.maxFramerate) !== null && _a !== void 0 ? _a : 30) /
                  ((_b = t.fps) !== null && _b !== void 0 ? _b : 30)))
          )
        ),
        t.fps,
        fromPreset.encoding.priority
      );
    });
  };
  // /**
  //  *
  //  * @internal
  //  * @experimental
  //  */
  // const computeDefaultMultiCodecSimulcastEncodings = (width: number, height: number) => {
  //   // use vp8 as a default
  //   const vp8 = determineAppropriateEncoding(false, width, height);
  //   const vp9 = { ...vp8, maxBitrate: vp8.maxBitrate * 0.9 };
  //   const h264 = { ...vp8, maxBitrate: vp8.maxBitrate * 1.1 };
  //   const av1 = { ...vp8, maxBitrate: vp8.maxBitrate * 0.7 };
  //   return {
  //     vp8,
  //     vp9,
  //     h264,
  //     av1,
  //   };
  // };
  const videoRids = ['q', 'h', 'f'];
  /* @internal */
  function computeVideoEncodings(isScreenShare, width, height, options) {
    var _a, _b;
    let videoEncoding = options === null || options === void 0 ? void 0 : options.videoEncoding;
    if (isScreenShare) {
      videoEncoding = options === null || options === void 0 ? void 0 : options.screenShareEncoding;
    }
    const useSimulcast = options === null || options === void 0 ? void 0 : options.simulcast;
    const scalabilityMode =
      options === null || options === void 0 ? void 0 : options.scalabilityMode;
    const videoCodec = options === null || options === void 0 ? void 0 : options.videoCodec;
    if ((!videoEncoding && !useSimulcast && !scalabilityMode) || !width || !height) {
      // when we aren't simulcasting or svc, will need to return a single encoding without
      // capping bandwidth. we always require a encoding for dynacast
      return [{}];
    }
    if (!videoEncoding) {
      // find the right encoding based on width/height
      videoEncoding = determineAppropriateEncoding(isScreenShare, width, height, videoCodec);
      livekitLogger.debug('using video encoding', videoEncoding);
    }
    const sourceFramerate = videoEncoding.maxFramerate;
    const original = new VideoPreset(
      width,
      height,
      videoEncoding.maxBitrate,
      videoEncoding.maxFramerate,
      videoEncoding.priority
    );
    if (scalabilityMode && isSVCCodec(videoCodec)) {
      const sm = new ScalabilityMode(scalabilityMode);
      const encodings = [];
      if (sm.spatial > 3) {
        throw new Error('unsupported scalabilityMode: '.concat(scalabilityMode));
      }
      // Before M113 in Chrome, defining multiple encodings with an SVC codec indicated
      // that SVC mode should be used. Safari still works this way.
      // This is a bit confusing but is due to how libwebrtc interpreted the encodings field
      // before M113.
      // Announced here: https://groups.google.com/g/discuss-webrtc/c/-QQ3pxrl-fw?pli=1
      const browser = getBrowser();
      if (
        isSafariBased() ||
        // Even tho RN runs M114, it does not produce SVC layers when a single encoding
        // is provided. So we'll use the legacy SVC specification for now.
        // TODO: when we upstream libwebrtc, this will need additional verification
        isReactNative() ||
        ((browser === null || browser === void 0 ? void 0 : browser.name) === 'Chrome' &&
          compareVersions(
            browser === null || browser === void 0 ? void 0 : browser.version,
            '113'
          ) < 0)
      ) {
        const bitratesRatio = sm.suffix == 'h' ? 2 : 3;
        // safari 18.4 uses a different svc API that requires scaleResolutionDownBy to be set.
        const requireScale = isSafariSvcApi(browser);
        for (let i = 0; i < sm.spatial; i += 1) {
          // in legacy SVC, scaleResolutionDownBy cannot be set
          encodings.push({
            rid: videoRids[2 - i],
            maxBitrate: videoEncoding.maxBitrate / Math.pow(bitratesRatio, i),
            maxFramerate: original.encoding.maxFramerate,
            scaleResolutionDownBy: requireScale ? Math.pow(2, i) : undefined,
          });
        }
        // legacy SVC, scalabilityMode is set only on the first encoding
        /* @ts-ignore */
        encodings[0].scalabilityMode = scalabilityMode;
      } else {
        encodings.push({
          maxBitrate: videoEncoding.maxBitrate,
          maxFramerate: original.encoding.maxFramerate,
          /* @ts-ignore */
          scalabilityMode: scalabilityMode,
        });
      }
      if (original.encoding.priority) {
        encodings[0].priority = original.encoding.priority;
        encodings[0].networkPriority = original.encoding.priority;
      }
      livekitLogger.debug('using svc encoding', {
        encodings,
      });
      return encodings;
    }
    if (!useSimulcast) {
      return [videoEncoding];
    }
    let presets = [];
    if (isScreenShare) {
      presets =
        (_a = sortPresets(
          options === null || options === void 0 ? void 0 : options.screenShareSimulcastLayers
        )) !== null && _a !== void 0
          ? _a
          : defaultSimulcastLayers(isScreenShare, original);
    } else {
      presets =
        (_b = sortPresets(
          options === null || options === void 0 ? void 0 : options.videoSimulcastLayers
        )) !== null && _b !== void 0
          ? _b
          : defaultSimulcastLayers(isScreenShare, original);
    }
    let midPreset;
    if (presets.length > 0) {
      const lowPreset = presets[0];
      if (presets.length > 1) {
        [, midPreset] = presets;
      }
      // NOTE:
      //   1. Ordering of these encodings is important. Chrome seems
      //      to use the index into encodings to decide which layer
      //      to disable when CPU constrained.
      //      So encodings should be ordered in increasing spatial
      //      resolution order.
      //   2. livekit-server translates rids into layers. So, all encodings
      //      should have the base layer `q` and then more added
      //      based on other conditions.
      const size = Math.max(width, height);
      if (size >= 960 && midPreset) {
        return encodingsFromPresets(
          width,
          height,
          [lowPreset, midPreset, original],
          sourceFramerate
        );
      }
      if (size >= 480) {
        return encodingsFromPresets(width, height, [lowPreset, original], sourceFramerate);
      }
    }
    return encodingsFromPresets(width, height, [original]);
  }
  function computeTrackBackupEncodings(track, videoCodec, opts) {
    var _a, _b, _c, _d;
    // backupCodec should not be true anymore, default codec is set in LocalParticipant.publish
    if (
      !opts.backupCodec ||
      opts.backupCodec === true ||
      opts.backupCodec.codec === opts.videoCodec
    ) {
      // backup codec publishing is disabled
      return;
    }
    if (videoCodec !== opts.backupCodec.codec) {
      livekitLogger.warn('requested a different codec than specified as backup', {
        serverRequested: videoCodec,
        backup: opts.backupCodec.codec,
      });
    }
    opts.videoCodec = videoCodec;
    // use backup encoding setting as videoEncoding for backup codec publishing
    opts.videoEncoding = opts.backupCodec.encoding;
    const settings = track.mediaStreamTrack.getSettings();
    const width =
      (_a = settings.width) !== null && _a !== void 0
        ? _a
        : (_b = track.dimensions) === null || _b === void 0
          ? void 0
          : _b.width;
    const height =
      (_c = settings.height) !== null && _c !== void 0
        ? _c
        : (_d = track.dimensions) === null || _d === void 0
          ? void 0
          : _d.height;
    // disable simulcast for screenshare backup codec since L1Tx is used by primary codec
    if (track.source === Track.Source.ScreenShare && opts.simulcast) {
      opts.simulcast = false;
    }
    const encodings = computeVideoEncodings(
      track.source === Track.Source.ScreenShare,
      width,
      height,
      opts
    );
    return encodings;
  }
  /* @internal */
  function determineAppropriateEncoding(isScreenShare, width, height, codec) {
    const presets = presetsForResolution(isScreenShare, width, height);
    let { encoding } = presets[0];
    // handle portrait by swapping dimensions
    const size = Math.max(width, height);
    for (let i = 0; i < presets.length; i += 1) {
      const preset = presets[i];
      encoding = preset.encoding;
      if (preset.width >= size) {
        break;
      }
    }
    // presets are based on the assumption of vp8 as a codec
    // for other codecs we adjust the maxBitrate if no specific videoEncoding has been provided
    // users should override these with ones that are optimized for their use case
    // NOTE: SVC codec bitrates are inclusive of all scalability layers. while
    // bitrate for non-SVC codecs does not include other simulcast layers.
    if (codec) {
      switch (codec) {
        case 'av1':
        case 'h265':
          encoding = Object.assign({}, encoding);
          encoding.maxBitrate = encoding.maxBitrate * 0.7;
          break;
        case 'vp9':
          encoding = Object.assign({}, encoding);
          encoding.maxBitrate = encoding.maxBitrate * 0.85;
          break;
      }
    }
    return encoding;
  }
  /* @internal */
  function presetsForResolution(isScreenShare, width, height) {
    if (isScreenShare) {
      return presetsScreenShare;
    }
    const aspect = width > height ? width / height : height / width;
    if (Math.abs(aspect - 16.0 / 9) < Math.abs(aspect - 4.0 / 3)) {
      return presets169;
    }
    return presets43;
  }
  /* @internal */
  function defaultSimulcastLayers(isScreenShare, original) {
    if (isScreenShare) {
      return computeDefaultScreenShareSimulcastPresets(original);
    }
    const { width, height } = original;
    const aspect = width > height ? width / height : height / width;
    if (Math.abs(aspect - 16.0 / 9) < Math.abs(aspect - 4.0 / 3)) {
      return defaultSimulcastPresets169;
    }
    return defaultSimulcastPresets43;
  }
  // presets should be ordered by low, medium, high
  function encodingsFromPresets(width, height, presets, sourceFramerate) {
    const encodings = [];
    presets.forEach((preset, idx) => {
      if (idx >= videoRids.length) {
        return;
      }
      const size = Math.min(width, height);
      const rid = videoRids[idx];
      const encoding = {
        rid,
        scaleResolutionDownBy: Math.max(1, size / Math.min(preset.width, preset.height)),
        maxBitrate: preset.encoding.maxBitrate,
      };
      // ensure that the sourceFramerate is the highest framerate applied across all layers so that the
      // original encoding doesn't get bumped unintentionally by any of the other layers
      const maxFramerate =
        sourceFramerate && preset.encoding.maxFramerate
          ? Math.min(sourceFramerate, preset.encoding.maxFramerate)
          : preset.encoding.maxFramerate;
      if (maxFramerate) {
        encoding.maxFramerate = maxFramerate;
      }
      const canSetPriority = isFireFox() || idx === 0;
      if (preset.encoding.priority && canSetPriority) {
        encoding.priority = preset.encoding.priority;
        encoding.networkPriority = preset.encoding.priority;
      }
      encodings.push(encoding);
    });
    // RN ios simulcast requires all same framerates.
    if (isReactNative() && getReactNativeOs() === 'ios') {
      let topFramerate = undefined;
      encodings.forEach((encoding) => {
        if (!topFramerate) {
          topFramerate = encoding.maxFramerate;
        } else if (encoding.maxFramerate && encoding.maxFramerate > topFramerate) {
          topFramerate = encoding.maxFramerate;
        }
      });
      let notifyOnce = true;
      encodings.forEach((encoding) => {
        var _a;
        if (encoding.maxFramerate != topFramerate) {
          if (notifyOnce) {
            notifyOnce = false;
            livekitLogger.info(
              'Simulcast on iOS React-Native requires all encodings to share the same framerate.'
            );
          }
          livekitLogger.info(
            'Setting framerate of encoding "'
              .concat((_a = encoding.rid) !== null && _a !== void 0 ? _a : '', '" to ')
              .concat(topFramerate)
          );
          encoding.maxFramerate = topFramerate;
        }
      });
    }
    return encodings;
  }
  /** @internal */
  function sortPresets(presets) {
    if (!presets) return;
    return presets.sort((a, b) => {
      const { encoding: aEnc } = a;
      const { encoding: bEnc } = b;
      if (aEnc.maxBitrate > bEnc.maxBitrate) {
        return 1;
      }
      if (aEnc.maxBitrate < bEnc.maxBitrate) return -1;
      if (aEnc.maxBitrate === bEnc.maxBitrate && aEnc.maxFramerate && bEnc.maxFramerate) {
        return aEnc.maxFramerate > bEnc.maxFramerate ? 1 : -1;
      }
      return 0;
    });
  }
  /** @internal */
  class ScalabilityMode {
    constructor(scalabilityMode) {
      const results = scalabilityMode.match(/^L(\d)T(\d)(h|_KEY|_KEY_SHIFT){0,1}$/);
      if (!results) {
        throw new Error('invalid scalability mode');
      }
      this.spatial = parseInt(results[1]);
      this.temporal = parseInt(results[2]);
      if (results.length > 3) {
        switch (results[3]) {
          case 'h':
          case '_KEY':
          case '_KEY_SHIFT':
            this.suffix = results[3];
        }
      }
    }
    toString() {
      var _a;
      return 'L'
        .concat(this.spatial, 'T')
        .concat(this.temporal)
        .concat((_a = this.suffix) !== null && _a !== void 0 ? _a : '');
    }
  }
  function getDefaultDegradationPreference(track) {
    // a few of reasons we have different default paths:
    // 1. without this, Chrome seems to aggressively resize the SVC video stating `quality-limitation: bandwidth` even when BW isn't an issue
    // 2. since we are overriding contentHint to motion (to workaround L1T3 publishing), it overrides the default degradationPreference to `balanced`
    if (
      track.source === Track.Source.ScreenShare ||
      (track.constraints.height && unwrapConstraint(track.constraints.height) >= 1080)
    ) {
      return 'maintain-resolution';
    } else {
      return 'balanced';
    }
  }

  const refreshSubscribedCodecAfterNewCodec = 5000;
  class LocalVideoTrack extends LocalTrack {
    get sender() {
      return this._sender;
    }
    set sender(sender) {
      this._sender = sender;
      if (this.degradationPreference) {
        this.setDegradationPreference(this.degradationPreference);
      }
    }
    /**
     *
     * @param mediaTrack
     * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks
     * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK
     */
    constructor(mediaTrack, constraints) {
      let userProvidedTrack =
        arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      let loggerOptions = arguments.length > 3 ? arguments[3] : undefined;
      super(mediaTrack, Track.Kind.Video, constraints, userProvidedTrack, loggerOptions);
      /* @internal */
      this.simulcastCodecs = new Map();
      this.degradationPreference = 'balanced';
      this.isCpuConstrained = false;
      this.optimizeForPerformance = false;
      this.monitorSender = () =>
        __awaiter(this, void 0, void 0, function* () {
          if (!this.sender) {
            this._currentBitrate = 0;
            return;
          }
          let stats;
          try {
            stats = yield this.getSenderStats();
          } catch (e) {
            this.log.error(
              'could not get video sender stats',
              Object.assign(Object.assign({}, this.logContext), {
                error: e,
              })
            );
            return;
          }
          const statsMap = new Map(stats.map((s) => [s.rid, s]));
          const isCpuConstrained = stats.some((s) => s.qualityLimitationReason === 'cpu');
          if (isCpuConstrained !== this.isCpuConstrained) {
            this.isCpuConstrained = isCpuConstrained;
            if (this.isCpuConstrained) {
              this.emit(TrackEvent.CpuConstrained);
            }
          }
          if (this.prevStats) {
            let totalBitrate = 0;
            statsMap.forEach((s, key) => {
              var _a;
              const prev = (_a = this.prevStats) === null || _a === void 0 ? void 0 : _a.get(key);
              totalBitrate += computeBitrate(s, prev);
            });
            this._currentBitrate = totalBitrate;
          }
          this.prevStats = statsMap;
        });
      this.senderLock = new livekit_client_esm_();
    }
    get isSimulcast() {
      if (this.sender && this.sender.getParameters().encodings.length > 1) {
        return true;
      }
      return false;
    }
    /* @internal */
    startMonitor(signalClient) {
      var _a;
      this.signalClient = signalClient;
      if (!isWeb()) {
        return;
      }
      // save original encodings
      // TODO : merge simulcast tracks stats
      const params = (_a = this.sender) === null || _a === void 0 ? void 0 : _a.getParameters();
      if (params) {
        this.encodings = params.encodings;
      }
      if (this.monitorInterval) {
        return;
      }
      this.monitorInterval = setInterval(() => {
        this.monitorSender();
      }, monitorFrequency);
    }
    stop() {
      this._mediaStreamTrack.getConstraints();
      this.simulcastCodecs.forEach((trackInfo) => {
        trackInfo.mediaStreamTrack.stop();
      });
      super.stop();
    }
    pauseUpstream() {
      const _super = Object.create(null, {
        pauseUpstream: {
          get: () => super.pauseUpstream,
        },
      });
      return __awaiter(this, void 0, void 0, function* () {
        var _a, e_1, _b, _c;
        var _d;
        yield _super.pauseUpstream.call(this);
        try {
          for (
            var _e = true, _f = __asyncValues(this.simulcastCodecs.values()), _g;
            (_g = yield _f.next()), (_a = _g.done), !_a;
            _e = true
          ) {
            _c = _g.value;
            _e = false;
            const sc = _c;
            yield (_d = sc.sender) === null || _d === void 0 ? void 0 : _d.replaceTrack(null);
          }
        } catch (e_1_1) {
          e_1 = {
            error: e_1_1,
          };
        } finally {
          try {
            if (!_e && !_a && (_b = _f.return)) yield _b.call(_f);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
      });
    }
    resumeUpstream() {
      const _super = Object.create(null, {
        resumeUpstream: {
          get: () => super.resumeUpstream,
        },
      });
      return __awaiter(this, void 0, void 0, function* () {
        var _a, e_2, _b, _c;
        var _d;
        yield _super.resumeUpstream.call(this);
        try {
          for (
            var _e = true, _f = __asyncValues(this.simulcastCodecs.values()), _g;
            (_g = yield _f.next()), (_a = _g.done), !_a;
            _e = true
          ) {
            _c = _g.value;
            _e = false;
            const sc = _c;
            yield (_d = sc.sender) === null || _d === void 0
              ? void 0
              : _d.replaceTrack(sc.mediaStreamTrack);
          }
        } catch (e_2_1) {
          e_2 = {
            error: e_2_1,
          };
        } finally {
          try {
            if (!_e && !_a && (_b = _f.return)) yield _b.call(_f);
          } finally {
            if (e_2) throw e_2.error;
          }
        }
      });
    }
    mute() {
      const _super = Object.create(null, {
        mute: {
          get: () => super.mute,
        },
      });
      return __awaiter(this, void 0, void 0, function* () {
        const unlock = yield this.muteLock.lock();
        try {
          if (this.isMuted) {
            this.log.debug('Track already muted', this.logContext);
            return this;
          }
          if (this.source === Track.Source.Camera && !this.isUserProvided) {
            this.log.debug('stopping camera track', this.logContext);
            // also stop the track, so that camera indicator is turned off
            this._mediaStreamTrack.stop();
          }
          yield _super.mute.call(this);
          return this;
        } finally {
          unlock();
        }
      });
    }
    unmute() {
      const _super = Object.create(null, {
        unmute: {
          get: () => super.unmute,
        },
      });
      return __awaiter(this, void 0, void 0, function* () {
        const unlock = yield this.muteLock.lock();
        try {
          if (!this.isMuted) {
            this.log.debug('Track already unmuted', this.logContext);
            return this;
          }
          if (this.source === Track.Source.Camera && !this.isUserProvided) {
            this.log.debug('reacquiring camera track', this.logContext);
            yield this.restartTrack();
          }
          yield _super.unmute.call(this);
          return this;
        } finally {
          unlock();
        }
      });
    }
    setTrackMuted(muted) {
      super.setTrackMuted(muted);
      for (const sc of this.simulcastCodecs.values()) {
        sc.mediaStreamTrack.enabled = !muted;
      }
    }
    getSenderStats() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        if (!((_a = this.sender) === null || _a === void 0 ? void 0 : _a.getStats)) {
          return [];
        }
        const items = [];
        const stats = yield this.sender.getStats();
        stats.forEach((v) => {
          var _a;
          if (v.type === 'outbound-rtp') {
            const vs = {
              type: 'video',
              streamId: v.id,
              frameHeight: v.frameHeight,
              frameWidth: v.frameWidth,
              framesPerSecond: v.framesPerSecond,
              framesSent: v.framesSent,
              firCount: v.firCount,
              pliCount: v.pliCount,
              nackCount: v.nackCount,
              packetsSent: v.packetsSent,
              bytesSent: v.bytesSent,
              qualityLimitationReason: v.qualityLimitationReason,
              qualityLimitationDurations: v.qualityLimitationDurations,
              qualityLimitationResolutionChanges: v.qualityLimitationResolutionChanges,
              rid: (_a = v.rid) !== null && _a !== void 0 ? _a : v.id,
              retransmittedPacketsSent: v.retransmittedPacketsSent,
              targetBitrate: v.targetBitrate,
              timestamp: v.timestamp,
            };
            //locate the appropriate remote-inbound-rtp item
            const r = stats.get(v.remoteId);
            if (r) {
              vs.jitter = r.jitter;
              vs.packetsLost = r.packetsLost;
              vs.roundTripTime = r.roundTripTime;
            }
            items.push(vs);
          }
        });
        // make sure highest res layer is always first
        items.sort((a, b) => {
          var _a, _b;
          return (
            ((_a = b.frameWidth) !== null && _a !== void 0 ? _a : 0) -
            ((_b = a.frameWidth) !== null && _b !== void 0 ? _b : 0)
          );
        });
        return items;
      });
    }
    setPublishingQuality(maxQuality) {
      const qualities = [];
      for (let q = VideoQuality.LOW; q <= VideoQuality.HIGH; q += 1) {
        qualities.push(
          new SubscribedQuality({
            quality: q,
            enabled: q <= maxQuality,
          })
        );
      }
      this.log.debug(
        'setting publishing quality. max quality '.concat(maxQuality),
        this.logContext
      );
      this.setPublishingLayers(isSVCCodec(this.codec), qualities);
    }
    restartTrack(options) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, e_3, _b, _c;
        var _d;
        let constraints;
        if (options) {
          const streamConstraints = constraintsForOptions({
            video: options,
          });
          if (typeof streamConstraints.video !== 'boolean') {
            constraints = streamConstraints.video;
          }
        }
        yield this.restart(constraints);
        // reset cpu constrained state after track is restarted
        this.isCpuConstrained = false;
        try {
          for (
            var _e = true, _f = __asyncValues(this.simulcastCodecs.values()), _g;
            (_g = yield _f.next()), (_a = _g.done), !_a;
            _e = true
          ) {
            _c = _g.value;
            _e = false;
            const sc = _c;
            if (
              sc.sender &&
              ((_d = sc.sender.transport) === null || _d === void 0 ? void 0 : _d.state) !==
                'closed'
            ) {
              sc.mediaStreamTrack = this.mediaStreamTrack.clone();
              yield sc.sender.replaceTrack(sc.mediaStreamTrack);
            }
          }
        } catch (e_3_1) {
          e_3 = {
            error: e_3_1,
          };
        } finally {
          try {
            if (!_e && !_a && (_b = _f.return)) yield _b.call(_f);
          } finally {
            if (e_3) throw e_3.error;
          }
        }
      });
    }
    setProcessor(processor_1) {
      const _super = Object.create(null, {
        setProcessor: {
          get: () => super.setProcessor,
        },
      });
      return __awaiter(this, arguments, void 0, function (processor) {
        var _this = this;
        let showProcessedStreamLocally =
          arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        return (function* () {
          var _a, e_4, _b, _c;
          var _d, _e;
          yield _super.setProcessor.call(_this, processor, showProcessedStreamLocally);
          if ((_d = _this.processor) === null || _d === void 0 ? void 0 : _d.processedTrack) {
            try {
              for (
                var _f = true, _g = __asyncValues(_this.simulcastCodecs.values()), _h;
                (_h = yield _g.next()), (_a = _h.done), !_a;
                _f = true
              ) {
                _c = _h.value;
                _f = false;
                const sc = _c;
                yield (_e = sc.sender) === null || _e === void 0
                  ? void 0
                  : _e.replaceTrack(_this.processor.processedTrack);
              }
            } catch (e_4_1) {
              e_4 = {
                error: e_4_1,
              };
            } finally {
              try {
                if (!_f && !_a && (_b = _g.return)) yield _b.call(_g);
              } finally {
                if (e_4) throw e_4.error;
              }
            }
          }
        })();
      });
    }
    setDegradationPreference(preference) {
      return __awaiter(this, void 0, void 0, function* () {
        this.degradationPreference = preference;
        if (this.sender) {
          try {
            this.log.debug('setting degradationPreference to '.concat(preference), this.logContext);
            const params = this.sender.getParameters();
            params.degradationPreference = preference;
            this.sender.setParameters(params);
          } catch (e) {
            this.log.warn(
              'failed to set degradationPreference',
              Object.assign(
                {
                  error: e,
                },
                this.logContext
              )
            );
          }
        }
      });
    }
    addSimulcastTrack(codec, encodings) {
      if (this.simulcastCodecs.has(codec)) {
        this.log.error(
          ''.concat(codec, ' already added, skipping adding simulcast codec'),
          this.logContext
        );
        return;
      }
      const simulcastCodecInfo = {
        codec,
        mediaStreamTrack: this.mediaStreamTrack.clone(),
        sender: undefined,
        encodings,
      };
      this.simulcastCodecs.set(codec, simulcastCodecInfo);
      return simulcastCodecInfo;
    }
    setSimulcastTrackSender(codec, sender) {
      const simulcastCodecInfo = this.simulcastCodecs.get(codec);
      if (!simulcastCodecInfo) {
        return;
      }
      simulcastCodecInfo.sender = sender;
      // browser will reenable disabled codec/layers after new codec has been published,
      // so refresh subscribedCodecs after publish a new codec
      setTimeout(() => {
        if (this.subscribedCodecs) {
          this.setPublishingCodecs(this.subscribedCodecs);
        }
      }, refreshSubscribedCodecAfterNewCodec);
    }
    /**
     * @internal
     * Sets codecs that should be publishing, returns new codecs that have not yet
     * been published
     */
    setPublishingCodecs(codecs) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, codecs_1, codecs_1_1;
        var _b, e_5, _c, _d;
        this.log.debug(
          'setting publishing codecs',
          Object.assign(Object.assign({}, this.logContext), {
            codecs,
            currentCodec: this.codec,
          })
        );
        // only enable simulcast codec for preference codec setted
        if (!this.codec && codecs.length > 0) {
          yield this.setPublishingLayers(isSVCCodec(codecs[0].codec), codecs[0].qualities);
          return [];
        }
        this.subscribedCodecs = codecs;
        const newCodecs = [];
        try {
          for (
            _a = true, codecs_1 = __asyncValues(codecs);
            (codecs_1_1 = yield codecs_1.next()), (_b = codecs_1_1.done), !_b;
            _a = true
          ) {
            _d = codecs_1_1.value;
            _a = false;
            const codec = _d;
            if (!this.codec || this.codec === codec.codec) {
              yield this.setPublishingLayers(isSVCCodec(codec.codec), codec.qualities);
            } else {
              const simulcastCodecInfo = this.simulcastCodecs.get(codec.codec);
              this.log.debug(
                'try setPublishingCodec for '.concat(codec.codec),
                Object.assign(Object.assign({}, this.logContext), {
                  simulcastCodecInfo,
                })
              );
              if (!simulcastCodecInfo || !simulcastCodecInfo.sender) {
                for (const q of codec.qualities) {
                  if (q.enabled) {
                    newCodecs.push(codec.codec);
                    break;
                  }
                }
              } else if (simulcastCodecInfo.encodings) {
                this.log.debug(
                  'try setPublishingLayersForSender '.concat(codec.codec),
                  this.logContext
                );
                yield setPublishingLayersForSender(
                  simulcastCodecInfo.sender,
                  simulcastCodecInfo.encodings,
                  codec.qualities,
                  this.senderLock,
                  isSVCCodec(codec.codec),
                  this.log,
                  this.logContext
                );
              }
            }
          }
        } catch (e_5_1) {
          e_5 = {
            error: e_5_1,
          };
        } finally {
          try {
            if (!_a && !_b && (_c = codecs_1.return)) yield _c.call(codecs_1);
          } finally {
            if (e_5) throw e_5.error;
          }
        }
        return newCodecs;
      });
    }
    /**
     * @internal
     * Sets layers that should be publishing
     */
    setPublishingLayers(isSvc, qualities) {
      return __awaiter(this, void 0, void 0, function* () {
        if (this.optimizeForPerformance) {
          this.log.info(
            'skipping setPublishingLayers due to optimized publishing performance',
            Object.assign(Object.assign({}, this.logContext), {
              qualities,
            })
          );
          return;
        }
        this.log.debug(
          'setting publishing layers',
          Object.assign(Object.assign({}, this.logContext), {
            qualities,
          })
        );
        if (!this.sender || !this.encodings) {
          return;
        }
        yield setPublishingLayersForSender(
          this.sender,
          this.encodings,
          qualities,
          this.senderLock,
          isSvc,
          this.log,
          this.logContext
        );
      });
    }
    /**
     * Designed for lower powered devices, reduces video publishing quality and disables simulcast.
     * @experimental
     */
    prioritizePerformance() {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.sender) {
          throw new Error('sender not found');
        }
        const unlock = yield this.senderLock.lock();
        try {
          this.optimizeForPerformance = true;
          const params = this.sender.getParameters();
          params.encodings = params.encodings.map((e, idx) => {
            var _a;
            return Object.assign(Object.assign({}, e), {
              active: idx === 0,
              scaleResolutionDownBy: Math.max(
                1,
                Math.ceil(
                  ((_a = this.mediaStreamTrack.getSettings().height) !== null && _a !== void 0
                    ? _a
                    : 360) / 360
                )
              ),
              scalabilityMode: idx === 0 && isSVCCodec(this.codec) ? 'L1T3' : undefined,
              maxFramerate: idx === 0 ? 15 : 0,
              maxBitrate: idx === 0 ? e.maxBitrate : 0,
            });
          });
          this.log.debug(
            'setting performance optimised encodings',
            Object.assign(Object.assign({}, this.logContext), {
              encodings: params.encodings,
            })
          );
          this.encodings = params.encodings;
          yield this.sender.setParameters(params);
        } catch (e) {
          this.log.error(
            'failed to set performance optimised encodings',
            Object.assign(Object.assign({}, this.logContext), {
              error: e,
            })
          );
          this.optimizeForPerformance = false;
        } finally {
          unlock();
        }
      });
    }
    handleAppVisibilityChanged() {
      const _super = Object.create(null, {
        handleAppVisibilityChanged: {
          get: () => super.handleAppVisibilityChanged,
        },
      });
      return __awaiter(this, void 0, void 0, function* () {
        yield _super.handleAppVisibilityChanged.call(this);
        if (!isMobile()) return;
        if (this.isInBackground && this.source === Track.Source.Camera) {
          this._mediaStreamTrack.enabled = false;
        }
      });
    }
  }
  function setPublishingLayersForSender(
    sender,
    senderEncodings,
    qualities,
    senderLock,
    isSVC,
    log,
    logContext
  ) {
    return __awaiter(this, void 0, void 0, function* () {
      const unlock = yield senderLock.lock();
      log.debug(
        'setPublishingLayersForSender',
        Object.assign(Object.assign({}, logContext), {
          sender,
          qualities,
          senderEncodings,
        })
      );
      try {
        const params = sender.getParameters();
        const { encodings } = params;
        if (!encodings) {
          return;
        }
        if (encodings.length !== senderEncodings.length) {
          log.warn(
            'cannot set publishing layers, encodings mismatch',
            Object.assign(Object.assign({}, logContext), {
              encodings,
              senderEncodings,
            })
          );
          return;
        }
        let hasChanged = false;
        /* disable closable spatial layer as it has video blur / frozen issue with current server / client
      1. chrome 113: when switching to up layer with scalability Mode change, it will generate a
            low resolution frame and recover very quickly, but noticable
      2. livekit sfu: additional pli request cause video frozen for a few frames, also noticable */
        const closableSpatial = false;
        /* @ts-ignore */
        if (closableSpatial && encodings[0].scalabilityMode);
        else {
          if (isSVC) {
            const hasEnabledEncoding = qualities.some((q) => q.enabled);
            if (hasEnabledEncoding) {
              qualities.forEach((q) => (q.enabled = true));
            }
          }
          // simulcast dynacast encodings
          encodings.forEach((encoding, idx) => {
            var _a;
            let rid = (_a = encoding.rid) !== null && _a !== void 0 ? _a : '';
            if (rid === '') {
              rid = 'q';
            }
            const quality = videoQualityForRid(rid);
            const subscribedQuality = qualities.find((q) => q.quality === quality);
            if (!subscribedQuality) {
              return;
            }
            if (encoding.active !== subscribedQuality.enabled) {
              hasChanged = true;
              encoding.active = subscribedQuality.enabled;
              log.debug(
                'setting layer '
                  .concat(subscribedQuality.quality, ' to ')
                  .concat(encoding.active ? 'enabled' : 'disabled'),
                logContext
              );
              // FireFox does not support setting encoding.active to false, so we
              // have a workaround of lowering its bitrate and resolution to the min.
              if (isFireFox()) {
                if (subscribedQuality.enabled) {
                  encoding.scaleResolutionDownBy = senderEncodings[idx].scaleResolutionDownBy;
                  encoding.maxBitrate = senderEncodings[idx].maxBitrate;
                  /* @ts-ignore */
                  encoding.maxFrameRate = senderEncodings[idx].maxFrameRate;
                } else {
                  encoding.scaleResolutionDownBy = 4;
                  encoding.maxBitrate = 10;
                  /* @ts-ignore */
                  encoding.maxFrameRate = 2;
                }
              }
            }
          });
        }
        if (hasChanged) {
          params.encodings = encodings;
          log.debug(
            'setting encodings',
            Object.assign(Object.assign({}, logContext), {
              encodings: params.encodings,
            })
          );
          yield sender.setParameters(params);
        }
      } finally {
        unlock();
      }
    });
  }
  function videoQualityForRid(rid) {
    switch (rid) {
      case 'f':
        return VideoQuality.HIGH;
      case 'h':
        return VideoQuality.MEDIUM;
      case 'q':
        return VideoQuality.LOW;
      default:
        return VideoQuality.HIGH;
    }
  }
  function videoLayersFromEncodings(width, height, encodings, svc) {
    // default to a single layer, HQ
    if (!encodings) {
      return [
        new VideoLayer({
          quality: VideoQuality.HIGH,
          width,
          height,
          bitrate: 0,
          ssrc: 0,
        }),
      ];
    }
    if (svc) {
      // svc layers
      /* @ts-ignore */
      const encodingSM = encodings[0].scalabilityMode;
      const sm = new ScalabilityMode(encodingSM);
      const layers = [];
      const resRatio = sm.suffix == 'h' ? 1.5 : 2;
      const bitratesRatio = sm.suffix == 'h' ? 2 : 3;
      for (let i = 0; i < sm.spatial; i += 1) {
        layers.push(
          new VideoLayer({
            quality: Math.min(VideoQuality.HIGH, sm.spatial - 1) - i,
            width: Math.ceil(width / Math.pow(resRatio, i)),
            height: Math.ceil(height / Math.pow(resRatio, i)),
            bitrate: encodings[0].maxBitrate
              ? Math.ceil(encodings[0].maxBitrate / Math.pow(bitratesRatio, i))
              : 0,
            ssrc: 0,
          })
        );
      }
      return layers;
    }
    return encodings.map((encoding) => {
      var _a, _b, _c;
      const scale = (_a = encoding.scaleResolutionDownBy) !== null && _a !== void 0 ? _a : 1;
      let quality = videoQualityForRid((_b = encoding.rid) !== null && _b !== void 0 ? _b : '');
      return new VideoLayer({
        quality,
        width: Math.ceil(width / scale),
        height: Math.ceil(height / scale),
        bitrate: (_c = encoding.maxBitrate) !== null && _c !== void 0 ? _c : 0,
        ssrc: 0,
      });
    });
  }

  const lossyDataChannel = '_lossy';
  const reliableDataChannel = '_reliable';
  const minReconnectWait = 2 * 1000;
  const leaveReconnect = 'leave-reconnect';
  const reliabeReceiveStateTTL = 30000;
  var PCState;
  (function (PCState) {
    PCState[(PCState['New'] = 0)] = 'New';
    PCState[(PCState['Connected'] = 1)] = 'Connected';
    PCState[(PCState['Disconnected'] = 2)] = 'Disconnected';
    PCState[(PCState['Reconnecting'] = 3)] = 'Reconnecting';
    PCState[(PCState['Closed'] = 4)] = 'Closed';
  })(PCState || (PCState = {}));
  /** @internal */
  class RTCEngine extends eventsExports.EventEmitter {
    get isClosed() {
      return this._isClosed;
    }
    get pendingReconnect() {
      return !!this.reconnectTimeout;
    }
    constructor(options) {
      var _a;
      super();
      this.options = options;
      this.rtcConfig = {};
      this.peerConnectionTimeout = roomConnectOptionDefaults.peerConnectionTimeout;
      this.fullReconnectOnNext = false;
      /**
       * @internal
       */
      this.latestRemoteOfferId = 0;
      this.subscriberPrimary = false;
      this.pcState = PCState.New;
      this._isClosed = true;
      this.pendingTrackResolvers = {};
      this.reconnectAttempts = 0;
      this.reconnectStart = 0;
      this.attemptingReconnect = false;
      /** keeps track of how often an initial join connection has been tried */
      this.joinAttempts = 0;
      /** specifies how often an initial join connection is allowed to retry */
      this.maxJoinAttempts = 1;
      this.shouldFailNext = false;
      this.log = livekitLogger;
      this.reliableDataSequence = 1;
      this.reliableMessageBuffer = new DataPacketBuffer();
      this.reliableReceivedState = new TTLMap(reliabeReceiveStateTTL);
      this.handleDataChannel = (_a) =>
        __awaiter(this, [_a], void 0, function (_ref) {
          var _this = this;
          let { channel } = _ref;
          return (function* () {
            if (!channel) {
              return;
            }
            if (channel.label === reliableDataChannel) {
              _this.reliableDCSub = channel;
            } else if (channel.label === lossyDataChannel) {
              _this.lossyDCSub = channel;
            } else {
              return;
            }
            _this.log.debug(
              'on data channel '.concat(channel.id, ', ').concat(channel.label),
              _this.logContext
            );
            channel.onmessage = _this.handleDataMessage;
          })();
        });
      this.handleDataMessage = (message) =>
        __awaiter(this, void 0, void 0, function* () {
          var _a, _b, _c, _d, _e;
          // make sure to respect incoming data message order by processing message events one after the other
          const unlock = yield this.dataProcessLock.lock();
          try {
            // decode
            let buffer;
            if (message.data instanceof ArrayBuffer) {
              buffer = message.data;
            } else if (message.data instanceof Blob) {
              buffer = yield message.data.arrayBuffer();
            } else {
              this.log.error(
                'unsupported data type',
                Object.assign(Object.assign({}, this.logContext), {
                  data: message.data,
                })
              );
              return;
            }
            const dp = DataPacket.fromBinary(new Uint8Array(buffer));
            if (dp.sequence > 0 && dp.participantSid !== '') {
              const lastSeq = this.reliableReceivedState.get(dp.participantSid);
              if (lastSeq && dp.sequence <= lastSeq) {
                // ignore duplicate or out-of-order packets in reliable channel
                return;
              }
              this.reliableReceivedState.set(dp.participantSid, dp.sequence);
            }
            if (((_a = dp.value) === null || _a === void 0 ? void 0 : _a.case) === 'speaker') {
              // dispatch speaker updates
              this.emit(EngineEvent.ActiveSpeakersUpdate, dp.value.value.speakers);
            } else if (
              ((_b = dp.value) === null || _b === void 0 ? void 0 : _b.case) === 'encryptedPacket'
            ) {
              if (!this.e2eeManager) {
                this.log.error('Received encrypted packet but E2EE not set up', this.logContext);
                return;
              }
              const decryptedData = yield (_c = this.e2eeManager) === null || _c === void 0
                ? void 0
                : _c.handleEncryptedData(
                    dp.value.value.encryptedValue,
                    dp.value.value.iv,
                    dp.participantIdentity,
                    dp.value.value.keyIndex
                  );
              const decryptedPacket = EncryptedPacketPayload.fromBinary(decryptedData.payload);
              const newDp = new DataPacket({
                value: decryptedPacket.value,
              });
              if (((_d = newDp.value) === null || _d === void 0 ? void 0 : _d.case) === 'user') {
                // compatibility
                applyUserDataCompat(newDp, newDp.value.value);
              }
              this.emit(EngineEvent.DataPacketReceived, newDp, dp.value.value.encryptionType);
            } else {
              if (((_e = dp.value) === null || _e === void 0 ? void 0 : _e.case) === 'user') {
                // compatibility
                applyUserDataCompat(dp, dp.value.value);
              }
              this.emit(EngineEvent.DataPacketReceived, dp, Encryption_Type.NONE);
            }
          } finally {
            unlock();
          }
        });
      this.handleDataError = (event) => {
        const channel = event.currentTarget;
        const channelKind = channel.maxRetransmits === 0 ? 'lossy' : 'reliable';
        if (event instanceof ErrorEvent && event.error) {
          const { error } = event.error;
          this.log.error(
            'DataChannel error on '.concat(channelKind, ': ').concat(event.message),
            Object.assign(Object.assign({}, this.logContext), {
              error,
            })
          );
        } else {
          this.log.error(
            'Unknown DataChannel error on '.concat(channelKind),
            Object.assign(Object.assign({}, this.logContext), {
              event,
            })
          );
        }
      };
      this.handleBufferedAmountLow = (event) => {
        const channel = event.currentTarget;
        const channelKind =
          channel.maxRetransmits === 0 ? DataPacket_Kind.LOSSY : DataPacket_Kind.RELIABLE;
        this.updateAndEmitDCBufferStatus(channelKind);
      };
      // websocket reconnect behavior. if websocket is interrupted, and the PeerConnection
      // continues to work, we can reconnect to websocket to continue the session
      // after a number of retries, we'll close and give up permanently
      this.handleDisconnect = (connection, disconnectReason) => {
        if (this._isClosed) {
          return;
        }
        this.log.warn(''.concat(connection, ' disconnected'), this.logContext);
        if (this.reconnectAttempts === 0) {
          // only reset start time on the first try
          this.reconnectStart = Date.now();
        }
        const disconnect = (duration) => {
          this.log.warn(
            'could not recover connection after '
              .concat(this.reconnectAttempts, ' attempts, ')
              .concat(duration, 'ms. giving up'),
            this.logContext
          );
          this.emit(EngineEvent.Disconnected);
          this.close();
        };
        const duration = Date.now() - this.reconnectStart;
        let delay = this.getNextRetryDelay({
          elapsedMs: duration,
          retryCount: this.reconnectAttempts,
        });
        if (delay === null) {
          disconnect(duration);
          return;
        }
        if (connection === leaveReconnect) {
          delay = 0;
        }
        this.log.debug('reconnecting in '.concat(delay, 'ms'), this.logContext);
        this.clearReconnectTimeout();
        if (this.token && this.regionUrlProvider) {
          // token may have been refreshed, we do not want to recreate the regionUrlProvider
          // since the current engine may have inherited a regional url
          this.regionUrlProvider.updateToken(this.token);
        }
        this.reconnectTimeout = CriticalTimers.setTimeout(
          () =>
            this.attemptReconnect(disconnectReason).finally(
              () => (this.reconnectTimeout = undefined)
            ),
          delay
        );
      };
      this.waitForRestarted = () => {
        return new Promise((resolve, reject) => {
          if (this.pcState === PCState.Connected) {
            resolve();
          }
          const onRestarted = () => {
            this.off(EngineEvent.Disconnected, onDisconnected);
            resolve();
          };
          const onDisconnected = () => {
            this.off(EngineEvent.Restarted, onRestarted);
            reject();
          };
          this.once(EngineEvent.Restarted, onRestarted);
          this.once(EngineEvent.Disconnected, onDisconnected);
        });
      };
      this.updateAndEmitDCBufferStatus = (kind) => {
        const status = this.isBufferStatusLow(kind);
        if (typeof status !== 'undefined' && status !== this.dcBufferStatus.get(kind)) {
          this.dcBufferStatus.set(kind, status);
          this.emit(EngineEvent.DCBufferStatusChanged, status, kind);
        }
      };
      this.isBufferStatusLow = (kind) => {
        const dc = this.dataChannelForKind(kind);
        if (dc) {
          if (kind === DataPacket_Kind.RELIABLE) {
            this.reliableMessageBuffer.alignBufferedAmount(dc.bufferedAmount);
          }
          return dc.bufferedAmount <= dc.bufferedAmountLowThreshold;
        }
      };
      this.handleBrowserOnLine = () => {
        // in case the engine is currently reconnecting, attempt a reconnect immediately after the browser state has changed to 'onLine'
        if (this.client.currentState === SignalConnectionState.RECONNECTING) {
          this.clearReconnectTimeout();
          this.attemptReconnect(ReconnectReason.RR_SIGNAL_DISCONNECTED);
        }
      };
      this.log = getLogger(
        (_a = options.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Engine
      );
      this.loggerOptions = {
        loggerName: options.loggerName,
        loggerContextCb: () => this.logContext,
      };
      this.client = new SignalClient(undefined, this.loggerOptions);
      this.client.signalLatency = this.options.expSignalLatency;
      this.reconnectPolicy = this.options.reconnectPolicy;
      this.closingLock = new livekit_client_esm_();
      this.dataProcessLock = new livekit_client_esm_();
      this.dcBufferStatus = new Map([
        [DataPacket_Kind.LOSSY, true],
        [DataPacket_Kind.RELIABLE, true],
      ]);
      this.client.onParticipantUpdate = (updates) =>
        this.emit(EngineEvent.ParticipantUpdate, updates);
      this.client.onConnectionQuality = (update) =>
        this.emit(EngineEvent.ConnectionQualityUpdate, update);
      this.client.onRoomUpdate = (update) => this.emit(EngineEvent.RoomUpdate, update);
      this.client.onSubscriptionError = (resp) => this.emit(EngineEvent.SubscriptionError, resp);
      this.client.onSubscriptionPermissionUpdate = (update) =>
        this.emit(EngineEvent.SubscriptionPermissionUpdate, update);
      this.client.onSpeakersChanged = (update) => this.emit(EngineEvent.SpeakersChanged, update);
      this.client.onStreamStateUpdate = (update) =>
        this.emit(EngineEvent.StreamStateChanged, update);
      this.client.onRequestResponse = (response) =>
        this.emit(EngineEvent.SignalRequestResponse, response);
    }
    /** @internal */
    get logContext() {
      var _a, _b, _c, _d, _e, _f;
      return {
        room:
          (_b = (_a = this.latestJoinResponse) === null || _a === void 0 ? void 0 : _a.room) ===
            null || _b === void 0
            ? void 0
            : _b.name,
        roomID:
          (_d = (_c = this.latestJoinResponse) === null || _c === void 0 ? void 0 : _c.room) ===
            null || _d === void 0
            ? void 0
            : _d.sid,
        participant:
          (_f =
            (_e = this.latestJoinResponse) === null || _e === void 0 ? void 0 : _e.participant) ===
            null || _f === void 0
            ? void 0
            : _f.identity,
        pID: this.participantSid,
      };
    }
    join(url, token, opts, abortSignal) {
      return __awaiter(this, void 0, void 0, function* () {
        this.url = url;
        this.token = token;
        this.signalOpts = opts;
        this.maxJoinAttempts = opts.maxRetries;
        try {
          this.joinAttempts += 1;
          this.setupSignalClientCallbacks();
          const joinResponse = yield this.client.join(url, token, opts, abortSignal);
          this._isClosed = false;
          this.latestJoinResponse = joinResponse;
          this.subscriberPrimary = joinResponse.subscriberPrimary;
          if (!this.pcManager) {
            yield this.configure(joinResponse);
          }
          // create offer
          if (!this.subscriberPrimary || joinResponse.fastPublish) {
            this.negotiate().catch((err) => {
              livekitLogger.error(err, this.logContext);
            });
          }
          this.registerOnLineListener();
          this.clientConfiguration = joinResponse.clientConfiguration;
          this.emit(EngineEvent.SignalConnected, joinResponse);
          return joinResponse;
        } catch (e) {
          if (e instanceof ConnectionError) {
            if (e.reason === ConnectionErrorReason.ServerUnreachable) {
              this.log.warn(
                "Couldn't connect to server, attempt "
                  .concat(this.joinAttempts, ' of ')
                  .concat(this.maxJoinAttempts),
                this.logContext
              );
              if (this.joinAttempts < this.maxJoinAttempts) {
                return this.join(url, token, opts, abortSignal);
              }
            }
          }
          throw e;
        }
      });
    }
    close() {
      return __awaiter(this, void 0, void 0, function* () {
        const unlock = yield this.closingLock.lock();
        if (this.isClosed) {
          unlock();
          return;
        }
        try {
          this._isClosed = true;
          this.joinAttempts = 0;
          this.emit(EngineEvent.Closing);
          this.removeAllListeners();
          this.deregisterOnLineListener();
          this.clearPendingReconnect();
          yield this.cleanupPeerConnections();
          yield this.cleanupClient();
        } finally {
          unlock();
        }
      });
    }
    cleanupPeerConnections() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        yield (_a = this.pcManager) === null || _a === void 0 ? void 0 : _a.close();
        this.pcManager = undefined;
        const dcCleanup = (dc) => {
          if (!dc) return;
          dc.close();
          dc.onbufferedamountlow = null;
          dc.onclose = null;
          dc.onclosing = null;
          dc.onerror = null;
          dc.onmessage = null;
          dc.onopen = null;
        };
        dcCleanup(this.lossyDC);
        dcCleanup(this.lossyDCSub);
        dcCleanup(this.reliableDC);
        dcCleanup(this.reliableDCSub);
        this.lossyDC = undefined;
        this.lossyDCSub = undefined;
        this.reliableDC = undefined;
        this.reliableDCSub = undefined;
        this.reliableMessageBuffer = new DataPacketBuffer();
        this.reliableDataSequence = 1;
        this.reliableReceivedState.clear();
      });
    }
    cleanupClient() {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.client.close();
        this.client.resetCallbacks();
      });
    }
    addTrack(req) {
      if (this.pendingTrackResolvers[req.cid]) {
        throw new TrackInvalidError('a track with the same ID has already been published');
      }
      return new Promise((resolve, reject) => {
        const publicationTimeout = setTimeout(() => {
          delete this.pendingTrackResolvers[req.cid];
          reject(
            new ConnectionError(
              'publication of local track timed out, no response from server',
              ConnectionErrorReason.Timeout
            )
          );
        }, 10000);
        this.pendingTrackResolvers[req.cid] = {
          resolve: (info) => {
            clearTimeout(publicationTimeout);
            resolve(info);
          },
          reject: () => {
            clearTimeout(publicationTimeout);
            reject(new Error('Cancelled publication by calling unpublish'));
          },
        };
        this.client.sendAddTrack(req);
      });
    }
    /**
     * Removes sender from PeerConnection, returning true if it was removed successfully
     * and a negotiation is necessary
     * @param sender
     * @returns
     */
    removeTrack(sender) {
      if (sender.track && this.pendingTrackResolvers[sender.track.id]) {
        const { reject } = this.pendingTrackResolvers[sender.track.id];
        if (reject) {
          reject();
        }
        delete this.pendingTrackResolvers[sender.track.id];
      }
      try {
        this.pcManager.removeTrack(sender);
        return true;
      } catch (e) {
        this.log.warn(
          'failed to remove track',
          Object.assign(Object.assign({}, this.logContext), {
            error: e,
          })
        );
      }
      return false;
    }
    updateMuteStatus(trackSid, muted) {
      this.client.sendMuteTrack(trackSid, muted);
    }
    get dataSubscriberReadyState() {
      var _a;
      return (_a = this.reliableDCSub) === null || _a === void 0 ? void 0 : _a.readyState;
    }
    getConnectedServerAddress() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        return (_a = this.pcManager) === null || _a === void 0 ? void 0 : _a.getConnectedAddress();
      });
    }
    /* @internal */
    setRegionUrlProvider(provider) {
      this.regionUrlProvider = provider;
    }
    configure(joinResponse) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, _b;
        // already configured
        if (this.pcManager && this.pcManager.currentState !== PCTransportState.NEW) {
          return;
        }
        this.participantSid =
          (_a = joinResponse.participant) === null || _a === void 0 ? void 0 : _a.sid;
        const rtcConfig = this.makeRTCConfiguration(joinResponse);
        this.pcManager = new PCTransportManager(
          rtcConfig,
          joinResponse.subscriberPrimary,
          this.loggerOptions
        );
        this.emit(
          EngineEvent.TransportsCreated,
          this.pcManager.publisher,
          this.pcManager.subscriber
        );
        this.pcManager.onIceCandidate = (candidate, target) => {
          this.client.sendIceCandidate(candidate, target);
        };
        this.pcManager.onPublisherOffer = (offer, offerId) => {
          this.client.sendOffer(offer, offerId);
        };
        this.pcManager.onDataChannel = this.handleDataChannel;
        this.pcManager.onStateChange = (connectionState, publisherState, subscriberState) =>
          __awaiter(this, void 0, void 0, function* () {
            this.log.debug('primary PC state changed '.concat(connectionState), this.logContext);
            if (['closed', 'disconnected', 'failed'].includes(publisherState)) {
              // reset publisher connection promise
              this.publisherConnectionPromise = undefined;
            }
            if (connectionState === PCTransportState.CONNECTED) {
              const shouldEmit = this.pcState === PCState.New;
              this.pcState = PCState.Connected;
              if (shouldEmit) {
                this.emit(EngineEvent.Connected, joinResponse);
              }
            } else if (connectionState === PCTransportState.FAILED) {
              // on Safari, PeerConnection will switch to 'disconnected' during renegotiation
              if (this.pcState === PCState.Connected || this.pcState === PCState.Reconnecting) {
                this.pcState = PCState.Disconnected;
                this.handleDisconnect(
                  'peerconnection failed',
                  subscriberState === 'failed'
                    ? ReconnectReason.RR_SUBSCRIBER_FAILED
                    : ReconnectReason.RR_PUBLISHER_FAILED
                );
              }
            }
            // detect cases where both signal client and peer connection are severed and assume that user has lost network connection
            const isSignalSevered =
              this.client.isDisconnected ||
              this.client.currentState === SignalConnectionState.RECONNECTING;
            const isPCSevered = [
              PCTransportState.FAILED,
              PCTransportState.CLOSING,
              PCTransportState.CLOSED,
            ].includes(connectionState);
            if (isSignalSevered && isPCSevered && !this._isClosed) {
              this.emit(EngineEvent.Offline);
            }
          });
        this.pcManager.onTrack = (ev) => {
          this.emit(EngineEvent.MediaTrackAdded, ev.track, ev.streams[0], ev.receiver);
        };
        if (
          !supportOptionalDatachannel(
            (_b = joinResponse.serverInfo) === null || _b === void 0 ? void 0 : _b.protocol
          )
        ) {
          this.createDataChannels();
        }
      });
    }
    setupSignalClientCallbacks() {
      // configure signaling client
      this.client.onAnswer = (sd, offerId) =>
        __awaiter(this, void 0, void 0, function* () {
          if (!this.pcManager) {
            return;
          }
          this.log.debug(
            'received server answer',
            Object.assign(Object.assign({}, this.logContext), {
              RTCSdpType: sd.type,
            })
          );
          yield this.pcManager.setPublisherAnswer(sd, offerId);
        });
      // add candidate on trickle
      this.client.onTrickle = (candidate, target) => {
        if (!this.pcManager) {
          return;
        }
        this.log.debug(
          'got ICE candidate from peer',
          Object.assign(Object.assign({}, this.logContext), {
            candidate,
            target,
          })
        );
        this.pcManager.addIceCandidate(candidate, target);
      };
      // when server creates an offer for the client
      this.client.onOffer = (sd, offerId) =>
        __awaiter(this, void 0, void 0, function* () {
          this.latestRemoteOfferId = offerId;
          if (!this.pcManager) {
            return;
          }
          const answer = yield this.pcManager.createSubscriberAnswerFromOffer(sd, offerId);
          if (answer) {
            this.client.sendAnswer(answer, offerId);
          }
        });
      this.client.onLocalTrackPublished = (res) => {
        var _a;
        this.log.debug(
          'received trackPublishedResponse',
          Object.assign(Object.assign({}, this.logContext), {
            cid: res.cid,
            track: (_a = res.track) === null || _a === void 0 ? void 0 : _a.sid,
          })
        );
        if (!this.pendingTrackResolvers[res.cid]) {
          this.log.error(
            'missing track resolver for '.concat(res.cid),
            Object.assign(Object.assign({}, this.logContext), {
              cid: res.cid,
            })
          );
          return;
        }
        const { resolve } = this.pendingTrackResolvers[res.cid];
        delete this.pendingTrackResolvers[res.cid];
        resolve(res.track);
      };
      this.client.onLocalTrackUnpublished = (response) => {
        this.emit(EngineEvent.LocalTrackUnpublished, response);
      };
      this.client.onLocalTrackSubscribed = (trackSid) => {
        this.emit(EngineEvent.LocalTrackSubscribed, trackSid);
      };
      this.client.onTokenRefresh = (token) => {
        this.token = token;
      };
      this.client.onRemoteMuteChanged = (trackSid, muted) => {
        this.emit(EngineEvent.RemoteMute, trackSid, muted);
      };
      this.client.onSubscribedQualityUpdate = (update) => {
        this.emit(EngineEvent.SubscribedQualityUpdate, update);
      };
      this.client.onRoomMoved = (res) => {
        var _a;
        this.participantSid = (_a = res.participant) === null || _a === void 0 ? void 0 : _a.sid;
        if (this.latestJoinResponse) {
          this.latestJoinResponse.room = res.room;
        }
        this.emit(EngineEvent.RoomMoved, res);
      };
      this.client.onClose = () => {
        this.handleDisconnect('signal', ReconnectReason.RR_SIGNAL_DISCONNECTED);
      };
      this.client.onLeave = (leave) => {
        this.log.debug(
          'client leave request',
          Object.assign(Object.assign({}, this.logContext), {
            reason: leave === null || leave === void 0 ? void 0 : leave.reason,
          })
        );
        if (leave.regions && this.regionUrlProvider) {
          this.log.debug('updating regions', this.logContext);
          this.regionUrlProvider.setServerReportedRegions(leave.regions);
        }
        switch (leave.action) {
          case LeaveRequest_Action.DISCONNECT:
            this.emit(
              EngineEvent.Disconnected,
              leave === null || leave === void 0 ? void 0 : leave.reason
            );
            this.close();
            break;
          case LeaveRequest_Action.RECONNECT:
            this.fullReconnectOnNext = true;
            // reconnect immediately instead of waiting for next attempt
            this.handleDisconnect(leaveReconnect);
            break;
          case LeaveRequest_Action.RESUME:
            // reconnect immediately instead of waiting for next attempt
            this.handleDisconnect(leaveReconnect);
        }
      };
    }
    makeRTCConfiguration(serverResponse) {
      var _a;
      const rtcConfig = Object.assign({}, this.rtcConfig);
      if ((_a = this.signalOpts) === null || _a === void 0 ? void 0 : _a.e2eeEnabled) {
        this.log.debug('E2EE - setting up transports with insertable streams', this.logContext);
        //  this makes sure that no data is sent before the transforms are ready
        // @ts-ignore
        rtcConfig.encodedInsertableStreams = true;
      }
      // update ICE servers before creating PeerConnection
      if (serverResponse.iceServers && !rtcConfig.iceServers) {
        const rtcIceServers = [];
        serverResponse.iceServers.forEach((iceServer) => {
          const rtcIceServer = {
            urls: iceServer.urls,
          };
          if (iceServer.username) rtcIceServer.username = iceServer.username;
          if (iceServer.credential) {
            rtcIceServer.credential = iceServer.credential;
          }
          rtcIceServers.push(rtcIceServer);
        });
        rtcConfig.iceServers = rtcIceServers;
      }
      if (
        serverResponse.clientConfiguration &&
        serverResponse.clientConfiguration.forceRelay === ClientConfigSetting.ENABLED
      ) {
        rtcConfig.iceTransportPolicy = 'relay';
      }
      // @ts-ignore
      rtcConfig.sdpSemantics = 'unified-plan';
      // @ts-ignore
      rtcConfig.continualGatheringPolicy = 'gather_continually';
      return rtcConfig;
    }
    createDataChannels() {
      if (!this.pcManager) {
        return;
      }
      // clear old data channel callbacks if recreate
      if (this.lossyDC) {
        this.lossyDC.onmessage = null;
        this.lossyDC.onerror = null;
      }
      if (this.reliableDC) {
        this.reliableDC.onmessage = null;
        this.reliableDC.onerror = null;
      }
      // create data channels
      this.lossyDC = this.pcManager.createPublisherDataChannel(lossyDataChannel, {
        ordered: false,
        maxRetransmits: 0,
      });
      this.reliableDC = this.pcManager.createPublisherDataChannel(reliableDataChannel, {
        ordered: true,
      });
      // also handle messages over the pub channel, for backwards compatibility
      this.lossyDC.onmessage = this.handleDataMessage;
      this.reliableDC.onmessage = this.handleDataMessage;
      // handle datachannel errors
      this.lossyDC.onerror = this.handleDataError;
      this.reliableDC.onerror = this.handleDataError;
      // set up dc buffer threshold, set to 64kB (otherwise 0 by default)
      this.lossyDC.bufferedAmountLowThreshold = 65535;
      this.reliableDC.bufferedAmountLowThreshold = 65535;
      // handle buffer amount low events
      this.lossyDC.onbufferedamountlow = this.handleBufferedAmountLow;
      this.reliableDC.onbufferedamountlow = this.handleBufferedAmountLow;
    }
    createSender(track, opts, encodings) {
      return __awaiter(this, void 0, void 0, function* () {
        if (supportsTransceiver()) {
          const sender = yield this.createTransceiverRTCRtpSender(track, opts, encodings);
          return sender;
        }
        if (supportsAddTrack()) {
          this.log.warn('using add-track fallback', this.logContext);
          const sender = yield this.createRTCRtpSender(track.mediaStreamTrack);
          return sender;
        }
        throw new UnexpectedConnectionState('Required webRTC APIs not supported on this device');
      });
    }
    createSimulcastSender(track, simulcastTrack, opts, encodings) {
      return __awaiter(this, void 0, void 0, function* () {
        // store RTCRtpSender
        if (supportsTransceiver()) {
          return this.createSimulcastTransceiverSender(track, simulcastTrack, opts, encodings);
        }
        if (supportsAddTrack()) {
          this.log.debug('using add-track fallback', this.logContext);
          return this.createRTCRtpSender(track.mediaStreamTrack);
        }
        throw new UnexpectedConnectionState('Cannot stream on this device');
      });
    }
    createTransceiverRTCRtpSender(track, opts, encodings) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.pcManager) {
          throw new UnexpectedConnectionState('publisher is closed');
        }
        const streams = [];
        if (track.mediaStream) {
          streams.push(track.mediaStream);
        }
        if (isVideoTrack(track)) {
          track.codec = opts.videoCodec;
        }
        const transceiverInit = {
          direction: 'sendonly',
          streams,
        };
        if (encodings) {
          transceiverInit.sendEncodings = encodings;
        }
        // addTransceiver for react-native is async. web is synchronous, but await won't effect it.
        const transceiver = yield this.pcManager.addPublisherTransceiver(
          track.mediaStreamTrack,
          transceiverInit
        );
        return transceiver.sender;
      });
    }
    createSimulcastTransceiverSender(track, simulcastTrack, opts, encodings) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.pcManager) {
          throw new UnexpectedConnectionState('publisher is closed');
        }
        const transceiverInit = {
          direction: 'sendonly',
        };
        if (encodings) {
          transceiverInit.sendEncodings = encodings;
        }
        // addTransceiver for react-native is async. web is synchronous, but await won't effect it.
        const transceiver = yield this.pcManager.addPublisherTransceiver(
          simulcastTrack.mediaStreamTrack,
          transceiverInit
        );
        if (!opts.videoCodec) {
          return;
        }
        track.setSimulcastTrackSender(opts.videoCodec, transceiver.sender);
        return transceiver.sender;
      });
    }
    createRTCRtpSender(track) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.pcManager) {
          throw new UnexpectedConnectionState('publisher is closed');
        }
        return this.pcManager.addPublisherTrack(track);
      });
    }
    attemptReconnect(reason) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, _b, _c;
        if (this._isClosed) {
          return;
        }
        // guard for attempting reconnection multiple times while one attempt is still not finished
        if (this.attemptingReconnect) {
          livekitLogger.warn('already attempting reconnect, returning early', this.logContext);
          return;
        }
        if (
          ((_a = this.clientConfiguration) === null || _a === void 0
            ? void 0
            : _a.resumeConnection) === ClientConfigSetting.DISABLED ||
          // signaling state could change to closed due to hardware sleep
          // those connections cannot be resumed
          ((_c = (_b = this.pcManager) === null || _b === void 0 ? void 0 : _b.currentState) !==
            null && _c !== void 0
            ? _c
            : PCTransportState.NEW) === PCTransportState.NEW
        ) {
          this.fullReconnectOnNext = true;
        }
        try {
          this.attemptingReconnect = true;
          if (this.fullReconnectOnNext) {
            yield this.restartConnection();
          } else {
            yield this.resumeConnection(reason);
          }
          this.clearPendingReconnect();
          this.fullReconnectOnNext = false;
        } catch (e) {
          this.reconnectAttempts += 1;
          let recoverable = true;
          if (e instanceof UnexpectedConnectionState) {
            this.log.debug(
              'received unrecoverable error',
              Object.assign(Object.assign({}, this.logContext), {
                error: e,
              })
            );
            // unrecoverable
            recoverable = false;
          } else if (!(e instanceof SignalReconnectError)) {
            // cannot resume
            this.fullReconnectOnNext = true;
          }
          if (recoverable) {
            this.handleDisconnect('reconnect', ReconnectReason.RR_UNKNOWN);
          } else {
            this.log.info(
              'could not recover connection after '
                .concat(this.reconnectAttempts, ' attempts, ')
                .concat(Date.now() - this.reconnectStart, 'ms. giving up'),
              this.logContext
            );
            this.emit(EngineEvent.Disconnected);
            yield this.close();
          }
        } finally {
          this.attemptingReconnect = false;
        }
      });
    }
    getNextRetryDelay(context) {
      try {
        return this.reconnectPolicy.nextRetryDelayInMs(context);
      } catch (e) {
        this.log.warn(
          'encountered error in reconnect policy',
          Object.assign(Object.assign({}, this.logContext), {
            error: e,
          })
        );
      }
      // error in user code with provided reconnect policy, stop reconnecting
      return null;
    }
    restartConnection(regionUrl) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, _b, _c;
        try {
          if (!this.url || !this.token) {
            // permanent failure, don't attempt reconnection
            throw new UnexpectedConnectionState('could not reconnect, url or token not saved');
          }
          this.log.info('reconnecting, attempt: '.concat(this.reconnectAttempts), this.logContext);
          this.emit(EngineEvent.Restarting);
          if (!this.client.isDisconnected) {
            yield this.client.sendLeave();
          }
          yield this.cleanupPeerConnections();
          yield this.cleanupClient();
          let joinResponse;
          try {
            if (!this.signalOpts) {
              this.log.warn(
                'attempted connection restart, without signal options present',
                this.logContext
              );
              throw new SignalReconnectError();
            }
            // in case a regionUrl is passed, the region URL takes precedence
            joinResponse = yield this.join(
              regionUrl !== null && regionUrl !== void 0 ? regionUrl : this.url,
              this.token,
              this.signalOpts
            );
          } catch (e) {
            if (e instanceof ConnectionError && e.reason === ConnectionErrorReason.NotAllowed) {
              throw new UnexpectedConnectionState('could not reconnect, token might be expired');
            }
            throw new SignalReconnectError();
          }
          if (this.shouldFailNext) {
            this.shouldFailNext = false;
            throw new Error('simulated failure');
          }
          this.client.setReconnected();
          this.emit(EngineEvent.SignalRestarted, joinResponse);
          yield this.waitForPCReconnected();
          // re-check signal connection state before setting engine as resumed
          if (this.client.currentState !== SignalConnectionState.CONNECTED) {
            throw new SignalReconnectError('Signal connection got severed during reconnect');
          }
          (_a = this.regionUrlProvider) === null || _a === void 0 ? void 0 : _a.resetAttempts();
          // reconnect success
          this.emit(EngineEvent.Restarted);
        } catch (error) {
          const nextRegionUrl = yield (_b = this.regionUrlProvider) === null || _b === void 0
            ? void 0
            : _b.getNextBestRegionUrl();
          if (nextRegionUrl) {
            yield this.restartConnection(nextRegionUrl);
            return;
          } else {
            // no more regions to try (or we're not on cloud)
            (_c = this.regionUrlProvider) === null || _c === void 0 ? void 0 : _c.resetAttempts();
            throw error;
          }
        }
      });
    }
    resumeConnection(reason) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        if (!this.url || !this.token) {
          // permanent failure, don't attempt reconnection
          throw new UnexpectedConnectionState('could not reconnect, url or token not saved');
        }
        // trigger publisher reconnect
        if (!this.pcManager) {
          throw new UnexpectedConnectionState('publisher and subscriber connections unset');
        }
        this.log.info(
          'resuming signal connection, attempt '.concat(this.reconnectAttempts),
          this.logContext
        );
        this.emit(EngineEvent.Resuming);
        let res;
        try {
          this.setupSignalClientCallbacks();
          res = yield this.client.reconnect(this.url, this.token, this.participantSid, reason);
        } catch (error) {
          let message = '';
          if (error instanceof Error) {
            message = error.message;
            this.log.error(
              error.message,
              Object.assign(Object.assign({}, this.logContext), {
                error,
              })
            );
          }
          if (
            error instanceof ConnectionError &&
            error.reason === ConnectionErrorReason.NotAllowed
          ) {
            throw new UnexpectedConnectionState('could not reconnect, token might be expired');
          }
          if (
            error instanceof ConnectionError &&
            error.reason === ConnectionErrorReason.LeaveRequest
          ) {
            throw error;
          }
          throw new SignalReconnectError(message);
        }
        this.emit(EngineEvent.SignalResumed);
        if (res) {
          const rtcConfig = this.makeRTCConfiguration(res);
          this.pcManager.updateConfiguration(rtcConfig);
          if (this.latestJoinResponse) {
            this.latestJoinResponse.serverInfo = res.serverInfo;
          }
        } else {
          this.log.warn('Did not receive reconnect response', this.logContext);
        }
        if (this.shouldFailNext) {
          this.shouldFailNext = false;
          throw new Error('simulated failure');
        }
        yield this.pcManager.triggerIceRestart();
        yield this.waitForPCReconnected();
        // re-check signal connection state before setting engine as resumed
        if (this.client.currentState !== SignalConnectionState.CONNECTED) {
          throw new SignalReconnectError('Signal connection got severed during reconnect');
        }
        this.client.setReconnected();
        // recreate publish datachannel if it's id is null
        // (for safari https://bugs.webkit.org/show_bug.cgi?id=184688)
        if (
          ((_a = this.reliableDC) === null || _a === void 0 ? void 0 : _a.readyState) === 'open' &&
          this.reliableDC.id === null
        ) {
          this.createDataChannels();
        }
        if (res === null || res === void 0 ? void 0 : res.lastMessageSeq) {
          this.resendReliableMessagesForResume(res.lastMessageSeq);
        }
        // resume success
        this.emit(EngineEvent.Resumed);
      });
    }
    waitForPCInitialConnection(timeout, abortController) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.pcManager) {
          throw new UnexpectedConnectionState('PC manager is closed');
        }
        yield this.pcManager.ensurePCTransportConnection(abortController, timeout);
      });
    }
    waitForPCReconnected() {
      return __awaiter(this, void 0, void 0, function* () {
        this.pcState = PCState.Reconnecting;
        this.log.debug('waiting for peer connection to reconnect', this.logContext);
        try {
          yield sleep(minReconnectWait); // FIXME setTimeout again not ideal for a connection critical path
          if (!this.pcManager) {
            throw new UnexpectedConnectionState('PC manager is closed');
          }
          yield this.pcManager.ensurePCTransportConnection(undefined, this.peerConnectionTimeout);
          this.pcState = PCState.Connected;
        } catch (e) {
          // TODO do we need a `failed` state here for the PC?
          this.pcState = PCState.Disconnected;
          throw new ConnectionError(
            'could not establish PC connection, '.concat(e.message),
            ConnectionErrorReason.InternalError
          );
        }
      });
    }
    /** @internal */
    publishRpcResponse(destinationIdentity, requestId, payload, error) {
      return __awaiter(this, void 0, void 0, function* () {
        const packet = new DataPacket({
          destinationIdentities: [destinationIdentity],
          kind: DataPacket_Kind.RELIABLE,
          value: {
            case: 'rpcResponse',
            value: new RpcResponse({
              requestId,
              value: error
                ? {
                    case: 'error',
                    value: error.toProto(),
                  }
                : {
                    case: 'payload',
                    value: payload !== null && payload !== void 0 ? payload : '',
                  },
            }),
          },
        });
        yield this.sendDataPacket(packet, DataPacket_Kind.RELIABLE);
      });
    }
    /** @internal */
    publishRpcAck(destinationIdentity, requestId) {
      return __awaiter(this, void 0, void 0, function* () {
        const packet = new DataPacket({
          destinationIdentities: [destinationIdentity],
          kind: DataPacket_Kind.RELIABLE,
          value: {
            case: 'rpcAck',
            value: new RpcAck({
              requestId,
            }),
          },
        });
        yield this.sendDataPacket(packet, DataPacket_Kind.RELIABLE);
      });
    }
    /* @internal */
    sendDataPacket(packet, kind) {
      return __awaiter(this, void 0, void 0, function* () {
        // make sure we do have a data connection
        yield this.ensurePublisherConnected(kind);
        if (this.e2eeManager && this.e2eeManager.isDataChannelEncryptionEnabled) {
          const encryptablePacket = asEncryptablePacket(packet);
          if (encryptablePacket) {
            const encryptedData = yield this.e2eeManager.encryptData(encryptablePacket.toBinary());
            packet.value = {
              case: 'encryptedPacket',
              value: new EncryptedPacket({
                encryptedValue: encryptedData.payload,
                iv: encryptedData.iv,
                keyIndex: encryptedData.keyIndex,
              }),
            };
          }
        }
        if (kind === DataPacket_Kind.RELIABLE) {
          packet.sequence = this.reliableDataSequence;
          this.reliableDataSequence += 1;
        }
        const msg = packet.toBinary();
        const dc = this.dataChannelForKind(kind);
        if (dc) {
          if (kind === DataPacket_Kind.RELIABLE) {
            this.reliableMessageBuffer.push({
              data: msg,
              sequence: packet.sequence,
            });
          }
          if (this.attemptingReconnect) {
            return;
          }
          dc.send(msg);
        }
        this.updateAndEmitDCBufferStatus(kind);
      });
    }
    resendReliableMessagesForResume(lastMessageSeq) {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.ensurePublisherConnected(DataPacket_Kind.RELIABLE);
        const dc = this.dataChannelForKind(DataPacket_Kind.RELIABLE);
        if (dc) {
          this.reliableMessageBuffer.popToSequence(lastMessageSeq);
          this.reliableMessageBuffer.getAll().forEach((msg) => {
            dc.send(msg.data);
          });
        }
        this.updateAndEmitDCBufferStatus(DataPacket_Kind.RELIABLE);
      });
    }
    waitForBufferStatusLow(kind) {
      return new Promise((resolve, reject) =>
        __awaiter(this, void 0, void 0, function* () {
          if (this.isBufferStatusLow(kind)) {
            resolve();
          } else {
            const onClosing = () => reject('Engine closed');
            this.once(EngineEvent.Closing, onClosing);
            while (!this.dcBufferStatus.get(kind)) {
              yield sleep(10);
            }
            this.off(EngineEvent.Closing, onClosing);
            resolve();
          }
        })
      );
    }
    /**
     * @internal
     */
    ensureDataTransportConnected(kind_1) {
      return __awaiter(this, arguments, void 0, function (kind) {
        var _this2 = this;
        let subscriber =
          arguments.length > 1 && arguments[1] !== undefined
            ? arguments[1]
            : this.subscriberPrimary;
        return (function* () {
          var _a;
          if (!_this2.pcManager) {
            throw new UnexpectedConnectionState('PC manager is closed');
          }
          const transport = subscriber ? _this2.pcManager.subscriber : _this2.pcManager.publisher;
          const transportName = subscriber ? 'Subscriber' : 'Publisher';
          if (!transport) {
            throw new ConnectionError(
              ''.concat(transportName, ' connection not set'),
              ConnectionErrorReason.InternalError
            );
          }
          let needNegotiation = false;
          if (!subscriber && !_this2.dataChannelForKind(kind, subscriber)) {
            _this2.createDataChannels();
            needNegotiation = true;
          }
          if (
            !needNegotiation &&
            !subscriber &&
            !_this2.pcManager.publisher.isICEConnected &&
            _this2.pcManager.publisher.getICEConnectionState() !== 'checking'
          ) {
            needNegotiation = true;
          }
          if (needNegotiation) {
            // start negotiation
            _this2.negotiate().catch((err) => {
              livekitLogger.error(err, _this2.logContext);
            });
          }
          const targetChannel = _this2.dataChannelForKind(kind, subscriber);
          if (
            (targetChannel === null || targetChannel === void 0
              ? void 0
              : targetChannel.readyState) === 'open'
          ) {
            return;
          }
          // wait until ICE connected
          const endTime = new Date().getTime() + _this2.peerConnectionTimeout;
          while (new Date().getTime() < endTime) {
            if (
              transport.isICEConnected &&
              ((_a = _this2.dataChannelForKind(kind, subscriber)) === null || _a === void 0
                ? void 0
                : _a.readyState) === 'open'
            ) {
              return;
            }
            yield sleep(50);
          }
          throw new ConnectionError(
            'could not establish '
              .concat(transportName, ' connection, state: ')
              .concat(transport.getICEConnectionState()),
            ConnectionErrorReason.InternalError
          );
        })();
      });
    }
    ensurePublisherConnected(kind) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.publisherConnectionPromise) {
          this.publisherConnectionPromise = this.ensureDataTransportConnected(kind, false);
        }
        yield this.publisherConnectionPromise;
      });
    }
    /* @internal */
    verifyTransport() {
      if (!this.pcManager) {
        return false;
      }
      // primary connection
      if (this.pcManager.currentState !== PCTransportState.CONNECTED) {
        return false;
      }
      // ensure signal is connected
      if (!this.client.ws || this.client.ws.readyState === WebSocket.CLOSED) {
        return false;
      }
      return true;
    }
    /** @internal */
    negotiate() {
      return __awaiter(this, void 0, void 0, function* () {
        // observe signal state
        return new Promise((resolve, reject) =>
          __awaiter(this, void 0, void 0, function* () {
            if (!this.pcManager) {
              reject(new NegotiationError('PC manager is closed'));
              return;
            }
            this.pcManager.requirePublisher();
            // don't negotiate without any transceivers or data channel, it will generate sdp without ice frag then negotiate failed
            if (
              this.pcManager.publisher.getTransceivers().length == 0 &&
              !this.lossyDC &&
              !this.reliableDC
            ) {
              this.createDataChannels();
            }
            const abortController = new AbortController();
            const handleClosed = () => {
              abortController.abort();
              this.log.debug('engine disconnected while negotiation was ongoing', this.logContext);
              resolve();
              return;
            };
            if (this.isClosed) {
              reject('cannot negotiate on closed engine');
            }
            this.on(EngineEvent.Closing, handleClosed);
            this.pcManager.publisher.once(PCEvents.RTPVideoPayloadTypes, (rtpTypes) => {
              const rtpMap = new Map();
              rtpTypes.forEach((rtp) => {
                const codec = rtp.codec.toLowerCase();
                if (isVideoCodec(codec)) {
                  rtpMap.set(rtp.payload, codec);
                }
              });
              this.emit(EngineEvent.RTPVideoMapUpdate, rtpMap);
            });
            try {
              yield this.pcManager.negotiate(abortController);
              resolve();
            } catch (e) {
              if (e instanceof NegotiationError) {
                this.fullReconnectOnNext = true;
              }
              this.handleDisconnect('negotiation', ReconnectReason.RR_UNKNOWN);
              reject(e);
            } finally {
              this.off(EngineEvent.Closing, handleClosed);
            }
          })
        );
      });
    }
    dataChannelForKind(kind, sub) {
      if (!sub) {
        if (kind === DataPacket_Kind.LOSSY) {
          return this.lossyDC;
        }
        if (kind === DataPacket_Kind.RELIABLE) {
          return this.reliableDC;
        }
      } else {
        if (kind === DataPacket_Kind.LOSSY) {
          return this.lossyDCSub;
        }
        if (kind === DataPacket_Kind.RELIABLE) {
          return this.reliableDCSub;
        }
      }
    }
    /** @internal */
    sendSyncState(remoteTracks, localTracks) {
      var _a, _b;
      if (!this.pcManager) {
        this.log.warn('sync state cannot be sent without peer connection setup', this.logContext);
        return;
      }
      const previousAnswer = this.pcManager.subscriber.getLocalDescription();
      const previousOffer = this.pcManager.subscriber.getRemoteDescription();
      /* 1. autosubscribe on, so subscribed tracks = all tracks - unsub tracks,
          in this case, we send unsub tracks, so server add all tracks to this
          subscribe pc and unsub special tracks from it.
       2. autosubscribe off, we send subscribed tracks.
    */
      const autoSubscribe =
        (_b = (_a = this.signalOpts) === null || _a === void 0 ? void 0 : _a.autoSubscribe) !==
          null && _b !== void 0
          ? _b
          : true;
      const trackSids = new Array();
      const trackSidsDisabled = new Array();
      remoteTracks.forEach((track) => {
        if (track.isDesired !== autoSubscribe) {
          trackSids.push(track.trackSid);
        }
        if (!track.isEnabled) {
          trackSidsDisabled.push(track.trackSid);
        }
      });
      this.client.sendSyncState(
        new SyncState({
          answer: previousAnswer
            ? toProtoSessionDescription({
                sdp: previousAnswer.sdp,
                type: previousAnswer.type,
              })
            : undefined,
          offer: previousOffer
            ? toProtoSessionDescription({
                sdp: previousOffer.sdp,
                type: previousOffer.type,
              })
            : undefined,
          subscription: new UpdateSubscription({
            trackSids,
            subscribe: !autoSubscribe,
            participantTracks: [],
          }),
          publishTracks: getTrackPublicationInfo(localTracks),
          dataChannels: this.dataChannelsInfo(),
          trackSidsDisabled,
          datachannelReceiveStates: this.reliableReceivedState.map((seq, sid) => {
            return new DataChannelReceiveState({
              publisherSid: sid,
              lastSeq: seq,
            });
          }),
        })
      );
    }
    /* @internal */
    failNext() {
      // debugging method to fail the next reconnect/resume attempt
      this.shouldFailNext = true;
    }
    dataChannelsInfo() {
      const infos = [];
      const getInfo = (dc, target) => {
        if ((dc === null || dc === void 0 ? void 0 : dc.id) !== undefined && dc.id !== null) {
          infos.push(
            new DataChannelInfo({
              label: dc.label,
              id: dc.id,
              target,
            })
          );
        }
      };
      getInfo(this.dataChannelForKind(DataPacket_Kind.LOSSY), SignalTarget.PUBLISHER);
      getInfo(this.dataChannelForKind(DataPacket_Kind.RELIABLE), SignalTarget.PUBLISHER);
      getInfo(this.dataChannelForKind(DataPacket_Kind.LOSSY, true), SignalTarget.SUBSCRIBER);
      getInfo(this.dataChannelForKind(DataPacket_Kind.RELIABLE, true), SignalTarget.SUBSCRIBER);
      return infos;
    }
    clearReconnectTimeout() {
      if (this.reconnectTimeout) {
        CriticalTimers.clearTimeout(this.reconnectTimeout);
      }
    }
    clearPendingReconnect() {
      this.clearReconnectTimeout();
      this.reconnectAttempts = 0;
    }
    registerOnLineListener() {
      if (isWeb()) {
        window.addEventListener('online', this.handleBrowserOnLine);
      }
    }
    deregisterOnLineListener() {
      if (isWeb()) {
        window.removeEventListener('online', this.handleBrowserOnLine);
      }
    }
  }
  class SignalReconnectError extends Error {}
  function supportOptionalDatachannel(protocol) {
    return protocol !== undefined && protocol > 13;
  }
  function applyUserDataCompat(newObj, oldObj) {
    const participantIdentity = newObj.participantIdentity
      ? newObj.participantIdentity
      : oldObj.participantIdentity;
    newObj.participantIdentity = participantIdentity;
    oldObj.participantIdentity = participantIdentity;
    const destinationIdentities =
      newObj.destinationIdentities.length !== 0
        ? newObj.destinationIdentities
        : oldObj.destinationIdentities;
    newObj.destinationIdentities = destinationIdentities;
    oldObj.destinationIdentities = destinationIdentities;
  }

  class RegionUrlProvider {
    constructor(url, token) {
      this.lastUpdateAt = 0;
      this.settingsCacheTime = 3000;
      this.attemptedRegions = [];
      this.serverUrl = new URL(url);
      this.token = token;
    }
    updateToken(token) {
      this.token = token;
    }
    isCloud() {
      return isCloud(this.serverUrl);
    }
    getServerUrl() {
      return this.serverUrl;
    }
    getNextBestRegionUrl(abortSignal) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.isCloud()) {
          throw Error('region availability is only supported for LiveKit Cloud domains');
        }
        if (!this.regionSettings || Date.now() - this.lastUpdateAt > this.settingsCacheTime) {
          this.regionSettings = yield this.fetchRegionSettings(abortSignal);
        }
        const regionsLeft = this.regionSettings.regions.filter(
          (region) => !this.attemptedRegions.find((attempted) => attempted.url === region.url)
        );
        if (regionsLeft.length > 0) {
          const nextRegion = regionsLeft[0];
          this.attemptedRegions.push(nextRegion);
          livekitLogger.debug('next region: '.concat(nextRegion.region));
          return nextRegion.url;
        } else {
          return null;
        }
      });
    }
    resetAttempts() {
      this.attemptedRegions = [];
    }
    /* @internal */
    fetchRegionSettings(signal) {
      return __awaiter(this, void 0, void 0, function* () {
        const regionSettingsResponse = yield fetch(
          ''.concat(getCloudConfigUrl(this.serverUrl), '/regions'),
          {
            headers: {
              authorization: 'Bearer '.concat(this.token),
            },
            signal,
          }
        );
        if (regionSettingsResponse.ok) {
          const regionSettings = yield regionSettingsResponse.json();
          this.lastUpdateAt = Date.now();
          return regionSettings;
        } else {
          throw new ConnectionError(
            'Could not fetch region settings: '.concat(regionSettingsResponse.statusText),
            regionSettingsResponse.status === 401
              ? ConnectionErrorReason.NotAllowed
              : ConnectionErrorReason.InternalError,
            regionSettingsResponse.status
          );
        }
      });
    }
    setServerReportedRegions(regions) {
      this.regionSettings = regions;
      this.lastUpdateAt = Date.now();
    }
  }
  function getCloudConfigUrl(serverUrl) {
    return ''
      .concat(serverUrl.protocol.replace('ws', 'http'), '//')
      .concat(serverUrl.host, '/settings');
  }

  class BaseStreamReader {
    get info() {
      return this._info;
    }
    /** @internal */
    validateBytesReceived() {
      let doneReceiving = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      if (typeof this.totalByteSize !== 'number' || this.totalByteSize === 0) {
        return;
      }
      if (doneReceiving && this.bytesReceived < this.totalByteSize) {
        throw new DataStreamError(
          'Not enough chunk(s) received - expected '
            .concat(this.totalByteSize, ' bytes of data total, only received ')
            .concat(this.bytesReceived, ' bytes'),
          DataStreamErrorReason.Incomplete
        );
      } else if (this.bytesReceived > this.totalByteSize) {
        throw new DataStreamError(
          'Extra chunk(s) received - expected '
            .concat(this.totalByteSize, ' bytes of data total, received ')
            .concat(this.bytesReceived, ' bytes'),
          DataStreamErrorReason.LengthExceeded
        );
      }
    }
    constructor(info, stream, totalByteSize, outOfBandFailureRejectingFuture) {
      this.reader = stream;
      this.totalByteSize = totalByteSize;
      this._info = info;
      this.bytesReceived = 0;
      this.outOfBandFailureRejectingFuture = outOfBandFailureRejectingFuture;
    }
  }
  class ByteStreamReader extends BaseStreamReader {
    handleChunkReceived(chunk) {
      var _a;
      this.bytesReceived += chunk.content.byteLength;
      this.validateBytesReceived();
      const currentProgress = this.totalByteSize
        ? this.bytesReceived / this.totalByteSize
        : undefined;
      (_a = this.onProgress) === null || _a === void 0 ? void 0 : _a.call(this, currentProgress);
    }
    [Symbol.asyncIterator]() {
      const reader = this.reader.getReader();
      let rejectingSignalFuture = new Future();
      let activeSignal = null;
      let onAbort = null;
      if (this.signal) {
        const signal = this.signal;
        onAbort = () => {
          var _a;
          (_a = rejectingSignalFuture.reject) === null || _a === void 0
            ? void 0
            : _a.call(rejectingSignalFuture, signal.reason);
        };
        signal.addEventListener('abort', onAbort);
        activeSignal = signal;
      }
      const cleanup = () => {
        reader.releaseLock();
        if (activeSignal && onAbort) {
          activeSignal.removeEventListener('abort', onAbort);
        }
        this.signal = undefined;
      };
      return {
        next: () =>
          __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            try {
              const { done, value } = yield Promise.race([
                reader.read(),
                // Rejects if this.signal is aborted
                rejectingSignalFuture.promise,
                // Rejects if something external says it should, like a participant disconnecting, etc
                (_b =
                  (_a = this.outOfBandFailureRejectingFuture) === null || _a === void 0
                    ? void 0
                    : _a.promise) !== null && _b !== void 0
                  ? _b
                  : new Promise(() => {
                      /* never resolves */
                    }),
              ]);
              if (done) {
                this.validateBytesReceived(true);
                return {
                  done: true,
                  value: undefined,
                };
              } else {
                this.handleChunkReceived(value);
                return {
                  done: false,
                  value: value.content,
                };
              }
            } catch (err) {
              cleanup();
              throw err;
            }
          }),
        // note: `return` runs only for premature exits, see:
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#errors_during_iteration
        return() {
          return __awaiter(this, void 0, void 0, function* () {
            cleanup();
            return {
              done: true,
              value: undefined,
            };
          });
        },
      };
    }
    /**
     * Injects an AbortSignal, which if aborted, will terminate the currently active
     * stream iteration operation.
     *
     * Note that when using AbortSignal.timeout(...), the timeout applies across
     * the whole iteration operation, not just one individual chunk read.
     */
    withAbortSignal(signal) {
      this.signal = signal;
      return this;
    }
    readAll() {
      return __awaiter(this, arguments, void 0, function () {
        var _this = this;
        let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return (function* () {
          var _a, e_1, _b, _c;
          let chunks = new Set();
          const iterator = opts.signal ? _this.withAbortSignal(opts.signal) : _this;
          try {
            for (
              var _d = true, iterator_1 = __asyncValues(iterator), iterator_1_1;
              (iterator_1_1 = yield iterator_1.next()), (_a = iterator_1_1.done), !_a;
              _d = true
            ) {
              _c = iterator_1_1.value;
              _d = false;
              const chunk = _c;
              chunks.add(chunk);
            }
          } catch (e_1_1) {
            e_1 = {
              error: e_1_1,
            };
          } finally {
            try {
              if (!_d && !_a && (_b = iterator_1.return)) yield _b.call(iterator_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
          return Array.from(chunks);
        })();
      });
    }
  }
  /**
   * A class to read chunks from a ReadableStream and provide them in a structured format.
   */
  class TextStreamReader extends BaseStreamReader {
    /**
     * A TextStreamReader instance can be used as an AsyncIterator that returns the entire string
     * that has been received up to the current point in time.
     */
    constructor(info, stream, totalChunkCount, outOfBandFailureRejectingFuture) {
      super(info, stream, totalChunkCount, outOfBandFailureRejectingFuture);
      this.receivedChunks = new Map();
    }
    handleChunkReceived(chunk) {
      var _a;
      const index = bigIntToNumber(chunk.chunkIndex);
      const previousChunkAtIndex = this.receivedChunks.get(index);
      if (previousChunkAtIndex && previousChunkAtIndex.version > chunk.version) {
        // we have a newer version already, dropping the old one
        return;
      }
      this.receivedChunks.set(index, chunk);
      this.bytesReceived += chunk.content.byteLength;
      this.validateBytesReceived();
      const currentProgress = this.totalByteSize
        ? this.bytesReceived / this.totalByteSize
        : undefined;
      (_a = this.onProgress) === null || _a === void 0 ? void 0 : _a.call(this, currentProgress);
    }
    /**
     * Async iterator implementation to allow usage of `for await...of` syntax.
     * Yields structured chunks from the stream.
     *
     */
    [Symbol.asyncIterator]() {
      const reader = this.reader.getReader();
      const decoder = new TextDecoder('utf-8', {
        fatal: true,
      });
      let rejectingSignalFuture = new Future();
      let activeSignal = null;
      let onAbort = null;
      if (this.signal) {
        const signal = this.signal;
        onAbort = () => {
          var _a;
          (_a = rejectingSignalFuture.reject) === null || _a === void 0
            ? void 0
            : _a.call(rejectingSignalFuture, signal.reason);
        };
        signal.addEventListener('abort', onAbort);
        activeSignal = signal;
      }
      const cleanup = () => {
        reader.releaseLock();
        if (activeSignal && onAbort) {
          activeSignal.removeEventListener('abort', onAbort);
        }
        this.signal = undefined;
      };
      return {
        next: () =>
          __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            try {
              const { done, value } = yield Promise.race([
                reader.read(),
                // Rejects if this.signal is aborted
                rejectingSignalFuture.promise,
                // Rejects if something external says it should, like a participant disconnecting, etc
                (_b =
                  (_a = this.outOfBandFailureRejectingFuture) === null || _a === void 0
                    ? void 0
                    : _a.promise) !== null && _b !== void 0
                  ? _b
                  : new Promise(() => {
                      /* never resolves */
                    }),
              ]);
              if (done) {
                this.validateBytesReceived(true);
                return {
                  done: true,
                  value: undefined,
                };
              } else {
                this.handleChunkReceived(value);
                let decodedResult;
                try {
                  decodedResult = decoder.decode(value.content);
                } catch (err) {
                  throw new DataStreamError(
                    'Cannot decode datastream chunk '
                      .concat(value.chunkIndex, ' as text: ')
                      .concat(err),
                    DataStreamErrorReason.DecodeFailed
                  );
                }
                return {
                  done: false,
                  value: decodedResult,
                };
              }
            } catch (err) {
              cleanup();
              throw err;
            }
          }),
        // note: `return` runs only for premature exits, see:
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#errors_during_iteration
        return() {
          return __awaiter(this, void 0, void 0, function* () {
            cleanup();
            return {
              done: true,
              value: undefined,
            };
          });
        },
      };
    }
    /**
     * Injects an AbortSignal, which if aborted, will terminate the currently active
     * stream iteration operation.
     *
     * Note that when using AbortSignal.timeout(...), the timeout applies across
     * the whole iteration operation, not just one individual chunk read.
     */
    withAbortSignal(signal) {
      this.signal = signal;
      return this;
    }
    readAll() {
      return __awaiter(this, arguments, void 0, function () {
        var _this2 = this;
        let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return (function* () {
          var _a, e_2, _b, _c;
          let finalString = '';
          const iterator = opts.signal ? _this2.withAbortSignal(opts.signal) : _this2;
          try {
            for (
              var _d = true, iterator_2 = __asyncValues(iterator), iterator_2_1;
              (iterator_2_1 = yield iterator_2.next()), (_a = iterator_2_1.done), !_a;
              _d = true
            ) {
              _c = iterator_2_1.value;
              _d = false;
              const chunk = _c;
              finalString += chunk;
            }
          } catch (e_2_1) {
            e_2 = {
              error: e_2_1,
            };
          } finally {
            try {
              if (!_d && !_a && (_b = iterator_2.return)) yield _b.call(iterator_2);
            } finally {
              if (e_2) throw e_2.error;
            }
          }
          return finalString;
        })();
      });
    }
  }

  class IncomingDataStreamManager {
    constructor() {
      this.log = livekitLogger;
      this.byteStreamControllers = new Map();
      this.textStreamControllers = new Map();
      this.byteStreamHandlers = new Map();
      this.textStreamHandlers = new Map();
    }
    registerTextStreamHandler(topic, callback) {
      if (this.textStreamHandlers.has(topic)) {
        throw new DataStreamError(
          'A text stream handler for topic "'.concat(topic, '" has already been set.'),
          DataStreamErrorReason.HandlerAlreadyRegistered
        );
      }
      this.textStreamHandlers.set(topic, callback);
    }
    unregisterTextStreamHandler(topic) {
      this.textStreamHandlers.delete(topic);
    }
    registerByteStreamHandler(topic, callback) {
      if (this.byteStreamHandlers.has(topic)) {
        throw new DataStreamError(
          'A byte stream handler for topic "'.concat(topic, '" has already been set.'),
          DataStreamErrorReason.HandlerAlreadyRegistered
        );
      }
      this.byteStreamHandlers.set(topic, callback);
    }
    unregisterByteStreamHandler(topic) {
      this.byteStreamHandlers.delete(topic);
    }
    clearHandlersAndControllers() {
      this.byteStreamControllers.clear();
      this.textStreamControllers.clear();
      this.byteStreamHandlers.clear();
      this.textStreamHandlers.clear();
    }
    validateParticipantHasNoActiveDataStreams(participantIdentity) {
      var _a, _b, _c, _d;
      // Terminate any in flight data stream receives from the given participant
      const textStreamsBeingSentByDisconnectingParticipant = Array.from(
        this.textStreamControllers.entries()
      ).filter((entry) => entry[1].sendingParticipantIdentity === participantIdentity);
      const byteStreamsBeingSentByDisconnectingParticipant = Array.from(
        this.byteStreamControllers.entries()
      ).filter((entry) => entry[1].sendingParticipantIdentity === participantIdentity);
      if (
        textStreamsBeingSentByDisconnectingParticipant.length > 0 ||
        byteStreamsBeingSentByDisconnectingParticipant.length > 0
      ) {
        const abnormalEndError = new DataStreamError(
          'Participant '.concat(
            participantIdentity,
            ' unexpectedly disconnected in the middle of sending data'
          ),
          DataStreamErrorReason.AbnormalEnd
        );
        for (const [id, controller] of byteStreamsBeingSentByDisconnectingParticipant) {
          (_b = (_a = controller.outOfBandFailureRejectingFuture).reject) === null || _b === void 0
            ? void 0
            : _b.call(_a, abnormalEndError);
          this.byteStreamControllers.delete(id);
        }
        for (const [id, controller] of textStreamsBeingSentByDisconnectingParticipant) {
          (_d = (_c = controller.outOfBandFailureRejectingFuture).reject) === null || _d === void 0
            ? void 0
            : _d.call(_c, abnormalEndError);
          this.textStreamControllers.delete(id);
        }
      }
    }
    handleDataStreamPacket(packet, encryptionType) {
      return __awaiter(this, void 0, void 0, function* () {
        switch (packet.value.case) {
          case 'streamHeader':
            return this.handleStreamHeader(
              packet.value.value,
              packet.participantIdentity,
              encryptionType
            );
          case 'streamChunk':
            return this.handleStreamChunk(packet.value.value, encryptionType);
          case 'streamTrailer':
            return this.handleStreamTrailer(packet.value.value, encryptionType);
          default:
            throw new Error(
              'DataPacket of value "'.concat(packet.value.case, '" is not data stream related!')
            );
        }
      });
    }
    handleStreamHeader(streamHeader, participantIdentity, encryptionType) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        if (streamHeader.contentHeader.case === 'byteHeader') {
          const streamHandlerCallback = this.byteStreamHandlers.get(streamHeader.topic);
          if (!streamHandlerCallback) {
            this.log.debug(
              'ignoring incoming byte stream due to no handler for topic',
              streamHeader.topic
            );
            return;
          }
          let streamController;
          const outOfBandFailureRejectingFuture = new Future();
          outOfBandFailureRejectingFuture.promise.catch((err) => {
            this.log.error(err);
          });
          const info = {
            id: streamHeader.streamId,
            name:
              (_a = streamHeader.contentHeader.value.name) !== null && _a !== void 0
                ? _a
                : 'unknown',
            mimeType: streamHeader.mimeType,
            size: streamHeader.totalLength ? Number(streamHeader.totalLength) : undefined,
            topic: streamHeader.topic,
            timestamp: bigIntToNumber(streamHeader.timestamp),
            attributes: streamHeader.attributes,
            encryptionType,
          };
          const stream = new ReadableStream({
            start: (controller) => {
              streamController = controller;
              if (this.textStreamControllers.has(streamHeader.streamId)) {
                throw new DataStreamError(
                  'A data stream read is already in progress for a stream with id '.concat(
                    streamHeader.streamId,
                    '.'
                  ),
                  DataStreamErrorReason.AlreadyOpened
                );
              }
              this.byteStreamControllers.set(streamHeader.streamId, {
                info,
                controller: streamController,
                startTime: Date.now(),
                sendingParticipantIdentity: participantIdentity,
                outOfBandFailureRejectingFuture,
              });
            },
          });
          streamHandlerCallback(
            new ByteStreamReader(
              info,
              stream,
              bigIntToNumber(streamHeader.totalLength),
              outOfBandFailureRejectingFuture
            ),
            {
              identity: participantIdentity,
            }
          );
        } else if (streamHeader.contentHeader.case === 'textHeader') {
          const streamHandlerCallback = this.textStreamHandlers.get(streamHeader.topic);
          if (!streamHandlerCallback) {
            this.log.debug(
              'ignoring incoming text stream due to no handler for topic',
              streamHeader.topic
            );
            return;
          }
          let streamController;
          const outOfBandFailureRejectingFuture = new Future();
          outOfBandFailureRejectingFuture.promise.catch((err) => {
            this.log.error(err);
          });
          const info = {
            id: streamHeader.streamId,
            mimeType: streamHeader.mimeType,
            size: streamHeader.totalLength ? Number(streamHeader.totalLength) : undefined,
            topic: streamHeader.topic,
            timestamp: Number(streamHeader.timestamp),
            attributes: streamHeader.attributes,
            encryptionType,
          };
          const stream = new ReadableStream({
            start: (controller) => {
              streamController = controller;
              if (this.textStreamControllers.has(streamHeader.streamId)) {
                throw new DataStreamError(
                  'A data stream read is already in progress for a stream with id '.concat(
                    streamHeader.streamId,
                    '.'
                  ),
                  DataStreamErrorReason.AlreadyOpened
                );
              }
              this.textStreamControllers.set(streamHeader.streamId, {
                info,
                controller: streamController,
                startTime: Date.now(),
                sendingParticipantIdentity: participantIdentity,
                outOfBandFailureRejectingFuture,
              });
            },
          });
          streamHandlerCallback(
            new TextStreamReader(
              info,
              stream,
              bigIntToNumber(streamHeader.totalLength),
              outOfBandFailureRejectingFuture
            ),
            {
              identity: participantIdentity,
            }
          );
        }
      });
    }
    handleStreamChunk(chunk, encryptionType) {
      const fileBuffer = this.byteStreamControllers.get(chunk.streamId);
      if (fileBuffer) {
        if (fileBuffer.info.encryptionType !== encryptionType) {
          fileBuffer.controller.error(
            new DataStreamError(
              'Encryption type mismatch for stream '
                .concat(chunk.streamId, '. Expected ')
                .concat(encryptionType, ', got ')
                .concat(fileBuffer.info.encryptionType),
              DataStreamErrorReason.EncryptionTypeMismatch
            )
          );
          this.byteStreamControllers.delete(chunk.streamId);
        } else if (chunk.content.length > 0) {
          fileBuffer.controller.enqueue(chunk);
        }
      }
      const textBuffer = this.textStreamControllers.get(chunk.streamId);
      if (textBuffer) {
        if (textBuffer.info.encryptionType !== encryptionType) {
          textBuffer.controller.error(
            new DataStreamError(
              'Encryption type mismatch for stream '
                .concat(chunk.streamId, '. Expected ')
                .concat(encryptionType, ', got ')
                .concat(textBuffer.info.encryptionType),
              DataStreamErrorReason.EncryptionTypeMismatch
            )
          );
          this.textStreamControllers.delete(chunk.streamId);
        } else if (chunk.content.length > 0) {
          textBuffer.controller.enqueue(chunk);
        }
      }
    }
    handleStreamTrailer(trailer, encryptionType) {
      const textBuffer = this.textStreamControllers.get(trailer.streamId);
      if (textBuffer) {
        if (textBuffer.info.encryptionType !== encryptionType) {
          textBuffer.controller.error(
            new DataStreamError(
              'Encryption type mismatch for stream '
                .concat(trailer.streamId, '. Expected ')
                .concat(encryptionType, ', got ')
                .concat(textBuffer.info.encryptionType),
              DataStreamErrorReason.EncryptionTypeMismatch
            )
          );
        } else {
          textBuffer.info.attributes = Object.assign(
            Object.assign({}, textBuffer.info.attributes),
            trailer.attributes
          );
          textBuffer.controller.close();
          this.textStreamControllers.delete(trailer.streamId);
        }
      }
      const fileBuffer = this.byteStreamControllers.get(trailer.streamId);
      if (fileBuffer) {
        if (fileBuffer.info.encryptionType !== encryptionType) {
          fileBuffer.controller.error(
            new DataStreamError(
              'Encryption type mismatch for stream '
                .concat(trailer.streamId, '. Expected ')
                .concat(encryptionType, ', got ')
                .concat(fileBuffer.info.encryptionType),
              DataStreamErrorReason.EncryptionTypeMismatch
            )
          );
        } else {
          fileBuffer.info.attributes = Object.assign(
            Object.assign({}, fileBuffer.info.attributes),
            trailer.attributes
          );
          fileBuffer.controller.close();
        }
        this.byteStreamControllers.delete(trailer.streamId);
      }
    }
  }

  class BaseStreamWriter {
    constructor(writableStream, info, onClose) {
      this.writableStream = writableStream;
      this.defaultWriter = writableStream.getWriter();
      this.onClose = onClose;
      this.info = info;
    }
    write(chunk) {
      return this.defaultWriter.write(chunk);
    }
    close() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        yield this.defaultWriter.close();
        this.defaultWriter.releaseLock();
        (_a = this.onClose) === null || _a === void 0 ? void 0 : _a.call(this);
      });
    }
  }
  class TextStreamWriter extends BaseStreamWriter {}
  class ByteStreamWriter extends BaseStreamWriter {}

  const STREAM_CHUNK_SIZE = 15000;
  /**
   * Manages sending custom user data via data channels.
   * @internal
   */
  class OutgoingDataStreamManager {
    constructor(engine, log) {
      this.engine = engine;
      this.log = log;
    }
    setupEngine(engine) {
      this.engine = engine;
    }
    /** {@inheritDoc LocalParticipant.sendText} */
    sendText(text, options) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        const streamId = crypto.randomUUID();
        const textInBytes = new TextEncoder().encode(text);
        const totalTextLength = textInBytes.byteLength;
        const fileIds =
          (_a = options === null || options === void 0 ? void 0 : options.attachments) === null ||
          _a === void 0
            ? void 0
            : _a.map(() => crypto.randomUUID());
        const progresses = new Array(fileIds ? fileIds.length + 1 : 1).fill(0);
        const handleProgress = (progress, idx) => {
          var _a;
          progresses[idx] = progress;
          const totalProgress = progresses.reduce((acc, val) => acc + val, 0);
          (_a = options === null || options === void 0 ? void 0 : options.onProgress) === null ||
          _a === void 0
            ? void 0
            : _a.call(options, totalProgress);
        };
        const writer = yield this.streamText({
          streamId,
          totalSize: totalTextLength,
          destinationIdentities:
            options === null || options === void 0 ? void 0 : options.destinationIdentities,
          topic: options === null || options === void 0 ? void 0 : options.topic,
          attachedStreamIds: fileIds,
          attributes: options === null || options === void 0 ? void 0 : options.attributes,
        });
        yield writer.write(text);
        // set text part of progress to 1
        handleProgress(1, 0);
        yield writer.close();
        if ((options === null || options === void 0 ? void 0 : options.attachments) && fileIds) {
          yield Promise.all(
            options.attachments.map((file, idx) =>
              __awaiter(this, void 0, void 0, function* () {
                return this._sendFile(fileIds[idx], file, {
                  topic: options.topic,
                  mimeType: file.type,
                  onProgress: (progress) => {
                    handleProgress(progress, idx + 1);
                  },
                });
              })
            )
          );
        }
        return writer.info;
      });
    }
    /**
     * @internal
     * @experimental CAUTION, might get removed in a minor release
     */
    streamText(options) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, _b, _c;
        const streamId =
          (_a = options === null || options === void 0 ? void 0 : options.streamId) !== null &&
          _a !== void 0
            ? _a
            : crypto.randomUUID();
        const info = {
          id: streamId,
          mimeType: 'text/plain',
          timestamp: Date.now(),
          topic:
            (_b = options === null || options === void 0 ? void 0 : options.topic) !== null &&
            _b !== void 0
              ? _b
              : '',
          size: options === null || options === void 0 ? void 0 : options.totalSize,
          attributes: options === null || options === void 0 ? void 0 : options.attributes,
          encryptionType: (
            (_c = this.engine.e2eeManager) === null || _c === void 0
              ? void 0
              : _c.isDataChannelEncryptionEnabled
          )
            ? Encryption_Type.GCM
            : Encryption_Type.NONE,
        };
        const header = new DataStream_Header({
          streamId,
          mimeType: info.mimeType,
          topic: info.topic,
          timestamp: numberToBigInt(info.timestamp),
          totalLength: numberToBigInt(
            options === null || options === void 0 ? void 0 : options.totalSize
          ),
          attributes: info.attributes,
          contentHeader: {
            case: 'textHeader',
            value: new DataStream_TextHeader({
              version: options === null || options === void 0 ? void 0 : options.version,
              attachedStreamIds:
                options === null || options === void 0 ? void 0 : options.attachedStreamIds,
              replyToStreamId:
                options === null || options === void 0 ? void 0 : options.replyToStreamId,
              operationType:
                (options === null || options === void 0 ? void 0 : options.type) === 'update'
                  ? DataStream_OperationType.UPDATE
                  : DataStream_OperationType.CREATE,
            }),
          },
        });
        const destinationIdentities =
          options === null || options === void 0 ? void 0 : options.destinationIdentities;
        const packet = new DataPacket({
          destinationIdentities,
          value: {
            case: 'streamHeader',
            value: header,
          },
        });
        yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);
        let chunkId = 0;
        const engine = this.engine;
        const writableStream = new WritableStream({
          // Implement the sink
          write(text) {
            return __awaiter(this, void 0, void 0, function* () {
              for (const textByteChunk of splitUtf8(text, STREAM_CHUNK_SIZE)) {
                yield engine.waitForBufferStatusLow(DataPacket_Kind.RELIABLE);
                const chunk = new DataStream_Chunk({
                  content: textByteChunk,
                  streamId,
                  chunkIndex: numberToBigInt(chunkId),
                });
                const chunkPacket = new DataPacket({
                  destinationIdentities,
                  value: {
                    case: 'streamChunk',
                    value: chunk,
                  },
                });
                yield engine.sendDataPacket(chunkPacket, DataPacket_Kind.RELIABLE);
                chunkId += 1;
              }
            });
          },
          close() {
            return __awaiter(this, void 0, void 0, function* () {
              const trailer = new DataStream_Trailer({
                streamId,
              });
              const trailerPacket = new DataPacket({
                destinationIdentities,
                value: {
                  case: 'streamTrailer',
                  value: trailer,
                },
              });
              yield engine.sendDataPacket(trailerPacket, DataPacket_Kind.RELIABLE);
            });
          },
          abort(err) {
            console.log('Sink error:', err);
            // TODO handle aborts to signal something to receiver side
          },
        });
        let onEngineClose = () =>
          __awaiter(this, void 0, void 0, function* () {
            yield writer.close();
          });
        engine.once(EngineEvent.Closing, onEngineClose);
        const writer = new TextStreamWriter(writableStream, info, () =>
          this.engine.off(EngineEvent.Closing, onEngineClose)
        );
        return writer;
      });
    }
    sendFile(file, options) {
      return __awaiter(this, void 0, void 0, function* () {
        const streamId = crypto.randomUUID();
        yield this._sendFile(streamId, file, options);
        return {
          id: streamId,
        };
      });
    }
    _sendFile(streamId, file, options) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        const writer = yield this.streamBytes({
          streamId,
          totalSize: file.size,
          name: file.name,
          mimeType:
            (_a = options === null || options === void 0 ? void 0 : options.mimeType) !== null &&
            _a !== void 0
              ? _a
              : file.type,
          topic: options === null || options === void 0 ? void 0 : options.topic,
          destinationIdentities:
            options === null || options === void 0 ? void 0 : options.destinationIdentities,
        });
        const reader = file.stream().getReader();
        while (true) {
          const { done, value } = yield reader.read();
          if (done) {
            break;
          }
          yield writer.write(value);
        }
        yield writer.close();
        return writer.info;
      });
    }
    streamBytes(options) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f;
        const streamId =
          (_a = options === null || options === void 0 ? void 0 : options.streamId) !== null &&
          _a !== void 0
            ? _a
            : crypto.randomUUID();
        const destinationIdentities =
          options === null || options === void 0 ? void 0 : options.destinationIdentities;
        const info = {
          id: streamId,
          mimeType:
            (_b = options === null || options === void 0 ? void 0 : options.mimeType) !== null &&
            _b !== void 0
              ? _b
              : 'application/octet-stream',
          topic:
            (_c = options === null || options === void 0 ? void 0 : options.topic) !== null &&
            _c !== void 0
              ? _c
              : '',
          timestamp: Date.now(),
          attributes: options === null || options === void 0 ? void 0 : options.attributes,
          size: options === null || options === void 0 ? void 0 : options.totalSize,
          name:
            (_d = options === null || options === void 0 ? void 0 : options.name) !== null &&
            _d !== void 0
              ? _d
              : 'unknown',
          encryptionType: (
            (_e = this.engine.e2eeManager) === null || _e === void 0
              ? void 0
              : _e.isDataChannelEncryptionEnabled
          )
            ? Encryption_Type.GCM
            : Encryption_Type.NONE,
        };
        const header = new DataStream_Header({
          totalLength: numberToBigInt((_f = info.size) !== null && _f !== void 0 ? _f : 0),
          mimeType: info.mimeType,
          streamId,
          topic: info.topic,
          timestamp: numberToBigInt(Date.now()),
          attributes: info.attributes,
          contentHeader: {
            case: 'byteHeader',
            value: new DataStream_ByteHeader({
              name: info.name,
            }),
          },
        });
        const packet = new DataPacket({
          destinationIdentities,
          value: {
            case: 'streamHeader',
            value: header,
          },
        });
        yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);
        let chunkId = 0;
        const writeMutex = new livekit_client_esm_();
        const engine = this.engine;
        const logLocal = this.log;
        const writableStream = new WritableStream({
          write(chunk) {
            return __awaiter(this, void 0, void 0, function* () {
              const unlock = yield writeMutex.lock();
              let byteOffset = 0;
              try {
                while (byteOffset < chunk.byteLength) {
                  const subChunk = chunk.slice(byteOffset, byteOffset + STREAM_CHUNK_SIZE);
                  yield engine.waitForBufferStatusLow(DataPacket_Kind.RELIABLE);
                  const chunkPacket = new DataPacket({
                    destinationIdentities,
                    value: {
                      case: 'streamChunk',
                      value: new DataStream_Chunk({
                        content: subChunk,
                        streamId,
                        chunkIndex: numberToBigInt(chunkId),
                      }),
                    },
                  });
                  yield engine.sendDataPacket(chunkPacket, DataPacket_Kind.RELIABLE);
                  chunkId += 1;
                  byteOffset += subChunk.byteLength;
                }
              } finally {
                unlock();
              }
            });
          },
          close() {
            return __awaiter(this, void 0, void 0, function* () {
              const trailer = new DataStream_Trailer({
                streamId,
              });
              const trailerPacket = new DataPacket({
                destinationIdentities,
                value: {
                  case: 'streamTrailer',
                  value: trailer,
                },
              });
              yield engine.sendDataPacket(trailerPacket, DataPacket_Kind.RELIABLE);
            });
          },
          abort(err) {
            logLocal.error('Sink error:', err);
          },
        });
        const byteWriter = new ByteStreamWriter(writableStream, info);
        return byteWriter;
      });
    }
  }

  class RemoteTrack extends Track {
    constructor(mediaTrack, sid, kind, receiver, loggerOptions) {
      super(mediaTrack, kind, loggerOptions);
      this.sid = sid;
      this.receiver = receiver;
    }
    get isLocal() {
      return false;
    }
    /** @internal */
    setMuted(muted) {
      if (this.isMuted !== muted) {
        this.isMuted = muted;
        this._mediaStreamTrack.enabled = !muted;
        this.emit(muted ? TrackEvent.Muted : TrackEvent.Unmuted, this);
      }
    }
    /** @internal */
    setMediaStream(stream) {
      // this is needed to determine when the track is finished
      this.mediaStream = stream;
      const onRemoveTrack = (event) => {
        if (event.track === this._mediaStreamTrack) {
          stream.removeEventListener('removetrack', onRemoveTrack);
          if (this.receiver && 'playoutDelayHint' in this.receiver) {
            this.receiver.playoutDelayHint = undefined;
          }
          this.receiver = undefined;
          this._currentBitrate = 0;
          this.emit(TrackEvent.Ended, this);
        }
      };
      stream.addEventListener('removetrack', onRemoveTrack);
    }
    start() {
      this.startMonitor();
      // use `enabled` of track to enable re-use of transceiver
      super.enable();
    }
    stop() {
      this.stopMonitor();
      // use `enabled` of track to enable re-use of transceiver
      super.disable();
    }
    /**
     * Gets the RTCStatsReport for the RemoteTrack's underlying RTCRtpReceiver
     * See https://developer.mozilla.org/en-US/docs/Web/API/RTCStatsReport
     *
     * @returns Promise<RTCStatsReport> | undefined
     */
    getRTCStatsReport() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        if (!((_a = this.receiver) === null || _a === void 0 ? void 0 : _a.getStats)) {
          return;
        }
        const statsReport = yield this.receiver.getStats();
        return statsReport;
      });
    }
    /**
     * Allows to set a playout delay (in seconds) for this track.
     * A higher value allows for more buffering of the track in the browser
     * and will result in a delay of media being played back of `delayInSeconds`
     */
    setPlayoutDelay(delayInSeconds) {
      if (this.receiver) {
        if ('playoutDelayHint' in this.receiver) {
          this.receiver.playoutDelayHint = delayInSeconds;
        } else {
          this.log.warn('Playout delay not supported in this browser');
        }
      } else {
        this.log.warn('Cannot set playout delay, track already ended');
      }
    }
    /**
     * Returns the current playout delay (in seconds) of this track.
     */
    getPlayoutDelay() {
      if (this.receiver) {
        if ('playoutDelayHint' in this.receiver) {
          return this.receiver.playoutDelayHint;
        } else {
          this.log.warn('Playout delay not supported in this browser');
        }
      } else {
        this.log.warn('Cannot get playout delay, track already ended');
      }
      return 0;
    }
    /* @internal */
    startMonitor() {
      if (!this.monitorInterval) {
        this.monitorInterval = setInterval(() => this.monitorReceiver(), monitorFrequency);
      }
      if (supportsSynchronizationSources()) {
        this.registerTimeSyncUpdate();
      }
    }
    registerTimeSyncUpdate() {
      const loop = () => {
        var _a;
        this.timeSyncHandle = requestAnimationFrame(() => loop());
        const sources =
          (_a = this.receiver) === null || _a === void 0
            ? void 0
            : _a.getSynchronizationSources()[0];
        if (sources) {
          const { timestamp, rtpTimestamp } = sources;
          if (rtpTimestamp && this.rtpTimestamp !== rtpTimestamp) {
            this.emit(TrackEvent.TimeSyncUpdate, {
              timestamp,
              rtpTimestamp,
            });
            this.rtpTimestamp = rtpTimestamp;
          }
        }
      };
      loop();
    }
  }

  class RemoteAudioTrack extends RemoteTrack {
    constructor(mediaTrack, sid, receiver, audioContext, audioOutput, loggerOptions) {
      super(mediaTrack, sid, Track.Kind.Audio, receiver, loggerOptions);
      this.monitorReceiver = () =>
        __awaiter(this, void 0, void 0, function* () {
          if (!this.receiver) {
            this._currentBitrate = 0;
            return;
          }
          const stats = yield this.getReceiverStats();
          if (stats && this.prevStats && this.receiver) {
            this._currentBitrate = computeBitrate(stats, this.prevStats);
          }
          this.prevStats = stats;
        });
      this.audioContext = audioContext;
      this.webAudioPluginNodes = [];
      if (audioOutput) {
        this.sinkId = audioOutput.deviceId;
      }
    }
    /**
     * sets the volume for all attached audio elements
     */
    setVolume(volume) {
      var _a;
      for (const el of this.attachedElements) {
        if (this.audioContext) {
          (_a = this.gainNode) === null || _a === void 0
            ? void 0
            : _a.gain.setTargetAtTime(volume, 0, 0.1);
        } else {
          el.volume = volume;
        }
      }
      if (isReactNative()) {
        // @ts-ignore
        this._mediaStreamTrack._setVolume(volume);
      }
      this.elementVolume = volume;
    }
    /**
     * gets the volume of attached audio elements (loudest)
     */
    getVolume() {
      if (this.elementVolume) {
        return this.elementVolume;
      }
      if (isReactNative()) {
        // RN volume value defaults to 1.0 if hasn't been changed.
        return 1.0;
      }
      let highestVolume = 0;
      this.attachedElements.forEach((element) => {
        if (element.volume > highestVolume) {
          highestVolume = element.volume;
        }
      });
      return highestVolume;
    }
    /**
     * calls setSinkId on all attached elements, if supported
     * @param deviceId audio output device
     */
    setSinkId(deviceId) {
      return __awaiter(this, void 0, void 0, function* () {
        this.sinkId = deviceId;
        yield Promise.all(
          this.attachedElements.map((elm) => {
            if (!supportsSetSinkId(elm)) {
              return;
            }
            /* @ts-ignore */
            return elm.setSinkId(deviceId);
          })
        );
      });
    }
    attach(element) {
      const needsNewWebAudioConnection = this.attachedElements.length === 0;
      if (!element) {
        element = super.attach();
      } else {
        super.attach(element);
      }
      if (this.sinkId && supportsSetSinkId(element)) {
        element.setSinkId(this.sinkId).catch((e) => {
          this.log.error('Failed to set sink id on remote audio track', e, this.logContext);
        });
      }
      if (this.audioContext && needsNewWebAudioConnection) {
        this.log.debug('using audio context mapping', this.logContext);
        this.connectWebAudio(this.audioContext, element);
        element.volume = 0;
        element.muted = true;
      }
      if (this.elementVolume) {
        // make sure volume setting is being applied to the newly attached element
        this.setVolume(this.elementVolume);
      }
      return element;
    }
    detach(element) {
      let detached;
      if (!element) {
        detached = super.detach();
        this.disconnectWebAudio();
      } else {
        detached = super.detach(element);
        // if there are still any attached elements after detaching, connect webaudio to the first element that's left
        // disconnect webaudio otherwise
        if (this.audioContext) {
          if (this.attachedElements.length > 0) {
            this.connectWebAudio(this.audioContext, this.attachedElements[0]);
          } else {
            this.disconnectWebAudio();
          }
        }
      }
      return detached;
    }
    /**
     * @internal
     * @experimental
     */
    setAudioContext(audioContext) {
      this.audioContext = audioContext;
      if (audioContext && this.attachedElements.length > 0) {
        this.connectWebAudio(audioContext, this.attachedElements[0]);
      } else if (!audioContext) {
        this.disconnectWebAudio();
      }
    }
    /**
     * @internal
     * @experimental
     * @param {AudioNode[]} nodes - An array of WebAudio nodes. These nodes should not be connected to each other when passed, as the sdk will take care of connecting them in the order of the array.
     */
    setWebAudioPlugins(nodes) {
      this.webAudioPluginNodes = nodes;
      if (this.attachedElements.length > 0 && this.audioContext) {
        this.connectWebAudio(this.audioContext, this.attachedElements[0]);
      }
    }
    connectWebAudio(context, element) {
      this.disconnectWebAudio();
      // @ts-ignore attached elements always have a srcObject set
      this.sourceNode = context.createMediaStreamSource(element.srcObject);
      let lastNode = this.sourceNode;
      this.webAudioPluginNodes.forEach((node) => {
        lastNode.connect(node);
        lastNode = node;
      });
      this.gainNode = context.createGain();
      lastNode.connect(this.gainNode);
      this.gainNode.connect(context.destination);
      if (this.elementVolume) {
        this.gainNode.gain.setTargetAtTime(this.elementVolume, 0, 0.1);
      }
      // try to resume the context if it isn't running already
      if (context.state !== 'running') {
        context
          .resume()
          .then(() => {
            if (context.state !== 'running') {
              this.emit(
                TrackEvent.AudioPlaybackFailed,
                new Error("Audio Context couldn't be started automatically")
              );
            }
          })
          .catch((e) => {
            this.emit(TrackEvent.AudioPlaybackFailed, e);
          });
      }
    }
    disconnectWebAudio() {
      var _a, _b;
      (_a = this.gainNode) === null || _a === void 0 ? void 0 : _a.disconnect();
      (_b = this.sourceNode) === null || _b === void 0 ? void 0 : _b.disconnect();
      this.gainNode = undefined;
      this.sourceNode = undefined;
    }
    getReceiverStats() {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.receiver || !this.receiver.getStats) {
          return;
        }
        const stats = yield this.receiver.getStats();
        let receiverStats;
        stats.forEach((v) => {
          if (v.type === 'inbound-rtp') {
            receiverStats = {
              type: 'audio',
              streamId: v.id,
              timestamp: v.timestamp,
              jitter: v.jitter,
              bytesReceived: v.bytesReceived,
              concealedSamples: v.concealedSamples,
              concealmentEvents: v.concealmentEvents,
              silentConcealedSamples: v.silentConcealedSamples,
              silentConcealmentEvents: v.silentConcealmentEvents,
              totalAudioEnergy: v.totalAudioEnergy,
              totalSamplesDuration: v.totalSamplesDuration,
            };
          }
        });
        return receiverStats;
      });
    }
  }

  const REACTION_DELAY = 100;
  class RemoteVideoTrack extends RemoteTrack {
    constructor(mediaTrack, sid, receiver, adaptiveStreamSettings, loggerOptions) {
      super(mediaTrack, sid, Track.Kind.Video, receiver, loggerOptions);
      this.elementInfos = [];
      this.monitorReceiver = () =>
        __awaiter(this, void 0, void 0, function* () {
          if (!this.receiver) {
            this._currentBitrate = 0;
            return;
          }
          const stats = yield this.getReceiverStats();
          if (stats && this.prevStats && this.receiver) {
            this._currentBitrate = computeBitrate(stats, this.prevStats);
          }
          this.prevStats = stats;
        });
      this.debouncedHandleResize = r(() => {
        this.updateDimensions();
      }, REACTION_DELAY);
      this.adaptiveStreamSettings = adaptiveStreamSettings;
    }
    get isAdaptiveStream() {
      return this.adaptiveStreamSettings !== undefined;
    }
    setStreamState(value) {
      super.setStreamState(value);
      console.log('setStreamState', value);
      if (value === Track.StreamState.Active) {
        // update visibility for adaptive stream tracks when stream state received from server is active
        // this is needed to ensure the track is stopped when there's no element attached to it at all
        this.updateVisibility();
      }
    }
    /**
     * Note: When using adaptiveStream, you need to use remoteVideoTrack.attach() to add the track to a HTMLVideoElement, otherwise your video tracks might never start
     */
    get mediaStreamTrack() {
      return this._mediaStreamTrack;
    }
    /** @internal */
    setMuted(muted) {
      super.setMuted(muted);
      this.attachedElements.forEach((element) => {
        // detach or attach
        if (muted) {
          detachTrack(this._mediaStreamTrack, element);
        } else {
          attachToElement(this._mediaStreamTrack, element);
        }
      });
    }
    attach(element) {
      if (!element) {
        element = super.attach();
      } else {
        super.attach(element);
      }
      // It's possible attach is called multiple times on an element. When that's
      // the case, we'd want to avoid adding duplicate elementInfos
      if (
        this.adaptiveStreamSettings &&
        this.elementInfos.find((info) => info.element === element) === undefined
      ) {
        const elementInfo = new HTMLElementInfo(element);
        this.observeElementInfo(elementInfo);
      }
      return element;
    }
    /**
     * Observe an ElementInfo for changes when adaptive streaming.
     * @param elementInfo
     * @internal
     */
    observeElementInfo(elementInfo) {
      if (
        this.adaptiveStreamSettings &&
        this.elementInfos.find((info) => info === elementInfo) === undefined
      ) {
        elementInfo.handleResize = () => {
          this.debouncedHandleResize();
        };
        elementInfo.handleVisibilityChanged = () => {
          this.updateVisibility();
        };
        this.elementInfos.push(elementInfo);
        elementInfo.observe();
        // trigger the first resize update cycle
        // if the tab is backgrounded, the initial resize event does not fire until
        // the tab comes into focus for the first time.
        this.debouncedHandleResize();
        this.updateVisibility();
      } else {
        this.log.warn('visibility resize observer not triggered', this.logContext);
      }
    }
    /**
     * Stop observing an ElementInfo for changes.
     * @param elementInfo
     * @internal
     */
    stopObservingElementInfo(elementInfo) {
      if (!this.isAdaptiveStream) {
        this.log.warn('stopObservingElementInfo ignored', this.logContext);
        return;
      }
      const stopElementInfos = this.elementInfos.filter((info) => info === elementInfo);
      for (const info of stopElementInfos) {
        info.stopObserving();
      }
      this.elementInfos = this.elementInfos.filter((info) => info !== elementInfo);
      this.updateVisibility();
      this.debouncedHandleResize();
    }
    detach(element) {
      let detachedElements = [];
      if (element) {
        this.stopObservingElement(element);
        return super.detach(element);
      }
      detachedElements = super.detach();
      for (const e of detachedElements) {
        this.stopObservingElement(e);
      }
      return detachedElements;
    }
    /** @internal */
    getDecoderImplementation() {
      var _a;
      return (_a = this.prevStats) === null || _a === void 0 ? void 0 : _a.decoderImplementation;
    }
    getReceiverStats() {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.receiver || !this.receiver.getStats) {
          return;
        }
        const stats = yield this.receiver.getStats();
        let receiverStats;
        let codecID = '';
        let codecs = new Map();
        stats.forEach((v) => {
          if (v.type === 'inbound-rtp') {
            codecID = v.codecId;
            receiverStats = {
              type: 'video',
              streamId: v.id,
              framesDecoded: v.framesDecoded,
              framesDropped: v.framesDropped,
              framesReceived: v.framesReceived,
              packetsReceived: v.packetsReceived,
              packetsLost: v.packetsLost,
              frameWidth: v.frameWidth,
              frameHeight: v.frameHeight,
              pliCount: v.pliCount,
              firCount: v.firCount,
              nackCount: v.nackCount,
              jitter: v.jitter,
              timestamp: v.timestamp,
              bytesReceived: v.bytesReceived,
              decoderImplementation: v.decoderImplementation,
            };
          } else if (v.type === 'codec') {
            codecs.set(v.id, v);
          }
        });
        if (receiverStats && codecID !== '' && codecs.get(codecID)) {
          receiverStats.mimeType = codecs.get(codecID).mimeType;
        }
        return receiverStats;
      });
    }
    stopObservingElement(element) {
      const stopElementInfos = this.elementInfos.filter((info) => info.element === element);
      for (const info of stopElementInfos) {
        this.stopObservingElementInfo(info);
      }
    }
    handleAppVisibilityChanged() {
      const _super = Object.create(null, {
        handleAppVisibilityChanged: {
          get: () => super.handleAppVisibilityChanged,
        },
      });
      return __awaiter(this, void 0, void 0, function* () {
        yield _super.handleAppVisibilityChanged.call(this);
        if (!this.isAdaptiveStream) return;
        this.updateVisibility();
      });
    }
    updateVisibility(forceEmit) {
      var _a, _b;
      const lastVisibilityChange = this.elementInfos.reduce(
        (prev, info) => Math.max(prev, info.visibilityChangedAt || 0),
        0
      );
      const backgroundPause = (
        (_b =
          (_a = this.adaptiveStreamSettings) === null || _a === void 0
            ? void 0
            : _a.pauseVideoInBackground) !== null && _b !== void 0
          ? _b
          : true
      ) // default to true
        ? this.isInBackground
        : false;
      const isPiPMode = this.elementInfos.some((info) => info.pictureInPicture);
      const isVisible =
        (this.elementInfos.some((info) => info.visible) && !backgroundPause) || isPiPMode;
      if (this.lastVisible === isVisible && !forceEmit) {
        return;
      }
      if (!isVisible && Date.now() - lastVisibilityChange < REACTION_DELAY) {
        // delay hidden events
        CriticalTimers.setTimeout(() => {
          this.updateVisibility();
        }, REACTION_DELAY);
        return;
      }
      this.lastVisible = isVisible;
      this.emit(TrackEvent.VisibilityChanged, isVisible, this);
    }
    updateDimensions() {
      var _a, _b;
      let maxWidth = 0;
      let maxHeight = 0;
      const pixelDensity = this.getPixelDensity();
      for (const info of this.elementInfos) {
        const currentElementWidth = info.width() * pixelDensity;
        const currentElementHeight = info.height() * pixelDensity;
        if (currentElementWidth + currentElementHeight > maxWidth + maxHeight) {
          maxWidth = currentElementWidth;
          maxHeight = currentElementHeight;
        }
      }
      if (
        ((_a = this.lastDimensions) === null || _a === void 0 ? void 0 : _a.width) === maxWidth &&
        ((_b = this.lastDimensions) === null || _b === void 0 ? void 0 : _b.height) === maxHeight
      ) {
        return;
      }
      this.lastDimensions = {
        width: maxWidth,
        height: maxHeight,
      };
      this.emit(TrackEvent.VideoDimensionsChanged, this.lastDimensions, this);
    }
    getPixelDensity() {
      var _a;
      const pixelDensity =
        (_a = this.adaptiveStreamSettings) === null || _a === void 0 ? void 0 : _a.pixelDensity;
      if (pixelDensity === 'screen') {
        return getDevicePixelRatio();
      } else if (!pixelDensity) {
        // when unset, we'll pick a sane default here.
        // for higher pixel density devices (mobile phones, etc), we'll use 2
        // otherwise it defaults to 1
        const devicePixelRatio = getDevicePixelRatio();
        if (devicePixelRatio > 2) {
          return 2;
        } else {
          return 1;
        }
      }
      return pixelDensity;
    }
  }
  class HTMLElementInfo {
    get visible() {
      return this.isPiP || this.isIntersecting;
    }
    get pictureInPicture() {
      return this.isPiP;
    }
    constructor(element, visible) {
      this.onVisibilityChanged = (entry) => {
        var _a;
        const { target, isIntersecting } = entry;
        if (target === this.element) {
          this.isIntersecting = isIntersecting;
          this.isPiP = isElementInPiP(this.element);
          this.visibilityChangedAt = Date.now();
          (_a = this.handleVisibilityChanged) === null || _a === void 0 ? void 0 : _a.call(this);
        }
      };
      this.onEnterPiP = () => {
        var _a, _b, _c;
        (_b =
          (_a = window.documentPictureInPicture) === null || _a === void 0 ? void 0 : _a.window) ===
          null || _b === void 0
          ? void 0
          : _b.addEventListener('pagehide', this.onLeavePiP);
        this.isPiP = isElementInPiP(this.element);
        (_c = this.handleVisibilityChanged) === null || _c === void 0 ? void 0 : _c.call(this);
      };
      this.onLeavePiP = () => {
        var _a;
        this.isPiP = isElementInPiP(this.element);
        (_a = this.handleVisibilityChanged) === null || _a === void 0 ? void 0 : _a.call(this);
      };
      this.element = element;
      this.isIntersecting =
        visible !== null && visible !== void 0 ? visible : isElementInViewport(element);
      this.isPiP = isWeb() && isElementInPiP(element);
      this.visibilityChangedAt = 0;
    }
    width() {
      return this.element.clientWidth;
    }
    height() {
      return this.element.clientHeight;
    }
    observe() {
      var _a, _b, _c;
      // make sure we update the current visible state once we start to observe
      this.isIntersecting = isElementInViewport(this.element);
      this.isPiP = isElementInPiP(this.element);
      this.element.handleResize = () => {
        var _a;
        (_a = this.handleResize) === null || _a === void 0 ? void 0 : _a.call(this);
      };
      this.element.handleVisibilityChanged = this.onVisibilityChanged;
      getIntersectionObserver().observe(this.element);
      getResizeObserver().observe(this.element);
      this.element.addEventListener('enterpictureinpicture', this.onEnterPiP);
      this.element.addEventListener('leavepictureinpicture', this.onLeavePiP);
      (_a = window.documentPictureInPicture) === null || _a === void 0
        ? void 0
        : _a.addEventListener('enter', this.onEnterPiP);
      (_c =
        (_b = window.documentPictureInPicture) === null || _b === void 0 ? void 0 : _b.window) ===
        null || _c === void 0
        ? void 0
        : _c.addEventListener('pagehide', this.onLeavePiP);
    }
    stopObserving() {
      var _a, _b, _c, _d, _e;
      (_a = getIntersectionObserver()) === null || _a === void 0
        ? void 0
        : _a.unobserve(this.element);
      (_b = getResizeObserver()) === null || _b === void 0 ? void 0 : _b.unobserve(this.element);
      this.element.removeEventListener('enterpictureinpicture', this.onEnterPiP);
      this.element.removeEventListener('leavepictureinpicture', this.onLeavePiP);
      (_c = window.documentPictureInPicture) === null || _c === void 0
        ? void 0
        : _c.removeEventListener('enter', this.onEnterPiP);
      (_e =
        (_d = window.documentPictureInPicture) === null || _d === void 0 ? void 0 : _d.window) ===
        null || _e === void 0
        ? void 0
        : _e.removeEventListener('pagehide', this.onLeavePiP);
    }
  }
  function isElementInPiP(el) {
    var _a, _b;
    // Simple video PiP
    if (document.pictureInPictureElement === el) return true;
    // Document PiP
    if ((_a = window.documentPictureInPicture) === null || _a === void 0 ? void 0 : _a.window)
      return isElementInViewport(
        el,
        (_b = window.documentPictureInPicture) === null || _b === void 0 ? void 0 : _b.window
      );
    return false;
  }
  // does not account for occlusion by other elements or opacity property
  function isElementInViewport(el, win) {
    const viewportWindow = win || window;
    let top = el.offsetTop;
    let left = el.offsetLeft;
    const width = el.offsetWidth;
    const height = el.offsetHeight;
    const { hidden } = el;
    const { display } = getComputedStyle(el);
    while (el.offsetParent) {
      el = el.offsetParent;
      top += el.offsetTop;
      left += el.offsetLeft;
    }
    return (
      top < viewportWindow.pageYOffset + viewportWindow.innerHeight &&
      left < viewportWindow.pageXOffset + viewportWindow.innerWidth &&
      top + height > viewportWindow.pageYOffset &&
      left + width > viewportWindow.pageXOffset &&
      !hidden &&
      display !== 'none'
    );
  }

  class TrackPublication extends eventsExports.EventEmitter {
    constructor(kind, id, name, loggerOptions) {
      var _a;
      super();
      this.metadataMuted = false;
      this.encryption = Encryption_Type.NONE;
      this.log = livekitLogger;
      this.handleMuted = () => {
        this.emit(TrackEvent.Muted);
      };
      this.handleUnmuted = () => {
        this.emit(TrackEvent.Unmuted);
      };
      this.log = getLogger(
        (_a =
          loggerOptions === null || loggerOptions === void 0
            ? void 0
            : loggerOptions.loggerName) !== null && _a !== void 0
          ? _a
          : LoggerNames.Publication
      );
      this.loggerContextCb = this.loggerContextCb;
      this.setMaxListeners(100);
      this.kind = kind;
      this.trackSid = id;
      this.trackName = name;
      this.source = Track.Source.Unknown;
    }
    /** @internal */
    setTrack(track) {
      if (this.track) {
        this.track.off(TrackEvent.Muted, this.handleMuted);
        this.track.off(TrackEvent.Unmuted, this.handleUnmuted);
      }
      this.track = track;
      if (track) {
        // forward events
        track.on(TrackEvent.Muted, this.handleMuted);
        track.on(TrackEvent.Unmuted, this.handleUnmuted);
      }
    }
    get logContext() {
      var _a;
      return Object.assign(
        Object.assign(
          {},
          (_a = this.loggerContextCb) === null || _a === void 0 ? void 0 : _a.call(this)
        ),
        getLogContextFromTrack(this)
      );
    }
    get isMuted() {
      return this.metadataMuted;
    }
    get isEnabled() {
      return true;
    }
    get isSubscribed() {
      return this.track !== undefined;
    }
    get isEncrypted() {
      return this.encryption !== Encryption_Type.NONE;
    }
    /**
     * an [AudioTrack] if this publication holds an audio track
     */
    get audioTrack() {
      if (isAudioTrack(this.track)) {
        return this.track;
      }
    }
    /**
     * an [VideoTrack] if this publication holds a video track
     */
    get videoTrack() {
      if (isVideoTrack(this.track)) {
        return this.track;
      }
    }
    /** @internal */
    updateInfo(info) {
      this.trackSid = info.sid;
      this.trackName = info.name;
      this.source = Track.sourceFromProto(info.source);
      this.mimeType = info.mimeType;
      if (this.kind === Track.Kind.Video && info.width > 0) {
        this.dimensions = {
          width: info.width,
          height: info.height,
        };
        this.simulcasted = info.simulcast;
      }
      this.encryption = info.encryption;
      this.trackInfo = info;
      this.log.debug(
        'update publication info',
        Object.assign(Object.assign({}, this.logContext), {
          info,
        })
      );
    }
  }
  (function (TrackPublication) {
    (function (SubscriptionStatus) {
      SubscriptionStatus['Desired'] = 'desired';
      SubscriptionStatus['Subscribed'] = 'subscribed';
      SubscriptionStatus['Unsubscribed'] = 'unsubscribed';
    })(TrackPublication.SubscriptionStatus || (TrackPublication.SubscriptionStatus = {}));
    (function (PermissionStatus) {
      PermissionStatus['Allowed'] = 'allowed';
      PermissionStatus['NotAllowed'] = 'not_allowed';
    })(TrackPublication.PermissionStatus || (TrackPublication.PermissionStatus = {}));
  })(TrackPublication || (TrackPublication = {}));

  class LocalTrackPublication extends TrackPublication {
    get isUpstreamPaused() {
      var _a;
      return (_a = this.track) === null || _a === void 0 ? void 0 : _a.isUpstreamPaused;
    }
    constructor(kind, ti, track, loggerOptions) {
      super(kind, ti.sid, ti.name, loggerOptions);
      this.track = undefined;
      this.handleTrackEnded = () => {
        this.emit(TrackEvent.Ended);
      };
      this.handleCpuConstrained = () => {
        if (this.track && isVideoTrack(this.track)) {
          this.emit(TrackEvent.CpuConstrained, this.track);
        }
      };
      this.updateInfo(ti);
      this.setTrack(track);
    }
    setTrack(track) {
      if (this.track) {
        this.track.off(TrackEvent.Ended, this.handleTrackEnded);
        this.track.off(TrackEvent.CpuConstrained, this.handleCpuConstrained);
      }
      super.setTrack(track);
      if (track) {
        track.on(TrackEvent.Ended, this.handleTrackEnded);
        track.on(TrackEvent.CpuConstrained, this.handleCpuConstrained);
      }
    }
    get isMuted() {
      if (this.track) {
        return this.track.isMuted;
      }
      return super.isMuted;
    }
    get audioTrack() {
      return super.audioTrack;
    }
    get videoTrack() {
      return super.videoTrack;
    }
    get isLocal() {
      return true;
    }
    /**
     * Mute the track associated with this publication
     */
    mute() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        return (_a = this.track) === null || _a === void 0 ? void 0 : _a.mute();
      });
    }
    /**
     * Unmute track associated with this publication
     */
    unmute() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        return (_a = this.track) === null || _a === void 0 ? void 0 : _a.unmute();
      });
    }
    /**
     * Pauses the media stream track associated with this publication from being sent to the server
     * and signals "muted" event to other participants
     * Useful if you want to pause the stream without pausing the local media stream track
     */
    pauseUpstream() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        yield (_a = this.track) === null || _a === void 0 ? void 0 : _a.pauseUpstream();
      });
    }
    /**
     * Resumes sending the media stream track associated with this publication to the server after a call to [[pauseUpstream()]]
     * and signals "unmuted" event to other participants (unless the track is explicitly muted)
     */
    resumeUpstream() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        yield (_a = this.track) === null || _a === void 0 ? void 0 : _a.resumeUpstream();
      });
    }
    getTrackFeatures() {
      var _a;
      if (isAudioTrack(this.track)) {
        const settings = this.track.getSourceTrackSettings();
        const features = new Set();
        if (settings.autoGainControl) {
          features.add(AudioTrackFeature.TF_AUTO_GAIN_CONTROL);
        }
        if (settings.echoCancellation) {
          features.add(AudioTrackFeature.TF_ECHO_CANCELLATION);
        }
        if (settings.noiseSuppression) {
          features.add(AudioTrackFeature.TF_NOISE_SUPPRESSION);
        }
        if (settings.channelCount && settings.channelCount > 1) {
          features.add(AudioTrackFeature.TF_STEREO);
        }
        if (!((_a = this.options) === null || _a === void 0 ? void 0 : _a.dtx)) {
          features.add(AudioTrackFeature.TF_NO_DTX);
        }
        if (this.track.enhancedNoiseCancellation) {
          features.add(AudioTrackFeature.TF_ENHANCED_NOISE_CANCELLATION);
        }
        return Array.from(features.values());
      } else return [];
    }
  }

  /**
   * Creates a local video and audio track at the same time. When acquiring both
   * audio and video tracks together, it'll display a single permission prompt to
   * the user instead of two separate ones.
   * @param options
   */
  function createLocalTracks(options, loggerOptions) {
    return __awaiter(this, void 0, void 0, function* () {
      options !== null && options !== void 0 ? options : (options = {});
      let attemptExactMatch = false;
      const {
        audioProcessor,
        videoProcessor,
        optionsWithoutProcessor: internalOptions,
      } = extractProcessorsFromOptions(options);
      let retryAudioOptions = internalOptions.audio;
      let retryVideoOptions = internalOptions.video;
      if (audioProcessor && typeof internalOptions.audio === 'object') {
        internalOptions.audio.processor = audioProcessor;
      }
      if (videoProcessor && typeof internalOptions.video === 'object') {
        internalOptions.video.processor = videoProcessor;
      }
      // if the user passes a device id as a string, we default to exact match
      if (
        options.audio &&
        typeof internalOptions.audio === 'object' &&
        typeof internalOptions.audio.deviceId === 'string'
      ) {
        const deviceId = internalOptions.audio.deviceId;
        internalOptions.audio.deviceId = {
          exact: deviceId,
        };
        attemptExactMatch = true;
        retryAudioOptions = Object.assign(Object.assign({}, internalOptions.audio), {
          deviceId: {
            ideal: deviceId,
          },
        });
      }
      if (
        internalOptions.video &&
        typeof internalOptions.video === 'object' &&
        typeof internalOptions.video.deviceId === 'string'
      ) {
        const deviceId = internalOptions.video.deviceId;
        internalOptions.video.deviceId = {
          exact: deviceId,
        };
        attemptExactMatch = true;
        retryVideoOptions = Object.assign(Object.assign({}, internalOptions.video), {
          deviceId: {
            ideal: deviceId,
          },
        });
      }
      if (
        internalOptions.audio === true ||
        (typeof internalOptions.audio === 'object' && !internalOptions.audio.deviceId)
      ) {
        internalOptions.audio = {
          deviceId: 'default',
        };
      }
      if (internalOptions.video === true) {
        internalOptions.video = {
          deviceId: 'default',
        };
      } else if (typeof internalOptions.video === 'object' && !internalOptions.video.deviceId) {
        internalOptions.video.deviceId = 'default';
      }
      const opts = mergeDefaultOptions(internalOptions, audioDefaults, videoDefaults);
      const constraints = constraintsForOptions(opts);
      // Keep a reference to the promise on DeviceManager and await it in getLocalDevices()
      // works around iOS Safari Bug https://bugs.webkit.org/show_bug.cgi?id=179363
      const mediaPromise = navigator.mediaDevices.getUserMedia(constraints);
      if (internalOptions.audio) {
        DeviceManager.userMediaPromiseMap.set('audioinput', mediaPromise);
        mediaPromise.catch(() => DeviceManager.userMediaPromiseMap.delete('audioinput'));
      }
      if (internalOptions.video) {
        DeviceManager.userMediaPromiseMap.set('videoinput', mediaPromise);
        mediaPromise.catch(() => DeviceManager.userMediaPromiseMap.delete('videoinput'));
      }
      try {
        const stream = yield mediaPromise;
        return yield Promise.all(
          stream.getTracks().map((mediaStreamTrack) =>
            __awaiter(this, void 0, void 0, function* () {
              const isAudio = mediaStreamTrack.kind === 'audio';
              let trackOptions = isAudio ? opts.audio : opts.video;
              if (typeof trackOptions === 'boolean' || !trackOptions) {
                trackOptions = {};
              }
              let trackConstraints;
              const conOrBool = isAudio ? constraints.audio : constraints.video;
              if (typeof conOrBool !== 'boolean') {
                trackConstraints = conOrBool;
              }
              // update the constraints with the device id the user gave permissions to in the permission prompt
              // otherwise each track restart (e.g. mute - unmute) will try to initialize the device again -> causing additional permission prompts
              const newDeviceId = mediaStreamTrack.getSettings().deviceId;
              if (
                (trackConstraints === null || trackConstraints === void 0
                  ? void 0
                  : trackConstraints.deviceId) &&
                unwrapConstraint(trackConstraints.deviceId) !== newDeviceId
              ) {
                trackConstraints.deviceId = newDeviceId;
              } else if (!trackConstraints) {
                trackConstraints = {
                  deviceId: newDeviceId,
                };
              }
              const track = mediaTrackToLocalTrack(
                mediaStreamTrack,
                trackConstraints,
                loggerOptions
              );
              if (track.kind === Track.Kind.Video) {
                track.source = Track.Source.Camera;
              } else if (track.kind === Track.Kind.Audio) {
                track.source = Track.Source.Microphone;
              }
              track.mediaStream = stream;
              if (isAudioTrack(track) && audioProcessor) {
                yield track.setProcessor(audioProcessor);
              } else if (isVideoTrack(track) && videoProcessor) {
                yield track.setProcessor(videoProcessor);
              }
              return track;
            })
          )
        );
      } catch (e) {
        if (!attemptExactMatch) {
          throw e;
        }
        return createLocalTracks(
          Object.assign(Object.assign({}, options), {
            audio: retryAudioOptions,
            video: retryVideoOptions,
          }),
          loggerOptions
        );
      }
    });
  }
  /**
   * Creates a [[LocalVideoTrack]] with getUserMedia()
   * @param options
   */
  function createLocalVideoTrack(options) {
    return __awaiter(this, void 0, void 0, function* () {
      const tracks = yield createLocalTracks({
        audio: false,
        video: options !== null && options !== void 0 ? options : true,
      });
      return tracks[0];
    });
  }
  function createLocalAudioTrack(options) {
    return __awaiter(this, void 0, void 0, function* () {
      const tracks = yield createLocalTracks({
        audio: options !== null && options !== void 0 ? options : true,
        video: false,
      });
      return tracks[0];
    });
  }
  /**
   * Creates a screen capture tracks with getDisplayMedia().
   * A LocalVideoTrack is always created and returned.
   * If { audio: true }, and the browser supports audio capture, a LocalAudioTrack is also created.
   */
  function createLocalScreenTracks(options) {
    return __awaiter(this, void 0, void 0, function* () {
      if (options === undefined) {
        options = {};
      }
      if (options.resolution === undefined && !isSafari17Based()) {
        options.resolution = ScreenSharePresets.h1080fps30.resolution;
      }
      if (navigator.mediaDevices.getDisplayMedia === undefined) {
        throw new DeviceUnsupportedError('getDisplayMedia not supported');
      }
      const constraints = screenCaptureToDisplayMediaStreamOptions(options);
      const stream = yield navigator.mediaDevices.getDisplayMedia(constraints);
      const tracks = stream.getVideoTracks();
      if (tracks.length === 0) {
        throw new TrackInvalidError('no video track found');
      }
      const screenVideo = new LocalVideoTrack(tracks[0], undefined, false);
      screenVideo.source = Track.Source.ScreenShare;
      const localTracks = [screenVideo];
      if (stream.getAudioTracks().length > 0) {
        const screenAudio = new LocalAudioTrack(stream.getAudioTracks()[0], undefined, false);
        screenAudio.source = Track.Source.ScreenShareAudio;
        localTracks.push(screenAudio);
      }
      return localTracks;
    });
  }

  var ConnectionQuality;
  (function (ConnectionQuality) {
    ConnectionQuality['Excellent'] = 'excellent';
    ConnectionQuality['Good'] = 'good';
    ConnectionQuality['Poor'] = 'poor';
    /**
     * Indicates that a participant has temporarily (or permanently) lost connection to LiveKit.
     * For permanent disconnection a `ParticipantDisconnected` event will be emitted after a timeout
     */
    ConnectionQuality['Lost'] = 'lost';
    ConnectionQuality['Unknown'] = 'unknown';
  })(ConnectionQuality || (ConnectionQuality = {}));
  function qualityFromProto(q) {
    switch (q) {
      case ConnectionQuality$1.EXCELLENT:
        return ConnectionQuality.Excellent;
      case ConnectionQuality$1.GOOD:
        return ConnectionQuality.Good;
      case ConnectionQuality$1.POOR:
        return ConnectionQuality.Poor;
      case ConnectionQuality$1.LOST:
        return ConnectionQuality.Lost;
      default:
        return ConnectionQuality.Unknown;
    }
  }
  class Participant extends eventsExports.EventEmitter {
    get logContext() {
      var _a, _b;
      return Object.assign(
        {},
        (_b = (_a = this.loggerOptions) === null || _a === void 0 ? void 0 : _a.loggerContextCb) ===
          null || _b === void 0
          ? void 0
          : _b.call(_a)
      );
    }
    get isEncrypted() {
      return (
        this.trackPublications.size > 0 &&
        Array.from(this.trackPublications.values()).every((tr) => tr.isEncrypted)
      );
    }
    get isAgent() {
      var _a;
      return (
        ((_a = this.permissions) === null || _a === void 0 ? void 0 : _a.agent) ||
        this.kind === ParticipantInfo_Kind.AGENT
      );
    }
    get isActive() {
      var _a;
      return (
        ((_a = this.participantInfo) === null || _a === void 0 ? void 0 : _a.state) ===
        ParticipantInfo_State.ACTIVE
      );
    }
    get kind() {
      return this._kind;
    }
    /** participant attributes, similar to metadata, but as a key/value map */
    get attributes() {
      return Object.freeze(Object.assign({}, this._attributes));
    }
    /** @internal */
    constructor(sid, identity, name, metadata, attributes, loggerOptions) {
      let kind =
        arguments.length > 6 && arguments[6] !== undefined
          ? arguments[6]
          : ParticipantInfo_Kind.STANDARD;
      var _a;
      super();
      /** audio level between 0-1.0, 1 being loudest, 0 being softest */
      this.audioLevel = 0;
      /** if participant is currently speaking */
      this.isSpeaking = false;
      this._connectionQuality = ConnectionQuality.Unknown;
      this.log = livekitLogger;
      this.log = getLogger(
        (_a =
          loggerOptions === null || loggerOptions === void 0
            ? void 0
            : loggerOptions.loggerName) !== null && _a !== void 0
          ? _a
          : LoggerNames.Participant
      );
      this.loggerOptions = loggerOptions;
      this.setMaxListeners(100);
      this.sid = sid;
      this.identity = identity;
      this.name = name;
      this.metadata = metadata;
      this.audioTrackPublications = new Map();
      this.videoTrackPublications = new Map();
      this.trackPublications = new Map();
      this._kind = kind;
      this._attributes = attributes !== null && attributes !== void 0 ? attributes : {};
    }
    getTrackPublications() {
      return Array.from(this.trackPublications.values());
    }
    /**
     * Finds the first track that matches the source filter, for example, getting
     * the user's camera track with getTrackBySource(Track.Source.Camera).
     */
    getTrackPublication(source) {
      for (const [, pub] of this.trackPublications) {
        if (pub.source === source) {
          return pub;
        }
      }
    }
    /**
     * Finds the first track that matches the track's name.
     */
    getTrackPublicationByName(name) {
      for (const [, pub] of this.trackPublications) {
        if (pub.trackName === name) {
          return pub;
        }
      }
    }
    /**
     * Waits until the participant is active and ready to receive data messages
     * @returns a promise that resolves when the participant is active
     */
    waitUntilActive() {
      if (this.isActive) {
        return Promise.resolve();
      }
      if (this.activeFuture) {
        return this.activeFuture.promise;
      }
      this.activeFuture = new Future();
      this.once(ParticipantEvent.Active, () => {
        var _a, _b;
        (_b = (_a = this.activeFuture) === null || _a === void 0 ? void 0 : _a.resolve) === null ||
        _b === void 0
          ? void 0
          : _b.call(_a);
        this.activeFuture = undefined;
      });
      return this.activeFuture.promise;
    }
    get connectionQuality() {
      return this._connectionQuality;
    }
    get isCameraEnabled() {
      var _a;
      const track = this.getTrackPublication(Track.Source.Camera);
      return !((_a = track === null || track === void 0 ? void 0 : track.isMuted) !== null &&
      _a !== void 0
        ? _a
        : true);
    }
    get isMicrophoneEnabled() {
      var _a;
      const track = this.getTrackPublication(Track.Source.Microphone);
      return !((_a = track === null || track === void 0 ? void 0 : track.isMuted) !== null &&
      _a !== void 0
        ? _a
        : true);
    }
    get isScreenShareEnabled() {
      const track = this.getTrackPublication(Track.Source.ScreenShare);
      return !!track;
    }
    get isLocal() {
      return false;
    }
    /** when participant joined the room */
    get joinedAt() {
      if (this.participantInfo) {
        return new Date(Number.parseInt(this.participantInfo.joinedAt.toString()) * 1000);
      }
      return new Date();
    }
    /** @internal */
    updateInfo(info) {
      var _a;
      // it's possible the update could be applied out of order due to await
      // during reconnect sequences. when that happens, it's possible for server
      // to have sent more recent version of participant info while JS is waiting
      // to process the existing payload.
      // when the participant sid remains the same, and we already have a later version
      // of the payload, they can be safely skipped
      if (
        this.participantInfo &&
        this.participantInfo.sid === info.sid &&
        this.participantInfo.version > info.version
      ) {
        return false;
      }
      this.identity = info.identity;
      this.sid = info.sid;
      this._setName(info.name);
      this._setMetadata(info.metadata);
      this._setAttributes(info.attributes);
      if (
        info.state === ParticipantInfo_State.ACTIVE &&
        ((_a = this.participantInfo) === null || _a === void 0 ? void 0 : _a.state) !==
          ParticipantInfo_State.ACTIVE
      ) {
        this.emit(ParticipantEvent.Active);
      }
      if (info.permission) {
        this.setPermissions(info.permission);
      }
      // set this last so setMetadata can detect changes
      this.participantInfo = info;
      return true;
    }
    /**
     * Updates metadata from server
     **/
    _setMetadata(md) {
      const changed = this.metadata !== md;
      const prevMetadata = this.metadata;
      this.metadata = md;
      if (changed) {
        this.emit(ParticipantEvent.ParticipantMetadataChanged, prevMetadata);
      }
    }
    _setName(name) {
      const changed = this.name !== name;
      this.name = name;
      if (changed) {
        this.emit(ParticipantEvent.ParticipantNameChanged, name);
      }
    }
    /**
     * Updates metadata from server
     **/
    _setAttributes(attributes) {
      const diff = diffAttributes(this.attributes, attributes);
      this._attributes = attributes;
      if (Object.keys(diff).length > 0) {
        this.emit(ParticipantEvent.AttributesChanged, diff);
      }
    }
    /** @internal */
    setPermissions(permissions) {
      var _a, _b, _c, _d, _e, _f;
      const prevPermissions = this.permissions;
      const changed =
        permissions.canPublish !==
          ((_a = this.permissions) === null || _a === void 0 ? void 0 : _a.canPublish) ||
        permissions.canSubscribe !==
          ((_b = this.permissions) === null || _b === void 0 ? void 0 : _b.canSubscribe) ||
        permissions.canPublishData !==
          ((_c = this.permissions) === null || _c === void 0 ? void 0 : _c.canPublishData) ||
        permissions.hidden !==
          ((_d = this.permissions) === null || _d === void 0 ? void 0 : _d.hidden) ||
        permissions.recorder !==
          ((_e = this.permissions) === null || _e === void 0 ? void 0 : _e.recorder) ||
        permissions.canPublishSources.length !== this.permissions.canPublishSources.length ||
        permissions.canPublishSources.some((value, index) => {
          var _a;
          return (
            value !==
            ((_a = this.permissions) === null || _a === void 0
              ? void 0
              : _a.canPublishSources[index])
          );
        }) ||
        permissions.canSubscribeMetrics !==
          ((_f = this.permissions) === null || _f === void 0 ? void 0 : _f.canSubscribeMetrics);
      this.permissions = permissions;
      if (changed) {
        this.emit(ParticipantEvent.ParticipantPermissionsChanged, prevPermissions);
      }
      return changed;
    }
    /** @internal */
    setIsSpeaking(speaking) {
      if (speaking === this.isSpeaking) {
        return;
      }
      this.isSpeaking = speaking;
      if (speaking) {
        this.lastSpokeAt = new Date();
      }
      this.emit(ParticipantEvent.IsSpeakingChanged, speaking);
    }
    /** @internal */
    setConnectionQuality(q) {
      const prevQuality = this._connectionQuality;
      this._connectionQuality = qualityFromProto(q);
      if (prevQuality !== this._connectionQuality) {
        this.emit(ParticipantEvent.ConnectionQualityChanged, this._connectionQuality);
      }
    }
    /**
     * @internal
     */
    setDisconnected() {
      var _a, _b;
      if (this.activeFuture) {
        (_b = (_a = this.activeFuture).reject) === null || _b === void 0
          ? void 0
          : _b.call(_a, new Error('Participant disconnected'));
        this.activeFuture = undefined;
      }
    }
    /**
     * @internal
     */
    setAudioContext(ctx) {
      this.audioContext = ctx;
      this.audioTrackPublications.forEach(
        (track) => isAudioTrack(track.track) && track.track.setAudioContext(ctx)
      );
    }
    addTrackPublication(publication) {
      // forward publication driven events
      publication.on(TrackEvent.Muted, () => {
        this.emit(ParticipantEvent.TrackMuted, publication);
      });
      publication.on(TrackEvent.Unmuted, () => {
        this.emit(ParticipantEvent.TrackUnmuted, publication);
      });
      const pub = publication;
      if (pub.track) {
        pub.track.sid = publication.trackSid;
      }
      this.trackPublications.set(publication.trackSid, publication);
      switch (publication.kind) {
        case Track.Kind.Audio:
          this.audioTrackPublications.set(publication.trackSid, publication);
          break;
        case Track.Kind.Video:
          this.videoTrackPublications.set(publication.trackSid, publication);
          break;
      }
    }
  }

  function trackPermissionToProto(perms) {
    var _a, _b, _c;
    if (!perms.participantSid && !perms.participantIdentity) {
      throw new Error(
        'Invalid track permission, must provide at least one of participantIdentity and participantSid'
      );
    }
    return new TrackPermission({
      participantIdentity: (_a = perms.participantIdentity) !== null && _a !== void 0 ? _a : '',
      participantSid: (_b = perms.participantSid) !== null && _b !== void 0 ? _b : '',
      allTracks: (_c = perms.allowAll) !== null && _c !== void 0 ? _c : false,
      trackSids: perms.allowedTrackSids || [],
    });
  }

  class LocalParticipant extends Participant {
    /** @internal */
    constructor(sid, identity, engine, options, roomRpcHandlers, roomOutgoingDataStreamManager) {
      super(sid, identity, undefined, undefined, undefined, {
        loggerName: options.loggerName,
        loggerContextCb: () => this.engine.logContext,
      });
      this.pendingPublishing = new Set();
      this.pendingPublishPromises = new Map();
      this.participantTrackPermissions = [];
      this.allParticipantsAllowedToSubscribe = true;
      this.encryptionType = Encryption_Type.NONE;
      this.enabledPublishVideoCodecs = [];
      this.pendingAcks = new Map();
      this.pendingResponses = new Map();
      this.handleReconnecting = () => {
        if (!this.reconnectFuture) {
          this.reconnectFuture = new Future();
        }
      };
      this.handleReconnected = () => {
        var _a, _b;
        (_b = (_a = this.reconnectFuture) === null || _a === void 0 ? void 0 : _a.resolve) ===
          null || _b === void 0
          ? void 0
          : _b.call(_a);
        this.reconnectFuture = undefined;
        this.updateTrackSubscriptionPermissions();
      };
      this.handleClosing = () => {
        var _a, _b, _c, _d, _e, _f;
        if (this.reconnectFuture) {
          this.reconnectFuture.promise.catch((e) => this.log.warn(e.message, this.logContext));
          (_b = (_a = this.reconnectFuture) === null || _a === void 0 ? void 0 : _a.reject) ===
            null || _b === void 0
            ? void 0
            : _b.call(_a, 'Got disconnected during reconnection attempt');
          this.reconnectFuture = undefined;
        }
        if (this.signalConnectedFuture) {
          (_d = (_c = this.signalConnectedFuture).reject) === null || _d === void 0
            ? void 0
            : _d.call(_c, 'Got disconnected without signal connected');
          this.signalConnectedFuture = undefined;
        }
        (_f = (_e = this.activeAgentFuture) === null || _e === void 0 ? void 0 : _e.reject) ===
          null || _f === void 0
          ? void 0
          : _f.call(_e, 'Got disconnected without active agent present');
        this.activeAgentFuture = undefined;
        this.firstActiveAgent = undefined;
      };
      this.handleSignalConnected = (joinResponse) => {
        var _a, _b;
        if (joinResponse.participant) {
          this.updateInfo(joinResponse.participant);
        }
        if (!this.signalConnectedFuture) {
          this.signalConnectedFuture = new Future();
        }
        (_b = (_a = this.signalConnectedFuture).resolve) === null || _b === void 0
          ? void 0
          : _b.call(_a);
      };
      this.handleSignalRequestResponse = (response) => {
        const { requestId, reason, message } = response;
        const targetRequest = this.pendingSignalRequests.get(requestId);
        if (targetRequest) {
          if (reason !== RequestResponse_Reason.OK) {
            targetRequest.reject(new SignalRequestError(message, reason));
          }
          this.pendingSignalRequests.delete(requestId);
        }
      };
      this.handleDataPacket = (packet) => {
        switch (packet.value.case) {
          case 'rpcResponse':
            let rpcResponse = packet.value.value;
            let payload = null;
            let error = null;
            if (rpcResponse.value.case === 'payload') {
              payload = rpcResponse.value.value;
            } else if (rpcResponse.value.case === 'error') {
              error = RpcError.fromProto(rpcResponse.value.value);
            }
            this.handleIncomingRpcResponse(rpcResponse.requestId, payload, error);
            break;
          case 'rpcAck':
            let rpcAck = packet.value.value;
            this.handleIncomingRpcAck(rpcAck.requestId);
            break;
        }
      };
      this.updateTrackSubscriptionPermissions = () => {
        this.log.debug(
          'updating track subscription permissions',
          Object.assign(Object.assign({}, this.logContext), {
            allParticipantsAllowed: this.allParticipantsAllowedToSubscribe,
            participantTrackPermissions: this.participantTrackPermissions,
          })
        );
        this.engine.client.sendUpdateSubscriptionPermissions(
          this.allParticipantsAllowedToSubscribe,
          this.participantTrackPermissions.map((p) => trackPermissionToProto(p))
        );
      };
      /** @internal */
      this.onTrackUnmuted = (track) => {
        this.onTrackMuted(track, track.isUpstreamPaused);
      };
      // when the local track changes in mute status, we'll notify server as such
      /** @internal */
      this.onTrackMuted = (track, muted) => {
        if (muted === undefined) {
          muted = true;
        }
        if (!track.sid) {
          this.log.error(
            'could not update mute status for unpublished track',
            Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track))
          );
          return;
        }
        this.engine.updateMuteStatus(track.sid, muted);
      };
      this.onTrackUpstreamPaused = (track) => {
        this.log.debug(
          'upstream paused',
          Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track))
        );
        this.onTrackMuted(track, true);
      };
      this.onTrackUpstreamResumed = (track) => {
        this.log.debug(
          'upstream resumed',
          Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track))
        );
        this.onTrackMuted(track, track.isMuted);
      };
      this.onTrackFeatureUpdate = (track) => {
        const pub = this.audioTrackPublications.get(track.sid);
        if (!pub) {
          this.log.warn(
            'Could not update local audio track settings, missing publication for track '.concat(
              track.sid
            ),
            this.logContext
          );
          return;
        }
        this.engine.client.sendUpdateLocalAudioTrack(pub.trackSid, pub.getTrackFeatures());
      };
      this.onTrackCpuConstrained = (track, publication) => {
        this.log.debug(
          'track cpu constrained',
          Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(publication))
        );
        this.emit(ParticipantEvent.LocalTrackCpuConstrained, track, publication);
      };
      this.handleSubscribedQualityUpdate = (update) =>
        __awaiter(this, void 0, void 0, function* () {
          var _a, e_1, _b, _c;
          var _d;
          if (!((_d = this.roomOptions) === null || _d === void 0 ? void 0 : _d.dynacast)) {
            return;
          }
          const pub = this.videoTrackPublications.get(update.trackSid);
          if (!pub) {
            this.log.warn(
              'received subscribed quality update for unknown track',
              Object.assign(Object.assign({}, this.logContext), {
                trackSid: update.trackSid,
              })
            );
            return;
          }
          if (!pub.videoTrack) {
            return;
          }
          const newCodecs = yield pub.videoTrack.setPublishingCodecs(update.subscribedCodecs);
          try {
            for (
              var _e = true, newCodecs_1 = __asyncValues(newCodecs), newCodecs_1_1;
              (newCodecs_1_1 = yield newCodecs_1.next()), (_a = newCodecs_1_1.done), !_a;
              _e = true
            ) {
              _c = newCodecs_1_1.value;
              _e = false;
              const codec = _c;
              if (isBackupCodec(codec)) {
                this.log.debug(
                  'publish '.concat(codec, ' for ').concat(pub.videoTrack.sid),
                  Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(pub))
                );
                yield this.publishAdditionalCodecForTrack(pub.videoTrack, codec, pub.options);
              }
            }
          } catch (e_1_1) {
            e_1 = {
              error: e_1_1,
            };
          } finally {
            try {
              if (!_e && !_a && (_b = newCodecs_1.return)) yield _b.call(newCodecs_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
        });
      this.handleLocalTrackUnpublished = (unpublished) => {
        const track = this.trackPublications.get(unpublished.trackSid);
        if (!track) {
          this.log.warn(
            'received unpublished event for unknown track',
            Object.assign(Object.assign({}, this.logContext), {
              trackSid: unpublished.trackSid,
            })
          );
          return;
        }
        this.unpublishTrack(track.track);
      };
      this.handleTrackEnded = (track) =>
        __awaiter(this, void 0, void 0, function* () {
          if (
            track.source === Track.Source.ScreenShare ||
            track.source === Track.Source.ScreenShareAudio
          ) {
            this.log.debug(
              'unpublishing local track due to TrackEnded',
              Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track))
            );
            this.unpublishTrack(track);
          } else if (track.isUserProvided) {
            yield track.mute();
          } else if (isLocalAudioTrack(track) || isLocalVideoTrack(track)) {
            try {
              if (isWeb()) {
                try {
                  const currentPermissions = yield navigator === null || navigator === void 0
                    ? void 0
                    : navigator.permissions.query({
                        // the permission query for camera and microphone currently not supported in Safari and Firefox
                        // @ts-ignore
                        name: track.source === Track.Source.Camera ? 'camera' : 'microphone',
                      });
                  if (currentPermissions && currentPermissions.state === 'denied') {
                    this.log.warn(
                      'user has revoked access to '.concat(track.source),
                      Object.assign(
                        Object.assign({}, this.logContext),
                        getLogContextFromTrack(track)
                      )
                    );
                    // detect granted change after permissions were denied to try and resume then
                    currentPermissions.onchange = () => {
                      if (currentPermissions.state !== 'denied') {
                        if (!track.isMuted) {
                          track.restartTrack();
                        }
                        currentPermissions.onchange = null;
                      }
                    };
                    throw new Error('GetUserMedia Permission denied');
                  }
                } catch (e) {
                  // permissions query fails for firefox, we continue and try to restart the track
                }
              }
              if (!track.isMuted) {
                this.log.debug(
                  'track ended, attempting to use a different device',
                  Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track))
                );
                if (isLocalAudioTrack(track)) {
                  // fall back to default device if available
                  yield track.restartTrack({
                    deviceId: 'default',
                  });
                } else {
                  yield track.restartTrack();
                }
              }
            } catch (e) {
              this.log.warn(
                'could not restart track, muting instead',
                Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track))
              );
              yield track.mute();
            }
          }
        });
      this.audioTrackPublications = new Map();
      this.videoTrackPublications = new Map();
      this.trackPublications = new Map();
      this.engine = engine;
      this.roomOptions = options;
      this.setupEngine(engine);
      this.activeDeviceMap = new Map([
        ['audioinput', 'default'],
        ['videoinput', 'default'],
        ['audiooutput', 'default'],
      ]);
      this.pendingSignalRequests = new Map();
      this.rpcHandlers = roomRpcHandlers;
      this.roomOutgoingDataStreamManager = roomOutgoingDataStreamManager;
    }
    get lastCameraError() {
      return this.cameraError;
    }
    get lastMicrophoneError() {
      return this.microphoneError;
    }
    get isE2EEEnabled() {
      return this.encryptionType !== Encryption_Type.NONE;
    }
    getTrackPublication(source) {
      const track = super.getTrackPublication(source);
      if (track) {
        return track;
      }
    }
    getTrackPublicationByName(name) {
      const track = super.getTrackPublicationByName(name);
      if (track) {
        return track;
      }
    }
    /**
     * @internal
     */
    setupEngine(engine) {
      var _a;
      this.engine = engine;
      this.engine.on(EngineEvent.RemoteMute, (trackSid, muted) => {
        const pub = this.trackPublications.get(trackSid);
        if (!pub || !pub.track) {
          return;
        }
        if (muted) {
          pub.mute();
        } else {
          pub.unmute();
        }
      });
      if ((_a = this.signalConnectedFuture) === null || _a === void 0 ? void 0 : _a.isResolved) {
        this.signalConnectedFuture = undefined;
      }
      this.engine
        .on(EngineEvent.Connected, this.handleReconnected)
        .on(EngineEvent.SignalConnected, this.handleSignalConnected)
        .on(EngineEvent.SignalRestarted, this.handleReconnected)
        .on(EngineEvent.SignalResumed, this.handleReconnected)
        .on(EngineEvent.Restarting, this.handleReconnecting)
        .on(EngineEvent.Resuming, this.handleReconnecting)
        .on(EngineEvent.LocalTrackUnpublished, this.handleLocalTrackUnpublished)
        .on(EngineEvent.SubscribedQualityUpdate, this.handleSubscribedQualityUpdate)
        .on(EngineEvent.Closing, this.handleClosing)
        .on(EngineEvent.SignalRequestResponse, this.handleSignalRequestResponse)
        .on(EngineEvent.DataPacketReceived, this.handleDataPacket);
    }
    /**
     * Sets and updates the metadata of the local participant.
     * Note: this requires `canUpdateOwnMetadata` permission.
     * method will throw if the user doesn't have the required permissions
     * @param metadata
     */
    setMetadata(metadata) {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.requestMetadataUpdate({
          metadata,
        });
      });
    }
    /**
     * Sets and updates the name of the local participant.
     * Note: this requires `canUpdateOwnMetadata` permission.
     * method will throw if the user doesn't have the required permissions
     * @param metadata
     */
    setName(name) {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.requestMetadataUpdate({
          name,
        });
      });
    }
    /**
     * Set or update participant attributes. It will make updates only to keys that
     * are present in `attributes`, and will not override others.
     * Note: this requires `canUpdateOwnMetadata` permission.
     * @param attributes attributes to update
     */
    setAttributes(attributes) {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.requestMetadataUpdate({
          attributes,
        });
      });
    }
    requestMetadataUpdate(_a) {
      return __awaiter(this, arguments, void 0, function (_ref) {
        var _this = this;
        let { metadata, name, attributes } = _ref;
        return (function* () {
          return new Promise((resolve, reject) =>
            __awaiter(_this, void 0, void 0, function* () {
              var _a, _b;
              try {
                let isRejected = false;
                const requestId = yield this.engine.client.sendUpdateLocalMetadata(
                  (_a = metadata !== null && metadata !== void 0 ? metadata : this.metadata) !==
                    null && _a !== void 0
                    ? _a
                    : '',
                  (_b = name !== null && name !== void 0 ? name : this.name) !== null &&
                    _b !== void 0
                    ? _b
                    : '',
                  attributes
                );
                const startTime = performance.now();
                this.pendingSignalRequests.set(requestId, {
                  resolve,
                  reject: (error) => {
                    reject(error);
                    isRejected = true;
                  },
                  values: {
                    name,
                    metadata,
                    attributes,
                  },
                });
                while (performance.now() - startTime < 5000 && !isRejected) {
                  if (
                    (!name || this.name === name) &&
                    (!metadata || this.metadata === metadata) &&
                    (!attributes ||
                      Object.entries(attributes).every((_ref2) => {
                        let [key, value] = _ref2;
                        return (
                          this.attributes[key] === value || (value === '' && !this.attributes[key])
                        );
                      }))
                  ) {
                    this.pendingSignalRequests.delete(requestId);
                    resolve();
                    return;
                  }
                  yield sleep(50);
                }
                reject(
                  new SignalRequestError(
                    'Request to update local metadata timed out',
                    'TimeoutError'
                  )
                );
              } catch (e) {
                if (e instanceof Error) reject(e);
              }
            })
          );
        })();
      });
    }
    /**
     * Enable or disable a participant's camera track.
     *
     * If a track has already published, it'll mute or unmute the track.
     * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise
     */
    setCameraEnabled(enabled, options, publishOptions) {
      return this.setTrackEnabled(Track.Source.Camera, enabled, options, publishOptions);
    }
    /**
     * Enable or disable a participant's microphone track.
     *
     * If a track has already published, it'll mute or unmute the track.
     * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise
     */
    setMicrophoneEnabled(enabled, options, publishOptions) {
      return this.setTrackEnabled(Track.Source.Microphone, enabled, options, publishOptions);
    }
    /**
     * Start or stop sharing a participant's screen
     * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise
     */
    setScreenShareEnabled(enabled, options, publishOptions) {
      return this.setTrackEnabled(Track.Source.ScreenShare, enabled, options, publishOptions);
    }
    /** @internal */
    setE2EEEnabled(enabled) {
      return __awaiter(this, void 0, void 0, function* () {
        this.encryptionType = enabled ? Encryption_Type.GCM : Encryption_Type.NONE;
        yield this.republishAllTracks(undefined, false);
      });
    }
    setTrackEnabled(source, enabled, options, publishOptions) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, _b;
        this.log.debug(
          'setTrackEnabled',
          Object.assign(Object.assign({}, this.logContext), {
            source,
            enabled,
          })
        );
        if (this.republishPromise) {
          yield this.republishPromise;
        }
        let track = this.getTrackPublication(source);
        if (enabled) {
          if (track) {
            yield track.unmute();
          } else {
            let localTracks;
            if (this.pendingPublishing.has(source)) {
              const pendingTrack = yield this.waitForPendingPublicationOfSource(source);
              if (!pendingTrack) {
                this.log.info(
                  'waiting for pending publication promise timed out',
                  Object.assign(Object.assign({}, this.logContext), {
                    source,
                  })
                );
              }
              yield pendingTrack === null || pendingTrack === void 0
                ? void 0
                : pendingTrack.unmute();
              return pendingTrack;
            }
            this.pendingPublishing.add(source);
            try {
              switch (source) {
                case Track.Source.Camera:
                  localTracks = yield this.createTracks({
                    video: (_a = options) !== null && _a !== void 0 ? _a : true,
                  });
                  break;
                case Track.Source.Microphone:
                  localTracks = yield this.createTracks({
                    audio: (_b = options) !== null && _b !== void 0 ? _b : true,
                  });
                  break;
                case Track.Source.ScreenShare:
                  localTracks = yield this.createScreenTracks(Object.assign({}, options));
                  break;
                default:
                  throw new TrackInvalidError(source);
              }
            } catch (e) {
              localTracks === null || localTracks === void 0
                ? void 0
                : localTracks.forEach((tr) => {
                    tr.stop();
                  });
              if (e instanceof Error) {
                this.emit(ParticipantEvent.MediaDevicesError, e, sourceToKind(source));
              }
              this.pendingPublishing.delete(source);
              throw e;
            }
            for (const localTrack of localTracks) {
              const opts = Object.assign(
                Object.assign({}, this.roomOptions.publishDefaults),
                options
              );
              if (
                source === Track.Source.Microphone &&
                isAudioTrack(localTrack) &&
                opts.preConnectBuffer
              ) {
                this.log.info(
                  'starting preconnect buffer for microphone',
                  Object.assign({}, this.logContext)
                );
                localTrack.startPreConnectBuffer();
              }
            }
            try {
              const publishPromises = [];
              for (const localTrack of localTracks) {
                this.log.info(
                  'publishing track',
                  Object.assign(
                    Object.assign({}, this.logContext),
                    getLogContextFromTrack(localTrack)
                  )
                );
                publishPromises.push(this.publishTrack(localTrack, publishOptions));
              }
              const publishedTracks = yield Promise.all(publishPromises);
              // for screen share publications including audio, this will only return the screen share publication, not the screen share audio one
              // revisit if we want to return an array of tracks instead for v2
              [track] = publishedTracks;
            } catch (e) {
              localTracks === null || localTracks === void 0
                ? void 0
                : localTracks.forEach((tr) => {
                    tr.stop();
                  });
              throw e;
            } finally {
              this.pendingPublishing.delete(source);
            }
          }
        } else {
          if (
            !(track === null || track === void 0 ? void 0 : track.track) &&
            this.pendingPublishing.has(source)
          ) {
            // if there's no track available yet first wait for pending publishing promises of that source to see if it becomes available
            track = yield this.waitForPendingPublicationOfSource(source);
            if (!track) {
              this.log.info(
                'waiting for pending publication promise timed out',
                Object.assign(Object.assign({}, this.logContext), {
                  source,
                })
              );
            }
          }
          if (track && track.track) {
            // screenshare cannot be muted, unpublish instead
            if (source === Track.Source.ScreenShare) {
              track = yield this.unpublishTrack(track.track);
              const screenAudioTrack = this.getTrackPublication(Track.Source.ScreenShareAudio);
              if (screenAudioTrack && screenAudioTrack.track) {
                this.unpublishTrack(screenAudioTrack.track);
              }
            } else {
              yield track.mute();
            }
          }
        }
        return track;
      });
    }
    /**
     * Publish both camera and microphone at the same time. This is useful for
     * displaying a single Permission Dialog box to the end user.
     */
    enableCameraAndMicrophone() {
      return __awaiter(this, void 0, void 0, function* () {
        if (
          this.pendingPublishing.has(Track.Source.Camera) ||
          this.pendingPublishing.has(Track.Source.Microphone)
        ) {
          // no-op it's already been requested
          return;
        }
        this.pendingPublishing.add(Track.Source.Camera);
        this.pendingPublishing.add(Track.Source.Microphone);
        try {
          const tracks = yield this.createTracks({
            audio: true,
            video: true,
          });
          yield Promise.all(tracks.map((track) => this.publishTrack(track)));
        } finally {
          this.pendingPublishing.delete(Track.Source.Camera);
          this.pendingPublishing.delete(Track.Source.Microphone);
        }
      });
    }
    /**
     * Create local camera and/or microphone tracks
     * @param options
     * @returns
     */
    createTracks(options) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, _b;
        options !== null && options !== void 0 ? options : (options = {});
        const mergedOptionsWithProcessors = mergeDefaultOptions(
          options,
          (_a = this.roomOptions) === null || _a === void 0 ? void 0 : _a.audioCaptureDefaults,
          (_b = this.roomOptions) === null || _b === void 0 ? void 0 : _b.videoCaptureDefaults
        );
        try {
          const tracks = yield createLocalTracks(mergedOptionsWithProcessors, {
            loggerName: this.roomOptions.loggerName,
            loggerContextCb: () => this.logContext,
          });
          const localTracks = tracks.map((track) => {
            if (isAudioTrack(track)) {
              this.microphoneError = undefined;
              track.setAudioContext(this.audioContext);
              track.source = Track.Source.Microphone;
              this.emit(ParticipantEvent.AudioStreamAcquired);
            }
            if (isVideoTrack(track)) {
              this.cameraError = undefined;
              track.source = Track.Source.Camera;
            }
            return track;
          });
          return localTracks;
        } catch (err) {
          if (err instanceof Error) {
            if (options.audio) {
              this.microphoneError = err;
            }
            if (options.video) {
              this.cameraError = err;
            }
          }
          throw err;
        }
      });
    }
    /**
     * Creates a screen capture tracks with getDisplayMedia().
     * A LocalVideoTrack is always created and returned.
     * If { audio: true }, and the browser supports audio capture, a LocalAudioTrack is also created.
     */
    createScreenTracks(options) {
      return __awaiter(this, void 0, void 0, function* () {
        if (options === undefined) {
          options = {};
        }
        if (navigator.mediaDevices.getDisplayMedia === undefined) {
          throw new DeviceUnsupportedError('getDisplayMedia not supported');
        }
        if (options.resolution === undefined && !isSafari17Based()) {
          // we need to constrain the dimensions, otherwise it could lead to low bitrate
          // due to encoding a huge video. Encoding such large surfaces is really expensive
          // unfortunately Safari 17 has a but and cannot be constrained by default
          options.resolution = ScreenSharePresets.h1080fps30.resolution;
        }
        const constraints = screenCaptureToDisplayMediaStreamOptions(options);
        const stream = yield navigator.mediaDevices.getDisplayMedia(constraints);
        const tracks = stream.getVideoTracks();
        if (tracks.length === 0) {
          throw new TrackInvalidError('no video track found');
        }
        const screenVideo = new LocalVideoTrack(tracks[0], undefined, false, {
          loggerName: this.roomOptions.loggerName,
          loggerContextCb: () => this.logContext,
        });
        screenVideo.source = Track.Source.ScreenShare;
        if (options.contentHint) {
          screenVideo.mediaStreamTrack.contentHint = options.contentHint;
        }
        const localTracks = [screenVideo];
        if (stream.getAudioTracks().length > 0) {
          this.emit(ParticipantEvent.AudioStreamAcquired);
          const screenAudio = new LocalAudioTrack(
            stream.getAudioTracks()[0],
            undefined,
            false,
            this.audioContext,
            {
              loggerName: this.roomOptions.loggerName,
              loggerContextCb: () => this.logContext,
            }
          );
          screenAudio.source = Track.Source.ScreenShareAudio;
          localTracks.push(screenAudio);
        }
        return localTracks;
      });
    }
    /**
     * Publish a new track to the room
     * @param track
     * @param options
     */
    publishTrack(track, options) {
      return __awaiter(this, void 0, void 0, function* () {
        return this.publishOrRepublishTrack(track, options);
      });
    }
    publishOrRepublishTrack(track_1, options_1) {
      return __awaiter(this, arguments, void 0, function (track, options) {
        var _this2 = this;
        let isRepublish = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        return (function* () {
          var _a, _b, _c, _d;
          if (isLocalAudioTrack(track)) {
            track.setAudioContext(_this2.audioContext);
          }
          yield (_a = _this2.reconnectFuture) === null || _a === void 0 ? void 0 : _a.promise;
          if (_this2.republishPromise && !isRepublish) {
            yield _this2.republishPromise;
          }
          if (isLocalTrack(track) && _this2.pendingPublishPromises.has(track)) {
            yield _this2.pendingPublishPromises.get(track);
          }
          let defaultConstraints;
          if (track instanceof MediaStreamTrack) {
            defaultConstraints = track.getConstraints();
          } else {
            // we want to access constraints directly as `track.mediaStreamTrack`
            // might be pointing to a non-device track (e.g. processed track) already
            defaultConstraints = track.constraints;
            let deviceKind = undefined;
            switch (track.source) {
              case Track.Source.Microphone:
                deviceKind = 'audioinput';
                break;
              case Track.Source.Camera:
                deviceKind = 'videoinput';
            }
            if (deviceKind && _this2.activeDeviceMap.has(deviceKind)) {
              defaultConstraints = Object.assign(Object.assign({}, defaultConstraints), {
                deviceId: _this2.activeDeviceMap.get(deviceKind),
              });
            }
          }
          // convert raw media track into audio or video track
          if (track instanceof MediaStreamTrack) {
            switch (track.kind) {
              case 'audio':
                track = new LocalAudioTrack(track, defaultConstraints, true, _this2.audioContext, {
                  loggerName: _this2.roomOptions.loggerName,
                  loggerContextCb: () => _this2.logContext,
                });
                break;
              case 'video':
                track = new LocalVideoTrack(track, defaultConstraints, true, {
                  loggerName: _this2.roomOptions.loggerName,
                  loggerContextCb: () => _this2.logContext,
                });
                break;
              default:
                throw new TrackInvalidError(
                  'unsupported MediaStreamTrack kind '.concat(track.kind)
                );
            }
          } else {
            track.updateLoggerOptions({
              loggerName: _this2.roomOptions.loggerName,
              loggerContextCb: () => _this2.logContext,
            });
          }
          // is it already published? if so skip
          let existingPublication;
          _this2.trackPublications.forEach((publication) => {
            if (!publication.track) {
              return;
            }
            if (publication.track === track) {
              existingPublication = publication;
            }
          });
          if (existingPublication) {
            _this2.log.warn(
              'track has already been published, skipping',
              Object.assign(
                Object.assign({}, _this2.logContext),
                getLogContextFromTrack(existingPublication)
              )
            );
            return existingPublication;
          }
          const opts = Object.assign(
            Object.assign({}, _this2.roomOptions.publishDefaults),
            options
          );
          const isStereoInput =
            ('channelCount' in track.mediaStreamTrack.getSettings() &&
              // @ts-ignore `channelCount` on getSettings() is currently only available for Safari, but is generally the best way to determine a stereo track https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackSettings/channelCount
              track.mediaStreamTrack.getSettings().channelCount === 2) ||
            track.mediaStreamTrack.getConstraints().channelCount === 2;
          const isStereo = (_b = opts.forceStereo) !== null && _b !== void 0 ? _b : isStereoInput;
          // disable dtx for stereo track if not enabled explicitly
          if (isStereo) {
            if (opts.dtx === undefined) {
              _this2.log.info(
                'Opus DTX will be disabled for stereo tracks by default. Enable them explicitly to make it work.',
                Object.assign(Object.assign({}, _this2.logContext), getLogContextFromTrack(track))
              );
            }
            if (opts.red === undefined) {
              _this2.log.info(
                'Opus RED will be disabled for stereo tracks by default. Enable them explicitly to make it work.'
              );
            }
            (_c = opts.dtx) !== null && _c !== void 0 ? _c : (opts.dtx = false);
            (_d = opts.red) !== null && _d !== void 0 ? _d : (opts.red = false);
          }
          if (!isE2EESimulcastSupported() && _this2.roomOptions.e2ee) {
            _this2.log.info(
              'End-to-end encryption is set up, simulcast publishing will be disabled on Safari versions and iOS browsers running iOS < v17.2',
              Object.assign({}, _this2.logContext)
            );
            opts.simulcast = false;
          }
          if (opts.source) {
            track.source = opts.source;
          }
          const publishPromise = new Promise((resolve, reject) =>
            __awaiter(_this2, void 0, void 0, function* () {
              try {
                if (this.engine.client.currentState !== SignalConnectionState.CONNECTED) {
                  this.log.debug(
                    'deferring track publication until signal is connected',
                    Object.assign(Object.assign({}, this.logContext), {
                      track: getLogContextFromTrack(track),
                    })
                  );
                  const timeout = setTimeout(() => {
                    reject(
                      new PublishTrackError(
                        'publishing rejected as engine not connected within timeout',
                        408
                      )
                    );
                  }, 15000);
                  yield this.waitUntilEngineConnected();
                  clearTimeout(timeout);
                  const publication = yield this.publish(track, opts, isStereo);
                  resolve(publication);
                } else {
                  try {
                    const publication = yield this.publish(track, opts, isStereo);
                    resolve(publication);
                  } catch (e) {
                    reject(e);
                  }
                }
              } catch (e) {
                reject(e);
              }
            })
          );
          _this2.pendingPublishPromises.set(track, publishPromise);
          try {
            const publication = yield publishPromise;
            return publication;
          } catch (e) {
            throw e;
          } finally {
            _this2.pendingPublishPromises.delete(track);
          }
        })();
      });
    }
    waitUntilEngineConnected() {
      if (!this.signalConnectedFuture) {
        this.signalConnectedFuture = new Future();
      }
      return this.signalConnectedFuture.promise;
    }
    hasPermissionsToPublish(track) {
      if (!this.permissions) {
        this.log.warn(
          'no permissions present for publishing track',
          Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track))
        );
        return false;
      }
      const { canPublish, canPublishSources } = this.permissions;
      if (
        canPublish &&
        (canPublishSources.length === 0 ||
          canPublishSources.map((source) => getTrackSourceFromProto(source)).includes(track.source))
      ) {
        return true;
      }
      this.log.warn(
        'insufficient permissions to publish',
        Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track))
      );
      return false;
    }
    publish(track, opts, isStereo) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        if (!this.hasPermissionsToPublish(track)) {
          throw new PublishTrackError('failed to publish track, insufficient permissions', 403);
        }
        const existingTrackOfSource = Array.from(this.trackPublications.values()).find(
          (publishedTrack) => isLocalTrack(track) && publishedTrack.source === track.source
        );
        if (existingTrackOfSource && track.source !== Track.Source.Unknown) {
          this.log.info(
            'publishing a second track with the same source: '.concat(track.source),
            Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track))
          );
        }
        if (opts.stopMicTrackOnMute && isAudioTrack(track)) {
          track.stopOnMute = true;
        }
        if (track.source === Track.Source.ScreenShare && isFireFox()) {
          // Firefox does not work well with simulcasted screen share
          // we frequently get no data on layer 0 when enabled
          opts.simulcast = false;
        }
        // require full AV1/VP9 SVC support prior to using it
        if (opts.videoCodec === 'av1' && !supportsAV1()) {
          opts.videoCodec = undefined;
        }
        if (opts.videoCodec === 'vp9' && !supportsVP9()) {
          opts.videoCodec = undefined;
        }
        if (opts.videoCodec === undefined) {
          opts.videoCodec = defaultVideoCodec;
        }
        if (this.enabledPublishVideoCodecs.length > 0) {
          // fallback to a supported codec if it is not supported
          if (
            !this.enabledPublishVideoCodecs.some(
              (c) => opts.videoCodec === mimeTypeToVideoCodecString(c.mime)
            )
          ) {
            opts.videoCodec = mimeTypeToVideoCodecString(this.enabledPublishVideoCodecs[0].mime);
          }
        }
        const videoCodec = opts.videoCodec;
        // handle track actions
        track.on(TrackEvent.Muted, this.onTrackMuted);
        track.on(TrackEvent.Unmuted, this.onTrackUnmuted);
        track.on(TrackEvent.Ended, this.handleTrackEnded);
        track.on(TrackEvent.UpstreamPaused, this.onTrackUpstreamPaused);
        track.on(TrackEvent.UpstreamResumed, this.onTrackUpstreamResumed);
        track.on(TrackEvent.AudioTrackFeatureUpdate, this.onTrackFeatureUpdate);
        const audioFeatures = [];
        const disableDtx = !((_a = opts.dtx) !== null && _a !== void 0 ? _a : true);
        const settings = track.getSourceTrackSettings();
        if (settings.autoGainControl) {
          audioFeatures.push(AudioTrackFeature.TF_AUTO_GAIN_CONTROL);
        }
        if (settings.echoCancellation) {
          audioFeatures.push(AudioTrackFeature.TF_ECHO_CANCELLATION);
        }
        if (settings.noiseSuppression) {
          audioFeatures.push(AudioTrackFeature.TF_NOISE_SUPPRESSION);
        }
        if (settings.channelCount && settings.channelCount > 1) {
          audioFeatures.push(AudioTrackFeature.TF_STEREO);
        }
        if (disableDtx) {
          audioFeatures.push(AudioTrackFeature.TF_NO_DTX);
        }
        if (isLocalAudioTrack(track) && track.hasPreConnectBuffer) {
          audioFeatures.push(AudioTrackFeature.TF_PRECONNECT_BUFFER);
        }
        // create track publication from track
        const req = new AddTrackRequest({
          // get local track id for use during publishing
          cid: track.mediaStreamTrack.id,
          name: opts.name,
          type: Track.kindToProto(track.kind),
          muted: track.isMuted,
          source: Track.sourceToProto(track.source),
          disableDtx,
          encryption: this.encryptionType,
          stereo: isStereo,
          disableRed:
            this.isE2EEEnabled || !((_b = opts.red) !== null && _b !== void 0 ? _b : true),
          stream: opts === null || opts === void 0 ? void 0 : opts.stream,
          backupCodecPolicy: opts === null || opts === void 0 ? void 0 : opts.backupCodecPolicy,
          audioFeatures,
        });
        // compute encodings and layers for video
        let encodings;
        if (track.kind === Track.Kind.Video) {
          let dims = {
            width: 0,
            height: 0,
          };
          try {
            dims = yield track.waitForDimensions();
          } catch (e) {
            // use defaults, it's quite painful for congestion control without simulcast
            // so using default dims according to publish settings
            const defaultRes =
              (_d =
                (_c = this.roomOptions.videoCaptureDefaults) === null || _c === void 0
                  ? void 0
                  : _c.resolution) !== null && _d !== void 0
                ? _d
                : VideoPresets.h720.resolution;
            dims = {
              width: defaultRes.width,
              height: defaultRes.height,
            };
            // log failure
            this.log.error(
              'could not determine track dimensions, using defaults',
              Object.assign(
                Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)),
                {
                  dims,
                }
              )
            );
          }
          // width and height should be defined for video
          req.width = dims.width;
          req.height = dims.height;
          // for svc codecs, disable simulcast and use vp8 for backup codec
          if (isLocalVideoTrack(track)) {
            if (isSVCCodec(videoCodec)) {
              if (track.source === Track.Source.ScreenShare) {
                // vp9 svc with screenshare cannot encode multiple spatial layers
                // doing so reduces publish resolution to minimal resolution
                opts.scalabilityMode = 'L1T3';
                // Chrome does not allow more than 5 fps with L1T3, and it has encoding bugs with L3T3
                // It has a different path for screenshare handling and it seems to be untested/buggy
                // As a workaround, we are setting contentHint to force it to go through the same
                // path as regular camera video. While this is not optimal, it delivers the performance
                // that we need
                if ('contentHint' in track.mediaStreamTrack) {
                  track.mediaStreamTrack.contentHint = 'motion';
                  this.log.info(
                    'forcing contentHint to motion for screenshare with SVC codecs',
                    Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track))
                  );
                }
              }
              // set scalabilityMode to 'L3T3_KEY' by default
              opts.scalabilityMode =
                (_e = opts.scalabilityMode) !== null && _e !== void 0 ? _e : 'L3T3_KEY';
            }
            req.simulcastCodecs = [
              new SimulcastCodec({
                codec: videoCodec,
                cid: track.mediaStreamTrack.id,
              }),
            ];
            // set up backup
            if (opts.backupCodec === true) {
              opts.backupCodec = {
                codec: defaultVideoCodec,
              };
            }
            if (
              opts.backupCodec &&
              videoCodec !== opts.backupCodec.codec &&
              // TODO remove this once e2ee is supported for backup codecs
              req.encryption === Encryption_Type.NONE
            ) {
              // multi-codec simulcast requires dynacast
              if (!this.roomOptions.dynacast) {
                this.roomOptions.dynacast = true;
              }
              req.simulcastCodecs.push(
                new SimulcastCodec({
                  codec: opts.backupCodec.codec,
                  cid: '',
                })
              );
            }
          }
          encodings = computeVideoEncodings(
            track.source === Track.Source.ScreenShare,
            req.width,
            req.height,
            opts
          );
          req.layers = videoLayersFromEncodings(
            req.width,
            req.height,
            encodings,
            isSVCCodec(opts.videoCodec)
          );
        } else if (track.kind === Track.Kind.Audio) {
          encodings = [
            {
              maxBitrate:
                (_f = opts.audioPreset) === null || _f === void 0 ? void 0 : _f.maxBitrate,
              priority:
                (_h = (_g = opts.audioPreset) === null || _g === void 0 ? void 0 : _g.priority) !==
                  null && _h !== void 0
                  ? _h
                  : 'high',
              networkPriority:
                (_k = (_j = opts.audioPreset) === null || _j === void 0 ? void 0 : _j.priority) !==
                  null && _k !== void 0
                  ? _k
                  : 'high',
            },
          ];
        }
        if (!this.engine || this.engine.isClosed) {
          throw new UnexpectedConnectionState('cannot publish track when not connected');
        }
        const negotiate = () =>
          __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c;
            if (!this.engine.pcManager) {
              throw new UnexpectedConnectionState('pcManager is not ready');
            }
            track.sender = yield this.engine.createSender(track, opts, encodings);
            this.emit(ParticipantEvent.LocalSenderCreated, track.sender, track);
            if (isLocalVideoTrack(track)) {
              (_a = opts.degradationPreference) !== null && _a !== void 0
                ? _a
                : (opts.degradationPreference = getDefaultDegradationPreference(track));
              track.setDegradationPreference(opts.degradationPreference);
            }
            if (encodings) {
              if (isFireFox() && track.kind === Track.Kind.Audio) {
                /* Refer to RFC https://datatracker.ietf.org/doc/html/rfc7587#section-6.1,
               livekit-server uses maxaveragebitrate=510000 in the answer sdp to permit client to
               publish high quality audio track. But firefox always uses this value as the actual
               bitrates, causing the audio bitrates to rise to 510Kbps in any stereo case unexpectedly.
               So the client need to modify maxaverragebitrates in answer sdp to user provided value to
               fix the issue.
             */
                let trackTransceiver = undefined;
                for (const transceiver of this.engine.pcManager.publisher.getTransceivers()) {
                  if (transceiver.sender === track.sender) {
                    trackTransceiver = transceiver;
                    break;
                  }
                }
                if (trackTransceiver) {
                  this.engine.pcManager.publisher.setTrackCodecBitrate({
                    transceiver: trackTransceiver,
                    codec: 'opus',
                    maxbr: ((_b = encodings[0]) === null || _b === void 0 ? void 0 : _b.maxBitrate)
                      ? encodings[0].maxBitrate / 1000
                      : 0,
                  });
                }
              } else if (
                track.codec &&
                isSVCCodec(track.codec) &&
                ((_c = encodings[0]) === null || _c === void 0 ? void 0 : _c.maxBitrate)
              ) {
                this.engine.pcManager.publisher.setTrackCodecBitrate({
                  cid: req.cid,
                  codec: track.codec,
                  maxbr: encodings[0].maxBitrate / 1000,
                });
              }
            }
            yield this.engine.negotiate();
          });
        let ti;
        const addTrackPromise = new Promise((resolve, reject) =>
          __awaiter(this, void 0, void 0, function* () {
            var _a;
            try {
              ti = yield this.engine.addTrack(req);
              resolve(ti);
            } catch (err) {
              if (
                track.sender &&
                ((_a = this.engine.pcManager) === null || _a === void 0 ? void 0 : _a.publisher)
              ) {
                this.engine.pcManager.publisher.removeTrack(track.sender);
                yield this.engine.negotiate().catch((negotiateErr) => {
                  this.log.error(
                    'failed to negotiate after removing track due to failed add track request',
                    Object.assign(
                      Object.assign(
                        Object.assign({}, this.logContext),
                        getLogContextFromTrack(track)
                      ),
                      {
                        error: negotiateErr,
                      }
                    )
                  );
                });
              }
              reject(err);
            }
          })
        );
        if (this.enabledPublishVideoCodecs.length > 0) {
          const rets = yield Promise.all([addTrackPromise, negotiate()]);
          ti = rets[0];
        } else {
          ti = yield addTrackPromise;
          // server might not support the codec the client has requested, in that case, fallback
          // to a supported codec
          let primaryCodecMime;
          ti.codecs.forEach((codec) => {
            if (primaryCodecMime === undefined) {
              primaryCodecMime = codec.mimeType;
            }
          });
          if (primaryCodecMime && track.kind === Track.Kind.Video) {
            const updatedCodec = mimeTypeToVideoCodecString(primaryCodecMime);
            if (updatedCodec !== videoCodec) {
              this.log.debug(
                'falling back to server selected codec',
                Object.assign(
                  Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)),
                  {
                    codec: updatedCodec,
                  }
                )
              );
              opts.videoCodec = updatedCodec;
              // recompute encodings since bitrates/etc could have changed
              encodings = computeVideoEncodings(
                track.source === Track.Source.ScreenShare,
                req.width,
                req.height,
                opts
              );
            }
          }
          yield negotiate();
        }
        const publication = new LocalTrackPublication(track.kind, ti, track, {
          loggerName: this.roomOptions.loggerName,
          loggerContextCb: () => this.logContext,
        });
        publication.on(TrackEvent.CpuConstrained, (constrainedTrack) =>
          this.onTrackCpuConstrained(constrainedTrack, publication)
        );
        // save options for when it needs to be republished again
        publication.options = opts;
        track.sid = ti.sid;
        this.log.debug(
          'publishing '.concat(track.kind, ' with encodings'),
          Object.assign(Object.assign({}, this.logContext), {
            encodings,
            trackInfo: ti,
          })
        );
        if (isLocalVideoTrack(track)) {
          track.startMonitor(this.engine.client);
        } else if (isLocalAudioTrack(track)) {
          track.startMonitor();
        }
        this.addTrackPublication(publication);
        // send event for publication
        this.emit(ParticipantEvent.LocalTrackPublished, publication);
        if (
          isLocalAudioTrack(track) &&
          ti.audioFeatures.includes(AudioTrackFeature.TF_PRECONNECT_BUFFER)
        ) {
          const stream = track.getPreConnectBuffer();
          const mimeType = track.getPreConnectBufferMimeType();
          // TODO: we're registering the listener after negotiation, so there might be a race
          this.on(ParticipantEvent.LocalTrackSubscribed, (pub) => {
            if (pub.trackSid === ti.sid) {
              if (!track.hasPreConnectBuffer) {
                this.log.warn(
                  'subscribe event came to late, buffer already closed',
                  this.logContext
                );
                return;
              }
              this.log.debug(
                'finished recording preconnect buffer',
                Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track))
              );
              track.stopPreConnectBuffer();
            }
          });
          if (stream) {
            const bufferStreamPromise = new Promise((resolve, reject) =>
              __awaiter(this, void 0, void 0, function* () {
                var _a, e_2, _b, _c;
                var _d, _e;
                try {
                  this.log.debug(
                    'waiting for agent',
                    Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track))
                  );
                  const agentActiveTimeout = setTimeout(() => {
                    reject(new Error('agent not active within 10 seconds'));
                  }, 10000);
                  const agent = yield this.waitUntilActiveAgentPresent();
                  clearTimeout(agentActiveTimeout);
                  this.log.debug(
                    'sending preconnect buffer',
                    Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track))
                  );
                  const writer = yield this.streamBytes({
                    name: 'preconnect-buffer',
                    mimeType,
                    topic: 'lk.agent.pre-connect-audio-buffer',
                    destinationIdentities: [agent.identity],
                    attributes: {
                      trackId: publication.trackSid,
                      sampleRate: String(
                        (_d = settings.sampleRate) !== null && _d !== void 0 ? _d : '48000'
                      ),
                      channels: String(
                        (_e = settings.channelCount) !== null && _e !== void 0 ? _e : '1'
                      ),
                    },
                  });
                  try {
                    for (
                      var _f = true, stream_1 = __asyncValues(stream), stream_1_1;
                      (stream_1_1 = yield stream_1.next()), (_a = stream_1_1.done), !_a;
                      _f = true
                    ) {
                      _c = stream_1_1.value;
                      _f = false;
                      const chunk = _c;
                      yield writer.write(chunk);
                    }
                  } catch (e_2_1) {
                    e_2 = {
                      error: e_2_1,
                    };
                  } finally {
                    try {
                      if (!_f && !_a && (_b = stream_1.return)) yield _b.call(stream_1);
                    } finally {
                      if (e_2) throw e_2.error;
                    }
                  }
                  yield writer.close();
                  resolve();
                } catch (e) {
                  reject(e);
                }
              })
            );
            bufferStreamPromise
              .then(() => {
                this.log.debug(
                  'preconnect buffer sent successfully',
                  Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track))
                );
              })
              .catch((e) => {
                this.log.error(
                  'error sending preconnect buffer',
                  Object.assign(
                    Object.assign(
                      Object.assign({}, this.logContext),
                      getLogContextFromTrack(track)
                    ),
                    {
                      error: e,
                    }
                  )
                );
              });
          }
        }
        return publication;
      });
    }
    get isLocal() {
      return true;
    }
    /** @internal
     * publish additional codec to existing track
     */
    publishAdditionalCodecForTrack(track, videoCodec, options) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        // TODO remove once e2ee is supported for backup tracks
        if (this.encryptionType !== Encryption_Type.NONE) {
          return;
        }
        // is it not published? if so skip
        let existingPublication;
        this.trackPublications.forEach((publication) => {
          if (!publication.track) {
            return;
          }
          if (publication.track === track) {
            existingPublication = publication;
          }
        });
        if (!existingPublication) {
          throw new TrackInvalidError('track is not published');
        }
        if (!isLocalVideoTrack(track)) {
          throw new TrackInvalidError('track is not a video track');
        }
        const opts = Object.assign(
          Object.assign(
            {},
            (_a = this.roomOptions) === null || _a === void 0 ? void 0 : _a.publishDefaults
          ),
          options
        );
        const encodings = computeTrackBackupEncodings(track, videoCodec, opts);
        if (!encodings) {
          this.log.info(
            'backup codec has been disabled, ignoring request to add additional codec for track',
            Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track))
          );
          return;
        }
        const simulcastTrack = track.addSimulcastTrack(videoCodec, encodings);
        if (!simulcastTrack) {
          return;
        }
        const req = new AddTrackRequest({
          cid: simulcastTrack.mediaStreamTrack.id,
          type: Track.kindToProto(track.kind),
          muted: track.isMuted,
          source: Track.sourceToProto(track.source),
          sid: track.sid,
          simulcastCodecs: [
            {
              codec: opts.videoCodec,
              cid: simulcastTrack.mediaStreamTrack.id,
            },
          ],
        });
        req.layers = videoLayersFromEncodings(req.width, req.height, encodings);
        if (!this.engine || this.engine.isClosed) {
          throw new UnexpectedConnectionState('cannot publish track when not connected');
        }
        const negotiate = () =>
          __awaiter(this, void 0, void 0, function* () {
            yield this.engine.createSimulcastSender(track, simulcastTrack, opts, encodings);
            yield this.engine.negotiate();
          });
        const rets = yield Promise.all([this.engine.addTrack(req), negotiate()]);
        const ti = rets[0];
        this.log.debug(
          'published '.concat(videoCodec, ' for track ').concat(track.sid),
          Object.assign(Object.assign({}, this.logContext), {
            encodings,
            trackInfo: ti,
          })
        );
      });
    }
    unpublishTrack(track, stopOnUnpublish) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, _b;
        if (isLocalTrack(track)) {
          const publishPromise = this.pendingPublishPromises.get(track);
          if (publishPromise) {
            this.log.info(
              'awaiting publish promise before attempting to unpublish',
              Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track))
            );
            yield publishPromise;
          }
        }
        // look through all published tracks to find the right ones
        const publication = this.getPublicationForTrack(track);
        const pubLogContext = publication ? getLogContextFromTrack(publication) : undefined;
        this.log.debug(
          'unpublishing track',
          Object.assign(Object.assign({}, this.logContext), pubLogContext)
        );
        if (!publication || !publication.track) {
          this.log.warn(
            'track was not unpublished because no publication was found',
            Object.assign(Object.assign({}, this.logContext), pubLogContext)
          );
          return undefined;
        }
        track = publication.track;
        track.off(TrackEvent.Muted, this.onTrackMuted);
        track.off(TrackEvent.Unmuted, this.onTrackUnmuted);
        track.off(TrackEvent.Ended, this.handleTrackEnded);
        track.off(TrackEvent.UpstreamPaused, this.onTrackUpstreamPaused);
        track.off(TrackEvent.UpstreamResumed, this.onTrackUpstreamResumed);
        track.off(TrackEvent.AudioTrackFeatureUpdate, this.onTrackFeatureUpdate);
        if (stopOnUnpublish === undefined) {
          stopOnUnpublish =
            (_b =
              (_a = this.roomOptions) === null || _a === void 0
                ? void 0
                : _a.stopLocalTrackOnUnpublish) !== null && _b !== void 0
              ? _b
              : true;
        }
        if (stopOnUnpublish) {
          track.stop();
        } else {
          track.stopMonitor();
        }
        let negotiationNeeded = false;
        const trackSender = track.sender;
        track.sender = undefined;
        if (
          this.engine.pcManager &&
          this.engine.pcManager.currentState < PCTransportState.FAILED &&
          trackSender
        ) {
          try {
            for (const transceiver of this.engine.pcManager.publisher.getTransceivers()) {
              // if sender is not currently sending (after replaceTrack(null))
              // removeTrack would have no effect.
              // to ensure we end up successfully removing the track, manually set
              // the transceiver to inactive
              if (transceiver.sender === trackSender) {
                transceiver.direction = 'inactive';
                negotiationNeeded = true;
              }
            }
            if (this.engine.removeTrack(trackSender)) {
              negotiationNeeded = true;
            }
            if (isLocalVideoTrack(track)) {
              for (const [, trackInfo] of track.simulcastCodecs) {
                if (trackInfo.sender) {
                  if (this.engine.removeTrack(trackInfo.sender)) {
                    negotiationNeeded = true;
                  }
                  trackInfo.sender = undefined;
                }
              }
              track.simulcastCodecs.clear();
            }
          } catch (e) {
            this.log.warn(
              'failed to unpublish track',
              Object.assign(Object.assign(Object.assign({}, this.logContext), pubLogContext), {
                error: e,
              })
            );
          }
        }
        // remove from our maps
        this.trackPublications.delete(publication.trackSid);
        switch (publication.kind) {
          case Track.Kind.Audio:
            this.audioTrackPublications.delete(publication.trackSid);
            break;
          case Track.Kind.Video:
            this.videoTrackPublications.delete(publication.trackSid);
            break;
        }
        this.emit(ParticipantEvent.LocalTrackUnpublished, publication);
        publication.setTrack(undefined);
        if (negotiationNeeded) {
          yield this.engine.negotiate();
        }
        return publication;
      });
    }
    unpublishTracks(tracks) {
      return __awaiter(this, void 0, void 0, function* () {
        const results = yield Promise.all(tracks.map((track) => this.unpublishTrack(track)));
        return results.filter((track) => !!track);
      });
    }
    republishAllTracks(options_1) {
      return __awaiter(this, arguments, void 0, function (options) {
        var _this3 = this;
        let restartTracks =
          arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        return (function* () {
          if (_this3.republishPromise) {
            yield _this3.republishPromise;
          }
          _this3.republishPromise = new Promise((resolve, reject) =>
            __awaiter(_this3, void 0, void 0, function* () {
              try {
                const localPubs = [];
                this.trackPublications.forEach((pub) => {
                  if (pub.track) {
                    if (options) {
                      pub.options = Object.assign(Object.assign({}, pub.options), options);
                    }
                    localPubs.push(pub);
                  }
                });
                yield Promise.all(
                  localPubs.map((pub) =>
                    __awaiter(this, void 0, void 0, function* () {
                      const track = pub.track;
                      yield this.unpublishTrack(track, false);
                      if (
                        restartTracks &&
                        !track.isMuted &&
                        track.source !== Track.Source.ScreenShare &&
                        track.source !== Track.Source.ScreenShareAudio &&
                        (isLocalAudioTrack(track) || isLocalVideoTrack(track)) &&
                        !track.isUserProvided
                      ) {
                        // generally we need to restart the track before publishing, often a full reconnect
                        // is necessary because computer had gone to sleep.
                        this.log.debug(
                          'restarting existing track',
                          Object.assign(Object.assign({}, this.logContext), {
                            track: pub.trackSid,
                          })
                        );
                        yield track.restartTrack();
                      }
                      yield this.publishOrRepublishTrack(track, pub.options, true);
                    })
                  )
                );
                resolve();
              } catch (error) {
                reject(error);
              } finally {
                this.republishPromise = undefined;
              }
            })
          );
          yield _this3.republishPromise;
        })();
      });
    }
    /**
     * Publish a new data payload to the room. Data will be forwarded to each
     * participant in the room if the destination field in publishOptions is empty
     *
     * @param data Uint8Array of the payload. To send string data, use TextEncoder.encode
     * @param options optionally specify a `reliable`, `topic` and `destination`
     */
    publishData(data_1) {
      return __awaiter(this, arguments, void 0, function (data) {
        var _this4 = this;
        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        return (function* () {
          const kind = options.reliable ? DataPacket_Kind.RELIABLE : DataPacket_Kind.LOSSY;
          const destinationIdentities = options.destinationIdentities;
          const topic = options.topic;
          let userPacket = new UserPacket({
            participantIdentity: _this4.identity,
            payload: data,
            destinationIdentities,
            topic,
          });
          const packet = new DataPacket({
            kind: kind,
            value: {
              case: 'user',
              value: userPacket,
            },
          });
          yield _this4.engine.sendDataPacket(packet, kind);
        })();
      });
    }
    /**
     * Publish SIP DTMF message to the room.
     *
     * @param code DTMF code
     * @param digit DTMF digit
     */
    publishDtmf(code, digit) {
      return __awaiter(this, void 0, void 0, function* () {
        const packet = new DataPacket({
          kind: DataPacket_Kind.RELIABLE,
          value: {
            case: 'sipDtmf',
            value: new SipDTMF({
              code: code,
              digit: digit,
            }),
          },
        });
        yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);
      });
    }
    /** @deprecated Consider migrating to {@link sendText} */
    sendChatMessage(text, options) {
      return __awaiter(this, void 0, void 0, function* () {
        const msg = {
          id: crypto.randomUUID(),
          message: text,
          timestamp: Date.now(),
          attachedFiles: options === null || options === void 0 ? void 0 : options.attachments,
        };
        const packet = new DataPacket({
          value: {
            case: 'chatMessage',
            value: new ChatMessage(
              Object.assign(Object.assign({}, msg), {
                timestamp: protoInt64.parse(msg.timestamp),
              })
            ),
          },
        });
        yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);
        this.emit(ParticipantEvent.ChatMessage, msg);
        return msg;
      });
    }
    /** @deprecated Consider migrating to {@link sendText} */
    editChatMessage(editText, originalMessage) {
      return __awaiter(this, void 0, void 0, function* () {
        const msg = Object.assign(Object.assign({}, originalMessage), {
          message: editText,
          editTimestamp: Date.now(),
        });
        const packet = new DataPacket({
          value: {
            case: 'chatMessage',
            value: new ChatMessage(
              Object.assign(Object.assign({}, msg), {
                timestamp: protoInt64.parse(msg.timestamp),
                editTimestamp: protoInt64.parse(msg.editTimestamp),
              })
            ),
          },
        });
        yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);
        this.emit(ParticipantEvent.ChatMessage, msg);
        return msg;
      });
    }
    /**
     * Sends the given string to participants in the room via the data channel.
     * For longer messages, consider using {@link streamText} instead.
     *
     * @param text The text payload
     * @param options.topic Topic identifier used to route the stream to appropriate handlers.
     */
    sendText(text, options) {
      return __awaiter(this, void 0, void 0, function* () {
        return this.roomOutgoingDataStreamManager.sendText(text, options);
      });
    }
    /**
     * Creates a new TextStreamWriter which can be used to stream text incrementally
     * to participants in the room via the data channel.
     *
     * @param options.topic Topic identifier used to route the stream to appropriate handlers.
     *
     * @internal
     * @experimental CAUTION, might get removed in a minor release
     */
    streamText(options) {
      return __awaiter(this, void 0, void 0, function* () {
        return this.roomOutgoingDataStreamManager.streamText(options);
      });
    }
    /** Send a File to all participants in the room via the data channel.
     * @param file The File object payload
     * @param options.topic Topic identifier used to route the stream to appropriate handlers.
     * @param options.onProgress A callback function used to monitor the upload progress percentage.
     */
    sendFile(file, options) {
      return __awaiter(this, void 0, void 0, function* () {
        return this.roomOutgoingDataStreamManager.sendFile(file, options);
      });
    }
    /**
     * Stream bytes incrementally to participants in the room via the data channel.
     * For sending files, consider using {@link sendFile} instead.
     *
     * @param options.topic Topic identifier used to route the stream to appropriate handlers.
     */
    streamBytes(options) {
      return __awaiter(this, void 0, void 0, function* () {
        return this.roomOutgoingDataStreamManager.streamBytes(options);
      });
    }
    /**
     * Initiate an RPC call to a remote participant
     * @param params - Parameters for initiating the RPC call, see {@link PerformRpcParams}
     * @returns A promise that resolves with the response payload or rejects with an error.
     * @throws Error on failure. Details in `message`.
     */
    performRpc(_a) {
      return __awaiter(this, arguments, void 0, function (_ref3) {
        var _this5 = this;
        let { destinationIdentity, method, payload, responseTimeout = 10000 } = _ref3;
        return (function* () {
          const maxRoundTripLatency = 2000;
          return new Promise((resolve, reject) =>
            __awaiter(_this5, void 0, void 0, function* () {
              var _a, _b, _c, _d;
              if (byteLength(payload) > MAX_PAYLOAD_BYTES) {
                reject(RpcError.builtIn('REQUEST_PAYLOAD_TOO_LARGE'));
                return;
              }
              if (
                ((_b =
                  (_a = this.engine.latestJoinResponse) === null || _a === void 0
                    ? void 0
                    : _a.serverInfo) === null || _b === void 0
                  ? void 0
                  : _b.version) &&
                compareVersions(
                  (_d =
                    (_c = this.engine.latestJoinResponse) === null || _c === void 0
                      ? void 0
                      : _c.serverInfo) === null || _d === void 0
                    ? void 0
                    : _d.version,
                  '1.8.0'
                ) < 0
              ) {
                reject(RpcError.builtIn('UNSUPPORTED_SERVER'));
                return;
              }
              const id = crypto.randomUUID();
              yield this.publishRpcRequest(
                destinationIdentity,
                id,
                method,
                payload,
                responseTimeout - maxRoundTripLatency
              );
              const ackTimeoutId = setTimeout(() => {
                this.pendingAcks.delete(id);
                reject(RpcError.builtIn('CONNECTION_TIMEOUT'));
                this.pendingResponses.delete(id);
                clearTimeout(responseTimeoutId);
              }, maxRoundTripLatency);
              this.pendingAcks.set(id, {
                resolve: () => {
                  clearTimeout(ackTimeoutId);
                },
                participantIdentity: destinationIdentity,
              });
              const responseTimeoutId = setTimeout(() => {
                this.pendingResponses.delete(id);
                reject(RpcError.builtIn('RESPONSE_TIMEOUT'));
              }, responseTimeout);
              this.pendingResponses.set(id, {
                resolve: (responsePayload, responseError) => {
                  clearTimeout(responseTimeoutId);
                  if (this.pendingAcks.has(id)) {
                    console.warn('RPC response received before ack', id);
                    this.pendingAcks.delete(id);
                    clearTimeout(ackTimeoutId);
                  }
                  if (responseError) {
                    reject(responseError);
                  } else {
                    resolve(
                      responsePayload !== null && responsePayload !== void 0 ? responsePayload : ''
                    );
                  }
                },
                participantIdentity: destinationIdentity,
              });
            })
          );
        })();
      });
    }
    /**
     * @deprecated use `room.registerRpcMethod` instead
     */
    registerRpcMethod(method, handler) {
      if (this.rpcHandlers.has(method)) {
        this.log.warn(
          "you're overriding the RPC handler for method ".concat(
            method,
            ', in the future this will throw an error'
          )
        );
      }
      this.rpcHandlers.set(method, handler);
    }
    /**
     * @deprecated use `room.unregisterRpcMethod` instead
     */
    unregisterRpcMethod(method) {
      this.rpcHandlers.delete(method);
    }
    /**
     * Control who can subscribe to LocalParticipant's published tracks.
     *
     * By default, all participants can subscribe. This allows fine-grained control over
     * who is able to subscribe at a participant and track level.
     *
     * Note: if access is given at a track-level (i.e. both [allParticipantsAllowed] and
     * [ParticipantTrackPermission.allTracksAllowed] are false), any newer published tracks
     * will not grant permissions to any participants and will require a subsequent
     * permissions update to allow subscription.
     *
     * @param allParticipantsAllowed Allows all participants to subscribe all tracks.
     *  Takes precedence over [[participantTrackPermissions]] if set to true.
     *  By default this is set to true.
     * @param participantTrackPermissions Full list of individual permissions per
     *  participant/track. Any omitted participants will not receive any permissions.
     */
    setTrackSubscriptionPermissions(allParticipantsAllowed) {
      let participantTrackPermissions =
        arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      this.participantTrackPermissions = participantTrackPermissions;
      this.allParticipantsAllowedToSubscribe = allParticipantsAllowed;
      if (!this.engine.client.isDisconnected) {
        this.updateTrackSubscriptionPermissions();
      }
    }
    handleIncomingRpcAck(requestId) {
      const handler = this.pendingAcks.get(requestId);
      if (handler) {
        handler.resolve();
        this.pendingAcks.delete(requestId);
      } else {
        console.error('Ack received for unexpected RPC request', requestId);
      }
    }
    handleIncomingRpcResponse(requestId, payload, error) {
      const handler = this.pendingResponses.get(requestId);
      if (handler) {
        handler.resolve(payload, error);
        this.pendingResponses.delete(requestId);
      } else {
        console.error('Response received for unexpected RPC request', requestId);
      }
    }
    /** @internal */
    publishRpcRequest(destinationIdentity, requestId, method, payload, responseTimeout) {
      return __awaiter(this, void 0, void 0, function* () {
        const packet = new DataPacket({
          destinationIdentities: [destinationIdentity],
          kind: DataPacket_Kind.RELIABLE,
          value: {
            case: 'rpcRequest',
            value: new RpcRequest({
              id: requestId,
              method,
              payload,
              responseTimeoutMs: responseTimeout,
              version: 1,
            }),
          },
        });
        yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);
      });
    }
    /** @internal */
    handleParticipantDisconnected(participantIdentity) {
      for (const [id, { participantIdentity: pendingIdentity }] of this.pendingAcks) {
        if (pendingIdentity === participantIdentity) {
          this.pendingAcks.delete(id);
        }
      }
      for (const [id, { participantIdentity: pendingIdentity, resolve }] of this.pendingResponses) {
        if (pendingIdentity === participantIdentity) {
          resolve(null, RpcError.builtIn('RECIPIENT_DISCONNECTED'));
          this.pendingResponses.delete(id);
        }
      }
    }
    /** @internal */
    setEnabledPublishCodecs(codecs) {
      this.enabledPublishVideoCodecs = codecs.filter(
        (c) => c.mime.split('/')[0].toLowerCase() === 'video'
      );
    }
    /** @internal */
    updateInfo(info) {
      if (!super.updateInfo(info)) {
        return false;
      }
      // reconcile track mute status.
      // if server's track mute status doesn't match actual, we'll have to update
      // the server's copy
      info.tracks.forEach((ti) => {
        var _a, _b;
        const pub = this.trackPublications.get(ti.sid);
        if (pub) {
          const mutedOnServer =
            pub.isMuted ||
            ((_b = (_a = pub.track) === null || _a === void 0 ? void 0 : _a.isUpstreamPaused) !==
              null && _b !== void 0
              ? _b
              : false);
          if (mutedOnServer !== ti.muted) {
            this.log.debug(
              'updating server mute state after reconcile',
              Object.assign(
                Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(pub)),
                {
                  mutedOnServer,
                }
              )
            );
            this.engine.client.sendMuteTrack(ti.sid, mutedOnServer);
          }
        }
      });
      return true;
    }
    /** @internal */
    setActiveAgent(agent) {
      var _a, _b, _c, _d;
      this.firstActiveAgent = agent;
      if (agent && !this.firstActiveAgent) {
        this.firstActiveAgent = agent;
      }
      if (agent) {
        (_b = (_a = this.activeAgentFuture) === null || _a === void 0 ? void 0 : _a.resolve) ===
          null || _b === void 0
          ? void 0
          : _b.call(_a, agent);
      } else {
        (_d = (_c = this.activeAgentFuture) === null || _c === void 0 ? void 0 : _c.reject) ===
          null || _d === void 0
          ? void 0
          : _d.call(_c, 'Agent disconnected');
      }
      this.activeAgentFuture = undefined;
    }
    waitUntilActiveAgentPresent() {
      if (this.firstActiveAgent) {
        return Promise.resolve(this.firstActiveAgent);
      }
      if (!this.activeAgentFuture) {
        this.activeAgentFuture = new Future();
      }
      return this.activeAgentFuture.promise;
    }
    getPublicationForTrack(track) {
      let publication;
      this.trackPublications.forEach((pub) => {
        const localTrack = pub.track;
        if (!localTrack) {
          return;
        }
        // this looks overly complicated due to this object tree
        if (track instanceof MediaStreamTrack) {
          if (isLocalAudioTrack(localTrack) || isLocalVideoTrack(localTrack)) {
            if (localTrack.mediaStreamTrack === track) {
              publication = pub;
            }
          }
        } else if (track === localTrack) {
          publication = pub;
        }
      });
      return publication;
    }
    waitForPendingPublicationOfSource(source) {
      return __awaiter(this, void 0, void 0, function* () {
        const waitForPendingTimeout = 10000;
        const startTime = Date.now();
        while (Date.now() < startTime + waitForPendingTimeout) {
          const publishPromiseEntry = Array.from(this.pendingPublishPromises.entries()).find(
            (_ref4) => {
              let [pendingTrack] = _ref4;
              return pendingTrack.source === source;
            }
          );
          if (publishPromiseEntry) {
            return publishPromiseEntry[1];
          }
          yield sleep(20);
        }
      });
    }
  }

  class RemoteTrackPublication extends TrackPublication {
    constructor(kind, ti, autoSubscribe, loggerOptions) {
      super(kind, ti.sid, ti.name, loggerOptions);
      this.track = undefined;
      /** @internal */
      this.allowed = true;
      this.requestedDisabled = undefined;
      this.visible = true;
      this.handleEnded = (track) => {
        this.setTrack(undefined);
        this.emit(TrackEvent.Ended, track);
      };
      this.handleVisibilityChange = (visible) => {
        this.log.debug(
          'adaptivestream video visibility '.concat(this.trackSid, ', visible=').concat(visible),
          this.logContext
        );
        this.visible = visible;
        this.emitTrackUpdate();
      };
      this.handleVideoDimensionsChange = (dimensions) => {
        this.log.debug(
          'adaptivestream video dimensions '
            .concat(dimensions.width, 'x')
            .concat(dimensions.height),
          this.logContext
        );
        this.videoDimensionsAdaptiveStream = dimensions;
        this.emitTrackUpdate();
      };
      this.subscribed = autoSubscribe;
      this.updateInfo(ti);
    }
    /**
     * Subscribe or unsubscribe to this remote track
     * @param subscribed true to subscribe to a track, false to unsubscribe
     */
    setSubscribed(subscribed) {
      const prevStatus = this.subscriptionStatus;
      const prevPermission = this.permissionStatus;
      this.subscribed = subscribed;
      // reset allowed status when desired subscription state changes
      // server will notify client via signal message if it's not allowed
      if (subscribed) {
        this.allowed = true;
      }
      const sub = new UpdateSubscription({
        trackSids: [this.trackSid],
        subscribe: this.subscribed,
        participantTracks: [
          new ParticipantTracks({
            // sending an empty participant id since TrackPublication doesn't keep it
            // this is filled in by the participant that receives this message
            participantSid: '',
            trackSids: [this.trackSid],
          }),
        ],
      });
      this.emit(TrackEvent.UpdateSubscription, sub);
      this.emitSubscriptionUpdateIfChanged(prevStatus);
      this.emitPermissionUpdateIfChanged(prevPermission);
    }
    get subscriptionStatus() {
      if (this.subscribed === false) {
        return TrackPublication.SubscriptionStatus.Unsubscribed;
      }
      if (!super.isSubscribed) {
        return TrackPublication.SubscriptionStatus.Desired;
      }
      return TrackPublication.SubscriptionStatus.Subscribed;
    }
    get permissionStatus() {
      return this.allowed
        ? TrackPublication.PermissionStatus.Allowed
        : TrackPublication.PermissionStatus.NotAllowed;
    }
    /**
     * Returns true if track is subscribed, and ready for playback
     */
    get isSubscribed() {
      if (this.subscribed === false) {
        return false;
      }
      return super.isSubscribed;
    }
    // returns client's desire to subscribe to a track, also true if autoSubscribe is enabled
    get isDesired() {
      return this.subscribed !== false;
    }
    get isEnabled() {
      return this.requestedDisabled !== undefined
        ? !this.requestedDisabled
        : this.isAdaptiveStream
          ? this.visible
          : true;
    }
    get isLocal() {
      return false;
    }
    /**
     * disable server from sending down data for this track. this is useful when
     * the participant is off screen, you may disable streaming down their video
     * to reduce bandwidth requirements
     * @param enabled
     */
    setEnabled(enabled) {
      if (!this.isManualOperationAllowed() || this.requestedDisabled === !enabled) {
        return;
      }
      this.requestedDisabled = !enabled;
      this.emitTrackUpdate();
    }
    /**
     * for tracks that support simulcasting, adjust subscribed quality
     *
     * This indicates the highest quality the client can accept. if network
     * bandwidth does not allow, server will automatically reduce quality to
     * optimize for uninterrupted video
     */
    setVideoQuality(quality) {
      if (!this.isManualOperationAllowed() || this.requestedMaxQuality === quality) {
        return;
      }
      this.requestedMaxQuality = quality;
      this.requestedVideoDimensions = undefined;
      this.emitTrackUpdate();
    }
    /**
     * Explicitly set the video dimensions for this track.
     *
     * This will take precedence over adaptive stream dimensions.
     *
     * @param dimensions The video dimensions to set.
     */
    setVideoDimensions(dimensions) {
      var _a, _b;
      if (!this.isManualOperationAllowed()) {
        return;
      }
      if (
        ((_a = this.requestedVideoDimensions) === null || _a === void 0 ? void 0 : _a.width) ===
          dimensions.width &&
        ((_b = this.requestedVideoDimensions) === null || _b === void 0 ? void 0 : _b.height) ===
          dimensions.height
      ) {
        return;
      }
      if (isRemoteVideoTrack(this.track)) {
        this.requestedVideoDimensions = dimensions;
      }
      this.requestedMaxQuality = undefined;
      this.emitTrackUpdate();
    }
    setVideoFPS(fps) {
      if (!this.isManualOperationAllowed()) {
        return;
      }
      if (!isRemoteVideoTrack(this.track)) {
        return;
      }
      if (this.fps === fps) {
        return;
      }
      this.fps = fps;
      this.emitTrackUpdate();
    }
    get videoQuality() {
      var _a;
      return (_a = this.requestedMaxQuality) !== null && _a !== void 0 ? _a : VideoQuality.HIGH;
    }
    /** @internal */
    setTrack(track) {
      const prevStatus = this.subscriptionStatus;
      const prevPermission = this.permissionStatus;
      const prevTrack = this.track;
      if (prevTrack === track) {
        return;
      }
      if (prevTrack) {
        // unregister listener
        prevTrack.off(TrackEvent.VideoDimensionsChanged, this.handleVideoDimensionsChange);
        prevTrack.off(TrackEvent.VisibilityChanged, this.handleVisibilityChange);
        prevTrack.off(TrackEvent.Ended, this.handleEnded);
        prevTrack.detach();
        prevTrack.stopMonitor();
        this.emit(TrackEvent.Unsubscribed, prevTrack);
      }
      super.setTrack(track);
      if (track) {
        track.sid = this.trackSid;
        track.on(TrackEvent.VideoDimensionsChanged, this.handleVideoDimensionsChange);
        track.on(TrackEvent.VisibilityChanged, this.handleVisibilityChange);
        track.on(TrackEvent.Ended, this.handleEnded);
        this.emit(TrackEvent.Subscribed, track);
      }
      this.emitPermissionUpdateIfChanged(prevPermission);
      this.emitSubscriptionUpdateIfChanged(prevStatus);
    }
    /** @internal */
    setAllowed(allowed) {
      const prevStatus = this.subscriptionStatus;
      const prevPermission = this.permissionStatus;
      this.allowed = allowed;
      this.emitPermissionUpdateIfChanged(prevPermission);
      this.emitSubscriptionUpdateIfChanged(prevStatus);
    }
    /** @internal */
    setSubscriptionError(error) {
      this.emit(TrackEvent.SubscriptionFailed, error);
    }
    /** @internal */
    updateInfo(info) {
      super.updateInfo(info);
      const prevMetadataMuted = this.metadataMuted;
      this.metadataMuted = info.muted;
      if (this.track) {
        this.track.setMuted(info.muted);
      } else if (prevMetadataMuted !== info.muted) {
        this.emit(info.muted ? TrackEvent.Muted : TrackEvent.Unmuted);
      }
    }
    emitSubscriptionUpdateIfChanged(previousStatus) {
      const currentStatus = this.subscriptionStatus;
      if (previousStatus === currentStatus) {
        return;
      }
      this.emit(TrackEvent.SubscriptionStatusChanged, currentStatus, previousStatus);
    }
    emitPermissionUpdateIfChanged(previousPermissionStatus) {
      const currentPermissionStatus = this.permissionStatus;
      if (currentPermissionStatus !== previousPermissionStatus) {
        this.emit(
          TrackEvent.SubscriptionPermissionChanged,
          this.permissionStatus,
          previousPermissionStatus
        );
      }
    }
    isManualOperationAllowed() {
      if (!this.isDesired) {
        this.log.warn('cannot update track settings when not subscribed', this.logContext);
        return false;
      }
      return true;
    }
    get isAdaptiveStream() {
      return isRemoteVideoTrack(this.track) && this.track.isAdaptiveStream;
    }
    /* @internal */
    emitTrackUpdate() {
      const settings = new UpdateTrackSettings({
        trackSids: [this.trackSid],
        disabled: !this.isEnabled,
        fps: this.fps,
      });
      if (this.kind === Track.Kind.Video) {
        let minDimensions = this.requestedVideoDimensions;
        if (this.videoDimensionsAdaptiveStream !== undefined) {
          if (minDimensions) {
            // check whether the adaptive stream dimensions are smaller than the requested dimensions and use smaller one
            const smallerAdaptive = areDimensionsSmaller(
              this.videoDimensionsAdaptiveStream,
              minDimensions
            );
            if (smallerAdaptive) {
              this.log.debug(
                'using adaptive stream dimensions instead of requested',
                Object.assign(
                  Object.assign({}, this.logContext),
                  this.videoDimensionsAdaptiveStream
                )
              );
              minDimensions = this.videoDimensionsAdaptiveStream;
            }
          } else if (this.requestedMaxQuality !== undefined && this.trackInfo) {
            // check whether adaptive stream dimensions are smaller than the max quality layer and use smaller one
            const maxQualityLayer = layerDimensionsFor(this.trackInfo, this.requestedMaxQuality);
            if (
              maxQualityLayer &&
              areDimensionsSmaller(this.videoDimensionsAdaptiveStream, maxQualityLayer)
            ) {
              this.log.debug(
                'using adaptive stream dimensions instead of max quality layer',
                Object.assign(
                  Object.assign({}, this.logContext),
                  this.videoDimensionsAdaptiveStream
                )
              );
              minDimensions = this.videoDimensionsAdaptiveStream;
            }
          } else {
            this.log.debug(
              'using adaptive stream dimensions',
              Object.assign(Object.assign({}, this.logContext), this.videoDimensionsAdaptiveStream)
            );
            minDimensions = this.videoDimensionsAdaptiveStream;
          }
        }
        if (minDimensions) {
          settings.width = Math.ceil(minDimensions.width);
          settings.height = Math.ceil(minDimensions.height);
        } else if (this.requestedMaxQuality !== undefined) {
          this.log.debug(
            'using requested max quality',
            Object.assign(Object.assign({}, this.logContext), {
              quality: this.requestedMaxQuality,
            })
          );
          settings.quality = this.requestedMaxQuality;
        } else {
          this.log.debug(
            'using default quality',
            Object.assign(Object.assign({}, this.logContext), {
              quality: VideoQuality.HIGH,
            })
          );
          // defaults to high quality
          settings.quality = VideoQuality.HIGH;
        }
      }
      this.emit(TrackEvent.UpdateSettings, settings);
    }
  }

  class RemoteParticipant extends Participant {
    /** @internal */
    static fromParticipantInfo(signalClient, pi, loggerOptions) {
      return new RemoteParticipant(
        signalClient,
        pi.sid,
        pi.identity,
        pi.name,
        pi.metadata,
        pi.attributes,
        loggerOptions,
        pi.kind
      );
    }
    get logContext() {
      return Object.assign(Object.assign({}, super.logContext), {
        rpID: this.sid,
        remoteParticipant: this.identity,
      });
    }
    /** @internal */
    constructor(signalClient, sid, identity, name, metadata, attributes, loggerOptions) {
      let kind =
        arguments.length > 7 && arguments[7] !== undefined
          ? arguments[7]
          : ParticipantInfo_Kind.STANDARD;
      super(sid, identity || '', name, metadata, attributes, loggerOptions, kind);
      this.signalClient = signalClient;
      this.trackPublications = new Map();
      this.audioTrackPublications = new Map();
      this.videoTrackPublications = new Map();
      this.volumeMap = new Map();
    }
    addTrackPublication(publication) {
      super.addTrackPublication(publication);
      // register action events
      publication.on(TrackEvent.UpdateSettings, (settings) => {
        this.log.debug(
          'send update settings',
          Object.assign(
            Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(publication)),
            {
              settings,
            }
          )
        );
        this.signalClient.sendUpdateTrackSettings(settings);
      });
      publication.on(TrackEvent.UpdateSubscription, (sub) => {
        sub.participantTracks.forEach((pt) => {
          pt.participantSid = this.sid;
        });
        this.signalClient.sendUpdateSubscription(sub);
      });
      publication.on(TrackEvent.SubscriptionPermissionChanged, (status) => {
        this.emit(ParticipantEvent.TrackSubscriptionPermissionChanged, publication, status);
      });
      publication.on(TrackEvent.SubscriptionStatusChanged, (status) => {
        this.emit(ParticipantEvent.TrackSubscriptionStatusChanged, publication, status);
      });
      publication.on(TrackEvent.Subscribed, (track) => {
        this.emit(ParticipantEvent.TrackSubscribed, track, publication);
      });
      publication.on(TrackEvent.Unsubscribed, (previousTrack) => {
        this.emit(ParticipantEvent.TrackUnsubscribed, previousTrack, publication);
      });
      publication.on(TrackEvent.SubscriptionFailed, (error) => {
        this.emit(ParticipantEvent.TrackSubscriptionFailed, publication.trackSid, error);
      });
    }
    getTrackPublication(source) {
      const track = super.getTrackPublication(source);
      if (track) {
        return track;
      }
    }
    getTrackPublicationByName(name) {
      const track = super.getTrackPublicationByName(name);
      if (track) {
        return track;
      }
    }
    /**
     * sets the volume on the participant's audio track
     * by default, this affects the microphone publication
     * a different source can be passed in as a second argument
     * if no track exists the volume will be applied when the microphone track is added
     */
    setVolume(volume) {
      let source =
        arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Track.Source.Microphone;
      this.volumeMap.set(source, volume);
      const audioPublication = this.getTrackPublication(source);
      if (audioPublication && audioPublication.track) {
        audioPublication.track.setVolume(volume);
      }
    }
    /**
     * gets the volume on the participant's microphone track
     */
    getVolume() {
      let source =
        arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Track.Source.Microphone;
      const audioPublication = this.getTrackPublication(source);
      if (audioPublication && audioPublication.track) {
        return audioPublication.track.getVolume();
      }
      return this.volumeMap.get(source);
    }
    /** @internal */
    addSubscribedMediaTrack(
      mediaTrack,
      sid,
      mediaStream,
      receiver,
      adaptiveStreamSettings,
      triesLeft
    ) {
      // find the track publication
      // it's possible for the media track to arrive before participant info
      let publication = this.getTrackPublicationBySid(sid);
      // it's also possible that the browser didn't honor our original track id
      // FireFox would use its own local uuid instead of server track id
      if (!publication) {
        if (!sid.startsWith('TR')) {
          // find the first track that matches type
          this.trackPublications.forEach((p) => {
            if (!publication && mediaTrack.kind === p.kind.toString()) {
              publication = p;
            }
          });
        }
      }
      // when we couldn't locate the track, it's possible that the metadata hasn't
      // yet arrived. Wait a bit longer for it to arrive, or fire an error
      if (!publication) {
        if (triesLeft === 0) {
          this.log.error(
            'could not find published track',
            Object.assign(Object.assign({}, this.logContext), {
              trackSid: sid,
            })
          );
          this.emit(ParticipantEvent.TrackSubscriptionFailed, sid);
          return;
        }
        if (triesLeft === undefined) triesLeft = 20;
        setTimeout(() => {
          this.addSubscribedMediaTrack(
            mediaTrack,
            sid,
            mediaStream,
            receiver,
            adaptiveStreamSettings,
            triesLeft - 1
          );
        }, 150);
        return;
      }
      if (mediaTrack.readyState === 'ended') {
        this.log.error(
          'unable to subscribe because MediaStreamTrack is ended. Do not call MediaStreamTrack.stop()',
          Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(publication))
        );
        this.emit(ParticipantEvent.TrackSubscriptionFailed, sid);
        return;
      }
      const isVideo = mediaTrack.kind === 'video';
      let track;
      if (isVideo) {
        track = new RemoteVideoTrack(mediaTrack, sid, receiver, adaptiveStreamSettings);
      } else {
        track = new RemoteAudioTrack(
          mediaTrack,
          sid,
          receiver,
          this.audioContext,
          this.audioOutput
        );
      }
      // set track info
      track.source = publication.source;
      // keep publication's muted status
      track.isMuted = publication.isMuted;
      track.setMediaStream(mediaStream);
      track.start();
      publication.setTrack(track);
      // set participant volumes on new audio tracks
      if (this.volumeMap.has(publication.source) && isRemoteTrack(track) && isAudioTrack(track)) {
        track.setVolume(this.volumeMap.get(publication.source));
      }
      return publication;
    }
    /** @internal */
    get hasMetadata() {
      return !!this.participantInfo;
    }
    /**
     * @internal
     */
    getTrackPublicationBySid(sid) {
      return this.trackPublications.get(sid);
    }
    /** @internal */
    updateInfo(info) {
      if (!super.updateInfo(info)) {
        return false;
      }
      // we are getting a list of all available tracks, reconcile in here
      // and send out events for changes
      // reconcile track publications, publish events only if metadata is already there
      // i.e. changes since the local participant has joined
      const validTracks = new Map();
      const newTracks = new Map();
      info.tracks.forEach((ti) => {
        var _a, _b;
        let publication = this.getTrackPublicationBySid(ti.sid);
        if (!publication) {
          // new publication
          const kind = Track.kindFromProto(ti.type);
          if (!kind) {
            return;
          }
          publication = new RemoteTrackPublication(
            kind,
            ti,
            (_a = this.signalClient.connectOptions) === null || _a === void 0
              ? void 0
              : _a.autoSubscribe,
            {
              loggerContextCb: () => this.logContext,
              loggerName:
                (_b = this.loggerOptions) === null || _b === void 0 ? void 0 : _b.loggerName,
            }
          );
          publication.updateInfo(ti);
          newTracks.set(ti.sid, publication);
          const existingTrackOfSource = Array.from(this.trackPublications.values()).find(
            (publishedTrack) =>
              publishedTrack.source ===
              (publication === null || publication === void 0 ? void 0 : publication.source)
          );
          if (existingTrackOfSource && publication.source !== Track.Source.Unknown) {
            this.log.debug(
              'received a second track publication for '
                .concat(this.identity, ' with the same source: ')
                .concat(publication.source),
              Object.assign(Object.assign({}, this.logContext), {
                oldTrack: getLogContextFromTrack(existingTrackOfSource),
                newTrack: getLogContextFromTrack(publication),
              })
            );
          }
          this.addTrackPublication(publication);
        } else {
          publication.updateInfo(ti);
        }
        validTracks.set(ti.sid, publication);
      });
      // detect removed tracks
      this.trackPublications.forEach((publication) => {
        if (!validTracks.has(publication.trackSid)) {
          this.log.trace(
            'detected removed track on remote participant, unpublishing',
            Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(publication))
          );
          this.unpublishTrack(publication.trackSid, true);
        }
      });
      // always emit events for new publications, Room will not forward them unless it's ready
      newTracks.forEach((publication) => {
        this.emit(ParticipantEvent.TrackPublished, publication);
      });
      return true;
    }
    /** @internal */
    unpublishTrack(sid, sendUnpublish) {
      const publication = this.trackPublications.get(sid);
      if (!publication) {
        return;
      }
      // also send unsubscribe, if track is actively subscribed
      const { track } = publication;
      if (track) {
        track.stop();
        publication.setTrack(undefined);
      }
      // remove track from maps only after unsubscribed has been fired
      this.trackPublications.delete(sid);
      // remove from the right type map
      switch (publication.kind) {
        case Track.Kind.Audio:
          this.audioTrackPublications.delete(sid);
          break;
        case Track.Kind.Video:
          this.videoTrackPublications.delete(sid);
          break;
      }
      if (sendUnpublish) {
        this.emit(ParticipantEvent.TrackUnpublished, publication);
      }
    }
    /**
     * @internal
     */
    setAudioOutput(output) {
      return __awaiter(this, void 0, void 0, function* () {
        this.audioOutput = output;
        const promises = [];
        this.audioTrackPublications.forEach((pub) => {
          var _a;
          if (isAudioTrack(pub.track) && isRemoteTrack(pub.track)) {
            promises.push(
              pub.track.setSinkId((_a = output.deviceId) !== null && _a !== void 0 ? _a : 'default')
            );
          }
        });
        yield Promise.all(promises);
      });
    }
    /** @internal */
    emit(event) {
      for (
        var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1;
        _key < _len;
        _key++
      ) {
        args[_key - 1] = arguments[_key];
      }
      this.log.trace(
        'participant event',
        Object.assign(Object.assign({}, this.logContext), {
          event,
          args,
        })
      );
      return super.emit(event, ...args);
    }
  }

  var ConnectionState;
  (function (ConnectionState) {
    ConnectionState['Disconnected'] = 'disconnected';
    ConnectionState['Connecting'] = 'connecting';
    ConnectionState['Connected'] = 'connected';
    ConnectionState['Reconnecting'] = 'reconnecting';
    ConnectionState['SignalReconnecting'] = 'signalReconnecting';
  })(ConnectionState || (ConnectionState = {}));
  const connectionReconcileFrequency = 4 * 1000;
  /**
   * In LiveKit, a room is the logical grouping for a list of participants.
   * Participants in a room can publish tracks, and subscribe to others' tracks.
   *
   * a Room fires [[RoomEvent | RoomEvents]].
   *
   * @noInheritDoc
   */
  class Room extends eventsExports.EventEmitter {
    get hasE2EESetup() {
      return this.e2eeManager !== undefined;
    }
    /**
     * Creates a new Room, the primary construct for a LiveKit session.
     * @param options
     */
    constructor(options) {
      var _this;
      var _a, _b, _c;
      super();
      _this = this;
      this.state = ConnectionState.Disconnected;
      /**
       * list of participants that are actively speaking. when this changes
       * a [[RoomEvent.ActiveSpeakersChanged]] event is fired
       */
      this.activeSpeakers = [];
      /** reflects the sender encryption status of the local participant */
      this.isE2EEEnabled = false;
      this.audioEnabled = true;
      this.isVideoPlaybackBlocked = false;
      this.log = livekitLogger;
      this.bufferedEvents = [];
      this.isResuming = false;
      this.rpcHandlers = new Map();
      this.connect = (url, token, opts) =>
        __awaiter(this, void 0, void 0, function* () {
          var _a;
          if (!isBrowserSupported()) {
            if (isReactNative()) {
              throw Error("WebRTC isn't detected, have you called registerGlobals?");
            } else {
              throw Error(
                "LiveKit doesn't seem to be supported on this browser. Try to update your browser and make sure no browser extensions are disabling webRTC."
              );
            }
          }
          // In case a disconnect called happened right before the connect call, make sure the disconnect is completed first by awaiting its lock
          const unlockDisconnect = yield this.disconnectLock.lock();
          if (this.state === ConnectionState.Connected) {
            // when the state is reconnecting or connected, this function returns immediately
            this.log.info('already connected to room '.concat(this.name), this.logContext);
            unlockDisconnect();
            return Promise.resolve();
          }
          if (this.connectFuture) {
            unlockDisconnect();
            return this.connectFuture.promise;
          }
          this.setAndEmitConnectionState(ConnectionState.Connecting);
          if (
            ((_a = this.regionUrlProvider) === null || _a === void 0
              ? void 0
              : _a.getServerUrl().toString()) !== url
          ) {
            this.regionUrl = undefined;
            this.regionUrlProvider = undefined;
          }
          if (isCloud(new URL(url))) {
            if (this.regionUrlProvider === undefined) {
              this.regionUrlProvider = new RegionUrlProvider(url, token);
            } else {
              this.regionUrlProvider.updateToken(token);
            }
            // trigger the first fetch without waiting for a response
            // if initial connection fails, this will speed up picking regional url
            // on subsequent runs
            this.regionUrlProvider
              .fetchRegionSettings()
              .then((settings) => {
                var _a;
                (_a = this.regionUrlProvider) === null || _a === void 0
                  ? void 0
                  : _a.setServerReportedRegions(settings);
              })
              .catch((e) => {
                this.log.warn(
                  'could not fetch region settings',
                  Object.assign(Object.assign({}, this.logContext), {
                    error: e,
                  })
                );
              });
          }
          const connectFn = (resolve, reject, regionUrl) =>
            __awaiter(this, void 0, void 0, function* () {
              var _a, _b;
              if (this.abortController) {
                this.abortController.abort();
              }
              // explicit creation as local var needed to satisfy TS compiler when passing it to `attemptConnection` further down
              const abortController = new AbortController();
              this.abortController = abortController;
              // at this point the intention to connect has been signalled so we can allow cancelling of the connection via disconnect() again
              unlockDisconnect === null || unlockDisconnect === void 0
                ? void 0
                : unlockDisconnect();
              try {
                yield this.attemptConnection(
                  regionUrl !== null && regionUrl !== void 0 ? regionUrl : url,
                  token,
                  opts,
                  abortController
                );
                this.abortController = undefined;
                resolve();
              } catch (e) {
                if (
                  this.regionUrlProvider &&
                  e instanceof ConnectionError &&
                  e.reason !== ConnectionErrorReason.Cancelled &&
                  e.reason !== ConnectionErrorReason.NotAllowed
                ) {
                  let nextUrl = null;
                  try {
                    nextUrl = yield this.regionUrlProvider.getNextBestRegionUrl(
                      (_a = this.abortController) === null || _a === void 0 ? void 0 : _a.signal
                    );
                  } catch (error) {
                    if (
                      error instanceof ConnectionError &&
                      (error.status === 401 || error.reason === ConnectionErrorReason.Cancelled)
                    ) {
                      this.handleDisconnect(this.options.stopLocalTrackOnUnpublish);
                      reject(error);
                      return;
                    }
                  }
                  if (
                    nextUrl &&
                    !((_b = this.abortController) === null || _b === void 0
                      ? void 0
                      : _b.signal.aborted)
                  ) {
                    this.log.info(
                      'Initial connection failed with ConnectionError: '
                        .concat(e.message, '. Retrying with another region: ')
                        .concat(nextUrl),
                      this.logContext
                    );
                    this.recreateEngine();
                    yield connectFn(resolve, reject, nextUrl);
                  } else {
                    this.handleDisconnect(
                      this.options.stopLocalTrackOnUnpublish,
                      getDisconnectReasonFromConnectionError(e)
                    );
                    reject(e);
                  }
                } else {
                  let disconnectReason = DisconnectReason.UNKNOWN_REASON;
                  if (e instanceof ConnectionError) {
                    disconnectReason = getDisconnectReasonFromConnectionError(e);
                  }
                  this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, disconnectReason);
                  reject(e);
                }
              }
            });
          const regionUrl = this.regionUrl;
          this.regionUrl = undefined;
          this.connectFuture = new Future(
            (resolve, reject) => {
              connectFn(resolve, reject, regionUrl);
            },
            () => {
              this.clearConnectionFutures();
            }
          );
          return this.connectFuture.promise;
        });
      this.connectSignal = (url, token, engine, connectOptions, roomOptions, abortController) =>
        __awaiter(this, void 0, void 0, function* () {
          var _a, _b, _c;
          const joinResponse = yield engine.join(
            url,
            token,
            {
              autoSubscribe: connectOptions.autoSubscribe,
              adaptiveStream:
                typeof roomOptions.adaptiveStream === 'object' ? true : roomOptions.adaptiveStream,
              maxRetries: connectOptions.maxRetries,
              e2eeEnabled: !!this.e2eeManager,
              websocketTimeout: connectOptions.websocketTimeout,
            },
            abortController.signal
          );
          let serverInfo = joinResponse.serverInfo;
          if (!serverInfo) {
            serverInfo = {
              version: joinResponse.serverVersion,
              region: joinResponse.serverRegion,
            };
          }
          this.serverInfo = serverInfo;
          this.log.debug(
            'connected to Livekit Server '.concat(
              Object.entries(serverInfo)
                .map((_ref) => {
                  let [key, value] = _ref;
                  return ''.concat(key, ': ').concat(value);
                })
                .join(', ')
            ),
            {
              room: (_a = joinResponse.room) === null || _a === void 0 ? void 0 : _a.name,
              roomSid: (_b = joinResponse.room) === null || _b === void 0 ? void 0 : _b.sid,
              identity:
                (_c = joinResponse.participant) === null || _c === void 0 ? void 0 : _c.identity,
            }
          );
          if (!serverInfo.version) {
            throw new UnsupportedServer('unknown server version');
          }
          if (serverInfo.version === '0.15.1' && this.options.dynacast) {
            this.log.debug('disabling dynacast due to server version', this.logContext);
            // dynacast has a bug in 0.15.1, so we cannot use it then
            roomOptions.dynacast = false;
          }
          return joinResponse;
        });
      this.applyJoinResponse = (joinResponse) => {
        const pi = joinResponse.participant;
        this.localParticipant.sid = pi.sid;
        this.localParticipant.identity = pi.identity;
        this.localParticipant.setEnabledPublishCodecs(joinResponse.enabledPublishCodecs);
        if (this.e2eeManager) {
          try {
            this.e2eeManager.setSifTrailer(joinResponse.sifTrailer);
          } catch (e) {
            this.log.error(
              e instanceof Error ? e.message : 'Could not set SifTrailer',
              Object.assign(Object.assign({}, this.logContext), {
                error: e,
              })
            );
          }
        }
        // populate remote participants, these should not trigger new events
        this.handleParticipantUpdates([pi, ...joinResponse.otherParticipants]);
        if (joinResponse.room) {
          this.handleRoomUpdate(joinResponse.room);
        }
      };
      this.attemptConnection = (url, token, opts, abortController) =>
        __awaiter(this, void 0, void 0, function* () {
          var _a, _b;
          if (
            this.state === ConnectionState.Reconnecting ||
            this.isResuming ||
            ((_a = this.engine) === null || _a === void 0 ? void 0 : _a.pendingReconnect)
          ) {
            this.log.info(
              'Reconnection attempt replaced by new connection attempt',
              this.logContext
            );
            // make sure we close and recreate the existing engine in order to get rid of any potentially ongoing reconnection attempts
            this.recreateEngine();
          } else {
            // create engine if previously disconnected
            this.maybeCreateEngine();
          }
          if ((_b = this.regionUrlProvider) === null || _b === void 0 ? void 0 : _b.isCloud()) {
            this.engine.setRegionUrlProvider(this.regionUrlProvider);
          }
          this.acquireAudioContext();
          this.connOptions = Object.assign(Object.assign({}, roomConnectOptionDefaults), opts);
          if (this.connOptions.rtcConfig) {
            this.engine.rtcConfig = this.connOptions.rtcConfig;
          }
          if (this.connOptions.peerConnectionTimeout) {
            this.engine.peerConnectionTimeout = this.connOptions.peerConnectionTimeout;
          }
          try {
            const joinResponse = yield this.connectSignal(
              url,
              token,
              this.engine,
              this.connOptions,
              this.options,
              abortController
            );
            this.applyJoinResponse(joinResponse);
            // forward metadata changed for the local participant
            this.setupLocalParticipantEvents();
            this.emit(RoomEvent.SignalConnected);
          } catch (err) {
            yield this.engine.close();
            this.recreateEngine();
            const resultingError = new ConnectionError(
              'could not establish signal connection',
              ConnectionErrorReason.ServerUnreachable
            );
            if (err instanceof Error) {
              resultingError.message = ''.concat(resultingError.message, ': ').concat(err.message);
            }
            if (err instanceof ConnectionError) {
              resultingError.reason = err.reason;
              resultingError.status = err.status;
            }
            this.log.debug(
              'error trying to establish signal connection',
              Object.assign(Object.assign({}, this.logContext), {
                error: err,
              })
            );
            throw resultingError;
          }
          if (abortController.signal.aborted) {
            yield this.engine.close();
            this.recreateEngine();
            throw new ConnectionError(
              'Connection attempt aborted',
              ConnectionErrorReason.Cancelled
            );
          }
          try {
            yield this.engine.waitForPCInitialConnection(
              this.connOptions.peerConnectionTimeout,
              abortController
            );
          } catch (e) {
            yield this.engine.close();
            this.recreateEngine();
            throw e;
          }
          // also hook unload event
          if (isWeb() && this.options.disconnectOnPageLeave) {
            // capturing both 'pagehide' and 'beforeunload' to capture broadest set of browser behaviors
            window.addEventListener('pagehide', this.onPageLeave);
            window.addEventListener('beforeunload', this.onPageLeave);
          }
          if (isWeb()) {
            document.addEventListener('freeze', this.onPageLeave);
          }
          this.setAndEmitConnectionState(ConnectionState.Connected);
          this.emit(RoomEvent.Connected);
          this.registerConnectionReconcile();
        });
      /**
       * disconnects the room, emits [[RoomEvent.Disconnected]]
       */
      this.disconnect = function () {
        for (var _len = arguments.length, args_1 = new Array(_len), _key = 0; _key < _len; _key++) {
          args_1[_key] = arguments[_key];
        }
        return __awaiter(_this, [...args_1], void 0, function () {
          var _this2 = this;
          let stopTracks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
          return (function* () {
            var _a, _b, _c, _d;
            const unlock = yield _this2.disconnectLock.lock();
            try {
              if (_this2.state === ConnectionState.Disconnected) {
                _this2.log.debug('already disconnected', _this2.logContext);
                return;
              }
              _this2.log.info('disconnect from room', Object.assign({}, _this2.logContext));
              if (
                _this2.state === ConnectionState.Connecting ||
                _this2.state === ConnectionState.Reconnecting ||
                _this2.isResuming
              ) {
                // try aborting pending connection attempt
                _this2.log.warn('abort connection attempt', _this2.logContext);
                (_a = _this2.abortController) === null || _a === void 0 ? void 0 : _a.abort();
                // in case the abort controller didn't manage to cancel the connection attempt, reject the connect promise explicitly
                (_c =
                  (_b = _this2.connectFuture) === null || _b === void 0 ? void 0 : _b.reject) ===
                  null || _c === void 0
                  ? void 0
                  : _c.call(
                      _b,
                      new ConnectionError(
                        'Client initiated disconnect',
                        ConnectionErrorReason.Cancelled
                      )
                    );
                _this2.connectFuture = undefined;
              }
              // send leave
              if (
                !((_d = _this2.engine) === null || _d === void 0
                  ? void 0
                  : _d.client.isDisconnected)
              ) {
                yield _this2.engine.client.sendLeave();
              }
              // close engine (also closes client)
              if (_this2.engine) {
                yield _this2.engine.close();
              }
              _this2.handleDisconnect(stopTracks, DisconnectReason.CLIENT_INITIATED);
              /* @ts-ignore */
              _this2.engine = undefined;
            } finally {
              unlock();
            }
          })();
        });
      };
      this.onPageLeave = () =>
        __awaiter(this, void 0, void 0, function* () {
          this.log.info('Page leave detected, disconnecting', this.logContext);
          yield this.disconnect();
        });
      /**
       * Browsers have different policies regarding audio playback. Most requiring
       * some form of user interaction (click/tap/etc).
       * In those cases, audio will be silent until a click/tap triggering one of the following
       * - `startAudio`
       * - `getUserMedia`
       */
      this.startAudio = () =>
        __awaiter(this, void 0, void 0, function* () {
          const elements = [];
          const browser = getBrowser();
          if (browser && browser.os === 'iOS') {
            /**
             * iOS blocks audio element playback if
             * - user is not publishing audio themselves and
             * - no other audio source is playing
             *
             * as a workaround, we create an audio element with an empty track, so that
             * silent audio is always playing
             */
            const audioId = 'livekit-dummy-audio-el';
            let dummyAudioEl = document.getElementById(audioId);
            if (!dummyAudioEl) {
              dummyAudioEl = document.createElement('audio');
              dummyAudioEl.id = audioId;
              dummyAudioEl.autoplay = true;
              dummyAudioEl.hidden = true;
              const track = getEmptyAudioStreamTrack();
              track.enabled = true;
              const stream = new MediaStream([track]);
              dummyAudioEl.srcObject = stream;
              document.addEventListener('visibilitychange', () => {
                if (!dummyAudioEl) {
                  return;
                }
                // set the srcObject to null on page hide in order to prevent lock screen controls to show up for it
                dummyAudioEl.srcObject = document.hidden ? null : stream;
                if (!document.hidden) {
                  this.log.debug(
                    'page visible again, triggering startAudio to resume playback and update playback status',
                    this.logContext
                  );
                  this.startAudio();
                }
              });
              document.body.append(dummyAudioEl);
              this.once(RoomEvent.Disconnected, () => {
                dummyAudioEl === null || dummyAudioEl === void 0 ? void 0 : dummyAudioEl.remove();
                dummyAudioEl = null;
              });
            }
            elements.push(dummyAudioEl);
          }
          this.remoteParticipants.forEach((p) => {
            p.audioTrackPublications.forEach((t) => {
              if (t.track) {
                t.track.attachedElements.forEach((e) => {
                  elements.push(e);
                });
              }
            });
          });
          try {
            yield Promise.all([
              this.acquireAudioContext(),
              ...elements.map((e) => {
                e.muted = false;
                return e.play();
              }),
            ]);
            this.handleAudioPlaybackStarted();
          } catch (err) {
            this.handleAudioPlaybackFailed(err);
            throw err;
          }
        });
      this.startVideo = () =>
        __awaiter(this, void 0, void 0, function* () {
          const elements = [];
          for (const p of this.remoteParticipants.values()) {
            p.videoTrackPublications.forEach((tr) => {
              var _a;
              (_a = tr.track) === null || _a === void 0
                ? void 0
                : _a.attachedElements.forEach((el) => {
                    if (!elements.includes(el)) {
                      elements.push(el);
                    }
                  });
            });
          }
          yield Promise.all(elements.map((el) => el.play()))
            .then(() => {
              this.handleVideoPlaybackStarted();
            })
            .catch((e) => {
              if (e.name === 'NotAllowedError') {
                this.handleVideoPlaybackFailed();
              } else {
                this.log.warn(
                  'Resuming video playback failed, make sure you call `startVideo` directly in a user gesture handler',
                  this.logContext
                );
              }
            });
        });
      this.handleRestarting = () => {
        this.clearConnectionReconcile();
        // in case we went from resuming to full-reconnect, make sure to reflect it on the isResuming flag
        this.isResuming = false;
        // also unwind existing participants & existing subscriptions
        for (const p of this.remoteParticipants.values()) {
          this.handleParticipantDisconnected(p.identity, p);
        }
        if (this.setAndEmitConnectionState(ConnectionState.Reconnecting)) {
          this.emit(RoomEvent.Reconnecting);
        }
      };
      this.handleSignalRestarted = (joinResponse) =>
        __awaiter(this, void 0, void 0, function* () {
          this.log.debug(
            'signal reconnected to server, region '.concat(joinResponse.serverRegion),
            Object.assign(Object.assign({}, this.logContext), {
              region: joinResponse.serverRegion,
            })
          );
          this.bufferedEvents = [];
          this.applyJoinResponse(joinResponse);
          try {
            // unpublish & republish tracks
            yield this.localParticipant.republishAllTracks(undefined, true);
          } catch (error) {
            this.log.error(
              'error trying to re-publish tracks after reconnection',
              Object.assign(Object.assign({}, this.logContext), {
                error,
              })
            );
          }
          try {
            yield this.engine.waitForRestarted();
            this.log.debug(
              'fully reconnected to server',
              Object.assign(Object.assign({}, this.logContext), {
                region: joinResponse.serverRegion,
              })
            );
          } catch (_a) {
            // reconnection failed, handleDisconnect is being invoked already, just return here
            return;
          }
          this.setAndEmitConnectionState(ConnectionState.Connected);
          this.emit(RoomEvent.Reconnected);
          this.registerConnectionReconcile();
          this.emitBufferedEvents();
        });
      this.handleParticipantUpdates = (participantInfos) => {
        // handle changes to participant state, and send events
        participantInfos.forEach((info) => {
          var _a;
          if (info.identity === this.localParticipant.identity) {
            this.localParticipant.updateInfo(info);
            return;
          }
          // LiveKit server doesn't send identity info prior to version 1.5.2 in disconnect updates
          // so we try to map an empty identity to an already known sID manually
          if (info.identity === '') {
            info.identity =
              (_a = this.sidToIdentity.get(info.sid)) !== null && _a !== void 0 ? _a : '';
          }
          let remoteParticipant = this.remoteParticipants.get(info.identity);
          // when it's disconnected, send updates
          if (info.state === ParticipantInfo_State.DISCONNECTED) {
            this.handleParticipantDisconnected(info.identity, remoteParticipant);
          } else {
            // create participant if doesn't exist
            remoteParticipant = this.getOrCreateParticipant(info.identity, info);
          }
        });
      };
      // updates are sent only when there's a change to speaker ordering
      this.handleActiveSpeakersUpdate = (speakers) => {
        const activeSpeakers = [];
        const seenSids = {};
        speakers.forEach((speaker) => {
          seenSids[speaker.sid] = true;
          if (speaker.sid === this.localParticipant.sid) {
            this.localParticipant.audioLevel = speaker.level;
            this.localParticipant.setIsSpeaking(true);
            activeSpeakers.push(this.localParticipant);
          } else {
            const p = this.getRemoteParticipantBySid(speaker.sid);
            if (p) {
              p.audioLevel = speaker.level;
              p.setIsSpeaking(true);
              activeSpeakers.push(p);
            }
          }
        });
        if (!seenSids[this.localParticipant.sid]) {
          this.localParticipant.audioLevel = 0;
          this.localParticipant.setIsSpeaking(false);
        }
        this.remoteParticipants.forEach((p) => {
          if (!seenSids[p.sid]) {
            p.audioLevel = 0;
            p.setIsSpeaking(false);
          }
        });
        this.activeSpeakers = activeSpeakers;
        this.emitWhenConnected(RoomEvent.ActiveSpeakersChanged, activeSpeakers);
      };
      // process list of changed speakers
      this.handleSpeakersChanged = (speakerUpdates) => {
        const lastSpeakers = new Map();
        this.activeSpeakers.forEach((p) => {
          const remoteParticipant = this.remoteParticipants.get(p.identity);
          if (remoteParticipant && remoteParticipant.sid !== p.sid) {
            return;
          }
          lastSpeakers.set(p.sid, p);
        });
        speakerUpdates.forEach((speaker) => {
          let p = this.getRemoteParticipantBySid(speaker.sid);
          if (speaker.sid === this.localParticipant.sid) {
            p = this.localParticipant;
          }
          if (!p) {
            return;
          }
          p.audioLevel = speaker.level;
          p.setIsSpeaking(speaker.active);
          if (speaker.active) {
            lastSpeakers.set(speaker.sid, p);
          } else {
            lastSpeakers.delete(speaker.sid);
          }
        });
        const activeSpeakers = Array.from(lastSpeakers.values());
        activeSpeakers.sort((a, b) => b.audioLevel - a.audioLevel);
        this.activeSpeakers = activeSpeakers;
        this.emitWhenConnected(RoomEvent.ActiveSpeakersChanged, activeSpeakers);
      };
      this.handleStreamStateUpdate = (streamStateUpdate) => {
        streamStateUpdate.streamStates.forEach((streamState) => {
          const participant = this.getRemoteParticipantBySid(streamState.participantSid);
          if (!participant) {
            return;
          }
          const pub = participant.getTrackPublicationBySid(streamState.trackSid);
          if (!pub || !pub.track) {
            return;
          }
          const newStreamState = Track.streamStateFromProto(streamState.state);
          pub.track.setStreamState(newStreamState);
          if (newStreamState !== pub.track.streamState) {
            participant.emit(ParticipantEvent.TrackStreamStateChanged, pub, pub.track.streamState);
            this.emitWhenConnected(
              RoomEvent.TrackStreamStateChanged,
              pub,
              pub.track.streamState,
              participant
            );
          }
        });
      };
      this.handleSubscriptionPermissionUpdate = (update) => {
        const participant = this.getRemoteParticipantBySid(update.participantSid);
        if (!participant) {
          return;
        }
        const pub = participant.getTrackPublicationBySid(update.trackSid);
        if (!pub) {
          return;
        }
        pub.setAllowed(update.allowed);
      };
      this.handleSubscriptionError = (update) => {
        const participant = Array.from(this.remoteParticipants.values()).find((p) =>
          p.trackPublications.has(update.trackSid)
        );
        if (!participant) {
          return;
        }
        const pub = participant.getTrackPublicationBySid(update.trackSid);
        if (!pub) {
          return;
        }
        pub.setSubscriptionError(update.err);
      };
      this.handleDataPacket = (packet, encryptionType) => {
        // find the participant
        const participant = this.remoteParticipants.get(packet.participantIdentity);
        if (packet.value.case === 'user') {
          this.handleUserPacket(participant, packet.value.value, packet.kind, encryptionType);
        } else if (packet.value.case === 'transcription') {
          this.handleTranscription(participant, packet.value.value);
        } else if (packet.value.case === 'sipDtmf') {
          this.handleSipDtmf(participant, packet.value.value);
        } else if (packet.value.case === 'chatMessage') {
          this.handleChatMessage(participant, packet.value.value);
        } else if (packet.value.case === 'metrics') {
          this.handleMetrics(packet.value.value, participant);
        } else if (
          packet.value.case === 'streamHeader' ||
          packet.value.case === 'streamChunk' ||
          packet.value.case === 'streamTrailer'
        ) {
          this.handleDataStream(packet, encryptionType);
        } else if (packet.value.case === 'rpcRequest') {
          const rpc = packet.value.value;
          this.handleIncomingRpcRequest(
            packet.participantIdentity,
            rpc.id,
            rpc.method,
            rpc.payload,
            rpc.responseTimeoutMs,
            rpc.version
          );
        }
      };
      this.handleUserPacket = (participant, userPacket, kind, encryptionType) => {
        this.emit(
          RoomEvent.DataReceived,
          userPacket.payload,
          participant,
          kind,
          userPacket.topic,
          encryptionType
        );
        // also emit on the participant
        participant === null || participant === void 0
          ? void 0
          : participant.emit(
              ParticipantEvent.DataReceived,
              userPacket.payload,
              kind,
              encryptionType
            );
      };
      this.handleSipDtmf = (participant, dtmf) => {
        this.emit(RoomEvent.SipDTMFReceived, dtmf, participant);
        // also emit on the participant
        participant === null || participant === void 0
          ? void 0
          : participant.emit(ParticipantEvent.SipDTMFReceived, dtmf);
      };
      this.handleTranscription = (_remoteParticipant, transcription) => {
        // find the participant
        const participant =
          transcription.transcribedParticipantIdentity === this.localParticipant.identity
            ? this.localParticipant
            : this.getParticipantByIdentity(transcription.transcribedParticipantIdentity);
        const publication =
          participant === null || participant === void 0
            ? void 0
            : participant.trackPublications.get(transcription.trackId);
        const segments = extractTranscriptionSegments(
          transcription,
          this.transcriptionReceivedTimes
        );
        publication === null || publication === void 0
          ? void 0
          : publication.emit(TrackEvent.TranscriptionReceived, segments);
        participant === null || participant === void 0
          ? void 0
          : participant.emit(ParticipantEvent.TranscriptionReceived, segments, publication);
        this.emit(RoomEvent.TranscriptionReceived, segments, participant, publication);
      };
      this.handleChatMessage = (participant, chatMessage) => {
        const msg = extractChatMessage(chatMessage);
        this.emit(RoomEvent.ChatMessage, msg, participant);
      };
      this.handleMetrics = (metrics, participant) => {
        this.emit(RoomEvent.MetricsReceived, metrics, participant);
      };
      this.handleDataStream = (packet, encryptionType) => {
        this.incomingDataStreamManager.handleDataStreamPacket(packet, encryptionType);
      };
      this.bufferedSegments = new Map();
      this.handleAudioPlaybackStarted = () => {
        if (this.canPlaybackAudio) {
          return;
        }
        this.audioEnabled = true;
        this.emit(RoomEvent.AudioPlaybackStatusChanged, true);
      };
      this.handleAudioPlaybackFailed = (e) => {
        this.log.warn(
          'could not playback audio',
          Object.assign(Object.assign({}, this.logContext), {
            error: e,
          })
        );
        if (!this.canPlaybackAudio) {
          return;
        }
        this.audioEnabled = false;
        this.emit(RoomEvent.AudioPlaybackStatusChanged, false);
      };
      this.handleVideoPlaybackStarted = () => {
        if (this.isVideoPlaybackBlocked) {
          this.isVideoPlaybackBlocked = false;
          this.emit(RoomEvent.VideoPlaybackStatusChanged, true);
        }
      };
      this.handleVideoPlaybackFailed = () => {
        if (!this.isVideoPlaybackBlocked) {
          this.isVideoPlaybackBlocked = true;
          this.emit(RoomEvent.VideoPlaybackStatusChanged, false);
        }
      };
      this.handleDeviceChange = () =>
        __awaiter(this, void 0, void 0, function* () {
          var _a;
          if (((_a = getBrowser()) === null || _a === void 0 ? void 0 : _a.os) !== 'iOS') {
            // default devices are non deterministic on iOS, so we don't attempt to select them here
            yield this.selectDefaultDevices();
          }
          this.emit(RoomEvent.MediaDevicesChanged);
        });
      this.handleRoomUpdate = (room) => {
        const oldRoom = this.roomInfo;
        this.roomInfo = room;
        if (oldRoom && oldRoom.metadata !== room.metadata) {
          this.emitWhenConnected(RoomEvent.RoomMetadataChanged, room.metadata);
        }
        if (
          (oldRoom === null || oldRoom === void 0 ? void 0 : oldRoom.activeRecording) !==
          room.activeRecording
        ) {
          this.emitWhenConnected(RoomEvent.RecordingStatusChanged, room.activeRecording);
        }
      };
      this.handleConnectionQualityUpdate = (update) => {
        update.updates.forEach((info) => {
          if (info.participantSid === this.localParticipant.sid) {
            this.localParticipant.setConnectionQuality(info.quality);
            return;
          }
          const participant = this.getRemoteParticipantBySid(info.participantSid);
          if (participant) {
            participant.setConnectionQuality(info.quality);
          }
        });
      };
      this.onLocalParticipantMetadataChanged = (metadata) => {
        this.emit(RoomEvent.ParticipantMetadataChanged, metadata, this.localParticipant);
      };
      this.onLocalParticipantNameChanged = (name) => {
        this.emit(RoomEvent.ParticipantNameChanged, name, this.localParticipant);
      };
      this.onLocalAttributesChanged = (changedAttributes) => {
        this.emit(RoomEvent.ParticipantAttributesChanged, changedAttributes, this.localParticipant);
      };
      this.onLocalTrackMuted = (pub) => {
        this.emit(RoomEvent.TrackMuted, pub, this.localParticipant);
      };
      this.onLocalTrackUnmuted = (pub) => {
        this.emit(RoomEvent.TrackUnmuted, pub, this.localParticipant);
      };
      this.onTrackProcessorUpdate = (processor) => {
        var _a;
        (_a = processor === null || processor === void 0 ? void 0 : processor.onPublish) === null ||
        _a === void 0
          ? void 0
          : _a.call(processor, this);
      };
      this.onLocalTrackPublished = (pub) =>
        __awaiter(this, void 0, void 0, function* () {
          var _a, _b, _c, _d, _e, _f;
          (_a = pub.track) === null || _a === void 0
            ? void 0
            : _a.on(TrackEvent.TrackProcessorUpdate, this.onTrackProcessorUpdate);
          (_b = pub.track) === null || _b === void 0
            ? void 0
            : _b.on(TrackEvent.Restarted, this.onLocalTrackRestarted);
          (_e =
            (_d = (_c = pub.track) === null || _c === void 0 ? void 0 : _c.getProcessor()) ===
              null || _d === void 0
              ? void 0
              : _d.onPublish) === null || _e === void 0
            ? void 0
            : _e.call(_d, this);
          this.emit(RoomEvent.LocalTrackPublished, pub, this.localParticipant);
          if (isLocalAudioTrack(pub.track)) {
            const trackIsSilent = yield pub.track.checkForSilence();
            if (trackIsSilent) {
              this.emit(RoomEvent.LocalAudioSilenceDetected, pub);
            }
          }
          const deviceId = yield (_f = pub.track) === null || _f === void 0
            ? void 0
            : _f.getDeviceId(false);
          const deviceKind = sourceToKind(pub.source);
          if (
            deviceKind &&
            deviceId &&
            deviceId !== this.localParticipant.activeDeviceMap.get(deviceKind)
          ) {
            this.localParticipant.activeDeviceMap.set(deviceKind, deviceId);
            this.emit(RoomEvent.ActiveDeviceChanged, deviceKind, deviceId);
          }
        });
      this.onLocalTrackUnpublished = (pub) => {
        var _a, _b;
        (_a = pub.track) === null || _a === void 0
          ? void 0
          : _a.off(TrackEvent.TrackProcessorUpdate, this.onTrackProcessorUpdate);
        (_b = pub.track) === null || _b === void 0
          ? void 0
          : _b.off(TrackEvent.Restarted, this.onLocalTrackRestarted);
        this.emit(RoomEvent.LocalTrackUnpublished, pub, this.localParticipant);
      };
      this.onLocalTrackRestarted = (track) =>
        __awaiter(this, void 0, void 0, function* () {
          const deviceId = yield track.getDeviceId(false);
          const deviceKind = sourceToKind(track.source);
          if (
            deviceKind &&
            deviceId &&
            deviceId !== this.localParticipant.activeDeviceMap.get(deviceKind)
          ) {
            this.log.debug(
              'local track restarted, setting '.concat(deviceKind, ' ').concat(deviceId, ' active'),
              this.logContext
            );
            this.localParticipant.activeDeviceMap.set(deviceKind, deviceId);
            this.emit(RoomEvent.ActiveDeviceChanged, deviceKind, deviceId);
          }
        });
      this.onLocalConnectionQualityChanged = (quality) => {
        this.emit(RoomEvent.ConnectionQualityChanged, quality, this.localParticipant);
      };
      this.onMediaDevicesError = (e, kind) => {
        this.emit(RoomEvent.MediaDevicesError, e, kind);
      };
      this.onLocalParticipantPermissionsChanged = (prevPermissions) => {
        this.emit(RoomEvent.ParticipantPermissionsChanged, prevPermissions, this.localParticipant);
      };
      this.onLocalChatMessageSent = (msg) => {
        this.emit(RoomEvent.ChatMessage, msg, this.localParticipant);
      };
      this.setMaxListeners(100);
      this.remoteParticipants = new Map();
      this.sidToIdentity = new Map();
      this.options = Object.assign(Object.assign({}, roomOptionDefaults), options);
      this.log = getLogger(
        (_a = this.options.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Room
      );
      this.transcriptionReceivedTimes = new Map();
      this.options.audioCaptureDefaults = Object.assign(
        Object.assign({}, audioDefaults),
        options === null || options === void 0 ? void 0 : options.audioCaptureDefaults
      );
      this.options.videoCaptureDefaults = Object.assign(
        Object.assign({}, videoDefaults),
        options === null || options === void 0 ? void 0 : options.videoCaptureDefaults
      );
      this.options.publishDefaults = Object.assign(
        Object.assign({}, publishDefaults),
        options === null || options === void 0 ? void 0 : options.publishDefaults
      );
      this.maybeCreateEngine();
      this.incomingDataStreamManager = new IncomingDataStreamManager();
      this.outgoingDataStreamManager = new OutgoingDataStreamManager(this.engine, this.log);
      this.disconnectLock = new livekit_client_esm_();
      this.localParticipant = new LocalParticipant(
        '',
        '',
        this.engine,
        this.options,
        this.rpcHandlers,
        this.outgoingDataStreamManager
      );
      if (this.options.e2ee || this.options.encryption) {
        this.setupE2EE();
      }
      this.engine.e2eeManager = this.e2eeManager;
      if (this.options.videoCaptureDefaults.deviceId) {
        this.localParticipant.activeDeviceMap.set(
          'videoinput',
          unwrapConstraint(this.options.videoCaptureDefaults.deviceId)
        );
      }
      if (this.options.audioCaptureDefaults.deviceId) {
        this.localParticipant.activeDeviceMap.set(
          'audioinput',
          unwrapConstraint(this.options.audioCaptureDefaults.deviceId)
        );
      }
      if ((_b = this.options.audioOutput) === null || _b === void 0 ? void 0 : _b.deviceId) {
        this.switchActiveDevice(
          'audiooutput',
          unwrapConstraint(this.options.audioOutput.deviceId)
        ).catch((e) =>
          this.log.warn('Could not set audio output: '.concat(e.message), this.logContext)
        );
      }
      if (isWeb()) {
        const abortController = new AbortController();
        // in order to catch device changes prior to room connection we need to register the event in the constructor
        (_c = navigator.mediaDevices) === null || _c === void 0
          ? void 0
          : _c.addEventListener('devicechange', this.handleDeviceChange, {
              signal: abortController.signal,
            });
        if (Room.cleanupRegistry) {
          Room.cleanupRegistry.register(this, () => {
            abortController.abort();
          });
        }
      }
    }
    registerTextStreamHandler(topic, callback) {
      return this.incomingDataStreamManager.registerTextStreamHandler(topic, callback);
    }
    unregisterTextStreamHandler(topic) {
      return this.incomingDataStreamManager.unregisterTextStreamHandler(topic);
    }
    registerByteStreamHandler(topic, callback) {
      return this.incomingDataStreamManager.registerByteStreamHandler(topic, callback);
    }
    unregisterByteStreamHandler(topic) {
      return this.incomingDataStreamManager.unregisterByteStreamHandler(topic);
    }
    /**
     * Establishes the participant as a receiver for calls of the specified RPC method.
     *
     * @param method - The name of the indicated RPC method
     * @param handler - Will be invoked when an RPC request for this method is received
     * @returns A promise that resolves when the method is successfully registered
     * @throws {Error} If a handler for this method is already registered (must call unregisterRpcMethod first)
     *
     * @example
     * ```typescript
     * room.localParticipant?.registerRpcMethod(
     *   'greet',
     *   async (data: RpcInvocationData) => {
     *     console.log(`Received greeting from ${data.callerIdentity}: ${data.payload}`);
     *     return `Hello, ${data.callerIdentity}!`;
     *   }
     * );
     * ```
     *
     * The handler should return a Promise that resolves to a string.
     * If unable to respond within `responseTimeout`, the request will result in an error on the caller's side.
     *
     * You may throw errors of type `RpcError` with a string `message` in the handler,
     * and they will be received on the caller's side with the message intact.
     * Other errors thrown in your handler will not be transmitted as-is, and will instead arrive to the caller as `1500` ("Application Error").
     */
    registerRpcMethod(method, handler) {
      if (this.rpcHandlers.has(method)) {
        throw Error(
          'RPC handler already registered for method '.concat(
            method,
            ', unregisterRpcMethod before trying to register again'
          )
        );
      }
      this.rpcHandlers.set(method, handler);
    }
    /**
     * Unregisters a previously registered RPC method.
     *
     * @param method - The name of the RPC method to unregister
     */
    unregisterRpcMethod(method) {
      this.rpcHandlers.delete(method);
    }
    /**
     * @experimental
     */
    setE2EEEnabled(enabled) {
      return __awaiter(this, void 0, void 0, function* () {
        if (this.e2eeManager) {
          yield Promise.all([this.localParticipant.setE2EEEnabled(enabled)]);
          if (this.localParticipant.identity !== '') {
            this.e2eeManager.setParticipantCryptorEnabled(enabled, this.localParticipant.identity);
          }
        } else {
          throw Error('e2ee not configured, please set e2ee settings within the room options');
        }
      });
    }
    setupE2EE() {
      // when encryption is enabled via `options.encryption`, we enable data channel encryption
      var _a;
      const dcEncryptionEnabled = !!this.options.encryption;
      const e2eeOptions = this.options.encryption || this.options.e2ee;
      if (e2eeOptions) {
        if ('e2eeManager' in e2eeOptions) {
          this.e2eeManager = e2eeOptions.e2eeManager;
        } else {
          this.e2eeManager = new E2EEManager(e2eeOptions, dcEncryptionEnabled);
        }
        this.e2eeManager.on(
          EncryptionEvent.ParticipantEncryptionStatusChanged,
          (enabled, participant) => {
            if (isLocalParticipant(participant)) {
              this.isE2EEEnabled = enabled;
            }
            this.emit(RoomEvent.ParticipantEncryptionStatusChanged, enabled, participant);
          }
        );
        this.e2eeManager.on(EncryptionEvent.EncryptionError, (error) =>
          this.emit(RoomEvent.EncryptionError, error)
        );
        (_a = this.e2eeManager) === null || _a === void 0 ? void 0 : _a.setup(this);
      }
    }
    get logContext() {
      var _a;
      return {
        room: this.name,
        roomID: (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.sid,
        participant: this.localParticipant.identity,
        pID: this.localParticipant.sid,
      };
    }
    /**
     * if the current room has a participant with `recorder: true` in its JWT grant
     **/
    get isRecording() {
      var _a, _b;
      return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.activeRecording) !==
        null && _b !== void 0
        ? _b
        : false;
    }
    /**
     * server assigned unique room id.
     * returns once a sid has been issued by the server.
     */
    getSid() {
      return __awaiter(this, void 0, void 0, function* () {
        if (this.state === ConnectionState.Disconnected) {
          return '';
        }
        if (this.roomInfo && this.roomInfo.sid !== '') {
          return this.roomInfo.sid;
        }
        return new Promise((resolve, reject) => {
          const handleRoomUpdate = (roomInfo) => {
            if (roomInfo.sid !== '') {
              this.engine.off(EngineEvent.RoomUpdate, handleRoomUpdate);
              resolve(roomInfo.sid);
            }
          };
          this.engine.on(EngineEvent.RoomUpdate, handleRoomUpdate);
          this.once(RoomEvent.Disconnected, () => {
            this.engine.off(EngineEvent.RoomUpdate, handleRoomUpdate);
            reject('Room disconnected before room server id was available');
          });
        });
      });
    }
    /** user assigned name, derived from JWT token */
    get name() {
      var _a, _b;
      return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.name) !== null &&
        _b !== void 0
        ? _b
        : '';
    }
    /** room metadata */
    get metadata() {
      var _a;
      return (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.metadata;
    }
    get numParticipants() {
      var _a, _b;
      return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.numParticipants) !==
        null && _b !== void 0
        ? _b
        : 0;
    }
    get numPublishers() {
      var _a, _b;
      return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.numPublishers) !==
        null && _b !== void 0
        ? _b
        : 0;
    }
    maybeCreateEngine() {
      if (this.engine && !this.engine.isClosed) {
        return;
      }
      this.engine = new RTCEngine(this.options);
      this.engine.e2eeManager = this.e2eeManager;
      this.engine
        .on(EngineEvent.ParticipantUpdate, this.handleParticipantUpdates)
        .on(EngineEvent.RoomUpdate, this.handleRoomUpdate)
        .on(EngineEvent.SpeakersChanged, this.handleSpeakersChanged)
        .on(EngineEvent.StreamStateChanged, this.handleStreamStateUpdate)
        .on(EngineEvent.ConnectionQualityUpdate, this.handleConnectionQualityUpdate)
        .on(EngineEvent.SubscriptionError, this.handleSubscriptionError)
        .on(EngineEvent.SubscriptionPermissionUpdate, this.handleSubscriptionPermissionUpdate)
        .on(EngineEvent.MediaTrackAdded, (mediaTrack, stream, receiver) => {
          this.onTrackAdded(mediaTrack, stream, receiver);
        })
        .on(EngineEvent.Disconnected, (reason) => {
          this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, reason);
        })
        .on(EngineEvent.ActiveSpeakersUpdate, this.handleActiveSpeakersUpdate)
        .on(EngineEvent.DataPacketReceived, this.handleDataPacket)
        .on(EngineEvent.Resuming, () => {
          this.clearConnectionReconcile();
          this.isResuming = true;
          this.log.info('Resuming signal connection', this.logContext);
          if (this.setAndEmitConnectionState(ConnectionState.SignalReconnecting)) {
            this.emit(RoomEvent.SignalReconnecting);
          }
        })
        .on(EngineEvent.Resumed, () => {
          this.registerConnectionReconcile();
          this.isResuming = false;
          this.log.info('Resumed signal connection', this.logContext);
          this.updateSubscriptions();
          this.emitBufferedEvents();
          if (this.setAndEmitConnectionState(ConnectionState.Connected)) {
            this.emit(RoomEvent.Reconnected);
          }
        })
        .on(EngineEvent.SignalResumed, () => {
          this.bufferedEvents = [];
          if (this.state === ConnectionState.Reconnecting || this.isResuming) {
            this.sendSyncState();
          }
        })
        .on(EngineEvent.Restarting, this.handleRestarting)
        .on(EngineEvent.SignalRestarted, this.handleSignalRestarted)
        .on(EngineEvent.Offline, () => {
          if (this.setAndEmitConnectionState(ConnectionState.Reconnecting)) {
            this.emit(RoomEvent.Reconnecting);
          }
        })
        .on(EngineEvent.DCBufferStatusChanged, (status, kind) => {
          this.emit(RoomEvent.DCBufferStatusChanged, status, kind);
        })
        .on(EngineEvent.LocalTrackSubscribed, (subscribedSid) => {
          const trackPublication = this.localParticipant.getTrackPublications().find((_ref2) => {
            let { trackSid } = _ref2;
            return trackSid === subscribedSid;
          });
          if (!trackPublication) {
            this.log.warn(
              'could not find local track subscription for subscribed event',
              this.logContext
            );
            return;
          }
          this.localParticipant.emit(ParticipantEvent.LocalTrackSubscribed, trackPublication);
          this.emitWhenConnected(
            RoomEvent.LocalTrackSubscribed,
            trackPublication,
            this.localParticipant
          );
        })
        .on(EngineEvent.RoomMoved, (roomMoved) => {
          this.log.debug('room moved', roomMoved);
          if (roomMoved.room) {
            this.handleRoomUpdate(roomMoved.room);
          }
          this.remoteParticipants.forEach((participant, identity) => {
            this.handleParticipantDisconnected(identity, participant);
          });
          this.emit(RoomEvent.Moved, roomMoved.room.name);
          if (roomMoved.participant) {
            this.handleParticipantUpdates([roomMoved.participant, ...roomMoved.otherParticipants]);
          } else {
            this.handleParticipantUpdates(roomMoved.otherParticipants);
          }
        });
      if (this.localParticipant) {
        this.localParticipant.setupEngine(this.engine);
      }
      if (this.e2eeManager) {
        this.e2eeManager.setupEngine(this.engine);
      }
      if (this.outgoingDataStreamManager) {
        this.outgoingDataStreamManager.setupEngine(this.engine);
      }
    }
    /**
     * getLocalDevices abstracts navigator.mediaDevices.enumerateDevices.
     * In particular, it requests device permissions by default if needed
     * and makes sure the returned device does not consist of dummy devices
     * @param kind
     * @returns a list of available local devices
     */
    static getLocalDevices(kind) {
      let requestPermissions =
        arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      return DeviceManager.getInstance().getDevices(kind, requestPermissions);
    }
    /**
     * prepareConnection should be called as soon as the page is loaded, in order
     * to speed up the connection attempt. This function will
     * - perform DNS resolution and pre-warm the DNS cache
     * - establish TLS connection and cache TLS keys
     *
     * With LiveKit Cloud, it will also determine the best edge data center for
     * the current client to connect to if a token is provided.
     */
    prepareConnection(url, token) {
      return __awaiter(this, void 0, void 0, function* () {
        if (this.state !== ConnectionState.Disconnected) {
          return;
        }
        this.log.debug('prepareConnection to '.concat(url), this.logContext);
        try {
          if (isCloud(new URL(url)) && token) {
            this.regionUrlProvider = new RegionUrlProvider(url, token);
            const regionUrl = yield this.regionUrlProvider.getNextBestRegionUrl();
            // we will not replace the regionUrl if an attempt had already started
            // to avoid overriding regionUrl after a new connection attempt had started
            if (regionUrl && this.state === ConnectionState.Disconnected) {
              this.regionUrl = regionUrl;
              yield fetch(toHttpUrl(regionUrl), {
                method: 'HEAD',
              });
              this.log.debug('prepared connection to '.concat(regionUrl), this.logContext);
            }
          } else {
            yield fetch(toHttpUrl(url), {
              method: 'HEAD',
            });
          }
        } catch (e) {
          this.log.warn(
            'could not prepare connection',
            Object.assign(Object.assign({}, this.logContext), {
              error: e,
            })
          );
        }
      });
    }
    /**
     * retrieves a participant by identity
     * @param identity
     * @returns
     */
    getParticipantByIdentity(identity) {
      if (this.localParticipant.identity === identity) {
        return this.localParticipant;
      }
      return this.remoteParticipants.get(identity);
    }
    clearConnectionFutures() {
      this.connectFuture = undefined;
    }
    /**
     * @internal for testing
     */
    simulateScenario(scenario, arg) {
      return __awaiter(this, void 0, void 0, function* () {
        let postAction = () => __awaiter(this, void 0, void 0, function* () {});
        let req;
        switch (scenario) {
          case 'signal-reconnect':
            // @ts-expect-error function is private
            yield this.engine.client.handleOnClose('simulate disconnect');
            break;
          case 'speaker':
            req = new SimulateScenario({
              scenario: {
                case: 'speakerUpdate',
                value: 3,
              },
            });
            break;
          case 'node-failure':
            req = new SimulateScenario({
              scenario: {
                case: 'nodeFailure',
                value: true,
              },
            });
            break;
          case 'server-leave':
            req = new SimulateScenario({
              scenario: {
                case: 'serverLeave',
                value: true,
              },
            });
            break;
          case 'migration':
            req = new SimulateScenario({
              scenario: {
                case: 'migration',
                value: true,
              },
            });
            break;
          case 'resume-reconnect':
            this.engine.failNext();
            // @ts-expect-error function is private
            yield this.engine.client.handleOnClose('simulate resume-disconnect');
            break;
          case 'disconnect-signal-on-resume':
            postAction = () =>
              __awaiter(this, void 0, void 0, function* () {
                // @ts-expect-error function is private
                yield this.engine.client.handleOnClose('simulate resume-disconnect');
              });
            req = new SimulateScenario({
              scenario: {
                case: 'disconnectSignalOnResume',
                value: true,
              },
            });
            break;
          case 'disconnect-signal-on-resume-no-messages':
            postAction = () =>
              __awaiter(this, void 0, void 0, function* () {
                // @ts-expect-error function is private
                yield this.engine.client.handleOnClose('simulate resume-disconnect');
              });
            req = new SimulateScenario({
              scenario: {
                case: 'disconnectSignalOnResumeNoMessages',
                value: true,
              },
            });
            break;
          case 'full-reconnect':
            this.engine.fullReconnectOnNext = true;
            // @ts-expect-error function is private
            yield this.engine.client.handleOnClose('simulate full-reconnect');
            break;
          case 'force-tcp':
          case 'force-tls':
            req = new SimulateScenario({
              scenario: {
                case: 'switchCandidateProtocol',
                value: scenario === 'force-tls' ? 2 : 1,
              },
            });
            postAction = () =>
              __awaiter(this, void 0, void 0, function* () {
                const onLeave = this.engine.client.onLeave;
                if (onLeave) {
                  onLeave(
                    new LeaveRequest({
                      reason: DisconnectReason.CLIENT_INITIATED,
                      action: LeaveRequest_Action.RECONNECT,
                    })
                  );
                }
              });
            break;
          case 'subscriber-bandwidth':
            if (arg === undefined || typeof arg !== 'number') {
              throw new Error('subscriber-bandwidth requires a number as argument');
            }
            req = new SimulateScenario({
              scenario: {
                case: 'subscriberBandwidth',
                value: numberToBigInt(arg),
              },
            });
            break;
          case 'leave-full-reconnect':
            req = new SimulateScenario({
              scenario: {
                case: 'leaveRequestFullReconnect',
                value: true,
              },
            });
        }
        if (req) {
          yield this.engine.client.sendSimulateScenario(req);
          yield postAction();
        }
      });
    }
    /**
     * Returns true if audio playback is enabled
     */
    get canPlaybackAudio() {
      return this.audioEnabled;
    }
    /**
     * Returns true if video playback is enabled
     */
    get canPlaybackVideo() {
      return !this.isVideoPlaybackBlocked;
    }
    getActiveDevice(kind) {
      return this.localParticipant.activeDeviceMap.get(kind);
    }
    /**
     * Switches all active devices used in this room to the given device.
     *
     * Note: setting AudioOutput is not supported on some browsers. See [setSinkId](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/setSinkId#browser_compatibility)
     *
     * @param kind use `videoinput` for camera track,
     *  `audioinput` for microphone track,
     *  `audiooutput` to set speaker for all incoming audio tracks
     * @param deviceId
     */
    switchActiveDevice(kind_1, deviceId_1) {
      return __awaiter(this, arguments, void 0, function (kind, deviceId) {
        var _this3 = this;
        let exact = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
        return (function* () {
          var _a, _b, _c, _d, _e, _f;
          var _g;
          let success = true;
          let shouldTriggerImmediateDeviceChange = false;
          const deviceConstraint = exact
            ? {
                exact: deviceId,
              }
            : deviceId;
          if (kind === 'audioinput') {
            shouldTriggerImmediateDeviceChange =
              _this3.localParticipant.audioTrackPublications.size === 0;
            const prevDeviceId =
              (_a = _this3.getActiveDevice(kind)) !== null && _a !== void 0
                ? _a
                : _this3.options.audioCaptureDefaults.deviceId;
            _this3.options.audioCaptureDefaults.deviceId = deviceConstraint;
            const tracks = Array.from(
              _this3.localParticipant.audioTrackPublications.values()
            ).filter((track) => track.source === Track.Source.Microphone);
            try {
              success = (yield Promise.all(
                tracks.map((t) => {
                  var _a;
                  return (_a = t.audioTrack) === null || _a === void 0
                    ? void 0
                    : _a.setDeviceId(deviceConstraint);
                })
              )).every((val) => val === true);
            } catch (e) {
              _this3.options.audioCaptureDefaults.deviceId = prevDeviceId;
              throw e;
            }
            const isMuted = tracks.some((t) => {
              var _a, _b;
              return (_b = (_a = t.track) === null || _a === void 0 ? void 0 : _a.isMuted) !==
                null && _b !== void 0
                ? _b
                : false;
            });
            if (success && isMuted) shouldTriggerImmediateDeviceChange = true;
          } else if (kind === 'videoinput') {
            shouldTriggerImmediateDeviceChange =
              _this3.localParticipant.videoTrackPublications.size === 0;
            const prevDeviceId =
              (_b = _this3.getActiveDevice(kind)) !== null && _b !== void 0
                ? _b
                : _this3.options.videoCaptureDefaults.deviceId;
            _this3.options.videoCaptureDefaults.deviceId = deviceConstraint;
            const tracks = Array.from(
              _this3.localParticipant.videoTrackPublications.values()
            ).filter((track) => track.source === Track.Source.Camera);
            try {
              success = (yield Promise.all(
                tracks.map((t) => {
                  var _a;
                  return (_a = t.videoTrack) === null || _a === void 0
                    ? void 0
                    : _a.setDeviceId(deviceConstraint);
                })
              )).every((val) => val === true);
            } catch (e) {
              _this3.options.videoCaptureDefaults.deviceId = prevDeviceId;
              throw e;
            }
            const isMuted = tracks.some((t) => {
              var _a, _b;
              return (_b = (_a = t.track) === null || _a === void 0 ? void 0 : _a.isMuted) !==
                null && _b !== void 0
                ? _b
                : false;
            });
            if (success && isMuted) shouldTriggerImmediateDeviceChange = true;
          } else if (kind === 'audiooutput') {
            shouldTriggerImmediateDeviceChange = true;
            if (
              (!supportsSetSinkId() && !_this3.options.webAudioMix) ||
              (_this3.options.webAudioMix &&
                _this3.audioContext &&
                !('setSinkId' in _this3.audioContext))
            ) {
              throw new Error(
                'cannot switch audio output, the current browser does not support it'
              );
            }
            if (_this3.options.webAudioMix) {
              // setting `default` for web audio output doesn't work, so we need to normalize the id before
              deviceId =
                (_c = yield DeviceManager.getInstance().normalizeDeviceId(
                  'audiooutput',
                  deviceId
                )) !== null && _c !== void 0
                  ? _c
                  : '';
            }
            (_d = (_g = _this3.options).audioOutput) !== null && _d !== void 0
              ? _d
              : (_g.audioOutput = {});
            const prevDeviceId =
              (_e = _this3.getActiveDevice(kind)) !== null && _e !== void 0
                ? _e
                : _this3.options.audioOutput.deviceId;
            _this3.options.audioOutput.deviceId = deviceId;
            try {
              if (_this3.options.webAudioMix) {
                // @ts-expect-error setSinkId is not yet in the typescript type of AudioContext
                (_f = _this3.audioContext) === null || _f === void 0
                  ? void 0
                  : _f.setSinkId(deviceId);
              }
              // also set audio output on all audio elements, even if webAudioMix is enabled in order to workaround echo cancellation not working on chrome with non-default output devices
              // see https://issues.chromium.org/issues/40252911#comment7
              yield Promise.all(
                Array.from(_this3.remoteParticipants.values()).map((p) =>
                  p.setAudioOutput({
                    deviceId,
                  })
                )
              );
            } catch (e) {
              _this3.options.audioOutput.deviceId = prevDeviceId;
              throw e;
            }
          }
          if (shouldTriggerImmediateDeviceChange) {
            _this3.localParticipant.activeDeviceMap.set(kind, deviceId);
            _this3.emit(RoomEvent.ActiveDeviceChanged, kind, deviceId);
          }
          return success;
        })();
      });
    }
    setupLocalParticipantEvents() {
      this.localParticipant
        .on(ParticipantEvent.ParticipantMetadataChanged, this.onLocalParticipantMetadataChanged)
        .on(ParticipantEvent.ParticipantNameChanged, this.onLocalParticipantNameChanged)
        .on(ParticipantEvent.AttributesChanged, this.onLocalAttributesChanged)
        .on(ParticipantEvent.TrackMuted, this.onLocalTrackMuted)
        .on(ParticipantEvent.TrackUnmuted, this.onLocalTrackUnmuted)
        .on(ParticipantEvent.LocalTrackPublished, this.onLocalTrackPublished)
        .on(ParticipantEvent.LocalTrackUnpublished, this.onLocalTrackUnpublished)
        .on(ParticipantEvent.ConnectionQualityChanged, this.onLocalConnectionQualityChanged)
        .on(ParticipantEvent.MediaDevicesError, this.onMediaDevicesError)
        .on(ParticipantEvent.AudioStreamAcquired, this.startAudio)
        .on(ParticipantEvent.ChatMessage, this.onLocalChatMessageSent)
        .on(
          ParticipantEvent.ParticipantPermissionsChanged,
          this.onLocalParticipantPermissionsChanged
        );
    }
    recreateEngine() {
      var _a;
      (_a = this.engine) === null || _a === void 0 ? void 0 : _a.close();
      /* @ts-ignore */
      this.engine = undefined;
      this.isResuming = false;
      // clear out existing remote participants, since they may have attached
      // the old engine
      this.remoteParticipants.clear();
      this.sidToIdentity.clear();
      this.bufferedEvents = [];
      this.maybeCreateEngine();
    }
    onTrackAdded(mediaTrack, stream, receiver) {
      // don't fire onSubscribed when connecting
      // WebRTC fires onTrack as soon as setRemoteDescription is called on the offer
      // at that time, ICE connectivity has not been established so the track is not
      // technically subscribed.
      // We'll defer these events until when the room is connected or eventually disconnected.
      if (
        this.state === ConnectionState.Connecting ||
        this.state === ConnectionState.Reconnecting
      ) {
        const reconnectedHandler = () => {
          this.onTrackAdded(mediaTrack, stream, receiver);
          cleanup();
        };
        const cleanup = () => {
          this.off(RoomEvent.Reconnected, reconnectedHandler);
          this.off(RoomEvent.Connected, reconnectedHandler);
          this.off(RoomEvent.Disconnected, cleanup);
        };
        this.once(RoomEvent.Reconnected, reconnectedHandler);
        this.once(RoomEvent.Connected, reconnectedHandler);
        this.once(RoomEvent.Disconnected, cleanup);
        return;
      }
      if (this.state === ConnectionState.Disconnected) {
        this.log.warn('skipping incoming track after Room disconnected', this.logContext);
        return;
      }
      if (mediaTrack.readyState === 'ended') {
        this.log.info('skipping incoming track as it already ended', this.logContext);
        return;
      }
      const parts = unpackStreamId(stream.id);
      const participantSid = parts[0];
      let streamId = parts[1];
      let trackId = mediaTrack.id;
      // firefox will get streamId (pID|trackId) instead of (pID|streamId) as it doesn't support sync tracks by stream
      // and generates its own track id instead of infer from sdp track id.
      if (streamId && streamId.startsWith('TR')) trackId = streamId;
      if (participantSid === this.localParticipant.sid) {
        this.log.warn('tried to create RemoteParticipant for local participant', this.logContext);
        return;
      }
      const participant = Array.from(this.remoteParticipants.values()).find(
        (p) => p.sid === participantSid
      );
      if (!participant) {
        this.log.error(
          "Tried to add a track for a participant, that's not present. Sid: ".concat(
            participantSid
          ),
          this.logContext
        );
        return;
      }
      let adaptiveStreamSettings;
      if (this.options.adaptiveStream) {
        if (typeof this.options.adaptiveStream === 'object') {
          adaptiveStreamSettings = this.options.adaptiveStream;
        } else {
          adaptiveStreamSettings = {};
        }
      }
      const publication = participant.addSubscribedMediaTrack(
        mediaTrack,
        trackId,
        stream,
        receiver,
        adaptiveStreamSettings
      );
      if (
        (publication === null || publication === void 0 ? void 0 : publication.isEncrypted) &&
        !this.e2eeManager
      ) {
        this.emit(
          RoomEvent.EncryptionError,
          new Error(
            'Encrypted '
              .concat(publication.source, ' track received from participant ')
              .concat(participant.sid, ', but room does not have encryption enabled!')
          )
        );
      }
    }
    handleDisconnect() {
      let shouldStopTracks =
        arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      let reason = arguments.length > 1 ? arguments[1] : undefined;
      var _a;
      this.clearConnectionReconcile();
      this.isResuming = false;
      this.bufferedEvents = [];
      this.transcriptionReceivedTimes.clear();
      this.incomingDataStreamManager.clearHandlersAndControllers();
      if (this.state === ConnectionState.Disconnected) {
        return;
      }
      this.regionUrl = undefined;
      try {
        this.remoteParticipants.forEach((p) => {
          p.trackPublications.forEach((pub) => {
            p.unpublishTrack(pub.trackSid);
          });
        });
        this.localParticipant.trackPublications.forEach((pub) => {
          var _a, _b, _c;
          if (pub.track) {
            this.localParticipant.unpublishTrack(pub.track, shouldStopTracks);
          }
          if (shouldStopTracks) {
            (_a = pub.track) === null || _a === void 0 ? void 0 : _a.detach();
            (_b = pub.track) === null || _b === void 0 ? void 0 : _b.stop();
          } else {
            (_c = pub.track) === null || _c === void 0 ? void 0 : _c.stopMonitor();
          }
        });
        this.localParticipant
          .off(ParticipantEvent.ParticipantMetadataChanged, this.onLocalParticipantMetadataChanged)
          .off(ParticipantEvent.ParticipantNameChanged, this.onLocalParticipantNameChanged)
          .off(ParticipantEvent.AttributesChanged, this.onLocalAttributesChanged)
          .off(ParticipantEvent.TrackMuted, this.onLocalTrackMuted)
          .off(ParticipantEvent.TrackUnmuted, this.onLocalTrackUnmuted)
          .off(ParticipantEvent.LocalTrackPublished, this.onLocalTrackPublished)
          .off(ParticipantEvent.LocalTrackUnpublished, this.onLocalTrackUnpublished)
          .off(ParticipantEvent.ConnectionQualityChanged, this.onLocalConnectionQualityChanged)
          .off(ParticipantEvent.MediaDevicesError, this.onMediaDevicesError)
          .off(ParticipantEvent.AudioStreamAcquired, this.startAudio)
          .off(ParticipantEvent.ChatMessage, this.onLocalChatMessageSent)
          .off(
            ParticipantEvent.ParticipantPermissionsChanged,
            this.onLocalParticipantPermissionsChanged
          );
        this.localParticipant.trackPublications.clear();
        this.localParticipant.videoTrackPublications.clear();
        this.localParticipant.audioTrackPublications.clear();
        this.remoteParticipants.clear();
        this.sidToIdentity.clear();
        this.activeSpeakers = [];
        if (this.audioContext && typeof this.options.webAudioMix === 'boolean') {
          this.audioContext.close();
          this.audioContext = undefined;
        }
        if (isWeb()) {
          window.removeEventListener('beforeunload', this.onPageLeave);
          window.removeEventListener('pagehide', this.onPageLeave);
          window.removeEventListener('freeze', this.onPageLeave);
          (_a = navigator.mediaDevices) === null || _a === void 0
            ? void 0
            : _a.removeEventListener('devicechange', this.handleDeviceChange);
        }
      } finally {
        this.setAndEmitConnectionState(ConnectionState.Disconnected);
        this.emit(RoomEvent.Disconnected, reason);
      }
    }
    handleParticipantDisconnected(identity, participant) {
      var _a;
      // remove and send event
      this.remoteParticipants.delete(identity);
      if (!participant) {
        return;
      }
      this.incomingDataStreamManager.validateParticipantHasNoActiveDataStreams(identity);
      participant.trackPublications.forEach((publication) => {
        participant.unpublishTrack(publication.trackSid, true);
      });
      this.emit(RoomEvent.ParticipantDisconnected, participant);
      participant.setDisconnected();
      (_a = this.localParticipant) === null || _a === void 0
        ? void 0
        : _a.handleParticipantDisconnected(participant.identity);
    }
    handleIncomingRpcRequest(callerIdentity, requestId, method, payload, responseTimeout, version) {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.engine.publishRpcAck(callerIdentity, requestId);
        if (version !== 1) {
          yield this.engine.publishRpcResponse(
            callerIdentity,
            requestId,
            null,
            RpcError.builtIn('UNSUPPORTED_VERSION')
          );
          return;
        }
        const handler = this.rpcHandlers.get(method);
        if (!handler) {
          yield this.engine.publishRpcResponse(
            callerIdentity,
            requestId,
            null,
            RpcError.builtIn('UNSUPPORTED_METHOD')
          );
          return;
        }
        let responseError = null;
        let responsePayload = null;
        try {
          const response = yield handler({
            requestId,
            callerIdentity,
            payload,
            responseTimeout,
          });
          if (byteLength(response) > MAX_PAYLOAD_BYTES) {
            responseError = RpcError.builtIn('RESPONSE_PAYLOAD_TOO_LARGE');
            console.warn('RPC Response payload too large for '.concat(method));
          } else {
            responsePayload = response;
          }
        } catch (error) {
          if (error instanceof RpcError) {
            responseError = error;
          } else {
            console.warn(
              'Uncaught error returned by RPC handler for '.concat(
                method,
                '. Returning APPLICATION_ERROR instead.'
              ),
              error
            );
            responseError = RpcError.builtIn('APPLICATION_ERROR');
          }
        }
        yield this.engine.publishRpcResponse(
          callerIdentity,
          requestId,
          responsePayload,
          responseError
        );
      });
    }
    /**
     * attempt to select the default devices if the previously selected devices are no longer available after a device change event
     */
    selectDefaultDevices() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, _b, _c;
        const previousDevices = DeviceManager.getInstance().previousDevices;
        // check for available devices, but don't request permissions in order to avoid prompts for kinds that haven't been used before
        const availableDevices = yield DeviceManager.getInstance().getDevices(undefined, false);
        const browser = getBrowser();
        if (
          (browser === null || browser === void 0 ? void 0 : browser.name) === 'Chrome' &&
          browser.os !== 'iOS'
        ) {
          for (let availableDevice of availableDevices) {
            const previousDevice = previousDevices.find(
              (info) => info.deviceId === availableDevice.deviceId
            );
            if (
              previousDevice &&
              previousDevice.label !== '' &&
              previousDevice.kind === availableDevice.kind &&
              previousDevice.label !== availableDevice.label
            ) {
              // label has changed on device the same deviceId, indicating that the default device has changed on the OS level
              if (this.getActiveDevice(availableDevice.kind) === 'default') {
                // emit an active device change event only if the selected output device is actually on `default`
                this.emit(
                  RoomEvent.ActiveDeviceChanged,
                  availableDevice.kind,
                  availableDevice.deviceId
                );
              }
            }
          }
        }
        const kinds = ['audiooutput', 'audioinput', 'videoinput'];
        for (let kind of kinds) {
          const targetSource = kindToSource(kind);
          const targetPublication = this.localParticipant.getTrackPublication(targetSource);
          if (
            targetPublication &&
            ((_a = targetPublication.track) === null || _a === void 0 ? void 0 : _a.isUserProvided)
          ) {
            // if the track is user provided, we don't want to switch devices on behalf of the user
            continue;
          }
          const devicesOfKind = availableDevices.filter((d) => d.kind === kind);
          const activeDevice = this.getActiveDevice(kind);
          if (
            activeDevice ===
            ((_b = previousDevices.filter((info) => info.kind === kind)[0]) === null ||
            _b === void 0
              ? void 0
              : _b.deviceId)
          ) {
            // in  Safari the first device is always the default, so we assume a user on the default device would like to switch to the default once it changes
            // FF doesn't emit an event when the default device changes, so we perform the same best effort and switch to the new device once connected and if it's the first in the array
            if (
              devicesOfKind.length > 0 &&
              ((_c = devicesOfKind[0]) === null || _c === void 0 ? void 0 : _c.deviceId) !==
                activeDevice
            ) {
              yield this.switchActiveDevice(kind, devicesOfKind[0].deviceId);
              continue;
            }
          }
          if ((kind === 'audioinput' && !isSafariBased()) || kind === 'videoinput') {
            // airpods on Safari need special handling for audioinput as the track doesn't end as soon as you take them out
            continue;
          }
          // switch to first available device if previously active device is not available any more
          if (
            devicesOfKind.length > 0 &&
            !devicesOfKind.find(
              (deviceInfo) => deviceInfo.deviceId === this.getActiveDevice(kind)
            ) &&
            // avoid switching audio output on safari without explicit user action as it leads to slowed down audio playback
            (kind !== 'audiooutput' || !isSafariBased())
          ) {
            yield this.switchActiveDevice(kind, devicesOfKind[0].deviceId);
          }
        }
      });
    }
    acquireAudioContext() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, _b;
        if (
          typeof this.options.webAudioMix !== 'boolean' &&
          this.options.webAudioMix.audioContext
        ) {
          // override audio context with custom audio context if supplied by user
          this.audioContext = this.options.webAudioMix.audioContext;
        } else if (!this.audioContext || this.audioContext.state === 'closed') {
          // by using an AudioContext, it reduces lag on audio elements
          // https://stackoverflow.com/questions/9811429/html5-audio-tag-on-safari-has-a-delay/54119854#54119854
          this.audioContext =
            (_a = getNewAudioContext()) !== null && _a !== void 0 ? _a : undefined;
        }
        if (this.options.webAudioMix) {
          this.remoteParticipants.forEach((participant) =>
            participant.setAudioContext(this.audioContext)
          );
        }
        this.localParticipant.setAudioContext(this.audioContext);
        if (this.audioContext && this.audioContext.state === 'suspended') {
          // for iOS a newly created AudioContext is always in `suspended` state.
          // we try our best to resume the context here, if that doesn't work, we just continue with regular processing
          try {
            yield Promise.race([this.audioContext.resume(), sleep(200)]);
          } catch (e) {
            this.log.warn(
              'Could not resume audio context',
              Object.assign(Object.assign({}, this.logContext), {
                error: e,
              })
            );
          }
        }
        const newContextIsRunning =
          ((_b = this.audioContext) === null || _b === void 0 ? void 0 : _b.state) === 'running';
        if (newContextIsRunning !== this.canPlaybackAudio) {
          this.audioEnabled = newContextIsRunning;
          this.emit(RoomEvent.AudioPlaybackStatusChanged, newContextIsRunning);
        }
      });
    }
    createParticipant(identity, info) {
      var _a;
      let participant;
      if (info) {
        participant = RemoteParticipant.fromParticipantInfo(this.engine.client, info, {
          loggerContextCb: () => this.logContext,
          loggerName: this.options.loggerName,
        });
      } else {
        participant = new RemoteParticipant(
          this.engine.client,
          '',
          identity,
          undefined,
          undefined,
          undefined,
          {
            loggerContextCb: () => this.logContext,
            loggerName: this.options.loggerName,
          }
        );
      }
      if (this.options.webAudioMix) {
        participant.setAudioContext(this.audioContext);
      }
      if ((_a = this.options.audioOutput) === null || _a === void 0 ? void 0 : _a.deviceId) {
        participant
          .setAudioOutput(this.options.audioOutput)
          .catch((e) =>
            this.log.warn('Could not set audio output: '.concat(e.message), this.logContext)
          );
      }
      return participant;
    }
    getOrCreateParticipant(identity, info) {
      if (this.remoteParticipants.has(identity)) {
        const existingParticipant = this.remoteParticipants.get(identity);
        if (info) {
          const wasUpdated = existingParticipant.updateInfo(info);
          if (wasUpdated) {
            this.sidToIdentity.set(info.sid, info.identity);
          }
        }
        return existingParticipant;
      }
      const participant = this.createParticipant(identity, info);
      this.remoteParticipants.set(identity, participant);
      this.sidToIdentity.set(info.sid, info.identity);
      // if we have valid info and the participant wasn't in the map before, we can assume the participant is new
      // firing here to make sure that `ParticipantConnected` fires before the initial track events
      this.emitWhenConnected(RoomEvent.ParticipantConnected, participant);
      // also forward events
      // trackPublished is only fired for tracks added after both local participant
      // and remote participant joined the room
      participant
        .on(ParticipantEvent.TrackPublished, (trackPublication) => {
          this.emitWhenConnected(RoomEvent.TrackPublished, trackPublication, participant);
        })
        .on(ParticipantEvent.TrackSubscribed, (track, publication) => {
          // monitor playback status
          if (track.kind === Track.Kind.Audio) {
            track.on(TrackEvent.AudioPlaybackStarted, this.handleAudioPlaybackStarted);
            track.on(TrackEvent.AudioPlaybackFailed, this.handleAudioPlaybackFailed);
          } else if (track.kind === Track.Kind.Video) {
            track.on(TrackEvent.VideoPlaybackFailed, this.handleVideoPlaybackFailed);
            track.on(TrackEvent.VideoPlaybackStarted, this.handleVideoPlaybackStarted);
          }
          this.emit(RoomEvent.TrackSubscribed, track, publication, participant);
        })
        .on(ParticipantEvent.TrackUnpublished, (publication) => {
          this.emit(RoomEvent.TrackUnpublished, publication, participant);
        })
        .on(ParticipantEvent.TrackUnsubscribed, (track, publication) => {
          this.emit(RoomEvent.TrackUnsubscribed, track, publication, participant);
        })
        .on(ParticipantEvent.TrackMuted, (pub) => {
          this.emitWhenConnected(RoomEvent.TrackMuted, pub, participant);
        })
        .on(ParticipantEvent.TrackUnmuted, (pub) => {
          this.emitWhenConnected(RoomEvent.TrackUnmuted, pub, participant);
        })
        .on(ParticipantEvent.ParticipantMetadataChanged, (metadata) => {
          this.emitWhenConnected(RoomEvent.ParticipantMetadataChanged, metadata, participant);
        })
        .on(ParticipantEvent.ParticipantNameChanged, (name) => {
          this.emitWhenConnected(RoomEvent.ParticipantNameChanged, name, participant);
        })
        .on(ParticipantEvent.AttributesChanged, (changedAttributes) => {
          this.emitWhenConnected(
            RoomEvent.ParticipantAttributesChanged,
            changedAttributes,
            participant
          );
        })
        .on(ParticipantEvent.ConnectionQualityChanged, (quality) => {
          this.emitWhenConnected(RoomEvent.ConnectionQualityChanged, quality, participant);
        })
        .on(ParticipantEvent.ParticipantPermissionsChanged, (prevPermissions) => {
          this.emitWhenConnected(
            RoomEvent.ParticipantPermissionsChanged,
            prevPermissions,
            participant
          );
        })
        .on(ParticipantEvent.TrackSubscriptionStatusChanged, (pub, status) => {
          this.emitWhenConnected(
            RoomEvent.TrackSubscriptionStatusChanged,
            pub,
            status,
            participant
          );
        })
        .on(ParticipantEvent.TrackSubscriptionFailed, (trackSid, error) => {
          this.emit(RoomEvent.TrackSubscriptionFailed, trackSid, participant, error);
        })
        .on(ParticipantEvent.TrackSubscriptionPermissionChanged, (pub, status) => {
          this.emitWhenConnected(
            RoomEvent.TrackSubscriptionPermissionChanged,
            pub,
            status,
            participant
          );
        })
        .on(ParticipantEvent.Active, () => {
          this.emitWhenConnected(RoomEvent.ParticipantActive, participant);
          if (participant.kind === ParticipantInfo_Kind.AGENT) {
            this.localParticipant.setActiveAgent(participant);
          }
        });
      // update info at the end after callbacks have been set up
      if (info) {
        participant.updateInfo(info);
      }
      return participant;
    }
    sendSyncState() {
      const remoteTracks = Array.from(this.remoteParticipants.values()).reduce(
        (acc, participant) => {
          acc.push(...participant.getTrackPublications()); // FIXME would be nice to have this return RemoteTrackPublications directly instead of the type cast
          return acc;
        },
        []
      );
      const localTracks = this.localParticipant.getTrackPublications(); // FIXME would be nice to have this return LocalTrackPublications directly instead of the type cast
      this.engine.sendSyncState(remoteTracks, localTracks);
    }
    /**
     * After resuming, we'll need to notify the server of the current
     * subscription settings.
     */
    updateSubscriptions() {
      for (const p of this.remoteParticipants.values()) {
        for (const pub of p.videoTrackPublications.values()) {
          if (pub.isSubscribed && isRemotePub(pub)) {
            pub.emitTrackUpdate();
          }
        }
      }
    }
    getRemoteParticipantBySid(sid) {
      const identity = this.sidToIdentity.get(sid);
      if (identity) {
        return this.remoteParticipants.get(identity);
      }
    }
    registerConnectionReconcile() {
      this.clearConnectionReconcile();
      let consecutiveFailures = 0;
      this.connectionReconcileInterval = CriticalTimers.setInterval(() => {
        if (
          // ensure we didn't tear it down
          !this.engine ||
          // engine detected close, but Room missed it
          this.engine.isClosed ||
          // transports failed without notifying engine
          !this.engine.verifyTransport()
        ) {
          consecutiveFailures++;
          this.log.warn(
            'detected connection state mismatch',
            Object.assign(Object.assign({}, this.logContext), {
              numFailures: consecutiveFailures,
              engine: this.engine
                ? {
                    closed: this.engine.isClosed,
                    transportsConnected: this.engine.verifyTransport(),
                  }
                : undefined,
            })
          );
          if (consecutiveFailures >= 3) {
            this.recreateEngine();
            this.handleDisconnect(
              this.options.stopLocalTrackOnUnpublish,
              DisconnectReason.STATE_MISMATCH
            );
          }
        } else {
          consecutiveFailures = 0;
        }
      }, connectionReconcileFrequency);
    }
    clearConnectionReconcile() {
      if (this.connectionReconcileInterval) {
        CriticalTimers.clearInterval(this.connectionReconcileInterval);
      }
    }
    setAndEmitConnectionState(state) {
      if (state === this.state) {
        // unchanged
        return false;
      }
      this.state = state;
      this.emit(RoomEvent.ConnectionStateChanged, this.state);
      return true;
    }
    emitBufferedEvents() {
      this.bufferedEvents.forEach((_ref3) => {
        let [ev, args] = _ref3;
        this.emit(ev, ...args);
      });
      this.bufferedEvents = [];
    }
    emitWhenConnected(event) {
      for (
        var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1;
        _key2 < _len2;
        _key2++
      ) {
        args[_key2 - 1] = arguments[_key2];
      }
      if (
        this.state === ConnectionState.Reconnecting ||
        this.isResuming ||
        !this.engine ||
        this.engine.pendingReconnect
      ) {
        // in case the room is reconnecting, buffer the events by firing them later after emitting RoomEvent.Reconnected
        this.bufferedEvents.push([event, args]);
      } else if (this.state === ConnectionState.Connected) {
        return this.emit(event, ...args);
      }
      return false;
    }
    /**
     * Allows to populate a room with simulated participants.
     * No actual connection to a server will be established, all state is
     * @experimental
     */
    simulateParticipants(options) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, _b;
        const publishOptions = Object.assign(
          {
            audio: true,
            video: true,
            useRealTracks: false,
          },
          options.publish
        );
        const participantOptions = Object.assign(
          {
            count: 9,
            audio: false,
            video: true,
            aspectRatios: [1.66, 1.7, 1.3],
          },
          options.participants
        );
        this.handleDisconnect();
        this.roomInfo = new Room$1({
          sid: 'RM_SIMULATED',
          name: 'simulated-room',
          emptyTimeout: 0,
          maxParticipants: 0,
          creationTime: protoInt64.parse(new Date().getTime()),
          metadata: '',
          numParticipants: 1,
          numPublishers: 1,
          turnPassword: '',
          enabledCodecs: [],
          activeRecording: false,
        });
        this.localParticipant.updateInfo(
          new ParticipantInfo({
            identity: 'simulated-local',
            name: 'local-name',
          })
        );
        this.setupLocalParticipantEvents();
        this.emit(RoomEvent.SignalConnected);
        this.emit(RoomEvent.Connected);
        this.setAndEmitConnectionState(ConnectionState.Connected);
        if (publishOptions.video) {
          const camPub = new LocalTrackPublication(
            Track.Kind.Video,
            new TrackInfo({
              source: TrackSource.CAMERA,
              sid: Math.floor(Math.random() * 10000).toString(),
              type: TrackType.AUDIO,
              name: 'video-dummy',
            }),
            new LocalVideoTrack(
              publishOptions.useRealTracks
                ? (yield window.navigator.mediaDevices.getUserMedia({
                    video: true,
                  })).getVideoTracks()[0]
                : createDummyVideoStreamTrack(
                    160 *
                      ((_a = participantOptions.aspectRatios[0]) !== null && _a !== void 0
                        ? _a
                        : 1),
                    160,
                    true,
                    true
                  ),
              undefined,
              false,
              {
                loggerName: this.options.loggerName,
                loggerContextCb: () => this.logContext,
              }
            ),
            {
              loggerName: this.options.loggerName,
              loggerContextCb: () => this.logContext,
            }
          );
          // @ts-ignore
          this.localParticipant.addTrackPublication(camPub);
          this.localParticipant.emit(ParticipantEvent.LocalTrackPublished, camPub);
        }
        if (publishOptions.audio) {
          const audioPub = new LocalTrackPublication(
            Track.Kind.Audio,
            new TrackInfo({
              source: TrackSource.MICROPHONE,
              sid: Math.floor(Math.random() * 10000).toString(),
              type: TrackType.AUDIO,
            }),
            new LocalAudioTrack(
              publishOptions.useRealTracks
                ? (yield navigator.mediaDevices.getUserMedia({
                    audio: true,
                  })).getAudioTracks()[0]
                : getEmptyAudioStreamTrack(),
              undefined,
              false,
              this.audioContext,
              {
                loggerName: this.options.loggerName,
                loggerContextCb: () => this.logContext,
              }
            ),
            {
              loggerName: this.options.loggerName,
              loggerContextCb: () => this.logContext,
            }
          );
          // @ts-ignore
          this.localParticipant.addTrackPublication(audioPub);
          this.localParticipant.emit(ParticipantEvent.LocalTrackPublished, audioPub);
        }
        for (let i = 0; i < participantOptions.count - 1; i += 1) {
          let info = new ParticipantInfo({
            sid: Math.floor(Math.random() * 10000).toString(),
            identity: 'simulated-'.concat(i),
            state: ParticipantInfo_State.ACTIVE,
            tracks: [],
            joinedAt: protoInt64.parse(Date.now()),
          });
          const p = this.getOrCreateParticipant(info.identity, info);
          if (participantOptions.video) {
            const dummyVideo = createDummyVideoStreamTrack(
              160 *
                ((_b =
                  participantOptions.aspectRatios[i % participantOptions.aspectRatios.length]) !==
                  null && _b !== void 0
                  ? _b
                  : 1),
              160,
              false,
              true
            );
            const videoTrack = new TrackInfo({
              source: TrackSource.CAMERA,
              sid: Math.floor(Math.random() * 10000).toString(),
              type: TrackType.AUDIO,
            });
            p.addSubscribedMediaTrack(
              dummyVideo,
              videoTrack.sid,
              new MediaStream([dummyVideo]),
              new RTCRtpReceiver()
            );
            info.tracks = [...info.tracks, videoTrack];
          }
          if (participantOptions.audio) {
            const dummyTrack = getEmptyAudioStreamTrack();
            const audioTrack = new TrackInfo({
              source: TrackSource.MICROPHONE,
              sid: Math.floor(Math.random() * 10000).toString(),
              type: TrackType.AUDIO,
            });
            p.addSubscribedMediaTrack(
              dummyTrack,
              audioTrack.sid,
              new MediaStream([dummyTrack]),
              new RTCRtpReceiver()
            );
            info.tracks = [...info.tracks, audioTrack];
          }
          p.updateInfo(info);
        }
      });
    }
    // /** @internal */
    emit(event) {
      for (
        var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1;
        _key3 < _len3;
        _key3++
      ) {
        args[_key3 - 1] = arguments[_key3];
      }
      // active speaker updates are too spammy
      if (event !== RoomEvent.ActiveSpeakersChanged && event !== RoomEvent.TranscriptionReceived) {
        // only extract logContext from arguments in order to avoid logging the whole object tree
        const minimizedArgs = mapArgs(args).filter((arg) => arg !== undefined);
        this.log.debug(
          'room event '.concat(event),
          Object.assign(Object.assign({}, this.logContext), {
            event,
            args: minimizedArgs,
          })
        );
      }
      return super.emit(event, ...args);
    }
  }
  Room.cleanupRegistry =
    typeof FinalizationRegistry !== 'undefined' &&
    new FinalizationRegistry((cleanup) => {
      cleanup();
    });
  function mapArgs(args) {
    return args.map((arg) => {
      if (!arg) {
        return;
      }
      if (Array.isArray(arg)) {
        return mapArgs(arg);
      }
      if (typeof arg === 'object') {
        return 'logContext' in arg ? arg.logContext : undefined;
      }
      return arg;
    });
  }

  // This file was generated from JSON Schema using quicktype, do not modify it directly.
  // The code generation lives at https://github.com/livekit/attribute-definitions
  //
  // To parse this data:
  //
  //   import { Convert, AgentAttributes, TranscriptionAttributes } from "./file";
  //
  //   const agentAttributes = Convert.toAgentAttributes(json);
  //   const transcriptionAttributes = Convert.toTranscriptionAttributes(json);
  // Converts JSON strings to/from your types
  class Convert {
    static toAgentAttributes(json) {
      return JSON.parse(json);
    }
    static agentAttributesToJson(value) {
      return JSON.stringify(value);
    }
    static toTranscriptionAttributes(json) {
      return JSON.parse(json);
    }
    static transcriptionAttributesToJson(value) {
      return JSON.stringify(value);
    }
  }

  var attributeTypings = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    Convert: Convert,
  });

  var CheckStatus;
  (function (CheckStatus) {
    CheckStatus[(CheckStatus['IDLE'] = 0)] = 'IDLE';
    CheckStatus[(CheckStatus['RUNNING'] = 1)] = 'RUNNING';
    CheckStatus[(CheckStatus['SKIPPED'] = 2)] = 'SKIPPED';
    CheckStatus[(CheckStatus['SUCCESS'] = 3)] = 'SUCCESS';
    CheckStatus[(CheckStatus['FAILED'] = 4)] = 'FAILED';
  })(CheckStatus || (CheckStatus = {}));
  class Checker extends eventsExports.EventEmitter {
    constructor(url, token) {
      let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      super();
      this.status = CheckStatus.IDLE;
      this.logs = [];
      this.options = {};
      this.url = url;
      this.token = token;
      this.name = this.constructor.name;
      this.room = new Room(options.roomOptions);
      this.connectOptions = options.connectOptions;
      this.options = options;
    }
    run(onComplete) {
      return __awaiter(this, void 0, void 0, function* () {
        if (this.status !== CheckStatus.IDLE) {
          throw Error('check is running already');
        }
        this.setStatus(CheckStatus.RUNNING);
        try {
          yield this.perform();
        } catch (err) {
          if (err instanceof Error) {
            if (this.options.errorsAsWarnings) {
              this.appendWarning(err.message);
            } else {
              this.appendError(err.message);
            }
          }
        }
        yield this.disconnect();
        // sleep for a bit to ensure disconnect
        yield new Promise((resolve) => setTimeout(resolve, 500));
        // @ts-ignore
        if (this.status !== CheckStatus.SKIPPED) {
          this.setStatus(this.isSuccess() ? CheckStatus.SUCCESS : CheckStatus.FAILED);
        }
        if (onComplete) {
          onComplete();
        }
        return this.getInfo();
      });
    }
    isSuccess() {
      return !this.logs.some((l) => l.level === 'error');
    }
    connect(url) {
      return __awaiter(this, void 0, void 0, function* () {
        if (this.room.state === ConnectionState.Connected) {
          return this.room;
        }
        if (!url) {
          url = this.url;
        }
        yield this.room.connect(url, this.token, this.connectOptions);
        return this.room;
      });
    }
    disconnect() {
      return __awaiter(this, void 0, void 0, function* () {
        if (this.room && this.room.state !== ConnectionState.Disconnected) {
          yield this.room.disconnect();
          // wait for it to go through
          yield new Promise((resolve) => setTimeout(resolve, 500));
        }
      });
    }
    skip() {
      this.setStatus(CheckStatus.SKIPPED);
    }
    switchProtocol(protocol) {
      return __awaiter(this, void 0, void 0, function* () {
        let hasReconnecting = false;
        let hasReconnected = false;
        this.room.on(RoomEvent.Reconnecting, () => {
          hasReconnecting = true;
        });
        this.room.once(RoomEvent.Reconnected, () => {
          hasReconnected = true;
        });
        this.room.simulateScenario('force-'.concat(protocol));
        yield new Promise((resolve) => setTimeout(resolve, 1000));
        if (!hasReconnecting) {
          // no need to wait for reconnection
          return;
        }
        // wait for 10 seconds for reconnection
        const timeout = Date.now() + 10000;
        while (Date.now() < timeout) {
          if (hasReconnected) {
            return;
          }
          yield sleep(100);
        }
        throw new Error(
          'Could not reconnect using '.concat(protocol, ' protocol after 10 seconds')
        );
      });
    }
    appendMessage(message) {
      this.logs.push({
        level: 'info',
        message,
      });
      this.emit('update', this.getInfo());
    }
    appendWarning(message) {
      this.logs.push({
        level: 'warning',
        message,
      });
      this.emit('update', this.getInfo());
    }
    appendError(message) {
      this.logs.push({
        level: 'error',
        message,
      });
      this.emit('update', this.getInfo());
    }
    setStatus(status) {
      this.status = status;
      this.emit('update', this.getInfo());
    }
    get engine() {
      var _a;
      return (_a = this.room) === null || _a === void 0 ? void 0 : _a.engine;
    }
    getInfo() {
      return {
        logs: this.logs,
        name: this.name,
        status: this.status,
        description: this.description,
      };
    }
  }

  /**
   * Checks for connections quality to closests Cloud regions and determining the best quality
   */
  class CloudRegionCheck extends Checker {
    get description() {
      return 'Cloud regions';
    }
    perform() {
      return __awaiter(this, void 0, void 0, function* () {
        const regionProvider = new RegionUrlProvider(this.url, this.token);
        if (!regionProvider.isCloud()) {
          this.skip();
          return;
        }
        const regionStats = [];
        const seenUrls = new Set();
        for (let i = 0; i < 3; i++) {
          const regionUrl = yield regionProvider.getNextBestRegionUrl();
          if (!regionUrl) {
            break;
          }
          if (seenUrls.has(regionUrl)) {
            continue;
          }
          seenUrls.add(regionUrl);
          const stats = yield this.checkCloudRegion(regionUrl);
          this.appendMessage(
            ''
              .concat(stats.region, ' RTT: ')
              .concat(stats.rtt, 'ms, duration: ')
              .concat(stats.duration, 'ms')
          );
          regionStats.push(stats);
        }
        regionStats.sort((a, b) => {
          return (a.duration - b.duration) * 0.5 + (a.rtt - b.rtt) * 0.5;
        });
        const bestRegion = regionStats[0];
        this.bestStats = bestRegion;
        this.appendMessage('best Cloud region: '.concat(bestRegion.region));
      });
    }
    getInfo() {
      const info = super.getInfo();
      info.data = this.bestStats;
      return info;
    }
    checkCloudRegion(url) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, _b;
        yield this.connect(url);
        if (this.options.protocol === 'tcp') {
          yield this.switchProtocol('tcp');
        }
        const region = (_a = this.room.serverInfo) === null || _a === void 0 ? void 0 : _a.region;
        if (!region) {
          throw new Error('Region not found');
        }
        const writer = yield this.room.localParticipant.streamText({
          topic: 'test',
        });
        const chunkSize = 1000; // each chunk is about 1000 bytes
        const totalSize = 1000000; // approximately 1MB of data
        const numChunks = totalSize / chunkSize; // will yield 1000 chunks
        const chunkData = 'A'.repeat(chunkSize); // create a string of 1000 'A' characters
        const startTime = Date.now();
        for (let i = 0; i < numChunks; i++) {
          yield writer.write(chunkData);
        }
        yield writer.close();
        const endTime = Date.now();
        const stats = yield (_b = this.room.engine.pcManager) === null || _b === void 0
          ? void 0
          : _b.publisher.getStats();
        const regionStats = {
          region: region,
          rtt: 10000,
          duration: endTime - startTime,
        };
        stats === null || stats === void 0
          ? void 0
          : stats.forEach((stat) => {
              if (stat.type === 'candidate-pair' && stat.nominated) {
                regionStats.rtt = stat.currentRoundTripTime * 1000;
              }
            });
        yield this.disconnect();
        return regionStats;
      });
    }
  }

  const TEST_DURATION = 10000;
  class ConnectionProtocolCheck extends Checker {
    get description() {
      return 'Connection via UDP vs TCP';
    }
    perform() {
      return __awaiter(this, void 0, void 0, function* () {
        const udpStats = yield this.checkConnectionProtocol('udp');
        const tcpStats = yield this.checkConnectionProtocol('tcp');
        this.bestStats = udpStats;
        // udp should is the better protocol typically. however, we'd prefer TCP when either of these conditions are true:
        // 1. the bandwidth limitation is worse on UDP by 500ms
        // 2. the packet loss is higher on UDP by 1%
        if (
          udpStats.qualityLimitationDurations.bandwidth -
            tcpStats.qualityLimitationDurations.bandwidth >
            0.5 ||
          (udpStats.packetsLost - tcpStats.packetsLost) / udpStats.packetsSent > 0.01
        ) {
          this.appendMessage('best connection quality via tcp');
          this.bestStats = tcpStats;
        } else {
          this.appendMessage('best connection quality via udp');
        }
        const stats = this.bestStats;
        this.appendMessage(
          'upstream bitrate: '.concat(
            (stats.bitrateTotal / stats.count / 1000 / 1000).toFixed(2),
            ' mbps'
          )
        );
        this.appendMessage(
          'RTT: '.concat(((stats.rttTotal / stats.count) * 1000).toFixed(2), ' ms')
        );
        this.appendMessage(
          'jitter: '.concat(((stats.jitterTotal / stats.count) * 1000).toFixed(2), ' ms')
        );
        if (stats.packetsLost > 0) {
          this.appendWarning(
            'packets lost: '.concat(((stats.packetsLost / stats.packetsSent) * 100).toFixed(2), '%')
          );
        }
        if (stats.qualityLimitationDurations.bandwidth > 1) {
          this.appendWarning(
            'bandwidth limited '.concat(
              ((stats.qualityLimitationDurations.bandwidth / (TEST_DURATION / 1000)) * 100).toFixed(
                2
              ),
              '%'
            )
          );
        }
        if (stats.qualityLimitationDurations.cpu > 0) {
          this.appendWarning(
            'cpu limited '.concat(
              ((stats.qualityLimitationDurations.cpu / (TEST_DURATION / 1000)) * 100).toFixed(2),
              '%'
            )
          );
        }
      });
    }
    getInfo() {
      const info = super.getInfo();
      info.data = this.bestStats;
      return info;
    }
    checkConnectionProtocol(protocol) {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.connect();
        if (protocol === 'tcp') {
          yield this.switchProtocol('tcp');
        } else {
          yield this.switchProtocol('udp');
        }
        // create a canvas with animated content
        const canvas = document.createElement('canvas');
        canvas.width = 1280;
        canvas.height = 720;
        const ctx = canvas.getContext('2d');
        if (!ctx) {
          throw new Error('Could not get canvas context');
        }
        let hue = 0;
        const animate = () => {
          hue = (hue + 1) % 360;
          ctx.fillStyle = 'hsl('.concat(hue, ', 100%, 50%)');
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          requestAnimationFrame(animate);
        };
        animate();
        // create video track from canvas
        const stream = canvas.captureStream(30); // 30fps
        const videoTrack = stream.getVideoTracks()[0];
        // publish to room
        const pub = yield this.room.localParticipant.publishTrack(videoTrack, {
          simulcast: false,
          degradationPreference: 'maintain-resolution',
          videoEncoding: {
            maxBitrate: 2000000,
          },
        });
        const track = pub.track;
        const protocolStats = {
          protocol,
          packetsLost: 0,
          packetsSent: 0,
          qualityLimitationDurations: {},
          rttTotal: 0,
          jitterTotal: 0,
          bitrateTotal: 0,
          count: 0,
        };
        // gather stats once a second
        const interval = setInterval(
          () =>
            __awaiter(this, void 0, void 0, function* () {
              const stats = yield track.getRTCStatsReport();
              stats === null || stats === void 0
                ? void 0
                : stats.forEach((stat) => {
                    if (stat.type === 'outbound-rtp') {
                      protocolStats.packetsSent = stat.packetsSent;
                      protocolStats.qualityLimitationDurations = stat.qualityLimitationDurations;
                      protocolStats.bitrateTotal += stat.targetBitrate;
                      protocolStats.count++;
                    } else if (stat.type === 'remote-inbound-rtp') {
                      protocolStats.packetsLost = stat.packetsLost;
                      protocolStats.rttTotal += stat.roundTripTime;
                      protocolStats.jitterTotal += stat.jitter;
                    }
                  });
            }),
          1000
        );
        // wait a bit to gather stats
        yield new Promise((resolve) => setTimeout(resolve, TEST_DURATION));
        clearInterval(interval);
        videoTrack.stop();
        canvas.remove();
        yield this.disconnect();
        return protocolStats;
      });
    }
  }

  class PublishAudioCheck extends Checker {
    get description() {
      return 'Can publish audio';
    }
    perform() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        const room = yield this.connect();
        const track = yield createLocalAudioTrack();
        const trackIsSilent = yield detectSilence(track, 1000);
        if (trackIsSilent) {
          throw new Error('unable to detect audio from microphone');
        }
        this.appendMessage('detected audio from microphone');
        room.localParticipant.publishTrack(track);
        // wait for a few seconds to publish
        yield new Promise((resolve) => setTimeout(resolve, 3000));
        // verify RTC stats that it's publishing
        const stats = yield (_a = track.sender) === null || _a === void 0 ? void 0 : _a.getStats();
        if (!stats) {
          throw new Error('Could not get RTCStats');
        }
        let numPackets = 0;
        stats.forEach((stat) => {
          if (
            stat.type === 'outbound-rtp' &&
            (stat.kind === 'audio' || (!stat.kind && stat.mediaType === 'audio'))
          ) {
            numPackets = stat.packetsSent;
          }
        });
        if (numPackets === 0) {
          throw new Error('Could not determine packets are sent');
        }
        this.appendMessage('published '.concat(numPackets, ' audio packets'));
      });
    }
  }

  class PublishVideoCheck extends Checker {
    get description() {
      return 'Can publish video';
    }
    perform() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        const room = yield this.connect();
        const track = yield createLocalVideoTrack();
        // check if we have video from camera
        yield this.checkForVideo(track.mediaStreamTrack);
        room.localParticipant.publishTrack(track);
        // wait for a few seconds to publish
        yield new Promise((resolve) => setTimeout(resolve, 5000));
        // verify RTC stats that it's publishing
        const stats = yield (_a = track.sender) === null || _a === void 0 ? void 0 : _a.getStats();
        if (!stats) {
          throw new Error('Could not get RTCStats');
        }
        let numPackets = 0;
        stats.forEach((stat) => {
          if (
            stat.type === 'outbound-rtp' &&
            (stat.kind === 'video' || (!stat.kind && stat.mediaType === 'video'))
          ) {
            numPackets += stat.packetsSent;
          }
        });
        if (numPackets === 0) {
          throw new Error('Could not determine packets are sent');
        }
        this.appendMessage('published '.concat(numPackets, ' video packets'));
      });
    }
    checkForVideo(track) {
      return __awaiter(this, void 0, void 0, function* () {
        const stream = new MediaStream();
        stream.addTrack(track.clone());
        // Create video element to check frames
        const video = document.createElement('video');
        video.srcObject = stream;
        video.muted = true;
        video.autoplay = true;
        video.playsInline = true;
        // For iOS Safari
        video.setAttribute('playsinline', 'true');
        document.body.appendChild(video);
        yield new Promise((resolve) => {
          video.onplay = () => {
            setTimeout(() => {
              var _a, _b, _c, _d;
              const canvas = document.createElement('canvas');
              const settings = track.getSettings();
              const width =
                (_b = (_a = settings.width) !== null && _a !== void 0 ? _a : video.videoWidth) !==
                  null && _b !== void 0
                  ? _b
                  : 1280;
              const height =
                (_d = (_c = settings.height) !== null && _c !== void 0 ? _c : video.videoHeight) !==
                  null && _d !== void 0
                  ? _d
                  : 720;
              canvas.width = width;
              canvas.height = height;
              const ctx = canvas.getContext('2d');
              // Draw video frame to canvas
              ctx.drawImage(video, 0, 0);
              // Get image data and check if all pixels are black
              const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
              const data = imageData.data;
              let isAllBlack = true;
              for (let i = 0; i < data.length; i += 4) {
                if (data[i] !== 0 || data[i + 1] !== 0 || data[i + 2] !== 0) {
                  isAllBlack = false;
                  break;
                }
              }
              if (isAllBlack) {
                this.appendError('camera appears to be producing only black frames');
              } else {
                this.appendMessage('received video frames');
              }
              resolve();
            }, 1000);
          };
          video.play();
        });
        stream.getTracks().forEach((t) => t.stop());
        video.remove();
      });
    }
  }

  class ReconnectCheck extends Checker {
    get description() {
      return 'Resuming connection after interruption';
    }
    perform() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        const room = yield this.connect();
        let reconnectingTriggered = false;
        let reconnected = false;
        let reconnectResolver;
        const reconnectTimeout = new Promise((resolve) => {
          setTimeout(resolve, 5000);
          reconnectResolver = resolve;
        });
        const handleReconnecting = () => {
          reconnectingTriggered = true;
        };
        room
          .on(RoomEvent.SignalReconnecting, handleReconnecting)
          .on(RoomEvent.Reconnecting, handleReconnecting)
          .on(RoomEvent.Reconnected, () => {
            reconnected = true;
            reconnectResolver(true);
          });
        (_a = room.engine.client.ws) === null || _a === void 0 ? void 0 : _a.close();
        const onClose = room.engine.client.onClose;
        if (onClose) {
          onClose('');
        }
        yield reconnectTimeout;
        if (!reconnectingTriggered) {
          throw new Error('Did not attempt to reconnect');
        } else if (!reconnected || room.state !== ConnectionState.Connected) {
          this.appendWarning('reconnection is only possible in Redis-based configurations');
          throw new Error('Not able to reconnect');
        }
      });
    }
  }

  class TURNCheck extends Checker {
    get description() {
      return 'Can connect via TURN';
    }
    perform() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, _b;
        const signalClient = new SignalClient();
        const joinRes = yield signalClient.join(this.url, this.token, {
          autoSubscribe: true,
          maxRetries: 0,
          e2eeEnabled: false,
          websocketTimeout: 15000,
        });
        let hasTLS = false;
        let hasTURN = false;
        let hasSTUN = false;
        for (let iceServer of joinRes.iceServers) {
          for (let url of iceServer.urls) {
            if (url.startsWith('turn:')) {
              hasTURN = true;
              hasSTUN = true;
            } else if (url.startsWith('turns:')) {
              hasTURN = true;
              hasSTUN = true;
              hasTLS = true;
            }
            if (url.startsWith('stun:')) {
              hasSTUN = true;
            }
          }
        }
        if (!hasSTUN) {
          this.appendWarning('No STUN servers configured on server side.');
        } else if (hasTURN && !hasTLS) {
          this.appendWarning('TURN is configured server side, but TURN/TLS is unavailable.');
        }
        yield signalClient.close();
        if (
          ((_b = (_a = this.connectOptions) === null || _a === void 0 ? void 0 : _a.rtcConfig) ===
            null || _b === void 0
            ? void 0
            : _b.iceServers) ||
          hasTURN
        ) {
          yield this.room.connect(this.url, this.token, {
            rtcConfig: {
              iceTransportPolicy: 'relay',
            },
          });
        } else {
          this.appendWarning('No TURN servers configured.');
          this.skip();
          yield new Promise((resolve) => setTimeout(resolve, 0));
        }
      });
    }
  }

  class WebRTCCheck extends Checker {
    get description() {
      return 'Establishing WebRTC connection';
    }
    perform() {
      return __awaiter(this, void 0, void 0, function* () {
        let hasTcp = false;
        let hasIpv4Udp = false;
        this.room.on(RoomEvent.SignalConnected, () => {
          const prevTrickle = this.room.engine.client.onTrickle;
          this.room.engine.client.onTrickle = (sd, target) => {
            if (sd.candidate) {
              const candidate = new RTCIceCandidate(sd);
              let str = ''
                .concat(candidate.protocol, ' ')
                .concat(candidate.address, ':')
                .concat(candidate.port, ' ')
                .concat(candidate.type);
              if (candidate.address) {
                if (isIPPrivate(candidate.address)) {
                  str += ' (private)';
                } else {
                  if (candidate.protocol === 'tcp' && candidate.tcpType === 'passive') {
                    hasTcp = true;
                    str += ' (passive)';
                  } else if (candidate.protocol === 'udp') {
                    hasIpv4Udp = true;
                  }
                }
              }
              this.appendMessage(str);
            }
            if (prevTrickle) {
              prevTrickle(sd, target);
            }
          };
          if (this.room.engine.pcManager) {
            this.room.engine.pcManager.subscriber.onIceCandidateError = (ev) => {
              if (ev instanceof RTCPeerConnectionIceErrorEvent) {
                this.appendWarning(
                  'error with ICE candidate: '
                    .concat(ev.errorCode, ' ')
                    .concat(ev.errorText, ' ')
                    .concat(ev.url)
                );
              }
            };
          }
        });
        try {
          yield this.connect();
          livekitLogger.info('now the room is connected');
        } catch (err) {
          this.appendWarning('ports need to be open on firewall in order to connect.');
          throw err;
        }
        if (!hasTcp) {
          this.appendWarning('Server is not configured for ICE/TCP');
        }
        if (!hasIpv4Udp) {
          this.appendWarning(
            'No public IPv4 UDP candidates were found. Your server is likely not configured correctly'
          );
        }
      });
    }
  }
  function isIPPrivate(address) {
    const parts = address.split('.');
    if (parts.length === 4) {
      if (parts[0] === '10') {
        return true;
      } else if (parts[0] === '192' && parts[1] === '168') {
        return true;
      } else if (parts[0] === '172') {
        const second = parseInt(parts[1], 10);
        if (second >= 16 && second <= 31) {
          return true;
        }
      }
    }
    return false;
  }

  class WebSocketCheck extends Checker {
    get description() {
      return 'Connecting to signal connection via WebSocket';
    }
    perform() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, _b, _c;
        if (this.url.startsWith('ws:') || this.url.startsWith('http:')) {
          this.appendWarning('Server is insecure, clients may block connections to it');
        }
        let signalClient = new SignalClient();
        const joinRes = yield signalClient.join(this.url, this.token, {
          autoSubscribe: true,
          maxRetries: 0,
          e2eeEnabled: false,
          websocketTimeout: 15000,
        });
        this.appendMessage('Connected to server, version '.concat(joinRes.serverVersion, '.'));
        if (
          ((_a = joinRes.serverInfo) === null || _a === void 0 ? void 0 : _a.edition) ===
            ServerInfo_Edition.Cloud &&
          ((_b = joinRes.serverInfo) === null || _b === void 0 ? void 0 : _b.region)
        ) {
          this.appendMessage(
            'LiveKit Cloud: '.concat(
              (_c = joinRes.serverInfo) === null || _c === void 0 ? void 0 : _c.region
            )
          );
        }
        yield signalClient.close();
      });
    }
  }

  class ConnectionCheck extends eventsExports.EventEmitter {
    constructor(url, token) {
      let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      super();
      this.options = {};
      this.checkResults = new Map();
      this.url = url;
      this.token = token;
      this.options = options;
    }
    getNextCheckId() {
      const nextId = this.checkResults.size;
      this.checkResults.set(nextId, {
        logs: [],
        status: CheckStatus.IDLE,
        name: '',
        description: '',
      });
      return nextId;
    }
    updateCheck(checkId, info) {
      this.checkResults.set(checkId, info);
      this.emit('checkUpdate', checkId, info);
    }
    isSuccess() {
      return Array.from(this.checkResults.values()).every((r) => r.status !== CheckStatus.FAILED);
    }
    getResults() {
      return Array.from(this.checkResults.values());
    }
    createAndRunCheck(check) {
      return __awaiter(this, void 0, void 0, function* () {
        const checkId = this.getNextCheckId();
        const test = new check(this.url, this.token, this.options);
        const handleUpdate = (info) => {
          this.updateCheck(checkId, info);
        };
        test.on('update', handleUpdate);
        const result = yield test.run();
        test.off('update', handleUpdate);
        return result;
      });
    }
    checkWebsocket() {
      return __awaiter(this, void 0, void 0, function* () {
        return this.createAndRunCheck(WebSocketCheck);
      });
    }
    checkWebRTC() {
      return __awaiter(this, void 0, void 0, function* () {
        return this.createAndRunCheck(WebRTCCheck);
      });
    }
    checkTURN() {
      return __awaiter(this, void 0, void 0, function* () {
        return this.createAndRunCheck(TURNCheck);
      });
    }
    checkReconnect() {
      return __awaiter(this, void 0, void 0, function* () {
        return this.createAndRunCheck(ReconnectCheck);
      });
    }
    checkPublishAudio() {
      return __awaiter(this, void 0, void 0, function* () {
        return this.createAndRunCheck(PublishAudioCheck);
      });
    }
    checkPublishVideo() {
      return __awaiter(this, void 0, void 0, function* () {
        return this.createAndRunCheck(PublishVideoCheck);
      });
    }
    checkConnectionProtocol() {
      return __awaiter(this, void 0, void 0, function* () {
        const info = yield this.createAndRunCheck(ConnectionProtocolCheck);
        if (info.data && 'protocol' in info.data) {
          const stats = info.data;
          this.options.protocol = stats.protocol;
        }
        return info;
      });
    }
    checkCloudRegion() {
      return __awaiter(this, void 0, void 0, function* () {
        return this.createAndRunCheck(CloudRegionCheck);
      });
    }
  }

  /** A Fixed TokenSource is a token source that takes no parameters and returns a completely
   * independently derived value on each fetch() call.
   *
   * The most common downstream implementer is {@link TokenSourceLiteral}.
   */
  class TokenSourceFixed {}
  /** A Configurable TokenSource is a token source that takes a
   * {@link TokenSourceFetchOptions} object as input and returns a deterministic
   * {@link TokenSourceResponseObject} output based on the options specified.
   *
   * For example, if options.participantName is set, it should be expected that
   * all tokens that are generated will have participant name field set to the
   * provided value.
   *
   * A few common downstream implementers are {@link TokenSourceEndpoint}
   * and {@link TokenSourceCustom}.
   */
  class TokenSourceConfigurable {}

  function _defineProperty(e, r, t) {
    return (
      (r = _toPropertyKey(r)) in e
        ? Object.defineProperty(e, r, {
            value: t,
            enumerable: true,
            configurable: true,
            writable: true,
          })
        : (e[r] = t),
      e
    );
  }
  function _toPrimitive(t, r) {
    if ('object' != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r);
      if ('object' != typeof i) return i;
      throw new TypeError('@@toPrimitive must return a primitive value.');
    }
    return ('string' === r ? String : Number)(t);
  }
  function _toPropertyKey(t) {
    var i = _toPrimitive(t, 'string');
    return 'symbol' == typeof i ? i : i + '';
  }

  new TextEncoder();
  const decoder = new TextDecoder();

  function decodeBase64(encoded) {
    if (Uint8Array.fromBase64) {
      return Uint8Array.fromBase64(encoded);
    }
    const binary = atob(encoded);
    const bytes = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i++) {
      bytes[i] = binary.charCodeAt(i);
    }
    return bytes;
  }

  function decode(input) {
    if (Uint8Array.fromBase64) {
      return Uint8Array.fromBase64(typeof input === 'string' ? input : decoder.decode(input), {
        alphabet: 'base64url',
      });
    }
    let encoded = input;
    if (encoded instanceof Uint8Array) {
      encoded = decoder.decode(encoded);
    }
    encoded = encoded.replace(/-/g, '+').replace(/_/g, '/').replace(/\s/g, '');
    try {
      return decodeBase64(encoded);
    } catch (_unused) {
      throw new TypeError('The input to be decoded is not correctly encoded.');
    }
  }

  class JOSEError extends Error {
    constructor(message, options) {
      var _Error$captureStackTr;
      super(message, options);
      _defineProperty(this, 'code', 'ERR_JOSE_GENERIC');
      this.name = this.constructor.name;
      (_Error$captureStackTr = Error.captureStackTrace) === null ||
        _Error$captureStackTr === void 0 ||
        _Error$captureStackTr.call(Error, this, this.constructor);
    }
  }
  _defineProperty(JOSEError, 'code', 'ERR_JOSE_GENERIC');
  class JWTClaimValidationFailed extends JOSEError {
    constructor(message, payload) {
      let claim = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'unspecified';
      let reason =
        arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'unspecified';
      super(message, {
        cause: {
          claim,
          reason,
          payload,
        },
      });
      _defineProperty(this, 'code', 'ERR_JWT_CLAIM_VALIDATION_FAILED');
      _defineProperty(this, 'claim', void 0);
      _defineProperty(this, 'reason', void 0);
      _defineProperty(this, 'payload', void 0);
      this.claim = claim;
      this.reason = reason;
      this.payload = payload;
    }
  }
  _defineProperty(JWTClaimValidationFailed, 'code', 'ERR_JWT_CLAIM_VALIDATION_FAILED');
  class JWTExpired extends JOSEError {
    constructor(message, payload) {
      let claim = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'unspecified';
      let reason =
        arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'unspecified';
      super(message, {
        cause: {
          claim,
          reason,
          payload,
        },
      });
      _defineProperty(this, 'code', 'ERR_JWT_EXPIRED');
      _defineProperty(this, 'claim', void 0);
      _defineProperty(this, 'reason', void 0);
      _defineProperty(this, 'payload', void 0);
      this.claim = claim;
      this.reason = reason;
      this.payload = payload;
    }
  }
  _defineProperty(JWTExpired, 'code', 'ERR_JWT_EXPIRED');
  class JOSEAlgNotAllowed extends JOSEError {
    constructor() {
      super(...arguments);
      _defineProperty(this, 'code', 'ERR_JOSE_ALG_NOT_ALLOWED');
    }
  }
  _defineProperty(JOSEAlgNotAllowed, 'code', 'ERR_JOSE_ALG_NOT_ALLOWED');
  class JOSENotSupported extends JOSEError {
    constructor() {
      super(...arguments);
      _defineProperty(this, 'code', 'ERR_JOSE_NOT_SUPPORTED');
    }
  }
  _defineProperty(JOSENotSupported, 'code', 'ERR_JOSE_NOT_SUPPORTED');
  class JWEDecryptionFailed extends JOSEError {
    constructor() {
      let message =
        arguments.length > 0 && arguments[0] !== undefined
          ? arguments[0]
          : 'decryption operation failed';
      let options = arguments.length > 1 ? arguments[1] : undefined;
      super(message, options);
      _defineProperty(this, 'code', 'ERR_JWE_DECRYPTION_FAILED');
    }
  }
  _defineProperty(JWEDecryptionFailed, 'code', 'ERR_JWE_DECRYPTION_FAILED');
  class JWEInvalid extends JOSEError {
    constructor() {
      super(...arguments);
      _defineProperty(this, 'code', 'ERR_JWE_INVALID');
    }
  }
  _defineProperty(JWEInvalid, 'code', 'ERR_JWE_INVALID');
  class JWSInvalid extends JOSEError {
    constructor() {
      super(...arguments);
      _defineProperty(this, 'code', 'ERR_JWS_INVALID');
    }
  }
  _defineProperty(JWSInvalid, 'code', 'ERR_JWS_INVALID');
  class JWTInvalid extends JOSEError {
    constructor() {
      super(...arguments);
      _defineProperty(this, 'code', 'ERR_JWT_INVALID');
    }
  }
  _defineProperty(JWTInvalid, 'code', 'ERR_JWT_INVALID');
  class JWKInvalid extends JOSEError {
    constructor() {
      super(...arguments);
      _defineProperty(this, 'code', 'ERR_JWK_INVALID');
    }
  }
  _defineProperty(JWKInvalid, 'code', 'ERR_JWK_INVALID');
  class JWKSInvalid extends JOSEError {
    constructor() {
      super(...arguments);
      _defineProperty(this, 'code', 'ERR_JWKS_INVALID');
    }
  }
  _defineProperty(JWKSInvalid, 'code', 'ERR_JWKS_INVALID');
  class JWKSNoMatchingKey extends JOSEError {
    constructor() {
      let message =
        arguments.length > 0 && arguments[0] !== undefined
          ? arguments[0]
          : 'no applicable key found in the JSON Web Key Set';
      let options = arguments.length > 1 ? arguments[1] : undefined;
      super(message, options);
      _defineProperty(this, 'code', 'ERR_JWKS_NO_MATCHING_KEY');
    }
  }
  _defineProperty(JWKSNoMatchingKey, 'code', 'ERR_JWKS_NO_MATCHING_KEY');
  class JWKSMultipleMatchingKeys extends JOSEError {
    constructor() {
      let message =
        arguments.length > 0 && arguments[0] !== undefined
          ? arguments[0]
          : 'multiple matching keys found in the JSON Web Key Set';
      let options = arguments.length > 1 ? arguments[1] : undefined;
      super(message, options);
      _defineProperty(this, Symbol.asyncIterator, void 0);
      _defineProperty(this, 'code', 'ERR_JWKS_MULTIPLE_MATCHING_KEYS');
    }
  }
  _defineProperty(JWKSMultipleMatchingKeys, 'code', 'ERR_JWKS_MULTIPLE_MATCHING_KEYS');
  class JWKSTimeout extends JOSEError {
    constructor() {
      let message =
        arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'request timed out';
      let options = arguments.length > 1 ? arguments[1] : undefined;
      super(message, options);
      _defineProperty(this, 'code', 'ERR_JWKS_TIMEOUT');
    }
  }
  _defineProperty(JWKSTimeout, 'code', 'ERR_JWKS_TIMEOUT');
  class JWSSignatureVerificationFailed extends JOSEError {
    constructor() {
      let message =
        arguments.length > 0 && arguments[0] !== undefined
          ? arguments[0]
          : 'signature verification failed';
      let options = arguments.length > 1 ? arguments[1] : undefined;
      super(message, options);
      _defineProperty(this, 'code', 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED');
    }
  }
  _defineProperty(JWSSignatureVerificationFailed, 'code', 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED');

  function isObjectLike(value) {
    return typeof value === 'object' && value !== null;
  }
  var isObject = (input) => {
    if (!isObjectLike(input) || Object.prototype.toString.call(input) !== '[object Object]') {
      return false;
    }
    if (Object.getPrototypeOf(input) === null) {
      return true;
    }
    let proto = input;
    while (Object.getPrototypeOf(proto) !== null) {
      proto = Object.getPrototypeOf(proto);
    }
    return Object.getPrototypeOf(input) === proto;
  };

  function decodeJwt(jwt) {
    if (typeof jwt !== 'string')
      throw new JWTInvalid('JWTs must use Compact JWS serialization, JWT must be a string');
    const { 1: payload, length } = jwt.split('.');
    if (length === 5)
      throw new JWTInvalid('Only JWTs using Compact JWS serialization can be decoded');
    if (length !== 3) throw new JWTInvalid('Invalid JWT');
    if (!payload) throw new JWTInvalid('JWTs must contain a payload');
    let decoded;
    try {
      decoded = decode(payload);
    } catch (_unused) {
      throw new JWTInvalid('Failed to base64url decode the payload');
    }
    let result;
    try {
      result = JSON.parse(decoder.decode(decoded));
    } catch (_unused2) {
      throw new JWTInvalid('Failed to parse the decoded payload as JSON');
    }
    if (!isObject(result)) throw new JWTInvalid('Invalid JWT Claims Set');
    return result;
  }

  const ONE_SECOND_IN_MILLISECONDS = 1000;
  const ONE_MINUTE_IN_MILLISECONDS = 60 * ONE_SECOND_IN_MILLISECONDS;
  function isResponseExpired(response) {
    const jwtPayload = decodeTokenPayload(response.participantToken);
    if (!(jwtPayload === null || jwtPayload === void 0 ? void 0 : jwtPayload.exp)) {
      return true;
    }
    const expInMilliseconds = jwtPayload.exp * ONE_SECOND_IN_MILLISECONDS;
    const expiresAt = new Date(expInMilliseconds - ONE_MINUTE_IN_MILLISECONDS);
    const now = new Date();
    return expiresAt >= now;
  }
  function decodeTokenPayload(token) {
    const payload = decodeJwt(token);
    const { roomConfig } = payload,
      rest = __rest(payload, ['roomConfig']);
    const mappedPayload = Object.assign(Object.assign({}, rest), {
      roomConfig: payload.roomConfig ? RoomConfiguration.fromJson(payload.roomConfig) : undefined,
    });
    return mappedPayload;
  }

  /** A TokenSourceCached is a TokenSource which caches the last {@link TokenSourceResponseObject} value and returns it
   * until a) it expires or b) the {@link TokenSourceFetchOptions} provided to .fetch(...) change. */
  class TokenSourceCached extends TokenSourceConfigurable {
    constructor() {
      super(...arguments);
      this.cachedFetchOptions = null;
      this.cachedResponse = null;
      this.fetchMutex = new livekit_client_esm_();
    }
    isSameAsCachedFetchOptions(options) {
      if (!this.cachedFetchOptions) {
        return false;
      }
      for (const key of Object.keys(this.cachedFetchOptions)) {
        switch (key) {
          case 'roomName':
          case 'participantName':
          case 'participantIdentity':
          case 'participantMetadata':
          case 'participantAttributes':
          case 'agentName':
          case 'agentMetadata':
            if (this.cachedFetchOptions[key] !== options[key]) {
              return false;
            }
            break;
          default:
            // ref: https://stackoverflow.com/a/58009992
            const exhaustiveCheckedKey = key;
            throw new Error(
              'Options key '.concat(exhaustiveCheckedKey, ' not being checked for equality!')
            );
        }
      }
      return true;
    }
    shouldReturnCachedValueFromFetch(fetchOptions) {
      if (!this.cachedResponse) {
        return false;
      }
      if (isResponseExpired(this.cachedResponse)) {
        return false;
      }
      if (this.isSameAsCachedFetchOptions(fetchOptions)) {
        return false;
      }
      return true;
    }
    getCachedResponseJwtPayload() {
      if (!this.cachedResponse) {
        return null;
      }
      return decodeTokenPayload(this.cachedResponse.participantToken);
    }
    fetch(options) {
      return __awaiter(this, void 0, void 0, function* () {
        const unlock = yield this.fetchMutex.lock();
        try {
          if (this.shouldReturnCachedValueFromFetch(options)) {
            return this.cachedResponse.toJson();
          }
          this.cachedFetchOptions = options;
          const tokenResponse = yield this.update(options);
          this.cachedResponse = tokenResponse;
          return tokenResponse.toJson();
        } finally {
          unlock();
        }
      });
    }
  }
  class TokenSourceLiteral extends TokenSourceFixed {
    constructor(literalOrFn) {
      super();
      this.literalOrFn = literalOrFn;
    }
    fetch() {
      return __awaiter(this, void 0, void 0, function* () {
        if (typeof this.literalOrFn === 'function') {
          return this.literalOrFn();
        } else {
          return this.literalOrFn;
        }
      });
    }
  }
  class TokenSourceCustom extends TokenSourceCached {
    constructor(customFn) {
      super();
      this.customFn = customFn;
    }
    update(options) {
      return __awaiter(this, void 0, void 0, function* () {
        const resultMaybePromise = this.customFn(options);
        let result;
        if (resultMaybePromise instanceof Promise) {
          result = yield resultMaybePromise;
        } else {
          result = resultMaybePromise;
        }
        return TokenSourceResponse.fromJson(result, {
          // NOTE: it could be possible that the response body could contain more fields than just
          // what's in TokenSourceResponse depending on the implementation
          ignoreUnknownFields: true,
        });
      });
    }
  }
  class TokenSourceEndpoint extends TokenSourceCached {
    constructor(url) {
      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      super();
      this.url = url;
      this.endpointOptions = options;
    }
    createRequestFromOptions(options) {
      var _a, _b, _c;
      const request = new TokenSourceRequest();
      for (const key of Object.keys(options)) {
        switch (key) {
          case 'roomName':
          case 'participantName':
          case 'participantIdentity':
          case 'participantMetadata':
            request[key] = options[key];
            break;
          case 'participantAttributes':
            request.participantAttributes =
              (_a = options.participantAttributes) !== null && _a !== void 0 ? _a : {};
            break;
          case 'agentName':
            request.roomConfig =
              (_b = request.roomConfig) !== null && _b !== void 0 ? _b : new RoomConfiguration();
            if (request.roomConfig.agents.length === 0) {
              request.roomConfig.agents.push(new RoomAgentDispatch());
            }
            request.roomConfig.agents[0].agentName = options.agentName;
            break;
          case 'agentMetadata':
            request.roomConfig =
              (_c = request.roomConfig) !== null && _c !== void 0 ? _c : new RoomConfiguration();
            if (request.roomConfig.agents.length === 0) {
              request.roomConfig.agents.push(new RoomAgentDispatch());
            }
            request.roomConfig.agents[0].metadata = options.agentMetadata;
            break;
          default:
            // ref: https://stackoverflow.com/a/58009992
            const exhaustiveCheckedKey = key;
            throw new Error(
              'Options key '.concat(exhaustiveCheckedKey, ' not being included in forming request!')
            );
        }
      }
      return request;
    }
    update(options) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        const request = this.createRequestFromOptions(options);
        const response = yield fetch(
          this.url,
          Object.assign(Object.assign({}, this.endpointOptions), {
            method: (_a = this.endpointOptions.method) !== null && _a !== void 0 ? _a : 'POST',
            headers: Object.assign(
              {
                'Content-Type': 'application/json',
              },
              this.endpointOptions.headers
            ),
            body: request.toJsonString({
              useProtoFieldName: true,
            }),
          })
        );
        if (!response.ok) {
          throw new Error(
            'Error generating token from endpoint '
              .concat(this.url, ': received ')
              .concat(response.status, ' / ')
              .concat(yield response.text())
          );
        }
        const body = yield response.json();
        return TokenSourceResponse.fromJson(body, {
          // NOTE: it could be possible that the response body could contain more fields than just
          // what's in TokenSourceResponse depending on the implementation (ie, SandboxTokenServer)
          ignoreUnknownFields: true,
        });
      });
    }
  }
  class TokenSourceSandboxTokenServer extends TokenSourceEndpoint {
    constructor(sandboxId, options) {
      const { baseUrl = 'https://cloud-api.livekit.io' } = options,
        rest = __rest(options, ['baseUrl']);
      super(
        ''.concat(baseUrl, '/api/v2/sandbox/connection-details'),
        Object.assign(Object.assign({}, rest), {
          headers: {
            'X-Sandbox-ID': sandboxId,
          },
        })
      );
    }
  }
  const TokenSource = {
    /** TokenSource.literal contains a single, literal set of {@link TokenSourceResponseObject}
     * credentials, either provided directly or returned from a provided function. */
    literal(literalOrFn) {
      return new TokenSourceLiteral(literalOrFn);
    },
    /**
     * TokenSource.custom allows a user to define a manual function which generates new
     * {@link TokenSourceResponseObject} values on demand.
     *
     * Use this to get credentials from custom backends / etc.
     */
    custom(customFn) {
      return new TokenSourceCustom(customFn);
    },
    /**
     * TokenSource.endpoint creates a token source that fetches credentials from a given URL using
     * the standard endpoint format:
     * FIXME: add docs link here in the future!
     */
    endpoint(url) {
      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return new TokenSourceEndpoint(url, options);
    },
    /**
     * TokenSource.sandboxTokenServer queries a sandbox token server for credentials,
     * which supports quick prototyping / getting started types of use cases.
     *
     * This token provider is INSECURE and should NOT be used in production.
     *
     * For more info:
     * @see https://cloud.livekit.io/projects/p_/sandbox/templates/token-server
     */
    sandboxTokenServer(sandboxId) {
      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return new TokenSourceSandboxTokenServer(sandboxId, options);
    },
  };

  /**
   * Try to analyze the local track to determine the facing mode of a track.
   *
   * @remarks
   * There is no property supported by all browsers to detect whether a video track originated from a user- or environment-facing camera device.
   * For this reason, we use the `facingMode` property when available, but will fall back on a string-based analysis of the device label to determine the facing mode.
   * If both methods fail, the default facing mode will be used.
   *
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints/facingMode | MDN docs on facingMode}
   * @experimental
   */
  function facingModeFromLocalTrack(localTrack) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var _a;
    const track = isLocalTrack(localTrack) ? localTrack.mediaStreamTrack : localTrack;
    const trackSettings = track.getSettings();
    let result = {
      facingMode: (_a = options.defaultFacingMode) !== null && _a !== void 0 ? _a : 'user',
      confidence: 'low',
    };
    // 1. Try to get facingMode from track settings.
    if ('facingMode' in trackSettings) {
      const rawFacingMode = trackSettings.facingMode;
      livekitLogger.trace('rawFacingMode', {
        rawFacingMode,
      });
      if (rawFacingMode && typeof rawFacingMode === 'string' && isFacingModeValue(rawFacingMode)) {
        result = {
          facingMode: rawFacingMode,
          confidence: 'high',
        };
      }
    }
    // 2. If we don't have a high confidence we try to get the facing mode from the device label.
    if (['low', 'medium'].includes(result.confidence)) {
      livekitLogger.trace('Try to get facing mode from device label: ('.concat(track.label, ')'));
      const labelAnalysisResult = facingModeFromDeviceLabel(track.label);
      if (labelAnalysisResult !== undefined) {
        result = labelAnalysisResult;
      }
    }
    return result;
  }
  const knownDeviceLabels = new Map([
    [
      'obs virtual camera',
      {
        facingMode: 'environment',
        confidence: 'medium',
      },
    ],
  ]);
  const knownDeviceLabelSections = new Map([
    [
      'iphone',
      {
        facingMode: 'environment',
        confidence: 'medium',
      },
    ],
    [
      'ipad',
      {
        facingMode: 'environment',
        confidence: 'medium',
      },
    ],
  ]);
  /**
   * Attempt to analyze the device label to determine the facing mode.
   *
   * @experimental
   */
  function facingModeFromDeviceLabel(deviceLabel) {
    var _a;
    const label = deviceLabel.trim().toLowerCase();
    // Empty string is a valid device label but we can't infer anything from it.
    if (label === '') {
      return undefined;
    }
    // Can we match against widely known device labels.
    if (knownDeviceLabels.has(label)) {
      return knownDeviceLabels.get(label);
    }
    // Can we match against sections of the device label.
    return (_a = Array.from(knownDeviceLabelSections.entries()).find((_ref) => {
      let [section] = _ref;
      return label.includes(section);
    })) === null || _a === void 0
      ? void 0
      : _a[1];
  }
  function isFacingModeValue(item) {
    const allowedValues = ['user', 'environment', 'left', 'right'];
    return item === undefined || allowedValues.includes(item);
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/render/components/create-proxy.mjs

  //# sourceMappingURL=livekit-client.esm.mjs.map

  function createDOMMotionComponentProxy(componentFactory) {
    if (typeof Proxy === 'undefined') {
      return componentFactory;
    }
    /**
     * A cache of generated `motion` components, e.g `motion.div`, `motion.input` etc.
     * Rather than generating them anew every render.
     */
    const componentCache = new Map();
    const deprecatedFactoryFunction = (...args) => {
      if (false) {
        // removed by dead control flow
      }
      return componentFactory(...args);
    };
    return new Proxy(deprecatedFactoryFunction, {
      /**
       * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
       * The prop name is passed through as `key` and we can use that to generate a `motion`
       * DOM component with that name.
       */
      get: (_target, key) => {
        if (key === 'create') return componentFactory;
        /**
         * If this element doesn't exist in the component cache, create it and cache.
         */
        if (!componentCache.has(key)) {
          componentCache.set(key, componentFactory(key));
        }
        return componentCache.get(key);
      },
    });
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/animation/utils/is-animation-controls.mjs

  function isAnimationControls(v) {
    return v !== null && typeof v === 'object' && typeof v.start === 'function';
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/render/utils/resolve-variants.mjs

  function getValueState(visualElement) {
    const state = [{}, {}];
    visualElement?.values.forEach((value, key) => {
      state[0][key] = value.get();
      state[1][key] = value.getVelocity();
    });
    return state;
  }
  function resolveVariantFromProps(props, definition, custom, visualElement) {
    /**
     * If the variant definition is a function, resolve.
     */
    if (typeof definition === 'function') {
      const [current, velocity] = getValueState(visualElement);
      definition = definition(custom !== undefined ? custom : props.custom, current, velocity);
    }
    /**
     * If the variant definition is a variant label, or
     * the function returned a variant label, resolve.
     */
    if (typeof definition === 'string') {
      definition = props.variants && props.variants[definition];
    }
    /**
     * At this point we've resolved both functions and variant labels,
     * but the resolved variant label might itself have been a function.
     * If so, resolve. This can only have returned a valid target object.
     */
    if (typeof definition === 'function') {
      const [current, velocity] = getValueState(visualElement);
      definition = definition(custom !== undefined ? custom : props.custom, current, velocity);
    }
    return definition;
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/render/utils/resolve-dynamic-variants.mjs

  function resolveVariant(visualElement, definition, custom) {
    const props = visualElement.getProps();
    return resolveVariantFromProps(
      props,
      definition,
      custom !== undefined ? custom : props.custom,
      visualElement
    );
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/animation/utils/is-keyframes-target.mjs

  const isKeyframesTarget = (v) => {
    return Array.isArray(v);
  }; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/frameloop/order.mjs

  const stepsOrder = [
    'setup', // Compute
    'read', // Read
    'resolveKeyframes', // Write/Read/Write/Read
    'preUpdate', // Compute
    'update', // Compute
    'preRender', // Compute
    'render', // Write
    'postRender', // Compute
  ]; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/stats/buffer.mjs

  const statsBuffer = {
    value: null,
    addProjectionMetrics: null,
  }; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/frameloop/render-step.mjs

  function createRenderStep(runNextFrame, stepName) {
    /**
     * We create and reuse two queues, one to queue jobs for the current frame
     * and one for the next. We reuse to avoid triggering GC after x frames.
     */
    let thisFrame = new Set();
    let nextFrame = new Set();
    /**
     * Track whether we're currently processing jobs in this step. This way
     * we can decide whether to schedule new jobs for this frame or next.
     */
    let isProcessing = false;
    let flushNextFrame = false;
    /**
     * A set of processes which were marked keepAlive when scheduled.
     */
    const toKeepAlive = new WeakSet();
    let latestFrameData = {
      delta: 0.0,
      timestamp: 0.0,
      isProcessing: false,
    };
    let numCalls = 0;
    function triggerCallback(callback) {
      if (toKeepAlive.has(callback)) {
        step.schedule(callback);
        runNextFrame();
      }
      numCalls++;
      callback(latestFrameData);
    }
    const step = {
      /**
       * Schedule a process to run on the next frame.
       */
      schedule: (callback, keepAlive = false, immediate = false) => {
        const addToCurrentFrame = immediate && isProcessing;
        const queue = addToCurrentFrame ? thisFrame : nextFrame;
        if (keepAlive) toKeepAlive.add(callback);
        if (!queue.has(callback)) queue.add(callback);
        return callback;
      },
      /**
       * Cancel the provided callback from running on the next frame.
       */
      cancel: (callback) => {
        nextFrame.delete(callback);
        toKeepAlive.delete(callback);
      },
      /**
       * Execute all schedule callbacks.
       */
      process: (frameData) => {
        latestFrameData = frameData;
        /**
         * If we're already processing we've probably been triggered by a flushSync
         * inside an existing process. Instead of executing, mark flushNextFrame
         * as true and ensure we flush the following frame at the end of this one.
         */
        if (isProcessing) {
          flushNextFrame = true;
          return;
        }
        isProcessing = true;
        [thisFrame, nextFrame] = [nextFrame, thisFrame];
        // Execute this frame
        thisFrame.forEach(triggerCallback);
        /**
         * If we're recording stats then
         */
        if (stepName && statsBuffer.value) {
          statsBuffer.value.frameloop[stepName].push(numCalls);
        }
        numCalls = 0;
        // Clear the frame so no callbacks remain. This is to avoid
        // memory leaks should this render step not run for a while.
        thisFrame.clear();
        isProcessing = false;
        if (flushNextFrame) {
          flushNextFrame = false;
          step.process(frameData);
        }
      },
    };
    return step;
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-utils/dist/es/global-config.mjs

  const MotionGlobalConfig = {}; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/frameloop/batcher.mjs

  const maxElapsed = 40;
  function createRenderBatcher(scheduleNextBatch, allowKeepAlive) {
    let runNextFrame = false;
    let useDefaultElapsed = true;
    const state = {
      delta: 0.0,
      timestamp: 0.0,
      isProcessing: false,
    };
    const flagRunNextFrame = () => (runNextFrame = true);
    const steps = stepsOrder.reduce((acc, key) => {
      acc[key] = createRenderStep(flagRunNextFrame, allowKeepAlive ? key : undefined);
      return acc;
    }, {});
    const { setup, read, resolveKeyframes, preUpdate, update, preRender, render, postRender } =
      steps;
    const processBatch = () => {
      const timestamp = MotionGlobalConfig.useManualTiming ? state.timestamp : performance.now();
      runNextFrame = false;
      if (!MotionGlobalConfig.useManualTiming) {
        state.delta = useDefaultElapsed
          ? 1000 / 60
          : Math.max(Math.min(timestamp - state.timestamp, maxElapsed), 1);
      }
      state.timestamp = timestamp;
      state.isProcessing = true;
      // Unrolled render loop for better per-frame performance
      setup.process(state);
      read.process(state);
      resolveKeyframes.process(state);
      preUpdate.process(state);
      update.process(state);
      preRender.process(state);
      render.process(state);
      postRender.process(state);
      state.isProcessing = false;
      if (runNextFrame && allowKeepAlive) {
        useDefaultElapsed = false;
        scheduleNextBatch(processBatch);
      }
    };
    const wake = () => {
      runNextFrame = true;
      useDefaultElapsed = true;
      if (!state.isProcessing) {
        scheduleNextBatch(processBatch);
      }
    };
    const schedule = stepsOrder.reduce((acc, key) => {
      const step = steps[key];
      acc[key] = (process, keepAlive = false, immediate = false) => {
        if (!runNextFrame) wake();
        return step.schedule(process, keepAlive, immediate);
      };
      return acc;
    }, {});
    const cancel = (process) => {
      for (let i = 0; i < stepsOrder.length; i++) {
        steps[stepsOrder[i]].cancel(process);
      }
    };
    return { schedule, cancel, state, steps };
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-utils/dist/es/noop.mjs

  /*#__NO_SIDE_EFFECTS__*/
  const noop = (any) => any; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/frameloop/frame.mjs

  const {
    schedule: frame_frame,
    cancel: cancelFrame,
    state: frameData,
    steps: frameSteps,
  } = /* @__PURE__ */ createRenderBatcher(
    typeof requestAnimationFrame !== 'undefined' ? requestAnimationFrame : noop,
    true
  ); // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/frameloop/sync-time.mjs

  let now;
  function clearTime() {
    now = undefined;
  }
  /**
   * An eventloop-synchronous alternative to performance.now().
   *
   * Ensures that time measurements remain consistent within a synchronous context.
   * Usually calling performance.now() twice within the same synchronous context
   * will return different values which isn't useful for animations when we're usually
   * trying to sync animations to the same frame.
   */
  const time = {
    now: () => {
      if (now === undefined) {
        time.set(
          frameData.isProcessing || MotionGlobalConfig.useManualTiming
            ? frameData.timestamp
            : performance.now()
        );
      }
      return now;
    },
    set: (newTime) => {
      now = newTime;
      queueMicrotask(clearTime);
    },
  }; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-utils/dist/es/array.mjs

  function addUniqueItem(arr, item) {
    if (arr.indexOf(item) === -1) arr.push(item);
  }
  function removeItem(arr, item) {
    const index = arr.indexOf(item);
    if (index > -1) arr.splice(index, 1);
  }
  // Adapted from array-move
  function moveItem([...arr], fromIndex, toIndex) {
    const startIndex = fromIndex < 0 ? arr.length + fromIndex : fromIndex;
    if (startIndex >= 0 && startIndex < arr.length) {
      const endIndex = toIndex < 0 ? arr.length + toIndex : toIndex;
      const [item] = arr.splice(fromIndex, 1);
      arr.splice(endIndex, 0, item);
    }
    return arr;
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-utils/dist/es/subscription-manager.mjs

  class SubscriptionManager {
    constructor() {
      this.subscriptions = [];
    }
    add(handler) {
      addUniqueItem(this.subscriptions, handler);
      return () => removeItem(this.subscriptions, handler);
    }
    notify(a, b, c) {
      const numSubscriptions = this.subscriptions.length;
      if (!numSubscriptions) return;
      if (numSubscriptions === 1) {
        /**
         * If there's only a single handler we can just call it without invoking a loop.
         */
        this.subscriptions[0](a, b, c);
      } else {
        for (let i = 0; i < numSubscriptions; i++) {
          /**
           * Check whether the handler exists before firing as it's possible
           * the subscriptions were modified during this loop running.
           */
          const handler = this.subscriptions[i];
          handler && handler(a, b, c);
        }
      }
    }
    getSize() {
      return this.subscriptions.length;
    }
    clear() {
      this.subscriptions.length = 0;
    }
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-utils/dist/es/velocity-per-second.mjs

  /*
  Convert velocity into velocity per second

  @param [number]: Unit per frame
  @param [number]: Frame duration in ms
*/
  function velocityPerSecond(velocity, frameDuration) {
    return frameDuration ? velocity * (1000 / frameDuration) : 0;
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/value/index.mjs

  /**
   * Maximum time between the value of two frames, beyond which we
   * assume the velocity has since been 0.
   */
  const MAX_VELOCITY_DELTA = 30;
  const isFloat = (value) => {
    return !isNaN(parseFloat(value));
  };
  const collectMotionValues = {
    current: undefined,
  };
  /**
   * `MotionValue` is used to track the state and velocity of motion values.
   *
   * @public
   */
  class MotionValue {
    /**
     * @param init - The initiating value
     * @param config - Optional configuration options
     *
     * -  `transformer`: A function to transform incoming values with.
     */
    constructor(init, options = {}) {
      /**
       * Tracks whether this value can output a velocity. Currently this is only true
       * if the value is numerical, but we might be able to widen the scope here and support
       * other value types.
       *
       * @internal
       */
      this.canTrackVelocity = null;
      /**
       * An object containing a SubscriptionManager for each active event.
       */
      this.events = {};
      this.updateAndNotify = (v, render = true) => {
        const currentTime = time.now();
        /**
         * If we're updating the value during another frame or eventloop
         * than the previous frame, then the we set the previous frame value
         * to current.
         */
        if (this.updatedAt !== currentTime) {
          this.setPrevFrameValue();
        }
        this.prev = this.current;
        this.setCurrent(v);
        // Update update subscribers
        if (this.current !== this.prev) {
          this.events.change?.notify(this.current);
          if (this.dependents) {
            for (const dependent of this.dependents) {
              dependent.dirty();
            }
          }
        }
        // Update render subscribers
        if (render) {
          this.events.renderRequest?.notify(this.current);
        }
      };
      this.hasAnimated = false;
      this.setCurrent(init);
      this.owner = options.owner;
    }
    setCurrent(current) {
      this.current = current;
      this.updatedAt = time.now();
      if (this.canTrackVelocity === null && current !== undefined) {
        this.canTrackVelocity = isFloat(this.current);
      }
    }
    setPrevFrameValue(prevFrameValue = this.current) {
      this.prevFrameValue = prevFrameValue;
      this.prevUpdatedAt = this.updatedAt;
    }
    /**
     * Adds a function that will be notified when the `MotionValue` is updated.
     *
     * It returns a function that, when called, will cancel the subscription.
     *
     * When calling `onChange` inside a React component, it should be wrapped with the
     * `useEffect` hook. As it returns an unsubscribe function, this should be returned
     * from the `useEffect` function to ensure you don't add duplicate subscribers..
     *
     * ```jsx
     * export const MyComponent = () => {
     *   const x = useMotionValue(0)
     *   const y = useMotionValue(0)
     *   const opacity = useMotionValue(1)
     *
     *   useEffect(() => {
     *     function updateOpacity() {
     *       const maxXY = Math.max(x.get(), y.get())
     *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
     *       opacity.set(newOpacity)
     *     }
     *
     *     const unsubscribeX = x.on("change", updateOpacity)
     *     const unsubscribeY = y.on("change", updateOpacity)
     *
     *     return () => {
     *       unsubscribeX()
     *       unsubscribeY()
     *     }
     *   }, [])
     *
     *   return <motion.div style={{ x }} />
     * }
     * ```
     *
     * @param subscriber - A function that receives the latest value.
     * @returns A function that, when called, will cancel this subscription.
     *
     * @deprecated
     */
    onChange(subscription) {
      if (false) {
        // removed by dead control flow
      }
      return this.on('change', subscription);
    }
    on(eventName, callback) {
      if (!this.events[eventName]) {
        this.events[eventName] = new SubscriptionManager();
      }
      const unsubscribe = this.events[eventName].add(callback);
      if (eventName === 'change') {
        return () => {
          unsubscribe();
          /**
           * If we have no more change listeners by the start
           * of the next frame, stop active animations.
           */
          frame_frame.read(() => {
            if (!this.events.change.getSize()) {
              this.stop();
            }
          });
        };
      }
      return unsubscribe;
    }
    clearListeners() {
      for (const eventManagers in this.events) {
        this.events[eventManagers].clear();
      }
    }
    /**
     * Attaches a passive effect to the `MotionValue`.
     */
    attach(passiveEffect, stopPassiveEffect) {
      this.passiveEffect = passiveEffect;
      this.stopPassiveEffect = stopPassiveEffect;
    }
    /**
     * Sets the state of the `MotionValue`.
     *
     * @remarks
     *
     * ```jsx
     * const x = useMotionValue(0)
     * x.set(10)
     * ```
     *
     * @param latest - Latest value to set.
     * @param render - Whether to notify render subscribers. Defaults to `true`
     *
     * @public
     */
    set(v, render = true) {
      if (!render || !this.passiveEffect) {
        this.updateAndNotify(v, render);
      } else {
        this.passiveEffect(v, this.updateAndNotify);
      }
    }
    setWithVelocity(prev, current, delta) {
      this.set(current);
      this.prev = undefined;
      this.prevFrameValue = prev;
      this.prevUpdatedAt = this.updatedAt - delta;
    }
    /**
     * Set the state of the `MotionValue`, stopping any active animations,
     * effects, and resets velocity to `0`.
     */
    jump(v, endAnimation = true) {
      this.updateAndNotify(v);
      this.prev = v;
      this.prevUpdatedAt = this.prevFrameValue = undefined;
      endAnimation && this.stop();
      if (this.stopPassiveEffect) this.stopPassiveEffect();
    }
    dirty() {
      this.events.change?.notify(this.current);
    }
    addDependent(dependent) {
      if (!this.dependents) {
        this.dependents = new Set();
      }
      this.dependents.add(dependent);
    }
    removeDependent(dependent) {
      if (this.dependents) {
        this.dependents.delete(dependent);
      }
    }
    /**
     * Returns the latest state of `MotionValue`
     *
     * @returns - The latest state of `MotionValue`
     *
     * @public
     */
    get() {
      if (collectMotionValues.current) {
        collectMotionValues.current.push(this);
      }
      return this.current;
    }
    /**
     * @public
     */
    getPrevious() {
      return this.prev;
    }
    /**
     * Returns the latest velocity of `MotionValue`
     *
     * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
     *
     * @public
     */
    getVelocity() {
      const currentTime = time.now();
      if (
        !this.canTrackVelocity ||
        this.prevFrameValue === undefined ||
        currentTime - this.updatedAt > MAX_VELOCITY_DELTA
      ) {
        return 0;
      }
      const delta = Math.min(this.updatedAt - this.prevUpdatedAt, MAX_VELOCITY_DELTA);
      // Casts because of parseFloat's poor typing
      return velocityPerSecond(parseFloat(this.current) - parseFloat(this.prevFrameValue), delta);
    }
    /**
     * Registers a new animation to control this `MotionValue`. Only one
     * animation can drive a `MotionValue` at one time.
     *
     * ```jsx
     * value.start()
     * ```
     *
     * @param animation - A function that starts the provided animation
     */
    start(startAnimation) {
      this.stop();
      return new Promise((resolve) => {
        this.hasAnimated = true;
        this.animation = startAnimation(resolve);
        if (this.events.animationStart) {
          this.events.animationStart.notify();
        }
      }).then(() => {
        if (this.events.animationComplete) {
          this.events.animationComplete.notify();
        }
        this.clearAnimation();
      });
    }
    /**
     * Stop the currently active animation.
     *
     * @public
     */
    stop() {
      if (this.animation) {
        this.animation.stop();
        if (this.events.animationCancel) {
          this.events.animationCancel.notify();
        }
      }
      this.clearAnimation();
    }
    /**
     * Returns `true` if this value is currently animating.
     *
     * @public
     */
    isAnimating() {
      return !!this.animation;
    }
    clearAnimation() {
      delete this.animation;
    }
    /**
     * Destroy and clean up subscribers to this `MotionValue`.
     *
     * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
     * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
     * created a `MotionValue` via the `motionValue` function.
     *
     * @public
     */
    destroy() {
      this.dependents?.clear();
      this.events.destroy?.notify();
      this.clearListeners();
      this.stop();
      if (this.stopPassiveEffect) {
        this.stopPassiveEffect();
      }
    }
  }
  function motionValue(init, options) {
    return new MotionValue(init, options);
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/render/utils/setters.mjs

  /**
   * Set VisualElement's MotionValue, creating a new MotionValue for it if
   * it doesn't exist.
   */
  function setMotionValue(visualElement, key, value) {
    if (visualElement.hasValue(key)) {
      visualElement.getValue(key).set(value);
    } else {
      visualElement.addValue(key, motionValue(value));
    }
  }
  function resolveFinalValueInKeyframes(v) {
    // TODO maybe throw if v.length - 1 is placeholder token?
    return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;
  }
  function setTarget(visualElement, definition) {
    const resolved = resolveVariant(visualElement, definition);
    let { transitionEnd = {}, transition = {}, ...target } = resolved || {};
    target = { ...target, ...transitionEnd };
    for (const key in target) {
      const value = resolveFinalValueInKeyframes(target[key]);
      setMotionValue(visualElement, key, value);
    }
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/value/utils/is-motion-value.mjs

  const isMotionValue = (value) => Boolean(value && value.getVelocity); // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/value/use-will-change/is.mjs

  function isWillChangeMotionValue(value) {
    return Boolean(isMotionValue(value) && value.add);
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/value/use-will-change/add-will-change.mjs

  function addValueToWillChange(visualElement, key) {
    const willChange = visualElement.getValue('willChange');
    /**
     * It could be that a user has set willChange to a regular MotionValue,
     * in which case we can't add the value to it.
     */
    if (isWillChangeMotionValue(willChange)) {
      return willChange.add(key);
    } else if (!willChange && MotionGlobalConfig.WillChange) {
      const newWillChange = new MotionGlobalConfig.WillChange('auto');
      visualElement.addValue('willChange', newWillChange);
      newWillChange.add(key);
    }
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/render/dom/utils/camel-to-dash.mjs

  /**
   * Convert camelCase to dash-case properties.
   */
  const camelToDash = (str) => str.replace(/([a-z])([A-Z])/gu, '$1-$2').toLowerCase(); // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/animation/optimized-appear/data-id.mjs

  const optimizedAppearDataId = 'framerAppearId';
  const optimizedAppearDataAttribute = 'data-' + camelToDash(optimizedAppearDataId); // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/animation/optimized-appear/get-appear-id.mjs

  function getOptimisedAppearId(visualElement) {
    return visualElement.props[optimizedAppearDataAttribute];
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/animation/animators/waapi/utils/get-final-keyframe.mjs

  const isNotNull = (value) => value !== null;
  function getFinalKeyframe(keyframes, { repeat, repeatType = 'loop' }, finalKeyframe) {
    const resolvedKeyframes = keyframes.filter(isNotNull);
    const index =
      repeat && repeatType !== 'loop' && repeat % 2 === 1 ? 0 : resolvedKeyframes.length - 1;
    return !index || finalKeyframe === undefined ? resolvedKeyframes[index] : finalKeyframe;
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/render/utils/keys-transform.mjs

  /**
   * Generate a list of every possible transform key.
   */
  const transformPropOrder = [
    'transformPerspective',
    'x',
    'y',
    'z',
    'translateX',
    'translateY',
    'translateZ',
    'scale',
    'scaleX',
    'scaleY',
    'rotate',
    'rotateX',
    'rotateY',
    'rotateZ',
    'skew',
    'skewX',
    'skewY',
  ];
  /**
   * A quick lookup for transform props.
   */
  const transformProps = /*@__PURE__*/ (() => new Set(transformPropOrder))(); // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/animation/utils/default-transitions.mjs

  const underDampedSpring = {
    type: 'spring',
    stiffness: 500,
    damping: 25,
    restSpeed: 10,
  };
  const criticallyDampedSpring = (target) => ({
    type: 'spring',
    stiffness: 550,
    damping: target === 0 ? 2 * Math.sqrt(550) : 30,
    restSpeed: 10,
  });
  const keyframesTransition = {
    type: 'keyframes',
    duration: 0.8,
  };
  /**
   * Default easing curve is a slightly shallower version of
   * the default browser easing curve.
   */
  const ease = {
    type: 'keyframes',
    ease: [0.25, 0.1, 0.35, 1],
    duration: 0.3,
  };
  const getDefaultTransition = (valueKey, { keyframes }) => {
    if (keyframes.length > 2) {
      return keyframesTransition;
    } else if (transformProps.has(valueKey)) {
      return valueKey.startsWith('scale')
        ? criticallyDampedSpring(keyframes[1])
        : underDampedSpring;
    }
    return ease;
  }; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/animation/utils/is-transition-defined.mjs

  /**
   * Decide whether a transition is defined on a given Transition.
   * This filters out orchestration options and returns true
   * if any options are left.
   */
  function isTransitionDefined({
    when,
    delay: _delay,
    delayChildren,
    staggerChildren,
    staggerDirection,
    repeat,
    repeatType,
    repeatDelay,
    from,
    elapsed,
    ...transition
  }) {
    return !!Object.keys(transition).length;
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/animation/utils/get-value-transition.mjs

  function getValueTransition(transition, key) {
    return transition?.[key] ?? transition?.['default'] ?? transition;
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-utils/dist/es/time-conversion.mjs

  /**
   * Converts seconds to milliseconds
   *
   * @param seconds - Time in seconds.
   * @return milliseconds - Converted time in milliseconds.
   */
  /*#__NO_SIDE_EFFECTS__*/
  const time_conversion_secondsToMilliseconds = (seconds) => seconds * 1000;
  /*#__NO_SIDE_EFFECTS__*/
  const millisecondsToSeconds = (milliseconds) => milliseconds / 1000; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/stats/animation-count.mjs

  const activeAnimations = {
    layout: 0,
    mainThread: 0,
    waapi: 0,
  }; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/animation/utils/is-css-variable.mjs

  const checkStringStartsWith = (token) => (key) =>
    typeof key === 'string' && key.startsWith(token);
  const isCSSVariableName = /*@__PURE__*/ checkStringStartsWith('--');
  const startsAsVariableToken = /*@__PURE__*/ checkStringStartsWith('var(--');
  const isCSSVariableToken = (value) => {
    const startsWithToken = startsAsVariableToken(value);
    if (!startsWithToken) return false;
    // Ensure any comments are stripped from the value as this can harm performance of the regex.
    return singleCssVariableRegex.test(value.split('/*')[0].trim());
  };
  const singleCssVariableRegex =
    /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-utils/dist/es/clamp.mjs

  const clamp = (min, max, v) => {
    if (v > max) return max;
    if (v < min) return min;
    return v;
  }; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/value/types/numbers/index.mjs

  const number = {
    test: (v) => typeof v === 'number',
    parse: parseFloat,
    transform: (v) => v,
  };
  const alpha = {
    ...number,
    transform: (v) => clamp(0, 1, v),
  };
  const scale = {
    ...number,
    default: 1,
  }; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/value/types/utils/sanitize.mjs

  // If this number is a decimal, make it just five decimal places
  // to avoid exponents
  const sanitize = (v) => Math.round(v * 100000) / 100000; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/value/types/utils/float-regex.mjs

  const floatRegex = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/value/types/utils/is-nullish.mjs

  function isNullish(v) {
    return v == null;
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/value/types/utils/single-color-regex.mjs

  const singleColorRegex =
    /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/value/types/color/utils.mjs

  /**
   * Returns true if the provided string is a color, ie rgba(0,0,0,0) or #000,
   * but false if a number or multiple colors
   */
  const isColorString = (type, testProp) => (v) => {
    return Boolean(
      (typeof v === 'string' && singleColorRegex.test(v) && v.startsWith(type)) ||
        (testProp && !isNullish(v) && Object.prototype.hasOwnProperty.call(v, testProp))
    );
  };
  const splitColor = (aName, bName, cName) => (v) => {
    if (typeof v !== 'string') return v;
    const [a, b, c, alpha] = v.match(floatRegex);
    return {
      [aName]: parseFloat(a),
      [bName]: parseFloat(b),
      [cName]: parseFloat(c),
      alpha: alpha !== undefined ? parseFloat(alpha) : 1,
    };
  }; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/value/types/color/rgba.mjs

  const clampRgbUnit = (v) => clamp(0, 255, v);
  const rgbUnit = {
    ...number,
    transform: (v) => Math.round(clampRgbUnit(v)),
  };
  const rgba = {
    test: /*@__PURE__*/ isColorString('rgb', 'red'),
    parse: /*@__PURE__*/ splitColor('red', 'green', 'blue'),
    transform: ({ red, green, blue, alpha: alpha$1 = 1 }) =>
      'rgba(' +
      rgbUnit.transform(red) +
      ', ' +
      rgbUnit.transform(green) +
      ', ' +
      rgbUnit.transform(blue) +
      ', ' +
      sanitize(alpha.transform(alpha$1)) +
      ')',
  }; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/value/types/color/hex.mjs

  function parseHex(v) {
    let r = '';
    let g = '';
    let b = '';
    let a = '';
    // If we have 6 characters, ie #FF0000
    if (v.length > 5) {
      r = v.substring(1, 3);
      g = v.substring(3, 5);
      b = v.substring(5, 7);
      a = v.substring(7, 9);
      // Or we have 3 characters, ie #F00
    } else {
      r = v.substring(1, 2);
      g = v.substring(2, 3);
      b = v.substring(3, 4);
      a = v.substring(4, 5);
      r += r;
      g += g;
      b += b;
      a += a;
    }
    return {
      red: parseInt(r, 16),
      green: parseInt(g, 16),
      blue: parseInt(b, 16),
      alpha: a ? parseInt(a, 16) / 255 : 1,
    };
  }
  const hex = {
    test: /*@__PURE__*/ isColorString('#'),
    parse: parseHex,
    transform: rgba.transform,
  }; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/value/types/numbers/units.mjs

  /*#__NO_SIDE_EFFECTS__*/
  const createUnitType = (unit) => ({
    test: (v) => typeof v === 'string' && v.endsWith(unit) && v.split(' ').length === 1,
    parse: parseFloat,
    transform: (v) => `${v}${unit}`,
  });
  const degrees = /*@__PURE__*/ createUnitType('deg');
  const percent = /*@__PURE__*/ createUnitType('%');
  const px = /*@__PURE__*/ createUnitType('px');
  const vh = /*@__PURE__*/ createUnitType('vh');
  const vw = /*@__PURE__*/ createUnitType('vw');
  const progressPercentage = /*@__PURE__*/ (() => ({
    ...percent,
    parse: (v) => percent.parse(v) / 100,
    transform: (v) => percent.transform(v * 100),
  }))(); // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/value/types/color/hsla.mjs

  const hsla = {
    test: /*@__PURE__*/ isColorString('hsl', 'hue'),
    parse: /*@__PURE__*/ splitColor('hue', 'saturation', 'lightness'),
    transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => {
      return (
        'hsla(' +
        Math.round(hue) +
        ', ' +
        percent.transform(sanitize(saturation)) +
        ', ' +
        percent.transform(sanitize(lightness)) +
        ', ' +
        sanitize(alpha.transform(alpha$1)) +
        ')'
      );
    },
  }; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/value/types/color/index.mjs

  const color = {
    test: (v) => rgba.test(v) || hex.test(v) || hsla.test(v),
    parse: (v) => {
      if (rgba.test(v)) {
        return rgba.parse(v);
      } else if (hsla.test(v)) {
        return hsla.parse(v);
      } else {
        return hex.parse(v);
      }
    },
    transform: (v) => {
      return typeof v === 'string'
        ? v
        : v.hasOwnProperty('red')
          ? rgba.transform(v)
          : hsla.transform(v);
    },
  }; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/value/types/utils/color-regex.mjs

  const colorRegex =
    /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/value/types/complex/index.mjs

  function test(v) {
    return (
      isNaN(v) &&
      typeof v === 'string' &&
      (v.match(floatRegex)?.length || 0) + (v.match(colorRegex)?.length || 0) > 0
    );
  }
  const NUMBER_TOKEN = 'number';
  const COLOR_TOKEN = 'color';
  const VAR_TOKEN = 'var';
  const VAR_FUNCTION_TOKEN = 'var(';
  const SPLIT_TOKEN = '${}';
  // this regex consists of the `singleCssVariableRegex|rgbHSLValueRegex|digitRegex`
  const complexRegex =
    /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
  function analyseComplexValue(value) {
    const originalValue = value.toString();
    const values = [];
    const indexes = {
      color: [],
      number: [],
      var: [],
    };
    const types = [];
    let i = 0;
    const tokenised = originalValue.replace(complexRegex, (parsedValue) => {
      if (color.test(parsedValue)) {
        indexes.color.push(i);
        types.push(COLOR_TOKEN);
        values.push(color.parse(parsedValue));
      } else if (parsedValue.startsWith(VAR_FUNCTION_TOKEN)) {
        indexes.var.push(i);
        types.push(VAR_TOKEN);
        values.push(parsedValue);
      } else {
        indexes.number.push(i);
        types.push(NUMBER_TOKEN);
        values.push(parseFloat(parsedValue));
      }
      ++i;
      return SPLIT_TOKEN;
    });
    const split = tokenised.split(SPLIT_TOKEN);
    return { values, split, indexes, types };
  }
  function parseComplexValue(v) {
    return analyseComplexValue(v).values;
  }
  function createTransformer(source) {
    const { split, types } = analyseComplexValue(source);
    const numSections = split.length;
    return (v) => {
      let output = '';
      for (let i = 0; i < numSections; i++) {
        output += split[i];
        if (v[i] !== undefined) {
          const type = types[i];
          if (type === NUMBER_TOKEN) {
            output += sanitize(v[i]);
          } else if (type === COLOR_TOKEN) {
            output += color.transform(v[i]);
          } else {
            output += v[i];
          }
        }
      }
      return output;
    };
  }
  const convertNumbersToZero = (v) => (typeof v === 'number' ? 0 : v);
  function getAnimatableNone(v) {
    const parsed = parseComplexValue(v);
    const transformer = createTransformer(v);
    return transformer(parsed.map(convertNumbersToZero));
  }
  const complex = {
    test,
    parse: parseComplexValue,
    createTransformer,
    getAnimatableNone,
  }; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/value/types/color/hsla-to-rgba.mjs

  // Adapted from https://gist.github.com/mjackson/5311256
  function hueToRgb(p, q, t) {
    if (t < 0) t += 1;
    if (t > 1) t -= 1;
    if (t < 1 / 6) return p + (q - p) * 6 * t;
    if (t < 1 / 2) return q;
    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
    return p;
  }
  function hslaToRgba({ hue, saturation, lightness, alpha }) {
    hue /= 360;
    saturation /= 100;
    lightness /= 100;
    let red = 0;
    let green = 0;
    let blue = 0;
    if (!saturation) {
      red = green = blue = lightness;
    } else {
      const q =
        lightness < 0.5
          ? lightness * (1 + saturation)
          : lightness + saturation - lightness * saturation;
      const p = 2 * lightness - q;
      red = hueToRgb(p, q, hue + 1 / 3);
      green = hueToRgb(p, q, hue);
      blue = hueToRgb(p, q, hue - 1 / 3);
    }
    return {
      red: Math.round(red * 255),
      green: Math.round(green * 255),
      blue: Math.round(blue * 255),
      alpha,
    };
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/utils/mix/immediate.mjs

  function mixImmediate(a, b) {
    return (p) => (p > 0 ? b : a);
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/utils/mix/number.mjs

  /*
  Value in range from progress

  Given a lower limit and an upper limit, we return the value within
  that range as expressed by progress (usually a number from 0 to 1)

  So progress = 0.5 would change

  from -------- to

  to

  from ---- to

  E.g. from = 10, to = 20, progress = 0.5 => 15

  @param [number]: Lower limit of range
  @param [number]: Upper limit of range
  @param [number]: The progress between lower and upper limits expressed 0-1
  @return [number]: Value as calculated from progress within range (not limited within range)
*/
  const mixNumber = (from, to, progress) => {
    return from + (to - from) * progress;
  }; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-utils/dist/es/errors.mjs

  let warning = () => {};
  let invariant = () => {};
  if (false) {
    // removed by dead control flow
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/utils/mix/color.mjs

  // Linear color space blending
  // Explained https://www.youtube.com/watch?v=LKnqECcg6Gw
  // Demonstrated http://codepen.io/osublake/pen/xGVVaN
  const mixLinearColor = (from, to, v) => {
    const fromExpo = from * from;
    const expo = v * (to * to - fromExpo) + fromExpo;
    return expo < 0 ? 0 : Math.sqrt(expo);
  };
  const colorTypes = [hex, rgba, hsla];
  const getColorType = (v) => colorTypes.find((type) => type.test(v));
  function asRGBA(color) {
    const type = getColorType(color);
    warning(
      Boolean(type),
      `'${color}' is not an animatable color. Use the equivalent color code instead.`
    );
    if (!Boolean(type)) return false;
    let model = type.parse(color);
    if (type === hsla) {
      // TODO Remove this cast - needed since Motion's stricter typing
      model = hslaToRgba(model);
    }
    return model;
  }
  const mixColor = (from, to) => {
    const fromRGBA = asRGBA(from);
    const toRGBA = asRGBA(to);
    if (!fromRGBA || !toRGBA) {
      return mixImmediate(from, to);
    }
    const blended = { ...fromRGBA };
    return (v) => {
      blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v);
      blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v);
      blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v);
      blended.alpha = mixNumber(fromRGBA.alpha, toRGBA.alpha, v);
      return rgba.transform(blended);
    };
  }; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/utils/mix/visibility.mjs

  const invisibleValues = new Set(['none', 'hidden']);
  /**
   * Returns a function that, when provided a progress value between 0 and 1,
   * will return the "none" or "hidden" string only when the progress is that of
   * the origin or target.
   */
  function mixVisibility(origin, target) {
    if (invisibleValues.has(origin)) {
      return (p) => (p <= 0 ? origin : target);
    } else {
      return (p) => (p >= 1 ? target : origin);
    }
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-utils/dist/es/pipe.mjs

  /**
   * Pipe
   * Compose other transformers to run linearily
   * pipe(min(20), max(40))
   * @param  {...functions} transformers
   * @return {function}
   */
  const combineFunctions = (a, b) => (v) => b(a(v));
  const pipe = (...transformers) => transformers.reduce(combineFunctions); // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/utils/mix/complex.mjs

  function complex_mixNumber(a, b) {
    return (p) => mixNumber(a, b, p);
  }
  function getMixer(a) {
    if (typeof a === 'number') {
      return complex_mixNumber;
    } else if (typeof a === 'string') {
      return isCSSVariableToken(a) ? mixImmediate : color.test(a) ? mixColor : mixComplex;
    } else if (Array.isArray(a)) {
      return mixArray;
    } else if (typeof a === 'object') {
      return color.test(a) ? mixColor : mixObject;
    }
    return mixImmediate;
  }
  function mixArray(a, b) {
    const output = [...a];
    const numValues = output.length;
    const blendValue = a.map((v, i) => getMixer(v)(v, b[i]));
    return (p) => {
      for (let i = 0; i < numValues; i++) {
        output[i] = blendValue[i](p);
      }
      return output;
    };
  }
  function mixObject(a, b) {
    const output = { ...a, ...b };
    const blendValue = {};
    for (const key in output) {
      if (a[key] !== undefined && b[key] !== undefined) {
        blendValue[key] = getMixer(a[key])(a[key], b[key]);
      }
    }
    return (v) => {
      for (const key in blendValue) {
        output[key] = blendValue[key](v);
      }
      return output;
    };
  }
  function matchOrder(origin, target) {
    const orderedOrigin = [];
    const pointers = { color: 0, var: 0, number: 0 };
    for (let i = 0; i < target.values.length; i++) {
      const type = target.types[i];
      const originIndex = origin.indexes[type][pointers[type]];
      const originValue = origin.values[originIndex] ?? 0;
      orderedOrigin[i] = originValue;
      pointers[type]++;
    }
    return orderedOrigin;
  }
  const mixComplex = (origin, target) => {
    const template = complex.createTransformer(target);
    const originStats = analyseComplexValue(origin);
    const targetStats = analyseComplexValue(target);
    const canInterpolate =
      originStats.indexes.var.length === targetStats.indexes.var.length &&
      originStats.indexes.color.length === targetStats.indexes.color.length &&
      originStats.indexes.number.length >= targetStats.indexes.number.length;
    if (canInterpolate) {
      if (
        (invisibleValues.has(origin) && !targetStats.values.length) ||
        (invisibleValues.has(target) && !originStats.values.length)
      ) {
        return mixVisibility(origin, target);
      }
      return pipe(mixArray(matchOrder(originStats, targetStats), targetStats.values), template);
    } else {
      warning(
        true,
        `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`
      );
      return mixImmediate(origin, target);
    }
  }; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/utils/mix/index.mjs

  function mix(from, to, p) {
    if (typeof from === 'number' && typeof to === 'number' && typeof p === 'number') {
      return mixNumber(from, to, p);
    }
    const mixer = getMixer(from);
    return mixer(from, to);
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/animation/drivers/frame.mjs

  const frameloopDriver = (update) => {
    const passTimestamp = ({ timestamp }) => update(timestamp);
    return {
      start: (keepAlive = true) => frame_frame.update(passTimestamp, keepAlive),
      stop: () => cancelFrame(passTimestamp),
      /**
       * If we're processing this frame we can use the
       * framelocked timestamp to keep things in sync.
       */
      now: () => (frameData.isProcessing ? frameData.timestamp : time.now()),
    };
  }; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/animation/waapi/utils/linear.mjs

  const generateLinearEasing = (
    easing,
    duration, // as milliseconds
    resolution = 10 // as milliseconds
  ) => {
    let points = '';
    const numPoints = Math.max(Math.round(duration / resolution), 2);
    for (let i = 0; i < numPoints; i++) {
      points += easing(i / (numPoints - 1)) + ', ';
    }
    return `linear(${points.substring(0, points.length - 2)})`;
  }; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/animation/generators/utils/calc-duration.mjs

  /**
   * Implement a practical max duration for keyframe generation
   * to prevent infinite loops
   */
  const maxGeneratorDuration = 20000;
  function calcGeneratorDuration(generator) {
    let duration = 0;
    const timeStep = 50;
    let state = generator.next(duration);
    while (!state.done && duration < maxGeneratorDuration) {
      duration += timeStep;
      state = generator.next(duration);
    }
    return duration >= maxGeneratorDuration ? Infinity : duration;
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/animation/generators/utils/create-generator-easing.mjs

  /**
   * Create a progress => progress easing function from a generator.
   */
  function createGeneratorEasing(options, scale = 100, createGenerator) {
    const generator = createGenerator({ ...options, keyframes: [0, scale] });
    const duration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);
    return {
      type: 'keyframes',
      ease: (progress) => {
        return generator.next(duration * progress).value / scale;
      },
      duration: millisecondsToSeconds(duration),
    };
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/animation/generators/utils/velocity.mjs

  const velocitySampleDuration = 5; // ms
  function calcGeneratorVelocity(resolveValue, t, current) {
    const prevT = Math.max(t - velocitySampleDuration, 0);
    return velocityPerSecond(current - resolveValue(prevT), t - prevT);
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/animation/generators/spring/defaults.mjs

  const springDefaults = {
    // Default spring physics
    stiffness: 100,
    damping: 10,
    mass: 1.0,
    velocity: 0.0,
    // Default duration/bounce-based options
    duration: 800, // in ms
    bounce: 0.3,
    visualDuration: 0.3, // in seconds
    // Rest thresholds
    restSpeed: {
      granular: 0.01,
      default: 2,
    },
    restDelta: {
      granular: 0.005,
      default: 0.5,
    },
    // Limits
    minDuration: 0.01, // in seconds
    maxDuration: 10.0, // in seconds
    minDamping: 0.05,
    maxDamping: 1,
  }; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/animation/generators/spring/find.mjs

  const safeMin = 0.001;
  function findSpring({
    duration = springDefaults.duration,
    bounce = springDefaults.bounce,
    velocity = springDefaults.velocity,
    mass = springDefaults.mass,
  }) {
    let envelope;
    let derivative;
    warning(
      duration <= time_conversion_secondsToMilliseconds(springDefaults.maxDuration),
      'Spring duration must be 10 seconds or less'
    );
    let dampingRatio = 1 - bounce;
    /**
     * Restrict dampingRatio and duration to within acceptable ranges.
     */
    dampingRatio = clamp(springDefaults.minDamping, springDefaults.maxDamping, dampingRatio);
    duration = clamp(
      springDefaults.minDuration,
      springDefaults.maxDuration,
      millisecondsToSeconds(duration)
    );
    if (dampingRatio < 1) {
      /**
       * Underdamped spring
       */
      envelope = (undampedFreq) => {
        const exponentialDecay = undampedFreq * dampingRatio;
        const delta = exponentialDecay * duration;
        const a = exponentialDecay - velocity;
        const b = calcAngularFreq(undampedFreq, dampingRatio);
        const c = Math.exp(-delta);
        return safeMin - (a / b) * c;
      };
      derivative = (undampedFreq) => {
        const exponentialDecay = undampedFreq * dampingRatio;
        const delta = exponentialDecay * duration;
        const d = delta * velocity + velocity;
        const e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq, 2) * duration;
        const f = Math.exp(-delta);
        const g = calcAngularFreq(Math.pow(undampedFreq, 2), dampingRatio);
        const factor = -envelope(undampedFreq) + safeMin > 0 ? -1 : 1;
        return (factor * ((d - e) * f)) / g;
      };
    } else {
      /**
       * Critically-damped spring
       */
      envelope = (undampedFreq) => {
        const a = Math.exp(-undampedFreq * duration);
        const b = (undampedFreq - velocity) * duration + 1;
        return -safeMin + a * b;
      };
      derivative = (undampedFreq) => {
        const a = Math.exp(-undampedFreq * duration);
        const b = (velocity - undampedFreq) * (duration * duration);
        return a * b;
      };
    }
    const initialGuess = 5 / duration;
    const undampedFreq = approximateRoot(envelope, derivative, initialGuess);
    duration = time_conversion_secondsToMilliseconds(duration);
    if (isNaN(undampedFreq)) {
      return {
        stiffness: springDefaults.stiffness,
        damping: springDefaults.damping,
        duration,
      };
    } else {
      const stiffness = Math.pow(undampedFreq, 2) * mass;
      return {
        stiffness,
        damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),
        duration,
      };
    }
  }
  const rootIterations = 12;
  function approximateRoot(envelope, derivative, initialGuess) {
    let result = initialGuess;
    for (let i = 1; i < rootIterations; i++) {
      result = result - envelope(result) / derivative(result);
    }
    return result;
  }
  function calcAngularFreq(undampedFreq, dampingRatio) {
    return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/animation/generators/spring/index.mjs

  const durationKeys = ['duration', 'bounce'];
  const physicsKeys = ['stiffness', 'damping', 'mass'];
  function isSpringType(options, keys) {
    return keys.some((key) => options[key] !== undefined);
  }
  function getSpringOptions(options) {
    let springOptions = {
      velocity: springDefaults.velocity,
      stiffness: springDefaults.stiffness,
      damping: springDefaults.damping,
      mass: springDefaults.mass,
      isResolvedFromDuration: false,
      ...options,
    };
    // stiffness/damping/mass overrides duration/bounce
    if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {
      if (options.visualDuration) {
        const visualDuration = options.visualDuration;
        const root = (2 * Math.PI) / (visualDuration * 1.2);
        const stiffness = root * root;
        const damping = 2 * clamp(0.05, 1, 1 - (options.bounce || 0)) * Math.sqrt(stiffness);
        springOptions = {
          ...springOptions,
          mass: springDefaults.mass,
          stiffness,
          damping,
        };
      } else {
        const derived = findSpring(options);
        springOptions = {
          ...springOptions,
          ...derived,
          mass: springDefaults.mass,
        };
        springOptions.isResolvedFromDuration = true;
      }
    }
    return springOptions;
  }
  function spring(
    optionsOrVisualDuration = springDefaults.visualDuration,
    bounce = springDefaults.bounce
  ) {
    const options =
      typeof optionsOrVisualDuration !== 'object'
        ? {
            visualDuration: optionsOrVisualDuration,
            keyframes: [0, 1],
            bounce,
          }
        : optionsOrVisualDuration;
    let { restSpeed, restDelta } = options;
    const origin = options.keyframes[0];
    const target = options.keyframes[options.keyframes.length - 1];
    /**
     * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator
     * to reduce GC during animation.
     */
    const state = { done: false, value: origin };
    const { stiffness, damping, mass, duration, velocity, isResolvedFromDuration } =
      getSpringOptions({
        ...options,
        velocity: -millisecondsToSeconds(options.velocity || 0),
      });
    const initialVelocity = velocity || 0.0;
    const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));
    const initialDelta = target - origin;
    const undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass));
    /**
     * If we're working on a granular scale, use smaller defaults for determining
     * when the spring is finished.
     *
     * These defaults have been selected emprically based on what strikes a good
     * ratio between feeling good and finishing as soon as changes are imperceptible.
     */
    const isGranularScale = Math.abs(initialDelta) < 5;
    restSpeed ||
      (restSpeed = isGranularScale
        ? springDefaults.restSpeed.granular
        : springDefaults.restSpeed.default);
    restDelta ||
      (restDelta = isGranularScale
        ? springDefaults.restDelta.granular
        : springDefaults.restDelta.default);
    let resolveSpring;
    if (dampingRatio < 1) {
      const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);
      // Underdamped spring
      resolveSpring = (t) => {
        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);
        return (
          target -
          envelope *
            (((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq) *
              Math.sin(angularFreq * t) +
              initialDelta * Math.cos(angularFreq * t))
        );
      };
    } else if (dampingRatio === 1) {
      // Critically damped spring
      resolveSpring = (t) =>
        target -
        Math.exp(-undampedAngularFreq * t) *
          (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t);
    } else {
      // Overdamped spring
      const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);
      resolveSpring = (t) => {
        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);
        // When performing sinh or cosh values can hit Infinity so we cap them here
        const freqForT = Math.min(dampedAngularFreq * t, 300);
        return (
          target -
          (envelope *
            ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) *
              Math.sinh(freqForT) +
              dampedAngularFreq * initialDelta * Math.cosh(freqForT))) /
            dampedAngularFreq
        );
      };
    }
    const generator = {
      calculatedDuration: isResolvedFromDuration ? duration || null : null,
      next: (t) => {
        const current = resolveSpring(t);
        if (!isResolvedFromDuration) {
          let currentVelocity = t === 0 ? initialVelocity : 0.0;
          /**
           * We only need to calculate velocity for under-damped springs
           * as over- and critically-damped springs can't overshoot, so
           * checking only for displacement is enough.
           */
          if (dampingRatio < 1) {
            currentVelocity =
              t === 0
                ? time_conversion_secondsToMilliseconds(initialVelocity)
                : calcGeneratorVelocity(resolveSpring, t, current);
          }
          const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;
          const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;
          state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;
        } else {
          state.done = t >= duration;
        }
        state.value = state.done ? target : current;
        return state;
      },
      toString: () => {
        const calculatedDuration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);
        const easing = generateLinearEasing(
          (progress) => generator.next(calculatedDuration * progress).value,
          calculatedDuration,
          30
        );
        return calculatedDuration + 'ms ' + easing;
      },
      toTransition: () => {},
    };
    return generator;
  }
  spring.applyToOptions = (options) => {
    const generatorOptions = createGeneratorEasing(options, 100, spring);
    options.ease = generatorOptions.ease;
    options.duration = time_conversion_secondsToMilliseconds(generatorOptions.duration);
    options.type = 'keyframes';
    return options;
  }; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/animation/generators/inertia.mjs

  function inertia({
    keyframes,
    velocity = 0.0,
    power = 0.8,
    timeConstant = 325,
    bounceDamping = 10,
    bounceStiffness = 500,
    modifyTarget,
    min,
    max,
    restDelta = 0.5,
    restSpeed,
  }) {
    const origin = keyframes[0];
    const state = {
      done: false,
      value: origin,
    };
    const isOutOfBounds = (v) => (min !== undefined && v < min) || (max !== undefined && v > max);
    const nearestBoundary = (v) => {
      if (min === undefined) return max;
      if (max === undefined) return min;
      return Math.abs(min - v) < Math.abs(max - v) ? min : max;
    };
    let amplitude = power * velocity;
    const ideal = origin + amplitude;
    const target = modifyTarget === undefined ? ideal : modifyTarget(ideal);
    /**
     * If the target has changed we need to re-calculate the amplitude, otherwise
     * the animation will start from the wrong position.
     */
    if (target !== ideal) amplitude = target - origin;
    const calcDelta = (t) => -amplitude * Math.exp(-t / timeConstant);
    const calcLatest = (t) => target + calcDelta(t);
    const applyFriction = (t) => {
      const delta = calcDelta(t);
      const latest = calcLatest(t);
      state.done = Math.abs(delta) <= restDelta;
      state.value = state.done ? target : latest;
    };
    /**
     * Ideally this would resolve for t in a stateless way, we could
     * do that by always precalculating the animation but as we know
     * this will be done anyway we can assume that spring will
     * be discovered during that.
     */
    let timeReachedBoundary;
    let spring$1;
    const checkCatchBoundary = (t) => {
      if (!isOutOfBounds(state.value)) return;
      timeReachedBoundary = t;
      spring$1 = spring({
        keyframes: [state.value, nearestBoundary(state.value)],
        velocity: calcGeneratorVelocity(calcLatest, t, state.value), // TODO: This should be passing * 1000
        damping: bounceDamping,
        stiffness: bounceStiffness,
        restDelta,
        restSpeed,
      });
    };
    checkCatchBoundary(0);
    return {
      calculatedDuration: null,
      next: (t) => {
        /**
         * We need to resolve the friction to figure out if we need a
         * spring but we don't want to do this twice per frame. So here
         * we flag if we updated for this frame and later if we did
         * we can skip doing it again.
         */
        let hasUpdatedFrame = false;
        if (!spring$1 && timeReachedBoundary === undefined) {
          hasUpdatedFrame = true;
          applyFriction(t);
          checkCatchBoundary(t);
        }
        /**
         * If we have a spring and the provided t is beyond the moment the friction
         * animation crossed the min/max boundary, use the spring.
         */
        if (timeReachedBoundary !== undefined && t >= timeReachedBoundary) {
          return spring$1.next(t - timeReachedBoundary);
        } else {
          !hasUpdatedFrame && applyFriction(t);
          return state;
        }
      },
    };
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-utils/dist/es/progress.mjs

  /*
  Progress within given range

  Given a lower limit and an upper limit, we return the progress
  (expressed as a number 0-1) represented by the given value, and
  limit that progress to within 0-1.

  @param [number]: Lower limit
  @param [number]: Upper limit
  @param [number]: Value to find progress within given range
  @return [number]: Progress of value within range as expressed 0-1
*/
  /*#__NO_SIDE_EFFECTS__*/
  const progress = (from, to, value) => {
    const toFromDifference = to - from;
    return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;
  }; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/utils/interpolate.mjs

  function createMixers(output, ease, customMixer) {
    const mixers = [];
    const mixerFactory = customMixer || MotionGlobalConfig.mix || mix;
    const numMixers = output.length - 1;
    for (let i = 0; i < numMixers; i++) {
      let mixer = mixerFactory(output[i], output[i + 1]);
      if (ease) {
        const easingFunction = Array.isArray(ease) ? ease[i] || noop : ease;
        mixer = pipe(easingFunction, mixer);
      }
      mixers.push(mixer);
    }
    return mixers;
  }
  /**
   * Create a function that maps from a numerical input array to a generic output array.
   *
   * Accepts:
   *   - Numbers
   *   - Colors (hex, hsl, hsla, rgb, rgba)
   *   - Complex (combinations of one or more numbers or strings)
   *
   * ```jsx
   * const mixColor = interpolate([0, 1], ['#fff', '#000'])
   *
   * mixColor(0.5) // 'rgba(128, 128, 128, 1)'
   * ```
   *
   * TODO Revisit this approach once we've moved to data models for values,
   * probably not needed to pregenerate mixer functions.
   *
   * @public
   */
  function interpolate(input, output, { clamp: isClamp = true, ease, mixer } = {}) {
    const inputLength = input.length;
    invariant(
      inputLength === output.length,
      'Both input and output ranges must be the same length'
    );
    /**
     * If we're only provided a single input, we can just make a function
     * that returns the output.
     */
    if (inputLength === 1) return () => output[0];
    if (inputLength === 2 && output[0] === output[1]) return () => output[1];
    const isZeroDeltaRange = input[0] === input[1];
    // If input runs highest -> lowest, reverse both arrays
    if (input[0] > input[inputLength - 1]) {
      input = [...input].reverse();
      output = [...output].reverse();
    }
    const mixers = createMixers(output, ease, mixer);
    const numMixers = mixers.length;
    const interpolator = (v) => {
      if (isZeroDeltaRange && v < input[0]) return output[0];
      let i = 0;
      if (numMixers > 1) {
        for (; i < input.length - 2; i++) {
          if (v < input[i + 1]) break;
        }
      }
      const progressInRange = progress(input[i], input[i + 1], v);
      return mixers[i](progressInRange);
    };
    return isClamp ? (v) => interpolator(clamp(input[0], input[inputLength - 1], v)) : interpolator;
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/animation/keyframes/offsets/fill.mjs

  function fillOffset(offset, remaining) {
    const min = offset[offset.length - 1];
    for (let i = 1; i <= remaining; i++) {
      const offsetProgress = progress(0, remaining, i);
      offset.push(mixNumber(min, 1, offsetProgress));
    }
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/animation/keyframes/offsets/default.mjs

  function defaultOffset(arr) {
    const offset = [0];
    fillOffset(offset, arr.length - 1);
    return offset;
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/animation/keyframes/offsets/time.mjs

  function convertOffsetToTimes(offset, duration) {
    return offset.map((o) => o * duration);
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-utils/dist/es/easing/cubic-bezier.mjs

  /*
  Bezier function generator
  This has been modified from Gatan Renaudeau's BezierEasing
  https://github.com/gre/bezier-easing/blob/master/src/index.js
  https://github.com/gre/bezier-easing/blob/master/LICENSE
  
  I've removed the newtonRaphsonIterate algo because in benchmarking it
  wasn't noticiably faster than binarySubdivision, indeed removing it
  usually improved times, depending on the curve.
  I also removed the lookup table, as for the added bundle size and loop we're
  only cutting ~4 or so subdivision iterations. I bumped the max iterations up
  to 12 to compensate and this still tended to be faster for no perceivable
  loss in accuracy.
  Usage
    const easeOut = cubicBezier(.17,.67,.83,.67);
    const x = easeOut(0.5); // returns 0.627...
*/
  // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.
  const calcBezier = (t, a1, a2) =>
    (((1.0 - 3.0 * a2 + 3.0 * a1) * t + (3.0 * a2 - 6.0 * a1)) * t + 3.0 * a1) * t;
  const subdivisionPrecision = 0.0000001;
  const subdivisionMaxIterations = 12;
  function binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {
    let currentX;
    let currentT;
    let i = 0;
    do {
      currentT = lowerBound + (upperBound - lowerBound) / 2.0;
      currentX = calcBezier(currentT, mX1, mX2) - x;
      if (currentX > 0.0) {
        upperBound = currentT;
      } else {
        lowerBound = currentT;
      }
    } while (Math.abs(currentX) > subdivisionPrecision && ++i < subdivisionMaxIterations);
    return currentT;
  }
  function cubicBezier(mX1, mY1, mX2, mY2) {
    // If this is a linear gradient, return linear easing
    if (mX1 === mY1 && mX2 === mY2) return noop;
    const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);
    // If animation is at start/end, return t without easing
    return (t) => (t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2));
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-utils/dist/es/easing/ease.mjs

  const easeIn = /*@__PURE__*/ cubicBezier(0.42, 0, 1, 1);
  const easeOut = /*@__PURE__*/ cubicBezier(0, 0, 0.58, 1);
  const easeInOut = /*@__PURE__*/ cubicBezier(0.42, 0, 0.58, 1); // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-utils/dist/es/easing/utils/is-easing-array.mjs

  const isEasingArray = (ease) => {
    return Array.isArray(ease) && typeof ease[0] !== 'number';
  }; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-utils/dist/es/easing/modifiers/mirror.mjs

  // Accepts an easing function and returns a new one that outputs mirrored values for
  // the second half of the animation. Turns easeIn into easeInOut.
  const mirrorEasing = (easing) => (p) =>
    p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-utils/dist/es/easing/modifiers/reverse.mjs

  // Accepts an easing function and returns a new one that outputs reversed values.
  // Turns easeIn into easeOut.
  const reverseEasing = (easing) => (p) => 1 - easing(1 - p); // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-utils/dist/es/easing/back.mjs

  const backOut = /*@__PURE__*/ cubicBezier(0.33, 1.53, 0.69, 0.99);
  const backIn = /*@__PURE__*/ reverseEasing(backOut);
  const backInOut = /*@__PURE__*/ mirrorEasing(backIn); // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-utils/dist/es/easing/anticipate.mjs

  const anticipate = (p) =>
    (p *= 2) < 1 ? 0.5 * backIn(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1))); // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-utils/dist/es/easing/circ.mjs

  const circIn = (p) => 1 - Math.sin(Math.acos(p));
  const circOut = reverseEasing(circIn);
  const circInOut = mirrorEasing(circIn); // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-utils/dist/es/easing/utils/is-bezier-definition.mjs

  const isBezierDefinition = (easing) => Array.isArray(easing) && typeof easing[0] === 'number'; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-utils/dist/es/easing/utils/map.mjs

  const easingLookup = {
    linear: noop,
    easeIn: easeIn,
    easeInOut: easeInOut,
    easeOut: easeOut,
    circIn: circIn,
    circInOut: circInOut,
    circOut: circOut,
    backIn: backIn,
    backInOut: backInOut,
    backOut: backOut,
    anticipate: anticipate,
  };
  const isValidEasing = (easing) => {
    return typeof easing === 'string';
  };
  const easingDefinitionToFunction = (definition) => {
    if (isBezierDefinition(definition)) {
      // If cubic bezier definition, create bezier curve
      invariant(definition.length === 4, `Cubic bezier arrays must contain four numerical values.`);
      const [x1, y1, x2, y2] = definition;
      return cubicBezier(x1, y1, x2, y2);
    } else if (isValidEasing(definition)) {
      // Else lookup from table
      invariant(easingLookup[definition] !== undefined, `Invalid easing type '${definition}'`);
      return easingLookup[definition];
    }
    return definition;
  }; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/animation/generators/keyframes.mjs

  function defaultEasing(values, easing) {
    return values.map(() => easing || easeInOut).splice(0, values.length - 1);
  }
  function keyframes({ duration = 300, keyframes: keyframeValues, times, ease = 'easeInOut' }) {
    /**
     * Easing functions can be externally defined as strings. Here we convert them
     * into actual functions.
     */
    const easingFunctions = isEasingArray(ease)
      ? ease.map(easingDefinitionToFunction)
      : easingDefinitionToFunction(ease);
    /**
     * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator
     * to reduce GC during animation.
     */
    const state = {
      done: false,
      value: keyframeValues[0],
    };
    /**
     * Create a times array based on the provided 0-1 offsets
     */
    const absoluteTimes = convertOffsetToTimes(
      // Only use the provided offsets if they're the correct length
      // TODO Maybe we should warn here if there's a length mismatch
      times && times.length === keyframeValues.length ? times : defaultOffset(keyframeValues),
      duration
    );
    const mapTimeToKeyframe = interpolate(absoluteTimes, keyframeValues, {
      ease: Array.isArray(easingFunctions)
        ? easingFunctions
        : defaultEasing(keyframeValues, easingFunctions),
    });
    return {
      calculatedDuration: duration,
      next: (t) => {
        state.value = mapTimeToKeyframe(t);
        state.done = t >= duration;
        return state;
      },
    };
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/animation/keyframes/get-final.mjs

  const get_final_isNotNull = (value) => value !== null;
  function get_final_getFinalKeyframe(
    keyframes,
    { repeat, repeatType = 'loop' },
    finalKeyframe,
    speed = 1
  ) {
    const resolvedKeyframes = keyframes.filter(get_final_isNotNull);
    const useFirstKeyframe = speed < 0 || (repeat && repeatType !== 'loop' && repeat % 2 === 1);
    const index = useFirstKeyframe ? 0 : resolvedKeyframes.length - 1;
    return !index || finalKeyframe === undefined ? resolvedKeyframes[index] : finalKeyframe;
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/animation/utils/replace-transition-type.mjs

  const transitionTypeMap = {
    decay: inertia,
    inertia: inertia,
    tween: keyframes,
    keyframes: keyframes,
    spring: spring,
  };
  function replaceTransitionType(transition) {
    if (typeof transition.type === 'string') {
      transition.type = transitionTypeMap[transition.type];
    }
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/animation/utils/WithPromise.mjs

  class WithPromise {
    constructor() {
      this.updateFinished();
    }
    get finished() {
      return this._finished;
    }
    updateFinished() {
      this._finished = new Promise((resolve) => {
        this.resolve = resolve;
      });
    }
    notifyFinished() {
      this.resolve();
    }
    /**
     * Allows the animation to be awaited.
     *
     * @deprecated Use `finished` instead.
     */
    then(onResolve, onReject) {
      return this.finished.then(onResolve, onReject);
    }
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/animation/JSAnimation.mjs

  const percentToProgress = (percent) => percent / 100;
  class JSAnimation extends WithPromise {
    constructor(options) {
      super();
      this.state = 'idle';
      this.startTime = null;
      this.isStopped = false;
      /**
       * The current time of the animation.
       */
      this.currentTime = 0;
      /**
       * The time at which the animation was paused.
       */
      this.holdTime = null;
      /**
       * Playback speed as a factor. 0 would be stopped, -1 reverse and 2 double speed.
       */
      this.playbackSpeed = 1;
      /**
       * This method is bound to the instance to fix a pattern where
       * animation.stop is returned as a reference from a useEffect.
       */
      this.stop = () => {
        const { motionValue } = this.options;
        if (motionValue && motionValue.updatedAt !== time.now()) {
          this.tick(time.now());
        }
        this.isStopped = true;
        if (this.state === 'idle') return;
        this.teardown();
        this.options.onStop?.();
      };
      activeAnimations.mainThread++;
      this.options = options;
      this.initAnimation();
      this.play();
      if (options.autoplay === false) this.pause();
    }
    initAnimation() {
      const { options } = this;
      replaceTransitionType(options);
      const { type = keyframes, repeat = 0, repeatDelay = 0, repeatType, velocity = 0 } = options;
      let { keyframes: keyframes$1 } = options;
      const generatorFactory = type || keyframes;
      if (false) {
        // removed by dead control flow
      }
      if (generatorFactory !== keyframes && typeof keyframes$1[0] !== 'number') {
        this.mixKeyframes = pipe(percentToProgress, mix(keyframes$1[0], keyframes$1[1]));
        keyframes$1 = [0, 100];
      }
      const generator = generatorFactory({ ...options, keyframes: keyframes$1 });
      /**
       * If we have a mirror repeat type we need to create a second generator that outputs the
       * mirrored (not reversed) animation and later ping pong between the two generators.
       */
      if (repeatType === 'mirror') {
        this.mirroredGenerator = generatorFactory({
          ...options,
          keyframes: [...keyframes$1].reverse(),
          velocity: -velocity,
        });
      }
      /**
       * If duration is undefined and we have repeat options,
       * we need to calculate a duration from the generator.
       *
       * We set it to the generator itself to cache the duration.
       * Any timeline resolver will need to have already precalculated
       * the duration by this step.
       */
      if (generator.calculatedDuration === null) {
        generator.calculatedDuration = calcGeneratorDuration(generator);
      }
      const { calculatedDuration } = generator;
      this.calculatedDuration = calculatedDuration;
      this.resolvedDuration = calculatedDuration + repeatDelay;
      this.totalDuration = this.resolvedDuration * (repeat + 1) - repeatDelay;
      this.generator = generator;
    }
    updateTime(timestamp) {
      const animationTime = Math.round(timestamp - this.startTime) * this.playbackSpeed;
      // Update currentTime
      if (this.holdTime !== null) {
        this.currentTime = this.holdTime;
      } else {
        // Rounding the time because floating point arithmetic is not always accurate, e.g. 3000.367 - 1000.367 =
        // 2000.0000000000002. This is a problem when we are comparing the currentTime with the duration, for
        // example.
        this.currentTime = animationTime;
      }
    }
    tick(timestamp, sample = false) {
      const {
        generator,
        totalDuration,
        mixKeyframes,
        mirroredGenerator,
        resolvedDuration,
        calculatedDuration,
      } = this;
      if (this.startTime === null) return generator.next(0);
      const {
        delay = 0,
        keyframes,
        repeat,
        repeatType,
        repeatDelay,
        type,
        onUpdate,
        finalKeyframe,
      } = this.options;
      /**
       * requestAnimationFrame timestamps can come through as lower than
       * the startTime as set by performance.now(). Here we prevent this,
       * though in the future it could be possible to make setting startTime
       * a pending operation that gets resolved here.
       */
      if (this.speed > 0) {
        this.startTime = Math.min(this.startTime, timestamp);
      } else if (this.speed < 0) {
        this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime);
      }
      if (sample) {
        this.currentTime = timestamp;
      } else {
        this.updateTime(timestamp);
      }
      // Rebase on delay
      const timeWithoutDelay = this.currentTime - delay * (this.playbackSpeed >= 0 ? 1 : -1);
      const isInDelayPhase =
        this.playbackSpeed >= 0 ? timeWithoutDelay < 0 : timeWithoutDelay > totalDuration;
      this.currentTime = Math.max(timeWithoutDelay, 0);
      // If this animation has finished, set the current time  to the total duration.
      if (this.state === 'finished' && this.holdTime === null) {
        this.currentTime = totalDuration;
      }
      let elapsed = this.currentTime;
      let frameGenerator = generator;
      if (repeat) {
        /**
         * Get the current progress (0-1) of the animation. If t is >
         * than duration we'll get values like 2.5 (midway through the
         * third iteration)
         */
        const progress = Math.min(this.currentTime, totalDuration) / resolvedDuration;
        /**
         * Get the current iteration (0 indexed). For instance the floor of
         * 2.5 is 2.
         */
        let currentIteration = Math.floor(progress);
        /**
         * Get the current progress of the iteration by taking the remainder
         * so 2.5 is 0.5 through iteration 2
         */
        let iterationProgress = progress % 1.0;
        /**
         * If iteration progress is 1 we count that as the end
         * of the previous iteration.
         */
        if (!iterationProgress && progress >= 1) {
          iterationProgress = 1;
        }
        iterationProgress === 1 && currentIteration--;
        currentIteration = Math.min(currentIteration, repeat + 1);
        /**
         * Reverse progress if we're not running in "normal" direction
         */
        const isOddIteration = Boolean(currentIteration % 2);
        if (isOddIteration) {
          if (repeatType === 'reverse') {
            iterationProgress = 1 - iterationProgress;
            if (repeatDelay) {
              iterationProgress -= repeatDelay / resolvedDuration;
            }
          } else if (repeatType === 'mirror') {
            frameGenerator = mirroredGenerator;
          }
        }
        elapsed = clamp(0, 1, iterationProgress) * resolvedDuration;
      }
      /**
       * If we're in negative time, set state as the initial keyframe.
       * This prevents delay: x, duration: 0 animations from finishing
       * instantly.
       */
      const state = isInDelayPhase
        ? { done: false, value: keyframes[0] }
        : frameGenerator.next(elapsed);
      if (mixKeyframes) {
        state.value = mixKeyframes(state.value);
      }
      let { done } = state;
      if (!isInDelayPhase && calculatedDuration !== null) {
        done = this.playbackSpeed >= 0 ? this.currentTime >= totalDuration : this.currentTime <= 0;
      }
      const isAnimationFinished =
        this.holdTime === null && (this.state === 'finished' || (this.state === 'running' && done));
      // TODO: The exception for inertia could be cleaner here
      if (isAnimationFinished && type !== inertia) {
        state.value = get_final_getFinalKeyframe(
          keyframes,
          this.options,
          finalKeyframe,
          this.speed
        );
      }
      if (onUpdate) {
        onUpdate(state.value);
      }
      if (isAnimationFinished) {
        this.finish();
      }
      return state;
    }
    /**
     * Allows the returned animation to be awaited or promise-chained. Currently
     * resolves when the animation finishes at all but in a future update could/should
     * reject if its cancels.
     */
    then(resolve, reject) {
      return this.finished.then(resolve, reject);
    }
    get duration() {
      return millisecondsToSeconds(this.calculatedDuration);
    }
    get time() {
      return millisecondsToSeconds(this.currentTime);
    }
    set time(newTime) {
      newTime = time_conversion_secondsToMilliseconds(newTime);
      this.currentTime = newTime;
      if (this.startTime === null || this.holdTime !== null || this.playbackSpeed === 0) {
        this.holdTime = newTime;
      } else if (this.driver) {
        this.startTime = this.driver.now() - newTime / this.playbackSpeed;
      }
      this.driver?.start(false);
    }
    get speed() {
      return this.playbackSpeed;
    }
    set speed(newSpeed) {
      this.updateTime(time.now());
      const hasChanged = this.playbackSpeed !== newSpeed;
      this.playbackSpeed = newSpeed;
      if (hasChanged) {
        this.time = millisecondsToSeconds(this.currentTime);
      }
    }
    play() {
      if (this.isStopped) return;
      const { driver = frameloopDriver, startTime } = this.options;
      if (!this.driver) {
        this.driver = driver((timestamp) => this.tick(timestamp));
      }
      this.options.onPlay?.();
      const now = this.driver.now();
      if (this.state === 'finished') {
        this.updateFinished();
        this.startTime = now;
      } else if (this.holdTime !== null) {
        this.startTime = now - this.holdTime;
      } else if (!this.startTime) {
        this.startTime = startTime ?? now;
      }
      if (this.state === 'finished' && this.speed < 0) {
        this.startTime += this.calculatedDuration;
      }
      this.holdTime = null;
      /**
       * Set playState to running only after we've used it in
       * the previous logic.
       */
      this.state = 'running';
      this.driver.start();
    }
    pause() {
      this.state = 'paused';
      this.updateTime(time.now());
      this.holdTime = this.currentTime;
    }
    complete() {
      if (this.state !== 'running') {
        this.play();
      }
      this.state = 'finished';
      this.holdTime = null;
    }
    finish() {
      this.notifyFinished();
      this.teardown();
      this.state = 'finished';
      this.options.onComplete?.();
    }
    cancel() {
      this.holdTime = null;
      this.startTime = 0;
      this.tick(0);
      this.teardown();
      this.options.onCancel?.();
    }
    teardown() {
      this.state = 'idle';
      this.stopDriver();
      this.startTime = this.holdTime = null;
      activeAnimations.mainThread--;
    }
    stopDriver() {
      if (!this.driver) return;
      this.driver.stop();
      this.driver = undefined;
    }
    sample(sampleTime) {
      this.startTime = 0;
      return this.tick(sampleTime, true);
    }
    attachTimeline(timeline) {
      if (this.options.allowFlatten) {
        this.options.type = 'keyframes';
        this.options.ease = 'linear';
        this.initAnimation();
      }
      this.driver?.stop();
      return timeline.observe(this);
    }
  }
  // Legacy function support
  function animateValue(options) {
    return new JSAnimation(options);
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/animation/keyframes/utils/fill-wildcards.mjs

  function fillWildcards(keyframes) {
    for (let i = 1; i < keyframes.length; i++) {
      keyframes[i] ?? (keyframes[i] = keyframes[i - 1]);
    }
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/render/dom/parse-transform.mjs

  const radToDeg = (rad) => (rad * 180) / Math.PI;
  const rotate = (v) => {
    const angle = radToDeg(Math.atan2(v[1], v[0]));
    return rebaseAngle(angle);
  };
  const matrix2dParsers = {
    x: 4,
    y: 5,
    translateX: 4,
    translateY: 5,
    scaleX: 0,
    scaleY: 3,
    scale: (v) => (Math.abs(v[0]) + Math.abs(v[3])) / 2,
    rotate,
    rotateZ: rotate,
    skewX: (v) => radToDeg(Math.atan(v[1])),
    skewY: (v) => radToDeg(Math.atan(v[2])),
    skew: (v) => (Math.abs(v[1]) + Math.abs(v[2])) / 2,
  };
  const rebaseAngle = (angle) => {
    angle = angle % 360;
    if (angle < 0) angle += 360;
    return angle;
  };
  const rotateZ = rotate;
  const scaleX = (v) => Math.sqrt(v[0] * v[0] + v[1] * v[1]);
  const scaleY = (v) => Math.sqrt(v[4] * v[4] + v[5] * v[5]);
  const matrix3dParsers = {
    x: 12,
    y: 13,
    z: 14,
    translateX: 12,
    translateY: 13,
    translateZ: 14,
    scaleX,
    scaleY,
    scale: (v) => (scaleX(v) + scaleY(v)) / 2,
    rotateX: (v) => rebaseAngle(radToDeg(Math.atan2(v[6], v[5]))),
    rotateY: (v) => rebaseAngle(radToDeg(Math.atan2(-v[2], v[0]))),
    rotateZ,
    rotate: rotateZ,
    skewX: (v) => radToDeg(Math.atan(v[4])),
    skewY: (v) => radToDeg(Math.atan(v[1])),
    skew: (v) => (Math.abs(v[1]) + Math.abs(v[4])) / 2,
  };
  function defaultTransformValue(name) {
    return name.includes('scale') ? 1 : 0;
  }
  function parseValueFromTransform(transform, name) {
    if (!transform || transform === 'none') {
      return defaultTransformValue(name);
    }
    const matrix3dMatch = transform.match(/^matrix3d\(([-\d.e\s,]+)\)$/u);
    let parsers;
    let match;
    if (matrix3dMatch) {
      parsers = matrix3dParsers;
      match = matrix3dMatch;
    } else {
      const matrix2dMatch = transform.match(/^matrix\(([-\d.e\s,]+)\)$/u);
      parsers = matrix2dParsers;
      match = matrix2dMatch;
    }
    if (!match) {
      return defaultTransformValue(name);
    }
    const valueParser = parsers[name];
    const values = match[1].split(',').map(convertTransformToNumber);
    return typeof valueParser === 'function' ? valueParser(values) : values[valueParser];
  }
  const readTransformValue = (instance, name) => {
    const { transform = 'none' } = getComputedStyle(instance);
    return parseValueFromTransform(transform, name);
  };
  function convertTransformToNumber(value) {
    return parseFloat(value.trim());
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/animation/keyframes/utils/unit-conversion.mjs

  const isNumOrPxType = (v) => v === number || v === px;
  const transformKeys = new Set(['x', 'y', 'z']);
  const nonTranslationalTransformKeys = transformPropOrder.filter((key) => !transformKeys.has(key));
  function removeNonTranslationalTransform(visualElement) {
    const removedTransforms = [];
    nonTranslationalTransformKeys.forEach((key) => {
      const value = visualElement.getValue(key);
      if (value !== undefined) {
        removedTransforms.push([key, value.get()]);
        value.set(key.startsWith('scale') ? 1 : 0);
      }
    });
    return removedTransforms;
  }
  const positionalValues = {
    // Dimensions
    width: ({ x }, { paddingLeft = '0', paddingRight = '0' }) =>
      x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight),
    height: ({ y }, { paddingTop = '0', paddingBottom = '0' }) =>
      y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom),
    top: (_bbox, { top }) => parseFloat(top),
    left: (_bbox, { left }) => parseFloat(left),
    bottom: ({ y }, { top }) => parseFloat(top) + (y.max - y.min),
    right: ({ x }, { left }) => parseFloat(left) + (x.max - x.min),
    // Transform
    x: (_bbox, { transform }) => parseValueFromTransform(transform, 'x'),
    y: (_bbox, { transform }) => parseValueFromTransform(transform, 'y'),
  };
  // Alias translate longform names
  positionalValues.translateX = positionalValues.x;
  positionalValues.translateY = positionalValues.y; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/animation/keyframes/KeyframesResolver.mjs

  const toResolve = new Set();
  let isScheduled = false;
  let anyNeedsMeasurement = false;
  let isForced = false;
  function measureAllKeyframes() {
    if (anyNeedsMeasurement) {
      const resolversToMeasure = Array.from(toResolve).filter(
        (resolver) => resolver.needsMeasurement
      );
      const elementsToMeasure = new Set(resolversToMeasure.map((resolver) => resolver.element));
      const transformsToRestore = new Map();
      /**
       * Write pass
       * If we're measuring elements we want to remove bounding box-changing transforms.
       */
      elementsToMeasure.forEach((element) => {
        const removedTransforms = removeNonTranslationalTransform(element);
        if (!removedTransforms.length) return;
        transformsToRestore.set(element, removedTransforms);
        element.render();
      });
      // Read
      resolversToMeasure.forEach((resolver) => resolver.measureInitialState());
      // Write
      elementsToMeasure.forEach((element) => {
        element.render();
        const restore = transformsToRestore.get(element);
        if (restore) {
          restore.forEach(([key, value]) => {
            element.getValue(key)?.set(value);
          });
        }
      });
      // Read
      resolversToMeasure.forEach((resolver) => resolver.measureEndState());
      // Write
      resolversToMeasure.forEach((resolver) => {
        if (resolver.suspendedScrollY !== undefined) {
          window.scrollTo(0, resolver.suspendedScrollY);
        }
      });
    }
    anyNeedsMeasurement = false;
    isScheduled = false;
    toResolve.forEach((resolver) => resolver.complete(isForced));
    toResolve.clear();
  }
  function readAllKeyframes() {
    toResolve.forEach((resolver) => {
      resolver.readKeyframes();
      if (resolver.needsMeasurement) {
        anyNeedsMeasurement = true;
      }
    });
  }
  function flushKeyframeResolvers() {
    isForced = true;
    readAllKeyframes();
    measureAllKeyframes();
    isForced = false;
  }
  class KeyframeResolver {
    constructor(unresolvedKeyframes, onComplete, name, motionValue, element, isAsync = false) {
      this.state = 'pending';
      /**
       * Track whether this resolver is async. If it is, it'll be added to the
       * resolver queue and flushed in the next frame. Resolvers that aren't going
       * to trigger read/write thrashing don't need to be async.
       */
      this.isAsync = false;
      /**
       * Track whether this resolver needs to perform a measurement
       * to resolve its keyframes.
       */
      this.needsMeasurement = false;
      this.unresolvedKeyframes = [...unresolvedKeyframes];
      this.onComplete = onComplete;
      this.name = name;
      this.motionValue = motionValue;
      this.element = element;
      this.isAsync = isAsync;
    }
    scheduleResolve() {
      this.state = 'scheduled';
      if (this.isAsync) {
        toResolve.add(this);
        if (!isScheduled) {
          isScheduled = true;
          frame_frame.read(readAllKeyframes);
          frame_frame.resolveKeyframes(measureAllKeyframes);
        }
      } else {
        this.readKeyframes();
        this.complete();
      }
    }
    readKeyframes() {
      const { unresolvedKeyframes, name, element, motionValue } = this;
      // If initial keyframe is null we need to read it from the DOM
      if (unresolvedKeyframes[0] === null) {
        const currentValue = motionValue?.get();
        // TODO: This doesn't work if the final keyframe is a wildcard
        const finalKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
        if (currentValue !== undefined) {
          unresolvedKeyframes[0] = currentValue;
        } else if (element && name) {
          const valueAsRead = element.readValue(name, finalKeyframe);
          if (valueAsRead !== undefined && valueAsRead !== null) {
            unresolvedKeyframes[0] = valueAsRead;
          }
        }
        if (unresolvedKeyframes[0] === undefined) {
          unresolvedKeyframes[0] = finalKeyframe;
        }
        if (motionValue && currentValue === undefined) {
          motionValue.set(unresolvedKeyframes[0]);
        }
      }
      fillWildcards(unresolvedKeyframes);
    }
    setFinalKeyframe() {}
    measureInitialState() {}
    renderEndStyles() {}
    measureEndState() {}
    complete(isForcedComplete = false) {
      this.state = 'complete';
      this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, isForcedComplete);
      toResolve.delete(this);
    }
    cancel() {
      if (this.state === 'scheduled') {
        toResolve.delete(this);
        this.state = 'pending';
      }
    }
    resume() {
      if (this.state === 'pending') this.scheduleResolve();
    }
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/render/dom/is-css-var.mjs

  const isCSSVar = (name) => name.startsWith('--'); // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/render/dom/style-set.mjs

  function setStyle(element, name, value) {
    isCSSVar(name) ? element.style.setProperty(name, value) : (element.style[name] = value);
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-utils/dist/es/memo.mjs

  /*#__NO_SIDE_EFFECTS__*/
  function memo(callback) {
    let result;
    return () => {
      if (result === undefined) result = callback();
      return result;
    };
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/utils/supports/scroll-timeline.mjs

  const supportsScrollTimeline = /* @__PURE__ */ memo(() => window.ScrollTimeline !== undefined); // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/utils/supports/flags.mjs

  /**
   * Add the ability for test suites to manually set support flags
   * to better test more environments.
   */
  const supportsFlags = {}; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/utils/supports/memo.mjs

  function memoSupports(callback, supportsFlag) {
    const memoized = memo(callback);
    return () => supportsFlags[supportsFlag] ?? memoized();
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/utils/supports/linear-easing.mjs

  const supportsLinearEasing = /*@__PURE__*/ memoSupports(() => {
    try {
      document.createElement('div').animate({ opacity: 0 }, { easing: 'linear(0, 1)' });
    } catch (e) {
      return false;
    }
    return true;
  }, 'linearEasing'); // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/animation/waapi/easing/cubic-bezier.mjs

  const cubicBezierAsString = ([a, b, c, d]) => `cubic-bezier(${a}, ${b}, ${c}, ${d})`; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/animation/waapi/easing/supported.mjs

  const supportedWaapiEasing = {
    linear: 'linear',
    ease: 'ease',
    easeIn: 'ease-in',
    easeOut: 'ease-out',
    easeInOut: 'ease-in-out',
    circIn: /*@__PURE__*/ cubicBezierAsString([0, 0.65, 0.55, 1]),
    circOut: /*@__PURE__*/ cubicBezierAsString([0.55, 0, 1, 0.45]),
    backIn: /*@__PURE__*/ cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),
    backOut: /*@__PURE__*/ cubicBezierAsString([0.33, 1.53, 0.69, 0.99]),
  }; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/animation/waapi/easing/map-easing.mjs

  function mapEasingToNativeEasing(easing, duration) {
    if (!easing) {
      return undefined;
    } else if (typeof easing === 'function') {
      return supportsLinearEasing() ? generateLinearEasing(easing, duration) : 'ease-out';
    } else if (isBezierDefinition(easing)) {
      return cubicBezierAsString(easing);
    } else if (Array.isArray(easing)) {
      return easing.map(
        (segmentEasing) =>
          mapEasingToNativeEasing(segmentEasing, duration) || supportedWaapiEasing.easeOut
      );
    } else {
      return supportedWaapiEasing[easing];
    }
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/animation/waapi/start-waapi-animation.mjs

  function startWaapiAnimation(
    element,
    valueName,
    keyframes,
    { delay = 0, duration = 300, repeat = 0, repeatType = 'loop', ease = 'easeOut', times } = {},
    pseudoElement = undefined
  ) {
    const keyframeOptions = {
      [valueName]: keyframes,
    };
    if (times) keyframeOptions.offset = times;
    const easing = mapEasingToNativeEasing(ease, duration);
    /**
     * If this is an easing array, apply to keyframes, not animation as a whole
     */
    if (Array.isArray(easing)) keyframeOptions.easing = easing;
    if (statsBuffer.value) {
      activeAnimations.waapi++;
    }
    const options = {
      delay,
      duration,
      easing: !Array.isArray(easing) ? easing : 'linear',
      fill: 'both',
      iterations: repeat + 1,
      direction: repeatType === 'reverse' ? 'alternate' : 'normal',
    };
    if (pseudoElement) options.pseudoElement = pseudoElement;
    const animation = element.animate(keyframeOptions, options);
    if (statsBuffer.value) {
      animation.finished.finally(() => {
        activeAnimations.waapi--;
      });
    }
    return animation;
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/animation/generators/utils/is-generator.mjs

  function isGenerator(type) {
    return typeof type === 'function' && 'applyToOptions' in type;
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/animation/waapi/utils/apply-generator.mjs

  function applyGeneratorOptions({ type, ...options }) {
    if (isGenerator(type) && supportsLinearEasing()) {
      return type.applyToOptions(options);
    } else {
      options.duration ?? (options.duration = 300);
      options.ease ?? (options.ease = 'easeOut');
    }
    return options;
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/animation/NativeAnimation.mjs

  /**
   * NativeAnimation implements AnimationPlaybackControls for the browser's Web Animations API.
   */
  class NativeAnimation extends WithPromise {
    constructor(options) {
      super();
      this.finishedTime = null;
      this.isStopped = false;
      if (!options) return;
      const {
        element,
        name,
        keyframes,
        pseudoElement,
        allowFlatten = false,
        finalKeyframe,
        onComplete,
      } = options;
      this.isPseudoElement = Boolean(pseudoElement);
      this.allowFlatten = allowFlatten;
      this.options = options;
      invariant(
        typeof options.type !== 'string',
        `animateMini doesn't support "type" as a string. Did you mean to import { spring } from "motion"?`
      );
      const transition = applyGeneratorOptions(options);
      this.animation = startWaapiAnimation(element, name, keyframes, transition, pseudoElement);
      if (transition.autoplay === false) {
        this.animation.pause();
      }
      this.animation.onfinish = () => {
        this.finishedTime = this.time;
        if (!pseudoElement) {
          const keyframe = get_final_getFinalKeyframe(
            keyframes,
            this.options,
            finalKeyframe,
            this.speed
          );
          if (this.updateMotionValue) {
            this.updateMotionValue(keyframe);
          } else {
            /**
             * If we can, we want to commit the final style as set by the user,
             * rather than the computed keyframe value supplied by the animation.
             */
            setStyle(element, name, keyframe);
          }
          this.animation.cancel();
        }
        onComplete?.();
        this.notifyFinished();
      };
    }
    play() {
      if (this.isStopped) return;
      this.animation.play();
      if (this.state === 'finished') {
        this.updateFinished();
      }
    }
    pause() {
      this.animation.pause();
    }
    complete() {
      this.animation.finish?.();
    }
    cancel() {
      try {
        this.animation.cancel();
      } catch (e) {}
    }
    stop() {
      if (this.isStopped) return;
      this.isStopped = true;
      const { state } = this;
      if (state === 'idle' || state === 'finished') {
        return;
      }
      if (this.updateMotionValue) {
        this.updateMotionValue();
      } else {
        this.commitStyles();
      }
      if (!this.isPseudoElement) this.cancel();
    }
    /**
     * WAAPI doesn't natively have any interruption capabilities.
     *
     * In this method, we commit styles back to the DOM before cancelling
     * the animation.
     *
     * This is designed to be overridden by NativeAnimationExtended, which
     * will create a renderless JS animation and sample it twice to calculate
     * its current value, "previous" value, and therefore allow
     * Motion to also correctly calculate velocity for any subsequent animation
     * while deferring the commit until the next animation frame.
     */
    commitStyles() {
      if (!this.isPseudoElement) {
        this.animation.commitStyles?.();
      }
    }
    get duration() {
      const duration = this.animation.effect?.getComputedTiming?.().duration || 0;
      return millisecondsToSeconds(Number(duration));
    }
    get time() {
      return millisecondsToSeconds(Number(this.animation.currentTime) || 0);
    }
    set time(newTime) {
      this.finishedTime = null;
      this.animation.currentTime = time_conversion_secondsToMilliseconds(newTime);
    }
    /**
     * The playback speed of the animation.
     * 1 = normal speed, 2 = double speed, 0.5 = half speed.
     */
    get speed() {
      return this.animation.playbackRate;
    }
    set speed(newSpeed) {
      // Allow backwards playback after finishing
      if (newSpeed < 0) this.finishedTime = null;
      this.animation.playbackRate = newSpeed;
    }
    get state() {
      return this.finishedTime !== null ? 'finished' : this.animation.playState;
    }
    get startTime() {
      return Number(this.animation.startTime);
    }
    set startTime(newStartTime) {
      this.animation.startTime = newStartTime;
    }
    /**
     * Attaches a timeline to the animation, for instance the `ScrollTimeline`.
     */
    attachTimeline({ timeline, observe }) {
      if (this.allowFlatten) {
        this.animation.effect?.updateTiming({ easing: 'linear' });
      }
      this.animation.onfinish = null;
      if (timeline && supportsScrollTimeline()) {
        this.animation.timeline = timeline;
        return noop;
      } else {
        return observe(this);
      }
    }
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/animation/waapi/utils/unsupported-easing.mjs

  const unsupportedEasingFunctions = {
    anticipate: anticipate,
    backInOut: backInOut,
    circInOut: circInOut,
  };
  function isUnsupportedEase(key) {
    return key in unsupportedEasingFunctions;
  }
  function replaceStringEasing(transition) {
    if (typeof transition.ease === 'string' && isUnsupportedEase(transition.ease)) {
      transition.ease = unsupportedEasingFunctions[transition.ease];
    }
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/animation/NativeAnimationExtended.mjs

  /**
   * 10ms is chosen here as it strikes a balance between smooth
   * results (more than one keyframe per frame at 60fps) and
   * keyframe quantity.
   */
  const sampleDelta = 10; //ms
  class NativeAnimationExtended extends NativeAnimation {
    constructor(options) {
      /**
       * The base NativeAnimation function only supports a subset
       * of Motion easings, and WAAPI also only supports some
       * easing functions via string/cubic-bezier definitions.
       *
       * This function replaces those unsupported easing functions
       * with a JS easing function. This will later get compiled
       * to a linear() easing function.
       */
      replaceStringEasing(options);
      /**
       * Ensure we replace the transition type with a generator function
       * before passing to WAAPI.
       *
       * TODO: Does this have a better home? It could be shared with
       * JSAnimation.
       */
      replaceTransitionType(options);
      super(options);
      if (options.startTime) {
        this.startTime = options.startTime;
      }
      this.options = options;
    }
    /**
     * WAAPI doesn't natively have any interruption capabilities.
     *
     * Rather than read commited styles back out of the DOM, we can
     * create a renderless JS animation and sample it twice to calculate
     * its current value, "previous" value, and therefore allow
     * Motion to calculate velocity for any subsequent animation.
     */
    updateMotionValue(value) {
      const { motionValue, onUpdate, onComplete, element, ...options } = this.options;
      if (!motionValue) return;
      if (value !== undefined) {
        motionValue.set(value);
        return;
      }
      const sampleAnimation = new JSAnimation({
        ...options,
        autoplay: false,
      });
      const sampleTime = time_conversion_secondsToMilliseconds(this.finishedTime ?? this.time);
      motionValue.setWithVelocity(
        sampleAnimation.sample(sampleTime - sampleDelta).value,
        sampleAnimation.sample(sampleTime).value,
        sampleDelta
      );
      sampleAnimation.stop();
    }
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/animation/utils/is-animatable.mjs

  /**
   * Check if a value is animatable. Examples:
   *
   * : 100, "100px", "#fff"
   * : "block", "url(2.jpg)"
   * @param value
   *
   * @internal
   */
  const isAnimatable = (value, name) => {
    // If the list of keys tat might be non-animatable grows, replace with Set
    if (name === 'zIndex') return false;
    // If it's a number or a keyframes array, we can animate it. We might at some point
    // need to do a deep isAnimatable check of keyframes, or let Popmotion handle this,
    // but for now lets leave it like this for performance reasons
    if (typeof value === 'number' || Array.isArray(value)) return true;
    if (
      typeof value === 'string' && // It's animatable if we have a string
      (complex.test(value) || value === '0') && // And it contains numbers and/or colors
      !value.startsWith('url(') // Unless it starts with "url("
    ) {
      return true;
    }
    return false;
  }; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/animation/utils/can-animate.mjs

  function hasKeyframesChanged(keyframes) {
    const current = keyframes[0];
    if (keyframes.length === 1) return true;
    for (let i = 0; i < keyframes.length; i++) {
      if (keyframes[i] !== current) return true;
    }
  }
  function canAnimate(keyframes, name, type, velocity) {
    /**
     * Check if we're able to animate between the start and end keyframes,
     * and throw a warning if we're attempting to animate between one that's
     * animatable and another that isn't.
     */
    const originKeyframe = keyframes[0];
    if (originKeyframe === null) return false;
    /**
     * These aren't traditionally animatable but we do support them.
     * In future we could look into making this more generic or replacing
     * this function with mix() === mixImmediate
     */
    if (name === 'display' || name === 'visibility') return true;
    const targetKeyframe = keyframes[keyframes.length - 1];
    const isOriginAnimatable = isAnimatable(originKeyframe, name);
    const isTargetAnimatable = isAnimatable(targetKeyframe, name);
    warning(
      isOriginAnimatable === isTargetAnimatable,
      `You are trying to animate ${name} from "${originKeyframe}" to "${targetKeyframe}". ${originKeyframe} is not an animatable value - to enable this animation set ${originKeyframe} to a value animatable to ${targetKeyframe} via the \`style\` property.`
    );
    // Always skip if any of these are true
    if (!isOriginAnimatable || !isTargetAnimatable) {
      return false;
    }
    return hasKeyframesChanged(keyframes) || ((type === 'spring' || isGenerator(type)) && velocity);
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-utils/dist/es/is-object.mjs

  function is_object_isObject(value) {
    return typeof value === 'object' && value !== null;
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/utils/is-html-element.mjs

  /**
   * Checks if an element is an HTML element in a way
   * that works across iframes
   */
  function isHTMLElement(element) {
    return is_object_isObject(element) && 'offsetHeight' in element;
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/animation/waapi/supports/waapi.mjs

  /**
   * A list of values that can be hardware-accelerated.
   */
  const acceleratedValues = new Set([
    'opacity',
    'clipPath',
    'filter',
    'transform',
    // TODO: Could be re-enabled now we have support for linear() easing
    // "background-color"
  ]);
  const supportsWaapi = /*@__PURE__*/ memo(() =>
    Object.hasOwnProperty.call(Element.prototype, 'animate')
  );
  function supportsBrowserAnimation(options) {
    const { motionValue, name, repeatDelay, repeatType, damping, type } = options;
    if (!isHTMLElement(motionValue?.owner?.current)) {
      return false;
    }
    const { onUpdate, transformTemplate } = motionValue.owner.getProps();
    return (
      supportsWaapi() &&
      name &&
      acceleratedValues.has(name) &&
      (name !== 'transform' || !transformTemplate) &&
      /**
       * If we're outputting values to onUpdate then we can't use WAAPI as there's
       * no way to read the value from WAAPI every frame.
       */
      !onUpdate &&
      !repeatDelay &&
      repeatType !== 'mirror' &&
      damping !== 0 &&
      type !== 'inertia'
    );
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/animation/AsyncMotionValueAnimation.mjs

  /**
   * Maximum time allowed between an animation being created and it being
   * resolved for us to use the latter as the start time.
   *
   * This is to ensure that while we prefer to "start" an animation as soon
   * as it's triggered, we also want to avoid a visual jump if there's a big delay
   * between these two moments.
   */
  const MAX_RESOLVE_DELAY = 40;
  class AsyncMotionValueAnimation extends WithPromise {
    constructor({
      autoplay = true,
      delay = 0,
      type = 'keyframes',
      repeat = 0,
      repeatDelay = 0,
      repeatType = 'loop',
      keyframes,
      name,
      motionValue,
      element,
      ...options
    }) {
      super();
      /**
       * Bound to support return animation.stop pattern
       */
      this.stop = () => {
        if (this._animation) {
          this._animation.stop();
          this.stopTimeline?.();
        }
        this.keyframeResolver?.cancel();
      };
      this.createdAt = time.now();
      const optionsWithDefaults = {
        autoplay,
        delay,
        type,
        repeat,
        repeatDelay,
        repeatType,
        name,
        motionValue,
        element,
        ...options,
      };
      const KeyframeResolver$1 = element?.KeyframeResolver || KeyframeResolver;
      this.keyframeResolver = new KeyframeResolver$1(
        keyframes,
        (resolvedKeyframes, finalKeyframe, forced) =>
          this.onKeyframesResolved(resolvedKeyframes, finalKeyframe, optionsWithDefaults, !forced),
        name,
        motionValue,
        element
      );
      this.keyframeResolver?.scheduleResolve();
    }
    onKeyframesResolved(keyframes, finalKeyframe, options, sync) {
      this.keyframeResolver = undefined;
      const { name, type, velocity, delay, isHandoff, onUpdate } = options;
      this.resolvedAt = time.now();
      /**
       * If we can't animate this value with the resolved keyframes
       * then we should complete it immediately.
       */
      if (!canAnimate(keyframes, name, type, velocity)) {
        if (MotionGlobalConfig.instantAnimations || !delay) {
          onUpdate?.(get_final_getFinalKeyframe(keyframes, options, finalKeyframe));
        }
        keyframes[0] = keyframes[keyframes.length - 1];
        options.duration = 0;
        options.repeat = 0;
      }
      /**
       * Resolve startTime for the animation.
       *
       * This method uses the createdAt and resolvedAt to calculate the
       * animation startTime. *Ideally*, we would use the createdAt time as t=0
       * as the following frame would then be the first frame of the animation in
       * progress, which would feel snappier.
       *
       * However, if there's a delay (main thread work) between the creation of
       * the animation and the first commited frame, we prefer to use resolvedAt
       * to avoid a sudden jump into the animation.
       */
      const startTime = sync
        ? !this.resolvedAt
          ? this.createdAt
          : this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY
            ? this.resolvedAt
            : this.createdAt
        : undefined;
      const resolvedOptions = {
        startTime,
        finalKeyframe,
        ...options,
        keyframes,
      };
      /**
       * Animate via WAAPI if possible. If this is a handoff animation, the optimised animation will be running via
       * WAAPI. Therefore, this animation must be JS to ensure it runs "under" the
       * optimised animation.
       */
      const animation =
        !isHandoff && supportsBrowserAnimation(resolvedOptions)
          ? new NativeAnimationExtended({
              ...resolvedOptions,
              element: resolvedOptions.motionValue.owner.current,
            })
          : new JSAnimation(resolvedOptions);
      animation.finished.then(() => this.notifyFinished()).catch(noop);
      if (this.pendingTimeline) {
        this.stopTimeline = animation.attachTimeline(this.pendingTimeline);
        this.pendingTimeline = undefined;
      }
      this._animation = animation;
    }
    get finished() {
      if (!this._animation) {
        return this._finished;
      } else {
        return this.animation.finished;
      }
    }
    then(onResolve, _onReject) {
      return this.finished.finally(onResolve).then(() => {});
    }
    get animation() {
      if (!this._animation) {
        this.keyframeResolver?.resume();
        flushKeyframeResolvers();
      }
      return this._animation;
    }
    get duration() {
      return this.animation.duration;
    }
    get time() {
      return this.animation.time;
    }
    set time(newTime) {
      this.animation.time = newTime;
    }
    get speed() {
      return this.animation.speed;
    }
    get state() {
      return this.animation.state;
    }
    set speed(newSpeed) {
      this.animation.speed = newSpeed;
    }
    get startTime() {
      return this.animation.startTime;
    }
    attachTimeline(timeline) {
      if (this._animation) {
        this.stopTimeline = this.animation.attachTimeline(timeline);
      } else {
        this.pendingTimeline = timeline;
      }
      return () => this.stop();
    }
    play() {
      this.animation.play();
    }
    pause() {
      this.animation.pause();
    }
    complete() {
      this.animation.complete();
    }
    cancel() {
      if (this._animation) {
        this.animation.cancel();
      }
      this.keyframeResolver?.cancel();
    }
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/animation/interfaces/motion-value.mjs

  const animateMotionValue =
    (name, value, target, transition = {}, element, isHandoff) =>
    (onComplete) => {
      const valueTransition = getValueTransition(transition, name) || {};
      /**
       * Most transition values are currently completely overwritten by value-specific
       * transitions. In the future it'd be nicer to blend these transitions. But for now
       * delay actually does inherit from the root transition if not value-specific.
       */
      const delay = valueTransition.delay || transition.delay || 0;
      /**
       * Elapsed isn't a public transition option but can be passed through from
       * optimized appear effects in milliseconds.
       */
      let { elapsed = 0 } = transition;
      elapsed = elapsed - time_conversion_secondsToMilliseconds(delay);
      const options = {
        keyframes: Array.isArray(target) ? target : [null, target],
        ease: 'easeOut',
        velocity: value.getVelocity(),
        ...valueTransition,
        delay: -elapsed,
        onUpdate: (v) => {
          value.set(v);
          valueTransition.onUpdate && valueTransition.onUpdate(v);
        },
        onComplete: () => {
          onComplete();
          valueTransition.onComplete && valueTransition.onComplete();
        },
        name,
        motionValue: value,
        element: isHandoff ? undefined : element,
      };
      /**
       * If there's no transition defined for this value, we can generate
       * unique transition settings for this value.
       */
      if (!isTransitionDefined(valueTransition)) {
        Object.assign(options, getDefaultTransition(name, options));
      }
      /**
       * Both WAAPI and our internal animation functions use durations
       * as defined by milliseconds, while our external API defines them
       * as seconds.
       */
      options.duration &&
        (options.duration = time_conversion_secondsToMilliseconds(options.duration));
      options.repeatDelay &&
        (options.repeatDelay = time_conversion_secondsToMilliseconds(options.repeatDelay));
      /**
       * Support deprecated way to set initial value. Prefer keyframe syntax.
       */
      if (options.from !== undefined) {
        options.keyframes[0] = options.from;
      }
      let shouldSkip = false;
      if (options.type === false || (options.duration === 0 && !options.repeatDelay)) {
        options.duration = 0;
        if (options.delay === 0) {
          shouldSkip = true;
        }
      }
      if (MotionGlobalConfig.instantAnimations || MotionGlobalConfig.skipAnimations) {
        shouldSkip = true;
        options.duration = 0;
        options.delay = 0;
      }
      /**
       * If the transition type or easing has been explicitly set by the user
       * then we don't want to allow flattening the animation.
       */
      options.allowFlatten = !valueTransition.type && !valueTransition.ease;
      /**
       * If we can or must skip creating the animation, and apply only
       * the final keyframe, do so. We also check once keyframes are resolved but
       * this early check prevents the need to create an animation at all.
       */
      if (shouldSkip && !isHandoff && value.get() !== undefined) {
        const finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);
        if (finalKeyframe !== undefined) {
          frame_frame.update(() => {
            options.onUpdate(finalKeyframe);
            options.onComplete();
          });
          return;
        }
      }
      return valueTransition.isSync
        ? new JSAnimation(options)
        : new AsyncMotionValueAnimation(options);
    }; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/render/utils/keys-position.mjs

  const positionalKeys = new Set([
    'width',
    'height',
    'top',
    'left',
    'right',
    'bottom',
    ...transformPropOrder,
  ]); // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/animation/interfaces/visual-element-target.mjs

  /**
   * Decide whether we should block this animation. Previously, we achieved this
   * just by checking whether the key was listed in protectedKeys, but this
   * posed problems if an animation was triggered by afterChildren and protectedKeys
   * had been set to true in the meantime.
   */
  function shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {
    const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;
    needsAnimating[key] = false;
    return shouldBlock;
  }
  function animateTarget(
    visualElement,
    targetAndTransition,
    { delay = 0, transitionOverride, type } = {}
  ) {
    let {
      transition = visualElement.getDefaultTransition(),
      transitionEnd,
      ...target
    } = targetAndTransition;
    if (transitionOverride) transition = transitionOverride;
    const animations = [];
    const animationTypeState =
      type && visualElement.animationState && visualElement.animationState.getState()[type];
    for (const key in target) {
      const value = visualElement.getValue(key, visualElement.latestValues[key] ?? null);
      const valueTarget = target[key];
      if (
        valueTarget === undefined ||
        (animationTypeState && shouldBlockAnimation(animationTypeState, key))
      ) {
        continue;
      }
      const valueTransition = {
        delay,
        ...getValueTransition(transition || {}, key),
      };
      /**
       * If the value is already at the defined target, skip the animation.
       */
      const currentValue = value.get();
      if (
        currentValue !== undefined &&
        !value.isAnimating &&
        !Array.isArray(valueTarget) &&
        valueTarget === currentValue &&
        !valueTransition.velocity
      ) {
        continue;
      }
      /**
       * If this is the first time a value is being animated, check
       * to see if we're handling off from an existing animation.
       */
      let isHandoff = false;
      if (window.MotionHandoffAnimation) {
        const appearId = getOptimisedAppearId(visualElement);
        if (appearId) {
          const startTime = window.MotionHandoffAnimation(appearId, key, frame_frame);
          if (startTime !== null) {
            valueTransition.startTime = startTime;
            isHandoff = true;
          }
        }
      }
      addValueToWillChange(visualElement, key);
      value.start(
        animateMotionValue(
          key,
          value,
          valueTarget,
          visualElement.shouldReduceMotion && positionalKeys.has(key)
            ? { type: false }
            : valueTransition,
          visualElement,
          isHandoff
        )
      );
      const animation = value.animation;
      if (animation) {
        animations.push(animation);
      }
    }
    if (transitionEnd) {
      Promise.all(animations).then(() => {
        frame_frame.update(() => {
          transitionEnd && setTarget(visualElement, transitionEnd);
        });
      });
    }
    return animations;
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/animation/interfaces/visual-element-variant.mjs

  function animateVariant(visualElement, variant, options = {}) {
    const resolved = resolveVariant(
      visualElement,
      variant,
      options.type === 'exit' ? visualElement.presenceContext?.custom : undefined
    );
    let { transition = visualElement.getDefaultTransition() || {} } = resolved || {};
    if (options.transitionOverride) {
      transition = options.transitionOverride;
    }
    /**
     * If we have a variant, create a callback that runs it as an animation.
     * Otherwise, we resolve a Promise immediately for a composable no-op.
     */
    const getAnimation = resolved
      ? () => Promise.all(animateTarget(visualElement, resolved, options))
      : () => Promise.resolve();
    /**
     * If we have children, create a callback that runs all their animations.
     * Otherwise, we resolve a Promise immediately for a composable no-op.
     */
    const getChildAnimations =
      visualElement.variantChildren && visualElement.variantChildren.size
        ? (forwardDelay = 0) => {
            const { delayChildren = 0, staggerChildren, staggerDirection } = transition;
            return animateChildren(
              visualElement,
              variant,
              delayChildren + forwardDelay,
              staggerChildren,
              staggerDirection,
              options
            );
          }
        : () => Promise.resolve();
    /**
     * If the transition explicitly defines a "when" option, we need to resolve either
     * this animation or all children animations before playing the other.
     */
    const { when } = transition;
    if (when) {
      const [first, last] =
        when === 'beforeChildren'
          ? [getAnimation, getChildAnimations]
          : [getChildAnimations, getAnimation];
      return first().then(() => last());
    } else {
      return Promise.all([getAnimation(), getChildAnimations(options.delay)]);
    }
  }
  function animateChildren(
    visualElement,
    variant,
    delayChildren = 0,
    staggerChildren = 0,
    staggerDirection = 1,
    options
  ) {
    const animations = [];
    const maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;
    const generateStaggerDuration =
      staggerDirection === 1
        ? (i = 0) => i * staggerChildren
        : (i = 0) => maxStaggerDuration - i * staggerChildren;
    Array.from(visualElement.variantChildren)
      .sort(sortByTreeOrder)
      .forEach((child, i) => {
        child.notify('AnimationStart', variant);
        animations.push(
          animateVariant(child, variant, {
            ...options,
            delay: delayChildren + generateStaggerDuration(i),
          }).then(() => child.notify('AnimationComplete', variant))
        );
      });
    return Promise.all(animations);
  }
  function sortByTreeOrder(a, b) {
    return a.sortNodePosition(b);
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/animation/interfaces/visual-element.mjs

  function animateVisualElement(visualElement, definition, options = {}) {
    visualElement.notify('AnimationStart', definition);
    let animation;
    if (Array.isArray(definition)) {
      const animations = definition.map((variant) =>
        animateVariant(visualElement, variant, options)
      );
      animation = Promise.all(animations);
    } else if (typeof definition === 'string') {
      animation = animateVariant(visualElement, definition, options);
    } else {
      const resolvedDefinition =
        typeof definition === 'function'
          ? resolveVariant(visualElement, definition, options.custom)
          : definition;
      animation = Promise.all(animateTarget(visualElement, resolvedDefinition, options));
    }
    return animation.then(() => {
      visualElement.notify('AnimationComplete', definition);
    });
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/utils/shallow-compare.mjs

  function shallowCompare(next, prev) {
    if (!Array.isArray(prev)) return false;
    const prevLength = prev.length;
    if (prevLength !== next.length) return false;
    for (let i = 0; i < prevLength; i++) {
      if (prev[i] !== next[i]) return false;
    }
    return true;
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/render/utils/is-variant-label.mjs

  /**
   * Decides if the supplied variable is variant label
   */
  function isVariantLabel(v) {
    return typeof v === 'string' || Array.isArray(v);
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/render/utils/variant-props.mjs

  const variantPriorityOrder = [
    'animate',
    'whileInView',
    'whileFocus',
    'whileHover',
    'whileTap',
    'whileDrag',
    'exit',
  ];
  const variantProps = ['initial', ...variantPriorityOrder]; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/render/utils/get-variant-context.mjs

  const numVariantProps = variantProps.length;
  function getVariantContext(visualElement) {
    if (!visualElement) return undefined;
    if (!visualElement.isControllingVariants) {
      const context = visualElement.parent ? getVariantContext(visualElement.parent) || {} : {};
      if (visualElement.props.initial !== undefined) {
        context.initial = visualElement.props.initial;
      }
      return context;
    }
    const context = {};
    for (let i = 0; i < numVariantProps; i++) {
      const name = variantProps[i];
      const prop = visualElement.props[name];
      if (isVariantLabel(prop) || prop === false) {
        context[name] = prop;
      }
    }
    return context;
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/render/utils/animation-state.mjs

  const reversePriorityOrder = [...variantPriorityOrder].reverse();
  const numAnimationTypes = variantPriorityOrder.length;
  function animateList(visualElement) {
    return (animations) =>
      Promise.all(
        animations.map(({ animation, options }) =>
          animateVisualElement(visualElement, animation, options)
        )
      );
  }
  function createAnimationState(visualElement) {
    let animate = animateList(visualElement);
    let state = createState();
    let isInitialRender = true;
    /**
     * This function will be used to reduce the animation definitions for
     * each active animation type into an object of resolved values for it.
     */
    const buildResolvedTypeValues = (type) => (acc, definition) => {
      const resolved = resolveVariant(
        visualElement,
        definition,
        type === 'exit' ? visualElement.presenceContext?.custom : undefined
      );
      if (resolved) {
        const { transition, transitionEnd, ...target } = resolved;
        acc = { ...acc, ...target, ...transitionEnd };
      }
      return acc;
    };
    /**
     * This just allows us to inject mocked animation functions
     * @internal
     */
    function setAnimateFunction(makeAnimator) {
      animate = makeAnimator(visualElement);
    }
    /**
     * When we receive new props, we need to:
     * 1. Create a list of protected keys for each type. This is a directory of
     *    value keys that are currently being "handled" by types of a higher priority
     *    so that whenever an animation is played of a given type, these values are
     *    protected from being animated.
     * 2. Determine if an animation type needs animating.
     * 3. Determine if any values have been removed from a type and figure out
     *    what to animate those to.
     */
    function animateChanges(changedActiveType) {
      const { props } = visualElement;
      const context = getVariantContext(visualElement.parent) || {};
      /**
       * A list of animations that we'll build into as we iterate through the animation
       * types. This will get executed at the end of the function.
       */
      const animations = [];
      /**
       * Keep track of which values have been removed. Then, as we hit lower priority
       * animation types, we can check if they contain removed values and animate to that.
       */
      const removedKeys = new Set();
      /**
       * A dictionary of all encountered keys. This is an object to let us build into and
       * copy it without iteration. Each time we hit an animation type we set its protected
       * keys - the keys its not allowed to animate - to the latest version of this object.
       */
      let encounteredKeys = {};
      /**
       * If a variant has been removed at a given index, and this component is controlling
       * variant animations, we want to ensure lower-priority variants are forced to animate.
       */
      let removedVariantIndex = Infinity;
      /**
       * Iterate through all animation types in reverse priority order. For each, we want to
       * detect which values it's handling and whether or not they've changed (and therefore
       * need to be animated). If any values have been removed, we want to detect those in
       * lower priority props and flag for animation.
       */
      for (let i = 0; i < numAnimationTypes; i++) {
        const type = reversePriorityOrder[i];
        const typeState = state[type];
        const prop = props[type] !== undefined ? props[type] : context[type];
        const propIsVariant = isVariantLabel(prop);
        /**
         * If this type has *just* changed isActive status, set activeDelta
         * to that status. Otherwise set to null.
         */
        const activeDelta = type === changedActiveType ? typeState.isActive : null;
        if (activeDelta === false) removedVariantIndex = i;
        /**
         * If this prop is an inherited variant, rather than been set directly on the
         * component itself, we want to make sure we allow the parent to trigger animations.
         *
         * TODO: Can probably change this to a !isControllingVariants check
         */
        let isInherited = prop === context[type] && prop !== props[type] && propIsVariant;
        /**
         *
         */
        if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount) {
          isInherited = false;
        }
        /**
         * Set all encountered keys so far as the protected keys for this type. This will
         * be any key that has been animated or otherwise handled by active, higher-priortiy types.
         */
        typeState.protectedKeys = { ...encounteredKeys };
        // Check if we can skip analysing this prop early
        if (
          // If it isn't active and hasn't *just* been set as inactive
          (!typeState.isActive && activeDelta === null) ||
          // If we didn't and don't have any defined prop for this animation type
          (!prop && !typeState.prevProp) ||
          // Or if the prop doesn't define an animation
          isAnimationControls(prop) ||
          typeof prop === 'boolean'
        ) {
          continue;
        }
        /**
         * As we go look through the values defined on this type, if we detect
         * a changed value or a value that was removed in a higher priority, we set
         * this to true and add this prop to the animation list.
         */
        const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);
        let shouldAnimateType =
          variantDidChange ||
          // If we're making this variant active, we want to always make it active
          (type === changedActiveType && typeState.isActive && !isInherited && propIsVariant) ||
          // If we removed a higher-priority variant (i is in reverse order)
          (i > removedVariantIndex && propIsVariant);
        let handledRemovedValues = false;
        /**
         * As animations can be set as variant lists, variants or target objects, we
         * coerce everything to an array if it isn't one already
         */
        const definitionList = Array.isArray(prop) ? prop : [prop];
        /**
         * Build an object of all the resolved values. We'll use this in the subsequent
         * animateChanges calls to determine whether a value has changed.
         */
        let resolvedValues = definitionList.reduce(buildResolvedTypeValues(type), {});
        if (activeDelta === false) resolvedValues = {};
        /**
         * Now we need to loop through all the keys in the prev prop and this prop,
         * and decide:
         * 1. If the value has changed, and needs animating
         * 2. If it has been removed, and needs adding to the removedKeys set
         * 3. If it has been removed in a higher priority type and needs animating
         * 4. If it hasn't been removed in a higher priority but hasn't changed, and
         *    needs adding to the type's protectedKeys list.
         */
        const { prevResolvedValues = {} } = typeState;
        const allKeys = {
          ...prevResolvedValues,
          ...resolvedValues,
        };
        const markToAnimate = (key) => {
          shouldAnimateType = true;
          if (removedKeys.has(key)) {
            handledRemovedValues = true;
            removedKeys.delete(key);
          }
          typeState.needsAnimating[key] = true;
          const motionValue = visualElement.getValue(key);
          if (motionValue) motionValue.liveStyle = false;
        };
        for (const key in allKeys) {
          const next = resolvedValues[key];
          const prev = prevResolvedValues[key];
          // If we've already handled this we can just skip ahead
          if (encounteredKeys.hasOwnProperty(key)) continue;
          /**
           * If the value has changed, we probably want to animate it.
           */
          let valueHasChanged = false;
          if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {
            valueHasChanged = !shallowCompare(next, prev);
          } else {
            valueHasChanged = next !== prev;
          }
          if (valueHasChanged) {
            if (next !== undefined && next !== null) {
              // If next is defined and doesn't equal prev, it needs animating
              markToAnimate(key);
            } else {
              // If it's undefined, it's been removed.
              removedKeys.add(key);
            }
          } else if (next !== undefined && removedKeys.has(key)) {
            /**
             * If next hasn't changed and it isn't undefined, we want to check if it's
             * been removed by a higher priority
             */
            markToAnimate(key);
          } else {
            /**
             * If it hasn't changed, we add it to the list of protected values
             * to ensure it doesn't get animated.
             */
            typeState.protectedKeys[key] = true;
          }
        }
        /**
         * Update the typeState so next time animateChanges is called we can compare the
         * latest prop and resolvedValues to these.
         */
        typeState.prevProp = prop;
        typeState.prevResolvedValues = resolvedValues;
        /**
         *
         */
        if (typeState.isActive) {
          encounteredKeys = { ...encounteredKeys, ...resolvedValues };
        }
        if (isInitialRender && visualElement.blockInitialAnimation) {
          shouldAnimateType = false;
        }
        /**
         * If this is an inherited prop we want to skip this animation
         * unless the inherited variants haven't changed on this render.
         */
        const willAnimateViaParent = isInherited && variantDidChange;
        const needsAnimating = !willAnimateViaParent || handledRemovedValues;
        if (shouldAnimateType && needsAnimating) {
          animations.push(
            ...definitionList.map((animation) => ({
              animation: animation,
              options: { type },
            }))
          );
        }
      }
      /**
       * If there are some removed value that haven't been dealt with,
       * we need to create a new animation that falls back either to the value
       * defined in the style prop, or the last read value.
       */
      if (removedKeys.size) {
        const fallbackAnimation = {};
        /**
         * If the initial prop contains a transition we can use that, otherwise
         * allow the animation function to use the visual element's default.
         */
        if (typeof props.initial !== 'boolean') {
          const initialTransition = resolveVariant(
            visualElement,
            Array.isArray(props.initial) ? props.initial[0] : props.initial
          );
          if (initialTransition && initialTransition.transition) {
            fallbackAnimation.transition = initialTransition.transition;
          }
        }
        removedKeys.forEach((key) => {
          const fallbackTarget = visualElement.getBaseTarget(key);
          const motionValue = visualElement.getValue(key);
          if (motionValue) motionValue.liveStyle = true;
          // @ts-expect-error - @mattgperry to figure if we should do something here
          fallbackAnimation[key] = fallbackTarget ?? null;
        });
        animations.push({ animation: fallbackAnimation });
      }
      let shouldAnimate = Boolean(animations.length);
      if (
        isInitialRender &&
        (props.initial === false || props.initial === props.animate) &&
        !visualElement.manuallyAnimateOnMount
      ) {
        shouldAnimate = false;
      }
      isInitialRender = false;
      return shouldAnimate ? animate(animations) : Promise.resolve();
    }
    /**
     * Change whether a certain animation type is active.
     */
    function setActive(type, isActive) {
      // If the active state hasn't changed, we can safely do nothing here
      if (state[type].isActive === isActive) return Promise.resolve();
      // Propagate active change to children
      visualElement.variantChildren?.forEach((child) =>
        child.animationState?.setActive(type, isActive)
      );
      state[type].isActive = isActive;
      const animations = animateChanges(type);
      for (const key in state) {
        state[key].protectedKeys = {};
      }
      return animations;
    }
    return {
      animateChanges,
      setActive,
      setAnimateFunction,
      getState: () => state,
      reset: () => {
        state = createState();
        isInitialRender = true;
      },
    };
  }
  function checkVariantsDidChange(prev, next) {
    if (typeof next === 'string') {
      return next !== prev;
    } else if (Array.isArray(next)) {
      return !shallowCompare(next, prev);
    }
    return false;
  }
  function createTypeState(isActive = false) {
    return {
      isActive,
      protectedKeys: {},
      needsAnimating: {},
      prevResolvedValues: {},
    };
  }
  function createState() {
    return {
      animate: createTypeState(true),
      whileInView: createTypeState(),
      whileHover: createTypeState(),
      whileTap: createTypeState(),
      whileDrag: createTypeState(),
      whileFocus: createTypeState(),
      exit: createTypeState(),
    };
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/motion/features/Feature.mjs

  class Feature {
    constructor(node) {
      this.isMounted = false;
      this.node = node;
    }
    update() {}
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/motion/features/animation/index.mjs

  class AnimationFeature extends Feature {
    /**
     * We dynamically generate the AnimationState manager as it contains a reference
     * to the underlying animation library. We only want to load that if we load this,
     * so people can optionally code split it out using the `m` component.
     */
    constructor(node) {
      super(node);
      node.animationState || (node.animationState = createAnimationState(node));
    }
    updateAnimationControlsSubscription() {
      const { animate } = this.node.getProps();
      if (isAnimationControls(animate)) {
        this.unmountControls = animate.subscribe(this.node);
      }
    }
    /**
     * Subscribe any provided AnimationControls to the component's VisualElement
     */
    mount() {
      this.updateAnimationControlsSubscription();
    }
    update() {
      const { animate } = this.node.getProps();
      const { animate: prevAnimate } = this.node.prevProps || {};
      if (animate !== prevAnimate) {
        this.updateAnimationControlsSubscription();
      }
    }
    unmount() {
      this.node.animationState.reset();
      this.unmountControls?.();
    }
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/motion/features/animation/exit.mjs

  let id = 0;
  class ExitAnimationFeature extends Feature {
    constructor() {
      super(...arguments);
      this.id = id++;
    }
    update() {
      if (!this.node.presenceContext) return;
      const { isPresent, onExitComplete } = this.node.presenceContext;
      const { isPresent: prevIsPresent } = this.node.prevPresenceContext || {};
      if (!this.node.animationState || isPresent === prevIsPresent) {
        return;
      }
      const exitAnimation = this.node.animationState.setActive('exit', !isPresent);
      if (onExitComplete && !isPresent) {
        exitAnimation.then(() => {
          onExitComplete(this.id);
        });
      }
    }
    mount() {
      const { register, onExitComplete } = this.node.presenceContext || {};
      if (onExitComplete) {
        onExitComplete(this.id);
      }
      if (register) {
        this.unmount = register(this.id);
      }
    }
    unmount() {}
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/motion/features/animations.mjs

  const animations = {
    animation: {
      Feature: AnimationFeature,
    },
    exit: {
      Feature: ExitAnimationFeature,
    },
  }; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/events/add-dom-event.mjs

  function addDomEvent(target, eventName, handler, options = { passive: true }) {
    target.addEventListener(eventName, handler, options);
    return () => target.removeEventListener(eventName, handler);
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/gestures/utils/is-primary-pointer.mjs

  const isPrimaryPointer = (event) => {
    if (event.pointerType === 'mouse') {
      return typeof event.button !== 'number' || event.button <= 0;
    } else {
      /**
       * isPrimary is true for all mice buttons, whereas every touch point
       * is regarded as its own input. So subsequent concurrent touch points
       * will be false.
       *
       * Specifically match against false here as incomplete versions of
       * PointerEvents in very old browser might have it set as undefined.
       */
      return event.isPrimary !== false;
    }
  }; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/events/event-info.mjs

  function extractEventInfo(event) {
    return {
      point: {
        x: event.pageX,
        y: event.pageY,
      },
    };
  }
  const addPointerInfo = (handler) => {
    return (event) => isPrimaryPointer(event) && handler(event, extractEventInfo(event));
  }; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/events/add-pointer-event.mjs

  function addPointerEvent(target, eventName, handler, options) {
    return addDomEvent(target, eventName, addPointerInfo(handler), options);
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/projection/geometry/conversion.mjs

  /**
   * Bounding boxes tend to be defined as top, left, right, bottom. For various operations
   * it's easier to consider each axis individually. This function returns a bounding box
   * as a map of single-axis min/max values.
   */
  function convertBoundingBoxToBox({ top, left, right, bottom }) {
    return {
      x: { min: left, max: right },
      y: { min: top, max: bottom },
    };
  }
  function convertBoxToBoundingBox({ x, y }) {
    return { top: y.min, right: x.max, bottom: y.max, left: x.min };
  }
  /**
   * Applies a TransformPoint function to a bounding box. TransformPoint is usually a function
   * provided by Framer to allow measured points to be corrected for device scaling. This is used
   * when measuring DOM elements and DOM event points.
   */
  function transformBoxPoints(point, transformPoint) {
    if (!transformPoint) return point;
    const topLeft = transformPoint({ x: point.left, y: point.top });
    const bottomRight = transformPoint({ x: point.right, y: point.bottom });
    return {
      top: topLeft.y,
      left: topLeft.x,
      bottom: bottomRight.y,
      right: bottomRight.x,
    };
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/projection/geometry/delta-calc.mjs

  const SCALE_PRECISION = 0.0001;
  const SCALE_MIN = 1 - SCALE_PRECISION;
  const SCALE_MAX = 1 + SCALE_PRECISION;
  const TRANSLATE_PRECISION = 0.01;
  const TRANSLATE_MIN = 0 - TRANSLATE_PRECISION;
  const TRANSLATE_MAX = 0 + TRANSLATE_PRECISION;
  function calcLength(axis) {
    return axis.max - axis.min;
  }
  function isNear(value, target, maxDistance) {
    return Math.abs(value - target) <= maxDistance;
  }
  function calcAxisDelta(delta, source, target, origin = 0.5) {
    delta.origin = origin;
    delta.originPoint = mixNumber(source.min, source.max, delta.origin);
    delta.scale = calcLength(target) / calcLength(source);
    delta.translate = mixNumber(target.min, target.max, delta.origin) - delta.originPoint;
    if ((delta.scale >= SCALE_MIN && delta.scale <= SCALE_MAX) || isNaN(delta.scale)) {
      delta.scale = 1.0;
    }
    if (
      (delta.translate >= TRANSLATE_MIN && delta.translate <= TRANSLATE_MAX) ||
      isNaN(delta.translate)
    ) {
      delta.translate = 0.0;
    }
  }
  function calcBoxDelta(delta, source, target, origin) {
    calcAxisDelta(delta.x, source.x, target.x, origin ? origin.originX : undefined);
    calcAxisDelta(delta.y, source.y, target.y, origin ? origin.originY : undefined);
  }
  function calcRelativeAxis(target, relative, parent) {
    target.min = parent.min + relative.min;
    target.max = target.min + calcLength(relative);
  }
  function calcRelativeBox(target, relative, parent) {
    calcRelativeAxis(target.x, relative.x, parent.x);
    calcRelativeAxis(target.y, relative.y, parent.y);
  }
  function calcRelativeAxisPosition(target, layout, parent) {
    target.min = layout.min - parent.min;
    target.max = target.min + calcLength(layout);
  }
  function calcRelativePosition(target, layout, parent) {
    calcRelativeAxisPosition(target.x, layout.x, parent.x);
    calcRelativeAxisPosition(target.y, layout.y, parent.y);
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/projection/geometry/models.mjs

  const createAxisDelta = () => ({
    translate: 0,
    scale: 1,
    origin: 0,
    originPoint: 0,
  });
  const createDelta = () => ({
    x: createAxisDelta(),
    y: createAxisDelta(),
  });
  const createAxis = () => ({ min: 0, max: 0 });
  const createBox = () => ({
    x: createAxis(),
    y: createAxis(),
  }); // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/projection/utils/each-axis.mjs

  function eachAxis(callback) {
    return [callback('x'), callback('y')];
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/projection/utils/has-transform.mjs

  function isIdentityScale(scale) {
    return scale === undefined || scale === 1;
  }
  function hasScale({ scale, scaleX, scaleY }) {
    return !isIdentityScale(scale) || !isIdentityScale(scaleX) || !isIdentityScale(scaleY);
  }
  function hasTransform(values) {
    return (
      hasScale(values) ||
      has2DTranslate(values) ||
      values.z ||
      values.rotate ||
      values.rotateX ||
      values.rotateY ||
      values.skewX ||
      values.skewY
    );
  }
  function has2DTranslate(values) {
    return is2DTranslate(values.x) || is2DTranslate(values.y);
  }
  function is2DTranslate(value) {
    return value && value !== '0%';
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/projection/geometry/delta-apply.mjs

  /**
   * Scales a point based on a factor and an originPoint
   */
  function scalePoint(point, scale, originPoint) {
    const distanceFromOrigin = point - originPoint;
    const scaled = scale * distanceFromOrigin;
    return originPoint + scaled;
  }
  /**
   * Applies a translate/scale delta to a point
   */
  function applyPointDelta(point, translate, scale, originPoint, boxScale) {
    if (boxScale !== undefined) {
      point = scalePoint(point, boxScale, originPoint);
    }
    return scalePoint(point, scale, originPoint) + translate;
  }
  /**
   * Applies a translate/scale delta to an axis
   */
  function applyAxisDelta(axis, translate = 0, scale = 1, originPoint, boxScale) {
    axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);
    axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);
  }
  /**
   * Applies a translate/scale delta to a box
   */
  function applyBoxDelta(box, { x, y }) {
    applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);
    applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);
  }
  const TREE_SCALE_SNAP_MIN = 0.999999999999;
  const TREE_SCALE_SNAP_MAX = 1.0000000000001;
  /**
   * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms
   * in a tree upon our box before then calculating how to project it into our desired viewport-relative box
   *
   * This is the final nested loop within updateLayoutDelta for future refactoring
   */
  function applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {
    const treeLength = treePath.length;
    if (!treeLength) return;
    // Reset the treeScale
    treeScale.x = treeScale.y = 1;
    let node;
    let delta;
    for (let i = 0; i < treeLength; i++) {
      node = treePath[i];
      delta = node.projectionDelta;
      /**
       * TODO: Prefer to remove this, but currently we have motion components with
       * display: contents in Framer.
       */
      const { visualElement } = node.options;
      if (
        visualElement &&
        visualElement.props.style &&
        visualElement.props.style.display === 'contents'
      ) {
        continue;
      }
      if (isSharedTransition && node.options.layoutScroll && node.scroll && node !== node.root) {
        transformBox(box, {
          x: -node.scroll.offset.x,
          y: -node.scroll.offset.y,
        });
      }
      if (delta) {
        // Incoporate each ancestor's scale into a culmulative treeScale for this component
        treeScale.x *= delta.x.scale;
        treeScale.y *= delta.y.scale;
        // Apply each ancestor's calculated delta into this component's recorded layout box
        applyBoxDelta(box, delta);
      }
      if (isSharedTransition && hasTransform(node.latestValues)) {
        transformBox(box, node.latestValues);
      }
    }
    /**
     * Snap tree scale back to 1 if it's within a non-perceivable threshold.
     * This will help reduce useless scales getting rendered.
     */
    if (treeScale.x < TREE_SCALE_SNAP_MAX && treeScale.x > TREE_SCALE_SNAP_MIN) {
      treeScale.x = 1.0;
    }
    if (treeScale.y < TREE_SCALE_SNAP_MAX && treeScale.y > TREE_SCALE_SNAP_MIN) {
      treeScale.y = 1.0;
    }
  }
  function translateAxis(axis, distance) {
    axis.min = axis.min + distance;
    axis.max = axis.max + distance;
  }
  /**
   * Apply a transform to an axis from the latest resolved motion values.
   * This function basically acts as a bridge between a flat motion value map
   * and applyAxisDelta
   */
  function transformAxis(axis, axisTranslate, axisScale, boxScale, axisOrigin = 0.5) {
    const originPoint = mixNumber(axis.min, axis.max, axisOrigin);
    // Apply the axis delta to the final axis
    applyAxisDelta(axis, axisTranslate, axisScale, originPoint, boxScale);
  }
  /**
   * Apply a transform to a box from the latest resolved motion values.
   */
  function transformBox(box, transform) {
    transformAxis(box.x, transform.x, transform.scaleX, transform.scale, transform.originX);
    transformAxis(box.y, transform.y, transform.scaleY, transform.scale, transform.originY);
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/projection/utils/measure.mjs

  function measureViewportBox(instance, transformPoint) {
    return convertBoundingBoxToBox(
      transformBoxPoints(instance.getBoundingClientRect(), transformPoint)
    );
  }
  function measurePageBox(element, rootProjectionNode, transformPagePoint) {
    const viewportBox = measureViewportBox(element, transformPagePoint);
    const { scroll } = rootProjectionNode;
    if (scroll) {
      translateAxis(viewportBox.x, scroll.offset.x);
      translateAxis(viewportBox.y, scroll.offset.y);
    }
    return viewportBox;
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/utils/get-context-window.mjs

  // Fixes https://github.com/motiondivision/motion/issues/2270
  const getContextWindow = ({ current }) => {
    return current ? current.ownerDocument.defaultView : null;
  }; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/utils/is-ref-object.mjs

  function isRefObject(ref) {
    return ref && typeof ref === 'object' && Object.prototype.hasOwnProperty.call(ref, 'current');
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/utils/distance.mjs

  const distance = (a, b) => Math.abs(a - b);
  function distance2D(a, b) {
    // Multi-dimensional
    const xDelta = distance(a.x, b.x);
    const yDelta = distance(a.y, b.y);
    return Math.sqrt(xDelta ** 2 + yDelta ** 2);
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/gestures/pan/PanSession.mjs

  /**
   * @internal
   */
  class PanSession {
    constructor(
      event,
      handlers,
      { transformPagePoint, contextWindow, dragSnapToOrigin = false } = {}
    ) {
      /**
       * @internal
       */
      this.startEvent = null;
      /**
       * @internal
       */
      this.lastMoveEvent = null;
      /**
       * @internal
       */
      this.lastMoveEventInfo = null;
      /**
       * @internal
       */
      this.handlers = {};
      /**
       * @internal
       */
      this.contextWindow = window;
      this.updatePoint = () => {
        if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return;
        const info = getPanInfo(this.lastMoveEventInfo, this.history);
        const isPanStarted = this.startEvent !== null;
        // Only start panning if the offset is larger than 3 pixels. If we make it
        // any larger than this we'll want to reset the pointer history
        // on the first update to avoid visual snapping to the cursoe.
        const isDistancePastThreshold = distance2D(info.offset, { x: 0, y: 0 }) >= 3;
        if (!isPanStarted && !isDistancePastThreshold) return;
        const { point } = info;
        const { timestamp } = frameData;
        this.history.push({ ...point, timestamp });
        const { onStart, onMove } = this.handlers;
        if (!isPanStarted) {
          onStart && onStart(this.lastMoveEvent, info);
          this.startEvent = this.lastMoveEvent;
        }
        onMove && onMove(this.lastMoveEvent, info);
      };
      this.handlePointerMove = (event, info) => {
        this.lastMoveEvent = event;
        this.lastMoveEventInfo = transformPoint(info, this.transformPagePoint);
        // Throttle mouse move event to once per frame
        frame_frame.update(this.updatePoint, true);
      };
      this.handlePointerUp = (event, info) => {
        this.end();
        const { onEnd, onSessionEnd, resumeAnimation } = this.handlers;
        if (this.dragSnapToOrigin) resumeAnimation && resumeAnimation();
        if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return;
        const panInfo = getPanInfo(
          event.type === 'pointercancel'
            ? this.lastMoveEventInfo
            : transformPoint(info, this.transformPagePoint),
          this.history
        );
        if (this.startEvent && onEnd) {
          onEnd(event, panInfo);
        }
        onSessionEnd && onSessionEnd(event, panInfo);
      };
      // If we have more than one touch, don't start detecting this gesture
      if (!isPrimaryPointer(event)) return;
      this.dragSnapToOrigin = dragSnapToOrigin;
      this.handlers = handlers;
      this.transformPagePoint = transformPagePoint;
      this.contextWindow = contextWindow || window;
      const info = extractEventInfo(event);
      const initialInfo = transformPoint(info, this.transformPagePoint);
      const { point } = initialInfo;
      const { timestamp } = frameData;
      this.history = [{ ...point, timestamp }];
      const { onSessionStart } = handlers;
      onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));
      this.removeListeners = pipe(
        addPointerEvent(this.contextWindow, 'pointermove', this.handlePointerMove),
        addPointerEvent(this.contextWindow, 'pointerup', this.handlePointerUp),
        addPointerEvent(this.contextWindow, 'pointercancel', this.handlePointerUp)
      );
    }
    updateHandlers(handlers) {
      this.handlers = handlers;
    }
    end() {
      this.removeListeners && this.removeListeners();
      cancelFrame(this.updatePoint);
    }
  }
  function transformPoint(info, transformPagePoint) {
    return transformPagePoint ? { point: transformPagePoint(info.point) } : info;
  }
  function subtractPoint(a, b) {
    return { x: a.x - b.x, y: a.y - b.y };
  }
  function getPanInfo({ point }, history) {
    return {
      point,
      delta: subtractPoint(point, lastDevicePoint(history)),
      offset: subtractPoint(point, startDevicePoint(history)),
      velocity: getVelocity(history, 0.1),
    };
  }
  function startDevicePoint(history) {
    return history[0];
  }
  function lastDevicePoint(history) {
    return history[history.length - 1];
  }
  function getVelocity(history, timeDelta) {
    if (history.length < 2) {
      return { x: 0, y: 0 };
    }
    let i = history.length - 1;
    let timestampedPoint = null;
    const lastPoint = lastDevicePoint(history);
    while (i >= 0) {
      timestampedPoint = history[i];
      if (
        lastPoint.timestamp - timestampedPoint.timestamp >
        time_conversion_secondsToMilliseconds(timeDelta)
      ) {
        break;
      }
      i--;
    }
    if (!timestampedPoint) {
      return { x: 0, y: 0 };
    }
    const time = millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);
    if (time === 0) {
      return { x: 0, y: 0 };
    }
    const currentVelocity = {
      x: (lastPoint.x - timestampedPoint.x) / time,
      y: (lastPoint.y - timestampedPoint.y) / time,
    };
    if (currentVelocity.x === Infinity) {
      currentVelocity.x = 0;
    }
    if (currentVelocity.y === Infinity) {
      currentVelocity.y = 0;
    }
    return currentVelocity;
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/gestures/drag/utils/constraints.mjs

  /**
   * Apply constraints to a point. These constraints are both physical along an
   * axis, and an elastic factor that determines how much to constrain the point
   * by if it does lie outside the defined parameters.
   */
  function applyConstraints(point, { min, max }, elastic) {
    if (min !== undefined && point < min) {
      // If we have a min point defined, and this is outside of that, constrain
      point = elastic ? mixNumber(min, point, elastic.min) : Math.max(point, min);
    } else if (max !== undefined && point > max) {
      // If we have a max point defined, and this is outside of that, constrain
      point = elastic ? mixNumber(max, point, elastic.max) : Math.min(point, max);
    }
    return point;
  }
  /**
   * Calculate constraints in terms of the viewport when defined relatively to the
   * measured axis. This is measured from the nearest edge, so a max constraint of 200
   * on an axis with a max value of 300 would return a constraint of 500 - axis length
   */
  function calcRelativeAxisConstraints(axis, min, max) {
    return {
      min: min !== undefined ? axis.min + min : undefined,
      max: max !== undefined ? axis.max + max - (axis.max - axis.min) : undefined,
    };
  }
  /**
   * Calculate constraints in terms of the viewport when
   * defined relatively to the measured bounding box.
   */
  function calcRelativeConstraints(layoutBox, { top, left, bottom, right }) {
    return {
      x: calcRelativeAxisConstraints(layoutBox.x, left, right),
      y: calcRelativeAxisConstraints(layoutBox.y, top, bottom),
    };
  }
  /**
   * Calculate viewport constraints when defined as another viewport-relative axis
   */
  function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {
    let min = constraintsAxis.min - layoutAxis.min;
    let max = constraintsAxis.max - layoutAxis.max;
    // If the constraints axis is actually smaller than the layout axis then we can
    // flip the constraints
    if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {
      [min, max] = [max, min];
    }
    return { min, max };
  }
  /**
   * Calculate viewport constraints when defined as another viewport-relative box
   */
  function calcViewportConstraints(layoutBox, constraintsBox) {
    return {
      x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),
      y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y),
    };
  }
  /**
   * Calculate a transform origin relative to the source axis, between 0-1, that results
   * in an asthetically pleasing scale/transform needed to project from source to target.
   */
  function calcOrigin(source, target) {
    let origin = 0.5;
    const sourceLength = calcLength(source);
    const targetLength = calcLength(target);
    if (targetLength > sourceLength) {
      origin = progress(target.min, target.max - sourceLength, source.min);
    } else if (sourceLength > targetLength) {
      origin = progress(source.min, source.max - targetLength, target.min);
    }
    return clamp(0, 1, origin);
  }
  /**
   * Rebase the calculated viewport constraints relative to the layout.min point.
   */
  function rebaseAxisConstraints(layout, constraints) {
    const relativeConstraints = {};
    if (constraints.min !== undefined) {
      relativeConstraints.min = constraints.min - layout.min;
    }
    if (constraints.max !== undefined) {
      relativeConstraints.max = constraints.max - layout.min;
    }
    return relativeConstraints;
  }
  const defaultElastic = 0.35;
  /**
   * Accepts a dragElastic prop and returns resolved elastic values for each axis.
   */
  function resolveDragElastic(dragElastic = defaultElastic) {
    if (dragElastic === false) {
      dragElastic = 0;
    } else if (dragElastic === true) {
      dragElastic = defaultElastic;
    }
    return {
      x: resolveAxisElastic(dragElastic, 'left', 'right'),
      y: resolveAxisElastic(dragElastic, 'top', 'bottom'),
    };
  }
  function resolveAxisElastic(dragElastic, minLabel, maxLabel) {
    return {
      min: resolvePointElastic(dragElastic, minLabel),
      max: resolvePointElastic(dragElastic, maxLabel),
    };
  }
  function resolvePointElastic(dragElastic, label) {
    return typeof dragElastic === 'number' ? dragElastic : dragElastic[label] || 0;
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/gestures/drag/state/is-active.mjs

  const isDragging = {
    x: false,
    y: false,
  };
  function isDragActive() {
    return isDragging.x || isDragging.y;
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/gestures/drag/state/set-active.mjs

  function setDragLock(axis) {
    if (axis === 'x' || axis === 'y') {
      if (isDragging[axis]) {
        return null;
      } else {
        isDragging[axis] = true;
        return () => {
          isDragging[axis] = false;
        };
      }
    } else {
      if (isDragging.x || isDragging.y) {
        return null;
      } else {
        isDragging.x = isDragging.y = true;
        return () => {
          isDragging.x = isDragging.y = false;
        };
      }
    }
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/gestures/drag/VisualElementDragControls.mjs

  const elementDragControls = new WeakMap();
  /**
   *
   */
  // let latestPointerEvent: PointerEvent
  class VisualElementDragControls {
    constructor(visualElement) {
      this.openDragLock = null;
      this.isDragging = false;
      this.currentDirection = null;
      this.originPoint = { x: 0, y: 0 };
      /**
       * The permitted boundaries of travel, in pixels.
       */
      this.constraints = false;
      this.hasMutatedConstraints = false;
      /**
       * The per-axis resolved elastic values.
       */
      this.elastic = createBox();
      this.visualElement = visualElement;
    }
    start(originEvent, { snapToCursor = false } = {}) {
      /**
       * Don't start dragging if this component is exiting
       */
      const { presenceContext } = this.visualElement;
      if (presenceContext && presenceContext.isPresent === false) return;
      const onSessionStart = (event) => {
        const { dragSnapToOrigin } = this.getProps();
        // Stop or pause any animations on both axis values immediately. This allows the user to throw and catch
        // the component.
        dragSnapToOrigin ? this.pauseAnimation() : this.stopAnimation();
        if (snapToCursor) {
          this.snapToCursor(extractEventInfo(event).point);
        }
      };
      const onStart = (event, info) => {
        // Attempt to grab the global drag gesture lock - maybe make this part of PanSession
        const { drag, dragPropagation, onDragStart } = this.getProps();
        if (drag && !dragPropagation) {
          if (this.openDragLock) this.openDragLock();
          this.openDragLock = setDragLock(drag);
          // If we don 't have the lock, don't start dragging
          if (!this.openDragLock) return;
        }
        this.isDragging = true;
        this.currentDirection = null;
        this.resolveConstraints();
        if (this.visualElement.projection) {
          this.visualElement.projection.isAnimationBlocked = true;
          this.visualElement.projection.target = undefined;
        }
        /**
         * Record gesture origin
         */
        eachAxis((axis) => {
          let current = this.getAxisMotionValue(axis).get() || 0;
          /**
           * If the MotionValue is a percentage value convert to px
           */
          if (percent.test(current)) {
            const { projection } = this.visualElement;
            if (projection && projection.layout) {
              const measuredAxis = projection.layout.layoutBox[axis];
              if (measuredAxis) {
                const length = calcLength(measuredAxis);
                current = length * (parseFloat(current) / 100);
              }
            }
          }
          this.originPoint[axis] = current;
        });
        // Fire onDragStart event
        if (onDragStart) {
          frame_frame.postRender(() => onDragStart(event, info));
        }
        addValueToWillChange(this.visualElement, 'transform');
        const { animationState } = this.visualElement;
        animationState && animationState.setActive('whileDrag', true);
      };
      const onMove = (event, info) => {
        // latestPointerEvent = event
        const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag } = this.getProps();
        // If we didn't successfully receive the gesture lock, early return.
        if (!dragPropagation && !this.openDragLock) return;
        const { offset } = info;
        // Attempt to detect drag direction if directionLock is true
        if (dragDirectionLock && this.currentDirection === null) {
          this.currentDirection = getCurrentDirection(offset);
          // If we've successfully set a direction, notify listener
          if (this.currentDirection !== null) {
            onDirectionLock && onDirectionLock(this.currentDirection);
          }
          return;
        }
        // Update each point with the latest position
        this.updateAxis('x', info.point, offset);
        this.updateAxis('y', info.point, offset);
        /**
         * Ideally we would leave the renderer to fire naturally at the end of
         * this frame but if the element is about to change layout as the result
         * of a re-render we want to ensure the browser can read the latest
         * bounding box to ensure the pointer and element don't fall out of sync.
         */
        this.visualElement.render();
        /**
         * This must fire after the render call as it might trigger a state
         * change which itself might trigger a layout update.
         */
        onDrag && onDrag(event, info);
      };
      const onSessionEnd = (event, info) => this.stop(event, info);
      const resumeAnimation = () =>
        eachAxis(
          (axis) =>
            this.getAnimationState(axis) === 'paused' &&
            this.getAxisMotionValue(axis).animation?.play()
        );
      const { dragSnapToOrigin } = this.getProps();
      this.panSession = new PanSession(
        originEvent,
        {
          onSessionStart,
          onStart,
          onMove,
          onSessionEnd,
          resumeAnimation,
        },
        {
          transformPagePoint: this.visualElement.getTransformPagePoint(),
          dragSnapToOrigin,
          contextWindow: getContextWindow(this.visualElement),
        }
      );
    }
    stop(event, info) {
      const isDragging = this.isDragging;
      this.cancel();
      if (!isDragging) return;
      const { velocity } = info;
      this.startAnimation(velocity);
      const { onDragEnd } = this.getProps();
      if (onDragEnd) {
        frame_frame.postRender(() => onDragEnd(event, info));
      }
    }
    cancel() {
      this.isDragging = false;
      const { projection, animationState } = this.visualElement;
      if (projection) {
        projection.isAnimationBlocked = false;
      }
      this.panSession && this.panSession.end();
      this.panSession = undefined;
      const { dragPropagation } = this.getProps();
      if (!dragPropagation && this.openDragLock) {
        this.openDragLock();
        this.openDragLock = null;
      }
      animationState && animationState.setActive('whileDrag', false);
    }
    updateAxis(axis, _point, offset) {
      const { drag } = this.getProps();
      // If we're not dragging this axis, do an early return.
      if (!offset || !shouldDrag(axis, drag, this.currentDirection)) return;
      const axisValue = this.getAxisMotionValue(axis);
      let next = this.originPoint[axis] + offset[axis];
      // Apply constraints
      if (this.constraints && this.constraints[axis]) {
        next = applyConstraints(next, this.constraints[axis], this.elastic[axis]);
      }
      axisValue.set(next);
    }
    resolveConstraints() {
      const { dragConstraints, dragElastic } = this.getProps();
      const layout =
        this.visualElement.projection && !this.visualElement.projection.layout
          ? this.visualElement.projection.measure(false)
          : this.visualElement.projection?.layout;
      const prevConstraints = this.constraints;
      if (dragConstraints && isRefObject(dragConstraints)) {
        if (!this.constraints) {
          this.constraints = this.resolveRefConstraints();
        }
      } else {
        if (dragConstraints && layout) {
          this.constraints = calcRelativeConstraints(layout.layoutBox, dragConstraints);
        } else {
          this.constraints = false;
        }
      }
      this.elastic = resolveDragElastic(dragElastic);
      /**
       * If we're outputting to external MotionValues, we want to rebase the measured constraints
       * from viewport-relative to component-relative.
       */
      if (
        prevConstraints !== this.constraints &&
        layout &&
        this.constraints &&
        !this.hasMutatedConstraints
      ) {
        eachAxis((axis) => {
          if (this.constraints !== false && this.getAxisMotionValue(axis)) {
            this.constraints[axis] = rebaseAxisConstraints(
              layout.layoutBox[axis],
              this.constraints[axis]
            );
          }
        });
      }
    }
    resolveRefConstraints() {
      const { dragConstraints: constraints, onMeasureDragConstraints } = this.getProps();
      if (!constraints || !isRefObject(constraints)) return false;
      const constraintsElement = constraints.current;
      invariant(
        constraintsElement !== null,
        "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop."
      );
      const { projection } = this.visualElement;
      // TODO
      if (!projection || !projection.layout) return false;
      const constraintsBox = measurePageBox(
        constraintsElement,
        projection.root,
        this.visualElement.getTransformPagePoint()
      );
      let measuredConstraints = calcViewportConstraints(
        projection.layout.layoutBox,
        constraintsBox
      );
      /**
       * If there's an onMeasureDragConstraints listener we call it and
       * if different constraints are returned, set constraints to that
       */
      if (onMeasureDragConstraints) {
        const userConstraints = onMeasureDragConstraints(
          convertBoxToBoundingBox(measuredConstraints)
        );
        this.hasMutatedConstraints = !!userConstraints;
        if (userConstraints) {
          measuredConstraints = convertBoundingBoxToBox(userConstraints);
        }
      }
      return measuredConstraints;
    }
    startAnimation(velocity) {
      const {
        drag,
        dragMomentum,
        dragElastic,
        dragTransition,
        dragSnapToOrigin,
        onDragTransitionEnd,
      } = this.getProps();
      const constraints = this.constraints || {};
      const momentumAnimations = eachAxis((axis) => {
        if (!shouldDrag(axis, drag, this.currentDirection)) {
          return;
        }
        let transition = (constraints && constraints[axis]) || {};
        if (dragSnapToOrigin) transition = { min: 0, max: 0 };
        /**
         * Overdamp the boundary spring if `dragElastic` is disabled. There's still a frame
         * of spring animations so we should look into adding a disable spring option to `inertia`.
         * We could do something here where we affect the `bounceStiffness` and `bounceDamping`
         * using the value of `dragElastic`.
         */
        const bounceStiffness = dragElastic ? 200 : 1000000;
        const bounceDamping = dragElastic ? 40 : 10000000;
        const inertia = {
          type: 'inertia',
          velocity: dragMomentum ? velocity[axis] : 0,
          bounceStiffness,
          bounceDamping,
          timeConstant: 750,
          restDelta: 1,
          restSpeed: 10,
          ...dragTransition,
          ...transition,
        };
        // If we're not animating on an externally-provided `MotionValue` we can use the
        // component's animation controls which will handle interactions with whileHover (etc),
        // otherwise we just have to animate the `MotionValue` itself.
        return this.startAxisValueAnimation(axis, inertia);
      });
      // Run all animations and then resolve the new drag constraints.
      return Promise.all(momentumAnimations).then(onDragTransitionEnd);
    }
    startAxisValueAnimation(axis, transition) {
      const axisValue = this.getAxisMotionValue(axis);
      addValueToWillChange(this.visualElement, axis);
      return axisValue.start(
        animateMotionValue(axis, axisValue, 0, transition, this.visualElement, false)
      );
    }
    stopAnimation() {
      eachAxis((axis) => this.getAxisMotionValue(axis).stop());
    }
    pauseAnimation() {
      eachAxis((axis) => this.getAxisMotionValue(axis).animation?.pause());
    }
    getAnimationState(axis) {
      return this.getAxisMotionValue(axis).animation?.state;
    }
    /**
     * Drag works differently depending on which props are provided.
     *
     * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
     * - Otherwise, we apply the delta to the x/y motion values.
     */
    getAxisMotionValue(axis) {
      const dragKey = `_drag${axis.toUpperCase()}`;
      const props = this.visualElement.getProps();
      const externalMotionValue = props[dragKey];
      return externalMotionValue
        ? externalMotionValue
        : this.visualElement.getValue(axis, (props.initial ? props.initial[axis] : undefined) || 0);
    }
    snapToCursor(point) {
      eachAxis((axis) => {
        const { drag } = this.getProps();
        // If we're not dragging this axis, do an early return.
        if (!shouldDrag(axis, drag, this.currentDirection)) return;
        const { projection } = this.visualElement;
        const axisValue = this.getAxisMotionValue(axis);
        if (projection && projection.layout) {
          const { min, max } = projection.layout.layoutBox[axis];
          axisValue.set(point[axis] - mixNumber(min, max, 0.5));
        }
      });
    }
    /**
     * When the viewport resizes we want to check if the measured constraints
     * have changed and, if so, reposition the element within those new constraints
     * relative to where it was before the resize.
     */
    scalePositionWithinConstraints() {
      if (!this.visualElement.current) return;
      const { drag, dragConstraints } = this.getProps();
      const { projection } = this.visualElement;
      if (!isRefObject(dragConstraints) || !projection || !this.constraints) return;
      /**
       * Stop current animations as there can be visual glitching if we try to do
       * this mid-animation
       */
      this.stopAnimation();
      /**
       * Record the relative position of the dragged element relative to the
       * constraints box and save as a progress value.
       */
      const boxProgress = { x: 0, y: 0 };
      eachAxis((axis) => {
        const axisValue = this.getAxisMotionValue(axis);
        if (axisValue && this.constraints !== false) {
          const latest = axisValue.get();
          boxProgress[axis] = calcOrigin({ min: latest, max: latest }, this.constraints[axis]);
        }
      });
      /**
       * Update the layout of this element and resolve the latest drag constraints
       */
      const { transformTemplate } = this.visualElement.getProps();
      this.visualElement.current.style.transform = transformTemplate
        ? transformTemplate({}, '')
        : 'none';
      projection.root && projection.root.updateScroll();
      projection.updateLayout();
      this.resolveConstraints();
      /**
       * For each axis, calculate the current progress of the layout axis
       * within the new constraints.
       */
      eachAxis((axis) => {
        if (!shouldDrag(axis, drag, null)) return;
        /**
         * Calculate a new transform based on the previous box progress
         */
        const axisValue = this.getAxisMotionValue(axis);
        const { min, max } = this.constraints[axis];
        axisValue.set(mixNumber(min, max, boxProgress[axis]));
      });
    }
    addListeners() {
      if (!this.visualElement.current) return;
      elementDragControls.set(this.visualElement, this);
      const element = this.visualElement.current;
      /**
       * Attach a pointerdown event listener on this DOM element to initiate drag tracking.
       */
      const stopPointerListener = addPointerEvent(element, 'pointerdown', (event) => {
        const { drag, dragListener = true } = this.getProps();
        drag && dragListener && this.start(event);
      });
      const measureDragConstraints = () => {
        const { dragConstraints } = this.getProps();
        if (isRefObject(dragConstraints) && dragConstraints.current) {
          this.constraints = this.resolveRefConstraints();
        }
      };
      const { projection } = this.visualElement;
      const stopMeasureLayoutListener = projection.addEventListener(
        'measure',
        measureDragConstraints
      );
      if (projection && !projection.layout) {
        projection.root && projection.root.updateScroll();
        projection.updateLayout();
      }
      frame_frame.read(measureDragConstraints);
      /**
       * Attach a window resize listener to scale the draggable target within its defined
       * constraints as the window resizes.
       */
      const stopResizeListener = addDomEvent(window, 'resize', () =>
        this.scalePositionWithinConstraints()
      );
      /**
       * If the element's layout changes, calculate the delta and apply that to
       * the drag gesture's origin point.
       */
      const stopLayoutUpdateListener = projection.addEventListener(
        'didUpdate',
        ({ delta, hasLayoutChanged }) => {
          if (this.isDragging && hasLayoutChanged) {
            eachAxis((axis) => {
              const motionValue = this.getAxisMotionValue(axis);
              if (!motionValue) return;
              this.originPoint[axis] += delta[axis].translate;
              motionValue.set(motionValue.get() + delta[axis].translate);
            });
            this.visualElement.render();
          }
        }
      );
      return () => {
        stopResizeListener();
        stopPointerListener();
        stopMeasureLayoutListener();
        stopLayoutUpdateListener && stopLayoutUpdateListener();
      };
    }
    getProps() {
      const props = this.visualElement.getProps();
      const {
        drag = false,
        dragDirectionLock = false,
        dragPropagation = false,
        dragConstraints = false,
        dragElastic = defaultElastic,
        dragMomentum = true,
      } = props;
      return {
        ...props,
        drag,
        dragDirectionLock,
        dragPropagation,
        dragConstraints,
        dragElastic,
        dragMomentum,
      };
    }
  }
  function shouldDrag(direction, drag, currentDirection) {
    return (
      (drag === true || drag === direction) &&
      (currentDirection === null || currentDirection === direction)
    );
  }
  /**
   * Based on an x/y offset determine the current drag direction. If both axis' offsets are lower
   * than the provided threshold, return `null`.
   *
   * @param offset - The x/y offset from origin.
   * @param lockThreshold - (Optional) - the minimum absolute offset before we can determine a drag direction.
   */
  function getCurrentDirection(offset, lockThreshold = 10) {
    let direction = null;
    if (Math.abs(offset.y) > lockThreshold) {
      direction = 'y';
    } else if (Math.abs(offset.x) > lockThreshold) {
      direction = 'x';
    }
    return direction;
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/gestures/drag/index.mjs

  class DragGesture extends Feature {
    constructor(node) {
      super(node);
      this.removeGroupControls = noop;
      this.removeListeners = noop;
      this.controls = new VisualElementDragControls(node);
    }
    mount() {
      // If we've been provided a DragControls for manual control over the drag gesture,
      // subscribe this component to it on mount.
      const { dragControls } = this.node.getProps();
      if (dragControls) {
        this.removeGroupControls = dragControls.subscribe(this.controls);
      }
      this.removeListeners = this.controls.addListeners() || noop;
    }
    unmount() {
      this.removeGroupControls();
      this.removeListeners();
    }
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/gestures/pan/index.mjs

  const asyncHandler = (handler) => (event, info) => {
    if (handler) {
      frame_frame.postRender(() => handler(event, info));
    }
  };
  class PanGesture extends Feature {
    constructor() {
      super(...arguments);
      this.removePointerDownListener = noop;
    }
    onPointerDown(pointerDownEvent) {
      this.session = new PanSession(pointerDownEvent, this.createPanHandlers(), {
        transformPagePoint: this.node.getTransformPagePoint(),
        contextWindow: getContextWindow(this.node),
      });
    }
    createPanHandlers() {
      const { onPanSessionStart, onPanStart, onPan, onPanEnd } = this.node.getProps();
      return {
        onSessionStart: asyncHandler(onPanSessionStart),
        onStart: asyncHandler(onPanStart),
        onMove: onPan,
        onEnd: (event, info) => {
          delete this.session;
          if (onPanEnd) {
            frame_frame.postRender(() => onPanEnd(event, info));
          }
        },
      };
    }
    mount() {
      this.removePointerDownListener = addPointerEvent(this.node.current, 'pointerdown', (event) =>
        this.onPointerDown(event)
      );
    }
    update() {
      this.session && this.session.updateHandlers(this.createPanHandlers());
    }
    unmount() {
      this.removePointerDownListener();
      this.session && this.session.end();
    }
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/context/PresenceContext.mjs

  ('use client');

  /**
   * @public
   */
  const PresenceContext_PresenceContext = /* @__PURE__ */ (0, react.createContext)(null); // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/components/AnimatePresence/use-presence.mjs

  /**
   * When a component is the child of `AnimatePresence`, it can use `usePresence`
   * to access information about whether it's still present in the React tree.
   *
   * ```jsx
   * import { usePresence } from "framer-motion"
   *
   * export const Component = () => {
   *   const [isPresent, safeToRemove] = usePresence()
   *
   *   useEffect(() => {
   *     !isPresent && setTimeout(safeToRemove, 1000)
   *   }, [isPresent])
   *
   *   return <div />
   * }
   * ```
   *
   * If `isPresent` is `false`, it means that a component has been removed the tree, but
   * `AnimatePresence` won't really remove it until `safeToRemove` has been called.
   *
   * @public
   */
  function usePresence(subscribe = true) {
    const context = (0, react.useContext)(PresenceContext_PresenceContext);
    if (context === null) return [true, null];
    const { isPresent, onExitComplete, register } = context;
    // It's safe to call the following hooks conditionally (after an early return) because the context will always
    // either be null or non-null for the lifespan of the component.
    const id = (0, react.useId)();
    (0, react.useEffect)(() => {
      if (subscribe) {
        return register(id);
      }
    }, [subscribe]);
    const safeToRemove = (0, react.useCallback)(
      () => subscribe && onExitComplete && onExitComplete(id),
      [id, onExitComplete, subscribe]
    );
    return !isPresent && onExitComplete ? [false, safeToRemove] : [true];
  }
  /**
   * Similar to `usePresence`, except `useIsPresent` simply returns whether or not the component is present.
   * There is no `safeToRemove` function.
   *
   * ```jsx
   * import { useIsPresent } from "framer-motion"
   *
   * export const Component = () => {
   *   const isPresent = useIsPresent()
   *
   *   useEffect(() => {
   *     !isPresent && console.log("I've been removed!")
   *   }, [isPresent])
   *
   *   return <div />
   * }
   * ```
   *
   * @public
   */
  function useIsPresent() {
    return isPresent(useContext(PresenceContext));
  }
  function isPresent(context) {
    return context === null ? true : context.isPresent;
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/context/LayoutGroupContext.mjs

  ('use client');

  const LayoutGroupContext = (0, react.createContext)({}); // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/context/SwitchLayoutGroupContext.mjs

  ('use client');

  /**
   * Internal, exported only for usage in Framer
   */
  const SwitchLayoutGroupContext = (0, react.createContext)({}); // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/projection/node/state.mjs

  /**
   * This should only ever be modified on the client otherwise it'll
   * persist through server requests. If we need instanced states we
   * could lazy-init via root.
   */
  const globalProjectionState = {
    /**
     * Global flag as to whether the tree has animated since the last time
     * we resized the window
     */
    hasAnimatedSinceResize: true,
    /**
     * We set this to true once, on the first update. Any nodes added to the tree beyond that
     * update will be given a `data-projection-id` attribute.
     */
    hasEverUpdated: false,
  }; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/projection/styles/scale-border-radius.mjs

  function pixelsToPercent(pixels, axis) {
    if (axis.max === axis.min) return 0;
    return (pixels / (axis.max - axis.min)) * 100;
  }
  /**
   * We always correct borderRadius as a percentage rather than pixels to reduce paints.
   * For example, if you are projecting a box that is 100px wide with a 10px borderRadius
   * into a box that is 200px wide with a 20px borderRadius, that is actually a 10%
   * borderRadius in both states. If we animate between the two in pixels that will trigger
   * a paint each time. If we animate between the two in percentage we'll avoid a paint.
   */
  const correctBorderRadius = {
    correct: (latest, node) => {
      if (!node.target) return latest;
      /**
       * If latest is a string, if it's a percentage we can return immediately as it's
       * going to be stretched appropriately. Otherwise, if it's a pixel, convert it to a number.
       */
      if (typeof latest === 'string') {
        if (px.test(latest)) {
          latest = parseFloat(latest);
        } else {
          return latest;
        }
      }
      /**
       * If latest is a number, it's a pixel value. We use the current viewportBox to calculate that
       * pixel value as a percentage of each axis
       */
      const x = pixelsToPercent(latest, node.target.x);
      const y = pixelsToPercent(latest, node.target.y);
      return `${x}% ${y}%`;
    },
  }; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/projection/styles/scale-box-shadow.mjs

  const correctBoxShadow = {
    correct: (latest, { treeScale, projectionDelta }) => {
      const original = latest;
      const shadow = complex.parse(latest);
      // TODO: Doesn't support multiple shadows
      if (shadow.length > 5) return original;
      const template = complex.createTransformer(latest);
      const offset = typeof shadow[0] !== 'number' ? 1 : 0;
      // Calculate the overall context scale
      const xScale = projectionDelta.x.scale * treeScale.x;
      const yScale = projectionDelta.y.scale * treeScale.y;
      shadow[0 + offset] /= xScale;
      shadow[1 + offset] /= yScale;
      /**
       * Ideally we'd correct x and y scales individually, but because blur and
       * spread apply to both we have to take a scale average and apply that instead.
       * We could potentially improve the outcome of this by incorporating the ratio between
       * the two scales.
       */
      const averageScale = mixNumber(xScale, yScale, 0.5);
      // Blur
      if (typeof shadow[2 + offset] === 'number') shadow[2 + offset] /= averageScale;
      // Spread
      if (typeof shadow[3 + offset] === 'number') shadow[3 + offset] /= averageScale;
      return template(shadow);
    },
  }; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/projection/styles/scale-correction.mjs

  const scaleCorrectors = {};
  function addScaleCorrector(correctors) {
    for (const key in correctors) {
      scaleCorrectors[key] = correctors[key];
      if (isCSSVariableName(key)) {
        scaleCorrectors[key].isCSSVariable = true;
      }
    }
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/frameloop/microtask.mjs

  const { schedule: microtask, cancel: cancelMicrotask } = /* @__PURE__ */ createRenderBatcher(
    queueMicrotask,
    false
  ); // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/motion/features/layout/MeasureLayout.mjs

  ('use client');

  class MeasureLayoutWithContext extends react.Component {
    /**
     * This only mounts projection nodes for components that
     * need measuring, we might want to do it for all components
     * in order to incorporate transforms
     */
    componentDidMount() {
      const { visualElement, layoutGroup, switchLayoutGroup, layoutId } = this.props;
      const { projection } = visualElement;
      addScaleCorrector(defaultScaleCorrectors);
      if (projection) {
        if (layoutGroup.group) layoutGroup.group.add(projection);
        if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {
          switchLayoutGroup.register(projection);
        }
        projection.root.didUpdate();
        projection.addEventListener('animationComplete', () => {
          this.safeToRemove();
        });
        projection.setOptions({
          ...projection.options,
          onExitComplete: () => this.safeToRemove(),
        });
      }
      globalProjectionState.hasEverUpdated = true;
    }
    getSnapshotBeforeUpdate(prevProps) {
      const { layoutDependency, visualElement, drag, isPresent } = this.props;
      const { projection } = visualElement;
      if (!projection) return null;
      /**
       * TODO: We use this data in relegate to determine whether to
       * promote a previous element. There's no guarantee its presence data
       * will have updated by this point - if a bug like this arises it will
       * have to be that we markForRelegation and then find a new lead some other way,
       * perhaps in didUpdate
       */
      projection.isPresent = isPresent;
      if (
        drag ||
        prevProps.layoutDependency !== layoutDependency ||
        layoutDependency === undefined ||
        prevProps.isPresent !== isPresent
      ) {
        projection.willUpdate();
      } else {
        this.safeToRemove();
      }
      if (prevProps.isPresent !== isPresent) {
        if (isPresent) {
          projection.promote();
        } else if (!projection.relegate()) {
          /**
           * If there's another stack member taking over from this one,
           * it's in charge of the exit animation and therefore should
           * be in charge of the safe to remove. Otherwise we call it here.
           */
          frame_frame.postRender(() => {
            const stack = projection.getStack();
            if (!stack || !stack.members.length) {
              this.safeToRemove();
            }
          });
        }
      }
      return null;
    }
    componentDidUpdate() {
      const { projection } = this.props.visualElement;
      if (projection) {
        projection.root.didUpdate();
        microtask.postRender(() => {
          if (!projection.currentAnimation && projection.isLead()) {
            this.safeToRemove();
          }
        });
      }
    }
    componentWillUnmount() {
      const { visualElement, layoutGroup, switchLayoutGroup: promoteContext } = this.props;
      const { projection } = visualElement;
      if (projection) {
        projection.scheduleCheckAfterUnmount();
        if (layoutGroup && layoutGroup.group) layoutGroup.group.remove(projection);
        if (promoteContext && promoteContext.deregister) promoteContext.deregister(projection);
      }
    }
    safeToRemove() {
      const { safeToRemove } = this.props;
      safeToRemove && safeToRemove();
    }
    render() {
      return null;
    }
  }
  function MeasureLayout(props) {
    const [isPresent, safeToRemove] = usePresence();
    const layoutGroup = (0, react.useContext)(LayoutGroupContext);
    return (0, jsx_runtime.jsx)(MeasureLayoutWithContext, {
      ...props,
      layoutGroup: layoutGroup,
      switchLayoutGroup: (0, react.useContext)(SwitchLayoutGroupContext),
      isPresent: isPresent,
      safeToRemove: safeToRemove,
    });
  }
  const defaultScaleCorrectors = {
    borderRadius: {
      ...correctBorderRadius,
      applyTo: [
        'borderTopLeftRadius',
        'borderTopRightRadius',
        'borderBottomLeftRadius',
        'borderBottomRightRadius',
      ],
    },
    borderTopLeftRadius: correctBorderRadius,
    borderTopRightRadius: correctBorderRadius,
    borderBottomLeftRadius: correctBorderRadius,
    borderBottomRightRadius: correctBorderRadius,
    boxShadow: correctBoxShadow,
  }; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/animation/animate/single-value.mjs

  function animateSingleValue(value, keyframes, options) {
    const motionValue$1 = isMotionValue(value) ? value : motionValue(value);
    motionValue$1.start(animateMotionValue('', motionValue$1, keyframes, options));
    return motionValue$1.animation;
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/render/utils/compare-by-depth.mjs

  const compareByDepth = (a, b) => a.depth - b.depth; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/render/utils/flat-tree.mjs

  class FlatTree {
    constructor() {
      this.children = [];
      this.isDirty = false;
    }
    add(child) {
      addUniqueItem(this.children, child);
      this.isDirty = true;
    }
    remove(child) {
      removeItem(this.children, child);
      this.isDirty = true;
    }
    forEach(callback) {
      this.isDirty && this.children.sort(compareByDepth);
      this.isDirty = false;
      this.children.forEach(callback);
    }
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/utils/delay.mjs

  /**
   * Timeout defined in ms
   */
  function delay(callback, timeout) {
    const start = time.now();
    const checkElapsed = ({ timestamp }) => {
      const elapsed = timestamp - start;
      if (elapsed >= timeout) {
        cancelFrame(checkElapsed);
        callback(elapsed - timeout);
      }
    };
    frame_frame.setup(checkElapsed, true);
    return () => cancelFrame(checkElapsed);
  }
  function delayInSeconds(callback, timeout) {
    return delay(callback, secondsToMilliseconds(timeout));
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/value/utils/resolve-motion-value.mjs

  /**
   * If the provided value is a MotionValue, this returns the actual value, otherwise just the value itself
   *
   * TODO: Remove and move to library
   */
  function resolveMotionValue(value) {
    return isMotionValue(value) ? value.get() : value;
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/projection/animation/mix-values.mjs

  const borders = ['TopLeft', 'TopRight', 'BottomLeft', 'BottomRight'];
  const numBorders = borders.length;
  const asNumber = (value) => (typeof value === 'string' ? parseFloat(value) : value);
  const isPx = (value) => typeof value === 'number' || px.test(value);
  function mixValues(target, follow, lead, progress, shouldCrossfadeOpacity, isOnlyMember) {
    if (shouldCrossfadeOpacity) {
      target.opacity = mixNumber(0, lead.opacity ?? 1, easeCrossfadeIn(progress));
      target.opacityExit = mixNumber(follow.opacity ?? 1, 0, easeCrossfadeOut(progress));
    } else if (isOnlyMember) {
      target.opacity = mixNumber(follow.opacity ?? 1, lead.opacity ?? 1, progress);
    }
    /**
     * Mix border radius
     */
    for (let i = 0; i < numBorders; i++) {
      const borderLabel = `border${borders[i]}Radius`;
      let followRadius = getRadius(follow, borderLabel);
      let leadRadius = getRadius(lead, borderLabel);
      if (followRadius === undefined && leadRadius === undefined) continue;
      followRadius || (followRadius = 0);
      leadRadius || (leadRadius = 0);
      const canMix =
        followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius);
      if (canMix) {
        target[borderLabel] = Math.max(
          mixNumber(asNumber(followRadius), asNumber(leadRadius), progress),
          0
        );
        if (percent.test(leadRadius) || percent.test(followRadius)) {
          target[borderLabel] += '%';
        }
      } else {
        target[borderLabel] = leadRadius;
      }
    }
    /**
     * Mix rotation
     */
    if (follow.rotate || lead.rotate) {
      target.rotate = mixNumber(follow.rotate || 0, lead.rotate || 0, progress);
    }
  }
  function getRadius(values, radiusName) {
    return values[radiusName] !== undefined ? values[radiusName] : values.borderRadius;
  }
  // /**
  //  * We only want to mix the background color if there's a follow element
  //  * that we're not crossfading opacity between. For instance with switch
  //  * AnimateSharedLayout animations, this helps the illusion of a continuous
  //  * element being animated but also cuts down on the number of paints triggered
  //  * for elements where opacity is doing that work for us.
  //  */
  // if (
  //     !hasFollowElement &&
  //     latestLeadValues.backgroundColor &&
  //     latestFollowValues.backgroundColor
  // ) {
  //     /**
  //      * This isn't ideal performance-wise as mixColor is creating a new function every frame.
  //      * We could probably create a mixer that runs at the start of the animation but
  //      * the idea behind the crossfader is that it runs dynamically between two potentially
  //      * changing targets (ie opacity or borderRadius may be animating independently via variants)
  //      */
  //     leadState.backgroundColor = followState.backgroundColor = mixColor(
  //         latestFollowValues.backgroundColor as string,
  //         latestLeadValues.backgroundColor as string
  //     )(p)
  // }
  const easeCrossfadeIn = /*@__PURE__*/ compress(0, 0.5, circOut);
  const easeCrossfadeOut = /*@__PURE__*/ compress(0.5, 0.95, noop);
  function compress(min, max, easing) {
    return (p) => {
      // Could replace ifs with clamp
      if (p < min) return 0;
      if (p > max) return 1;
      return easing(progress(min, max, p));
    };
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/projection/geometry/copy.mjs

  /**
   * Reset an axis to the provided origin box.
   *
   * This is a mutative operation.
   */
  function copyAxisInto(axis, originAxis) {
    axis.min = originAxis.min;
    axis.max = originAxis.max;
  }
  /**
   * Reset a box to the provided origin box.
   *
   * This is a mutative operation.
   */
  function copyBoxInto(box, originBox) {
    copyAxisInto(box.x, originBox.x);
    copyAxisInto(box.y, originBox.y);
  }
  /**
   * Reset a delta to the provided origin box.
   *
   * This is a mutative operation.
   */
  function copyAxisDeltaInto(delta, originDelta) {
    delta.translate = originDelta.translate;
    delta.scale = originDelta.scale;
    delta.originPoint = originDelta.originPoint;
    delta.origin = originDelta.origin;
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/projection/geometry/delta-remove.mjs

  /**
   * Remove a delta from a point. This is essentially the steps of applyPointDelta in reverse
   */
  function removePointDelta(point, translate, scale, originPoint, boxScale) {
    point -= translate;
    point = scalePoint(point, 1 / scale, originPoint);
    if (boxScale !== undefined) {
      point = scalePoint(point, 1 / boxScale, originPoint);
    }
    return point;
  }
  /**
   * Remove a delta from an axis. This is essentially the steps of applyAxisDelta in reverse
   */
  function removeAxisDelta(
    axis,
    translate = 0,
    scale = 1,
    origin = 0.5,
    boxScale,
    originAxis = axis,
    sourceAxis = axis
  ) {
    if (percent.test(translate)) {
      translate = parseFloat(translate);
      const relativeProgress = mixNumber(sourceAxis.min, sourceAxis.max, translate / 100);
      translate = relativeProgress - sourceAxis.min;
    }
    if (typeof translate !== 'number') return;
    let originPoint = mixNumber(originAxis.min, originAxis.max, origin);
    if (axis === originAxis) originPoint -= translate;
    axis.min = removePointDelta(axis.min, translate, scale, originPoint, boxScale);
    axis.max = removePointDelta(axis.max, translate, scale, originPoint, boxScale);
  }
  /**
   * Remove a transforms from an axis. This is essentially the steps of applyAxisTransforms in reverse
   * and acts as a bridge between motion values and removeAxisDelta
   */
  function removeAxisTransforms(axis, transforms, [key, scaleKey, originKey], origin, sourceAxis) {
    removeAxisDelta(
      axis,
      transforms[key],
      transforms[scaleKey],
      transforms[originKey],
      transforms.scale,
      origin,
      sourceAxis
    );
  }
  /**
   * The names of the motion values we want to apply as translation, scale and origin.
   */
  const xKeys = ['x', 'scaleX', 'originX'];
  const yKeys = ['y', 'scaleY', 'originY'];
  /**
   * Remove a transforms from an box. This is essentially the steps of applyAxisBox in reverse
   * and acts as a bridge between motion values and removeAxisDelta
   */
  function removeBoxTransforms(box, transforms, originBox, sourceBox) {
    removeAxisTransforms(
      box.x,
      transforms,
      xKeys,
      originBox ? originBox.x : undefined,
      sourceBox ? sourceBox.x : undefined
    );
    removeAxisTransforms(
      box.y,
      transforms,
      yKeys,
      originBox ? originBox.y : undefined,
      sourceBox ? sourceBox.y : undefined
    );
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/projection/geometry/utils.mjs

  function isAxisDeltaZero(delta) {
    return delta.translate === 0 && delta.scale === 1;
  }
  function isDeltaZero(delta) {
    return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);
  }
  function axisEquals(a, b) {
    return a.min === b.min && a.max === b.max;
  }
  function boxEquals(a, b) {
    return axisEquals(a.x, b.x) && axisEquals(a.y, b.y);
  }
  function axisEqualsRounded(a, b) {
    return Math.round(a.min) === Math.round(b.min) && Math.round(a.max) === Math.round(b.max);
  }
  function boxEqualsRounded(a, b) {
    return axisEqualsRounded(a.x, b.x) && axisEqualsRounded(a.y, b.y);
  }
  function aspectRatio(box) {
    return calcLength(box.x) / calcLength(box.y);
  }
  function axisDeltaEquals(a, b) {
    return a.translate === b.translate && a.scale === b.scale && a.originPoint === b.originPoint;
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/projection/shared/stack.mjs

  class NodeStack {
    constructor() {
      this.members = [];
    }
    add(node) {
      addUniqueItem(this.members, node);
      node.scheduleRender();
    }
    remove(node) {
      removeItem(this.members, node);
      if (node === this.prevLead) {
        this.prevLead = undefined;
      }
      if (node === this.lead) {
        const prevLead = this.members[this.members.length - 1];
        if (prevLead) {
          this.promote(prevLead);
        }
      }
    }
    relegate(node) {
      const indexOfNode = this.members.findIndex((member) => node === member);
      if (indexOfNode === 0) return false;
      /**
       * Find the next projection node that is present
       */
      let prevLead;
      for (let i = indexOfNode; i >= 0; i--) {
        const member = this.members[i];
        if (member.isPresent !== false) {
          prevLead = member;
          break;
        }
      }
      if (prevLead) {
        this.promote(prevLead);
        return true;
      } else {
        return false;
      }
    }
    promote(node, preserveFollowOpacity) {
      const prevLead = this.lead;
      if (node === prevLead) return;
      this.prevLead = prevLead;
      this.lead = node;
      node.show();
      if (prevLead) {
        prevLead.instance && prevLead.scheduleRender();
        node.scheduleRender();
        node.resumeFrom = prevLead;
        if (preserveFollowOpacity) {
          node.resumeFrom.preserveOpacity = true;
        }
        if (prevLead.snapshot) {
          node.snapshot = prevLead.snapshot;
          node.snapshot.latestValues = prevLead.animationValues || prevLead.latestValues;
        }
        if (node.root && node.root.isUpdating) {
          node.isLayoutDirty = true;
        }
        const { crossfade } = node.options;
        if (crossfade === false) {
          prevLead.hide();
        }
        /**
         * TODO:
         *   - Test border radius when previous node was deleted
         *   - boxShadow mixing
         *   - Shared between element A in scrolled container and element B (scroll stays the same or changes)
         *   - Shared between element A in transformed container and element B (transform stays the same or changes)
         *   - Shared between element A in scrolled page and element B (scroll stays the same or changes)
         * ---
         *   - Crossfade opacity of root nodes
         *   - layoutId changes after animation
         *   - layoutId changes mid animation
         */
      }
    }
    exitAnimationComplete() {
      this.members.forEach((node) => {
        const { options, resumingFrom } = node;
        options.onExitComplete && options.onExitComplete();
        if (resumingFrom) {
          resumingFrom.options.onExitComplete && resumingFrom.options.onExitComplete();
        }
      });
    }
    scheduleRender() {
      this.members.forEach((node) => {
        node.instance && node.scheduleRender(false);
      });
    }
    /**
     * Clear any leads that have been removed this render to prevent them from being
     * used in future animations and to prevent memory leaks
     */
    removeLeadSnapshot() {
      if (this.lead && this.lead.snapshot) {
        this.lead.snapshot = undefined;
      }
    }
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/projection/styles/transform.mjs

  function buildProjectionTransform(delta, treeScale, latestTransform) {
    let transform = '';
    /**
     * The translations we use to calculate are always relative to the viewport coordinate space.
     * But when we apply scales, we also scale the coordinate space of an element and its children.
     * For instance if we have a treeScale (the culmination of all parent scales) of 0.5 and we need
     * to move an element 100 pixels, we actually need to move it 200 in within that scaled space.
     */
    const xTranslate = delta.x.translate / treeScale.x;
    const yTranslate = delta.y.translate / treeScale.y;
    const zTranslate = latestTransform?.z || 0;
    if (xTranslate || yTranslate || zTranslate) {
      transform = `translate3d(${xTranslate}px, ${yTranslate}px, ${zTranslate}px) `;
    }
    /**
     * Apply scale correction for the tree transform.
     * This will apply scale to the screen-orientated axes.
     */
    if (treeScale.x !== 1 || treeScale.y !== 1) {
      transform += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;
    }
    if (latestTransform) {
      const { transformPerspective, rotate, rotateX, rotateY, skewX, skewY } = latestTransform;
      if (transformPerspective) transform = `perspective(${transformPerspective}px) ${transform}`;
      if (rotate) transform += `rotate(${rotate}deg) `;
      if (rotateX) transform += `rotateX(${rotateX}deg) `;
      if (rotateY) transform += `rotateY(${rotateY}deg) `;
      if (skewX) transform += `skewX(${skewX}deg) `;
      if (skewY) transform += `skewY(${skewY}deg) `;
    }
    /**
     * Apply scale to match the size of the element to the size we want it.
     * This will apply scale to the element-orientated axes.
     */
    const elementScaleX = delta.x.scale * treeScale.x;
    const elementScaleY = delta.y.scale * treeScale.y;
    if (elementScaleX !== 1 || elementScaleY !== 1) {
      transform += `scale(${elementScaleX}, ${elementScaleY})`;
    }
    return transform || 'none';
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/utils/is-svg-element.mjs

  /**
   * Checks if an element is an SVG element in a way
   * that works across iframes
   */
  function isSVGElement(element) {
    return is_object_isObject(element) && 'ownerSVGElement' in element;
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/utils/is-svg-svg-element.mjs

  /**
   * Checks if an element is specifically an SVGSVGElement (the root SVG element)
   * in a way that works across iframes
   */
  function isSVGSVGElement(element) {
    return isSVGElement(element) && element.tagName === 'svg';
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/projection/node/create-projection-node.mjs

  const metrics = {
    nodes: 0,
    calculatedTargetDeltas: 0,
    calculatedProjections: 0,
  };
  const transformAxes = ['', 'X', 'Y', 'Z'];
  const hiddenVisibility = { visibility: 'hidden' };
  /**
   * We use 1000 as the animation target as 0-1000 maps better to pixels than 0-1
   * which has a noticeable difference in spring animations
   */
  const animationTarget = 1000;
  let create_projection_node_id = 0;
  function resetDistortingTransform(key, visualElement, values, sharedAnimationValues) {
    const { latestValues } = visualElement;
    // Record the distorting transform and then temporarily set it to 0
    if (latestValues[key]) {
      values[key] = latestValues[key];
      visualElement.setStaticValue(key, 0);
      if (sharedAnimationValues) {
        sharedAnimationValues[key] = 0;
      }
    }
  }
  function cancelTreeOptimisedTransformAnimations(projectionNode) {
    projectionNode.hasCheckedOptimisedAppear = true;
    if (projectionNode.root === projectionNode) return;
    const { visualElement } = projectionNode.options;
    if (!visualElement) return;
    const appearId = getOptimisedAppearId(visualElement);
    if (window.MotionHasOptimisedAnimation(appearId, 'transform')) {
      const { layout, layoutId } = projectionNode.options;
      window.MotionCancelOptimisedAnimation(
        appearId,
        'transform',
        frame_frame,
        !(layout || layoutId)
      );
    }
    const { parent } = projectionNode;
    if (parent && !parent.hasCheckedOptimisedAppear) {
      cancelTreeOptimisedTransformAnimations(parent);
    }
  }
  function createProjectionNode({
    attachResizeListener,
    defaultParent,
    measureScroll,
    checkIsScrollRoot,
    resetTransform,
  }) {
    return class ProjectionNode {
      constructor(latestValues = {}, parent = defaultParent?.()) {
        /**
         * A unique ID generated for every projection node.
         */
        this.id = create_projection_node_id++;
        /**
         * An id that represents a unique session instigated by startUpdate.
         */
        this.animationId = 0;
        /**
         * A Set containing all this component's children. This is used to iterate
         * through the children.
         *
         * TODO: This could be faster to iterate as a flat array stored on the root node.
         */
        this.children = new Set();
        /**
         * Options for the node. We use this to configure what kind of layout animations
         * we should perform (if any).
         */
        this.options = {};
        /**
         * We use this to detect when its safe to shut down part of a projection tree.
         * We have to keep projecting children for scale correction and relative projection
         * until all their parents stop performing layout animations.
         */
        this.isTreeAnimating = false;
        this.isAnimationBlocked = false;
        /**
         * Flag to true if we think this layout has been changed. We can't always know this,
         * currently we set it to true every time a component renders, or if it has a layoutDependency
         * if that has changed between renders. Additionally, components can be grouped by LayoutGroup
         * and if one node is dirtied, they all are.
         */
        this.isLayoutDirty = false;
        /**
         * Flag to true if we think the projection calculations for this node needs
         * recalculating as a result of an updated transform or layout animation.
         */
        this.isProjectionDirty = false;
        /**
         * Flag to true if the layout *or* transform has changed. This then gets propagated
         * throughout the projection tree, forcing any element below to recalculate on the next frame.
         */
        this.isSharedProjectionDirty = false;
        /**
         * Flag transform dirty. This gets propagated throughout the whole tree but is only
         * respected by shared nodes.
         */
        this.isTransformDirty = false;
        /**
         * Block layout updates for instant layout transitions throughout the tree.
         */
        this.updateManuallyBlocked = false;
        this.updateBlockedByResize = false;
        /**
         * Set to true between the start of the first `willUpdate` call and the end of the `didUpdate`
         * call.
         */
        this.isUpdating = false;
        /**
         * If this is an SVG element we currently disable projection transforms
         */
        this.isSVG = false;
        /**
         * Flag to true (during promotion) if a node doing an instant layout transition needs to reset
         * its projection styles.
         */
        this.needsReset = false;
        /**
         * Flags whether this node should have its transform reset prior to measuring.
         */
        this.shouldResetTransform = false;
        /**
         * Store whether this node has been checked for optimised appear animations. As
         * effects fire bottom-up, and we want to look up the tree for appear animations,
         * this makes sure we only check each path once, stopping at nodes that
         * have already been checked.
         */
        this.hasCheckedOptimisedAppear = false;
        /**
         * An object representing the calculated contextual/accumulated/tree scale.
         * This will be used to scale calculcated projection transforms, as these are
         * calculated in screen-space but need to be scaled for elements to layoutly
         * make it to their calculated destinations.
         *
         * TODO: Lazy-init
         */
        this.treeScale = { x: 1, y: 1 };
        /**
         *
         */
        this.eventHandlers = new Map();
        this.hasTreeAnimated = false;
        // Note: Currently only running on root node
        this.updateScheduled = false;
        this.scheduleUpdate = () => this.update();
        this.projectionUpdateScheduled = false;
        this.checkUpdateFailed = () => {
          if (this.isUpdating) {
            this.isUpdating = false;
            this.clearAllSnapshots();
          }
        };
        /**
         * This is a multi-step process as shared nodes might be of different depths. Nodes
         * are sorted by depth order, so we need to resolve the entire tree before moving to
         * the next step.
         */
        this.updateProjection = () => {
          this.projectionUpdateScheduled = false;
          /**
           * Reset debug counts. Manually resetting rather than creating a new
           * object each frame.
           */
          if (statsBuffer.value) {
            metrics.nodes = metrics.calculatedTargetDeltas = metrics.calculatedProjections = 0;
          }
          this.nodes.forEach(propagateDirtyNodes);
          this.nodes.forEach(resolveTargetDelta);
          this.nodes.forEach(calcProjection);
          this.nodes.forEach(cleanDirtyNodes);
          if (statsBuffer.addProjectionMetrics) {
            statsBuffer.addProjectionMetrics(metrics);
          }
        };
        /**
         * Frame calculations
         */
        this.resolvedRelativeTargetAt = 0.0;
        this.hasProjected = false;
        this.isVisible = true;
        this.animationProgress = 0;
        /**
         * Shared layout
         */
        // TODO Only running on root node
        this.sharedNodes = new Map();
        this.latestValues = latestValues;
        this.root = parent ? parent.root || parent : this;
        this.path = parent ? [...parent.path, parent] : [];
        this.parent = parent;
        this.depth = parent ? parent.depth + 1 : 0;
        for (let i = 0; i < this.path.length; i++) {
          this.path[i].shouldResetTransform = true;
        }
        if (this.root === this) this.nodes = new FlatTree();
      }
      addEventListener(name, handler) {
        if (!this.eventHandlers.has(name)) {
          this.eventHandlers.set(name, new SubscriptionManager());
        }
        return this.eventHandlers.get(name).add(handler);
      }
      notifyListeners(name, ...args) {
        const subscriptionManager = this.eventHandlers.get(name);
        subscriptionManager && subscriptionManager.notify(...args);
      }
      hasListeners(name) {
        return this.eventHandlers.has(name);
      }
      /**
       * Lifecycles
       */
      mount(instance) {
        if (this.instance) return;
        this.isSVG = isSVGElement(instance) && !isSVGSVGElement(instance);
        this.instance = instance;
        const { layoutId, layout, visualElement } = this.options;
        if (visualElement && !visualElement.current) {
          visualElement.mount(instance);
        }
        this.root.nodes.add(this);
        this.parent && this.parent.children.add(this);
        if (this.root.hasTreeAnimated && (layout || layoutId)) {
          this.isLayoutDirty = true;
        }
        if (attachResizeListener) {
          let cancelDelay;
          const resizeUnblockUpdate = () => (this.root.updateBlockedByResize = false);
          attachResizeListener(instance, () => {
            this.root.updateBlockedByResize = true;
            cancelDelay && cancelDelay();
            cancelDelay = delay(resizeUnblockUpdate, 250);
            if (globalProjectionState.hasAnimatedSinceResize) {
              globalProjectionState.hasAnimatedSinceResize = false;
              this.nodes.forEach(finishAnimation);
            }
          });
        }
        if (layoutId) {
          this.root.registerSharedNode(layoutId, this);
        }
        // Only register the handler if it requires layout animation
        if (this.options.animate !== false && visualElement && (layoutId || layout)) {
          this.addEventListener(
            'didUpdate',
            ({ delta, hasLayoutChanged, hasRelativeLayoutChanged, layout: newLayout }) => {
              if (this.isTreeAnimationBlocked()) {
                this.target = undefined;
                this.relativeTarget = undefined;
                return;
              }
              // TODO: Check here if an animation exists
              const layoutTransition =
                this.options.transition ||
                visualElement.getDefaultTransition() ||
                defaultLayoutTransition;
              const { onLayoutAnimationStart, onLayoutAnimationComplete } =
                visualElement.getProps();
              /**
               * The target layout of the element might stay the same,
               * but its position relative to its parent has changed.
               */
              const hasTargetChanged =
                !this.targetLayout || !boxEqualsRounded(this.targetLayout, newLayout);
              /*
               * Note: Disabled to fix relative animations always triggering new
               * layout animations. If this causes further issues, we can try
               * a different approach to detecting relative target changes.
               */
              // || hasRelativeLayoutChanged
              /**
               * If the layout hasn't seemed to have changed, it might be that the
               * element is visually in the same place in the document but its position
               * relative to its parent has indeed changed. So here we check for that.
               */
              const hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeLayoutChanged;
              if (
                this.options.layoutRoot ||
                this.resumeFrom ||
                hasOnlyRelativeTargetChanged ||
                (hasLayoutChanged && (hasTargetChanged || !this.currentAnimation))
              ) {
                if (this.resumeFrom) {
                  this.resumingFrom = this.resumeFrom;
                  this.resumingFrom.resumingFrom = undefined;
                }
                const animationOptions = {
                  ...getValueTransition(layoutTransition, 'layout'),
                  onPlay: onLayoutAnimationStart,
                  onComplete: onLayoutAnimationComplete,
                };
                if (visualElement.shouldReduceMotion || this.options.layoutRoot) {
                  animationOptions.delay = 0;
                  animationOptions.type = false;
                }
                this.startAnimation(animationOptions);
                /**
                 * Set animation origin after starting animation to avoid layout jump
                 * caused by stopping previous layout animation
                 */
                this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);
              } else {
                /**
                 * If the layout hasn't changed and we have an animation that hasn't started yet,
                 * finish it immediately. Otherwise it will be animating from a location
                 * that was probably never commited to screen and look like a jumpy box.
                 */
                if (!hasLayoutChanged) {
                  finishAnimation(this);
                }
                if (this.isLead() && this.options.onExitComplete) {
                  this.options.onExitComplete();
                }
              }
              this.targetLayout = newLayout;
            }
          );
        }
      }
      unmount() {
        this.options.layoutId && this.willUpdate();
        this.root.nodes.remove(this);
        const stack = this.getStack();
        stack && stack.remove(this);
        this.parent && this.parent.children.delete(this);
        this.instance = undefined;
        this.eventHandlers.clear();
        cancelFrame(this.updateProjection);
      }
      // only on the root
      blockUpdate() {
        this.updateManuallyBlocked = true;
      }
      unblockUpdate() {
        this.updateManuallyBlocked = false;
      }
      isUpdateBlocked() {
        return this.updateManuallyBlocked || this.updateBlockedByResize;
      }
      isTreeAnimationBlocked() {
        return (
          this.isAnimationBlocked || (this.parent && this.parent.isTreeAnimationBlocked()) || false
        );
      }
      // Note: currently only running on root node
      startUpdate() {
        if (this.isUpdateBlocked()) return;
        this.isUpdating = true;
        this.nodes && this.nodes.forEach(resetSkewAndRotation);
        this.animationId++;
      }
      getTransformTemplate() {
        const { visualElement } = this.options;
        return visualElement && visualElement.getProps().transformTemplate;
      }
      willUpdate(shouldNotifyListeners = true) {
        this.root.hasTreeAnimated = true;
        if (this.root.isUpdateBlocked()) {
          this.options.onExitComplete && this.options.onExitComplete();
          return;
        }
        /**
         * If we're running optimised appear animations then these must be
         * cancelled before measuring the DOM. This is so we can measure
         * the true layout of the element rather than the WAAPI animation
         * which will be unaffected by the resetSkewAndRotate step.
         *
         * Note: This is a DOM write. Worst case scenario is this is sandwiched
         * between other snapshot reads which will cause unnecessary style recalculations.
         * This has to happen here though, as we don't yet know which nodes will need
         * snapshots in startUpdate(), but we only want to cancel optimised animations
         * if a layout animation measurement is actually going to be affected by them.
         */
        if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear) {
          cancelTreeOptimisedTransformAnimations(this);
        }
        !this.root.isUpdating && this.root.startUpdate();
        if (this.isLayoutDirty) return;
        this.isLayoutDirty = true;
        for (let i = 0; i < this.path.length; i++) {
          const node = this.path[i];
          node.shouldResetTransform = true;
          node.updateScroll('snapshot');
          if (node.options.layoutRoot) {
            node.willUpdate(false);
          }
        }
        const { layoutId, layout } = this.options;
        if (layoutId === undefined && !layout) return;
        const transformTemplate = this.getTransformTemplate();
        this.prevTransformTemplateValue = transformTemplate
          ? transformTemplate(this.latestValues, '')
          : undefined;
        this.updateSnapshot();
        shouldNotifyListeners && this.notifyListeners('willUpdate');
      }
      update() {
        this.updateScheduled = false;
        const updateWasBlocked = this.isUpdateBlocked();
        // When doing an instant transition, we skip the layout update,
        // but should still clean up the measurements so that the next
        // snapshot could be taken correctly.
        if (updateWasBlocked) {
          this.unblockUpdate();
          this.clearAllSnapshots();
          this.nodes.forEach(clearMeasurements);
          return;
        }
        if (!this.isUpdating) {
          this.nodes.forEach(clearIsLayoutDirty);
        }
        this.isUpdating = false;
        /**
         * Write
         */
        this.nodes.forEach(resetTransformStyle);
        /**
         * Read ==================
         */
        // Update layout measurements of updated children
        this.nodes.forEach(updateLayout);
        /**
         * Write
         */
        // Notify listeners that the layout is updated
        this.nodes.forEach(notifyLayoutUpdate);
        this.clearAllSnapshots();
        /**
         * Manually flush any pending updates. Ideally
         * we could leave this to the following requestAnimationFrame but this seems
         * to leave a flash of incorrectly styled content.
         */
        const now = time.now();
        frameData.delta = clamp(0, 1000 / 60, now - frameData.timestamp);
        frameData.timestamp = now;
        frameData.isProcessing = true;
        frameSteps.update.process(frameData);
        frameSteps.preRender.process(frameData);
        frameSteps.render.process(frameData);
        frameData.isProcessing = false;
      }
      didUpdate() {
        if (!this.updateScheduled) {
          this.updateScheduled = true;
          microtask.read(this.scheduleUpdate);
        }
      }
      clearAllSnapshots() {
        this.nodes.forEach(clearSnapshot);
        this.sharedNodes.forEach(removeLeadSnapshots);
      }
      scheduleUpdateProjection() {
        if (!this.projectionUpdateScheduled) {
          this.projectionUpdateScheduled = true;
          frame_frame.preRender(this.updateProjection, false, true);
        }
      }
      scheduleCheckAfterUnmount() {
        /**
         * If the unmounting node is in a layoutGroup and did trigger a willUpdate,
         * we manually call didUpdate to give a chance to the siblings to animate.
         * Otherwise, cleanup all snapshots to prevents future nodes from reusing them.
         */
        frame_frame.postRender(() => {
          if (this.isLayoutDirty) {
            this.root.didUpdate();
          } else {
            this.root.checkUpdateFailed();
          }
        });
      }
      /**
       * Update measurements
       */
      updateSnapshot() {
        if (this.snapshot || !this.instance) return;
        this.snapshot = this.measure();
        if (
          this.snapshot &&
          !calcLength(this.snapshot.measuredBox.x) &&
          !calcLength(this.snapshot.measuredBox.y)
        ) {
          this.snapshot = undefined;
        }
      }
      updateLayout() {
        if (!this.instance) return;
        // TODO: Incorporate into a forwarded scroll offset
        this.updateScroll();
        if (!(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty) {
          return;
        }
        /**
         * When a node is mounted, it simply resumes from the prevLead's
         * snapshot instead of taking a new one, but the ancestors scroll
         * might have updated while the prevLead is unmounted. We need to
         * update the scroll again to make sure the layout we measure is
         * up to date.
         */
        if (this.resumeFrom && !this.resumeFrom.instance) {
          for (let i = 0; i < this.path.length; i++) {
            const node = this.path[i];
            node.updateScroll();
          }
        }
        const prevLayout = this.layout;
        this.layout = this.measure(false);
        this.layoutCorrected = createBox();
        this.isLayoutDirty = false;
        this.projectionDelta = undefined;
        this.notifyListeners('measure', this.layout.layoutBox);
        const { visualElement } = this.options;
        visualElement &&
          visualElement.notify(
            'LayoutMeasure',
            this.layout.layoutBox,
            prevLayout ? prevLayout.layoutBox : undefined
          );
      }
      updateScroll(phase = 'measure') {
        let needsMeasurement = Boolean(this.options.layoutScroll && this.instance);
        if (
          this.scroll &&
          this.scroll.animationId === this.root.animationId &&
          this.scroll.phase === phase
        ) {
          needsMeasurement = false;
        }
        if (needsMeasurement && this.instance) {
          const isRoot = checkIsScrollRoot(this.instance);
          this.scroll = {
            animationId: this.root.animationId,
            phase,
            isRoot,
            offset: measureScroll(this.instance),
            wasRoot: this.scroll ? this.scroll.isRoot : isRoot,
          };
        }
      }
      resetTransform() {
        if (!resetTransform) return;
        const isResetRequested =
          this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout;
        const hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);
        const transformTemplate = this.getTransformTemplate();
        const transformTemplateValue = transformTemplate
          ? transformTemplate(this.latestValues, '')
          : undefined;
        const transformTemplateHasChanged =
          transformTemplateValue !== this.prevTransformTemplateValue;
        if (
          isResetRequested &&
          this.instance &&
          (hasProjection || hasTransform(this.latestValues) || transformTemplateHasChanged)
        ) {
          resetTransform(this.instance, transformTemplateValue);
          this.shouldResetTransform = false;
          this.scheduleRender();
        }
      }
      measure(removeTransform = true) {
        const pageBox = this.measurePageBox();
        let layoutBox = this.removeElementScroll(pageBox);
        /**
         * Measurements taken during the pre-render stage
         * still have transforms applied so we remove them
         * via calculation.
         */
        if (removeTransform) {
          layoutBox = this.removeTransform(layoutBox);
        }
        roundBox(layoutBox);
        return {
          animationId: this.root.animationId,
          measuredBox: pageBox,
          layoutBox,
          latestValues: {},
          source: this.id,
        };
      }
      measurePageBox() {
        const { visualElement } = this.options;
        if (!visualElement) return createBox();
        const box = visualElement.measureViewportBox();
        const wasInScrollRoot = this.scroll?.wasRoot || this.path.some(checkNodeWasScrollRoot);
        if (!wasInScrollRoot) {
          // Remove viewport scroll to give page-relative coordinates
          const { scroll } = this.root;
          if (scroll) {
            translateAxis(box.x, scroll.offset.x);
            translateAxis(box.y, scroll.offset.y);
          }
        }
        return box;
      }
      removeElementScroll(box) {
        const boxWithoutScroll = createBox();
        copyBoxInto(boxWithoutScroll, box);
        if (this.scroll?.wasRoot) {
          return boxWithoutScroll;
        }
        /**
         * Performance TODO: Keep a cumulative scroll offset down the tree
         * rather than loop back up the path.
         */
        for (let i = 0; i < this.path.length; i++) {
          const node = this.path[i];
          const { scroll, options } = node;
          if (node !== this.root && scroll && options.layoutScroll) {
            /**
             * If this is a new scroll root, we want to remove all previous scrolls
             * from the viewport box.
             */
            if (scroll.wasRoot) {
              copyBoxInto(boxWithoutScroll, box);
            }
            translateAxis(boxWithoutScroll.x, scroll.offset.x);
            translateAxis(boxWithoutScroll.y, scroll.offset.y);
          }
        }
        return boxWithoutScroll;
      }
      applyTransform(box, transformOnly = false) {
        const withTransforms = createBox();
        copyBoxInto(withTransforms, box);
        for (let i = 0; i < this.path.length; i++) {
          const node = this.path[i];
          if (!transformOnly && node.options.layoutScroll && node.scroll && node !== node.root) {
            transformBox(withTransforms, {
              x: -node.scroll.offset.x,
              y: -node.scroll.offset.y,
            });
          }
          if (!hasTransform(node.latestValues)) continue;
          transformBox(withTransforms, node.latestValues);
        }
        if (hasTransform(this.latestValues)) {
          transformBox(withTransforms, this.latestValues);
        }
        return withTransforms;
      }
      removeTransform(box) {
        const boxWithoutTransform = createBox();
        copyBoxInto(boxWithoutTransform, box);
        for (let i = 0; i < this.path.length; i++) {
          const node = this.path[i];
          if (!node.instance) continue;
          if (!hasTransform(node.latestValues)) continue;
          hasScale(node.latestValues) && node.updateSnapshot();
          const sourceBox = createBox();
          const nodeBox = node.measurePageBox();
          copyBoxInto(sourceBox, nodeBox);
          removeBoxTransforms(
            boxWithoutTransform,
            node.latestValues,
            node.snapshot ? node.snapshot.layoutBox : undefined,
            sourceBox
          );
        }
        if (hasTransform(this.latestValues)) {
          removeBoxTransforms(boxWithoutTransform, this.latestValues);
        }
        return boxWithoutTransform;
      }
      setTargetDelta(delta) {
        this.targetDelta = delta;
        this.root.scheduleUpdateProjection();
        this.isProjectionDirty = true;
      }
      setOptions(options) {
        this.options = {
          ...this.options,
          ...options,
          crossfade: options.crossfade !== undefined ? options.crossfade : true,
        };
      }
      clearMeasurements() {
        this.scroll = undefined;
        this.layout = undefined;
        this.snapshot = undefined;
        this.prevTransformTemplateValue = undefined;
        this.targetDelta = undefined;
        this.target = undefined;
        this.isLayoutDirty = false;
      }
      forceRelativeParentToResolveTarget() {
        if (!this.relativeParent) return;
        /**
         * If the parent target isn't up-to-date, force it to update.
         * This is an unfortunate de-optimisation as it means any updating relative
         * projection will cause all the relative parents to recalculate back
         * up the tree.
         */
        if (this.relativeParent.resolvedRelativeTargetAt !== frameData.timestamp) {
          this.relativeParent.resolveTargetDelta(true);
        }
      }
      resolveTargetDelta(forceRecalculation = false) {
        /**
         * Once the dirty status of nodes has been spread through the tree, we also
         * need to check if we have a shared node of a different depth that has itself
         * been dirtied.
         */
        const lead = this.getLead();
        this.isProjectionDirty || (this.isProjectionDirty = lead.isProjectionDirty);
        this.isTransformDirty || (this.isTransformDirty = lead.isTransformDirty);
        this.isSharedProjectionDirty ||
          (this.isSharedProjectionDirty = lead.isSharedProjectionDirty);
        const isShared = Boolean(this.resumingFrom) || this !== lead;
        /**
         * We don't use transform for this step of processing so we don't
         * need to check whether any nodes have changed transform.
         */
        const canSkip = !(
          forceRecalculation ||
          (isShared && this.isSharedProjectionDirty) ||
          this.isProjectionDirty ||
          this.parent?.isProjectionDirty ||
          this.attemptToResolveRelativeTarget ||
          this.root.updateBlockedByResize
        );
        if (canSkip) return;
        const { layout, layoutId } = this.options;
        /**
         * If we have no layout, we can't perform projection, so early return
         */
        if (!this.layout || !(layout || layoutId)) return;
        this.resolvedRelativeTargetAt = frameData.timestamp;
        /**
         * If we don't have a targetDelta but do have a layout, we can attempt to resolve
         * a relativeParent. This will allow a component to perform scale correction
         * even if no animation has started.
         */
        if (!this.targetDelta && !this.relativeTarget) {
          const relativeParent = this.getClosestProjectingParent();
          if (relativeParent && relativeParent.layout && this.animationProgress !== 1) {
            this.relativeParent = relativeParent;
            this.forceRelativeParentToResolveTarget();
            this.relativeTarget = createBox();
            this.relativeTargetOrigin = createBox();
            calcRelativePosition(
              this.relativeTargetOrigin,
              this.layout.layoutBox,
              relativeParent.layout.layoutBox
            );
            copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
          } else {
            this.relativeParent = this.relativeTarget = undefined;
          }
        }
        /**
         * If we have no relative target or no target delta our target isn't valid
         * for this frame.
         */
        if (!this.relativeTarget && !this.targetDelta) return;
        /**
         * Lazy-init target data structure
         */
        if (!this.target) {
          this.target = createBox();
          this.targetWithTransforms = createBox();
        }
        /**
         * If we've got a relative box for this component, resolve it into a target relative to the parent.
         */
        if (
          this.relativeTarget &&
          this.relativeTargetOrigin &&
          this.relativeParent &&
          this.relativeParent.target
        ) {
          this.forceRelativeParentToResolveTarget();
          calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);
          /**
           * If we've only got a targetDelta, resolve it into a target
           */
        } else if (this.targetDelta) {
          if (Boolean(this.resumingFrom)) {
            // TODO: This is creating a new object every frame
            this.target = this.applyTransform(this.layout.layoutBox);
          } else {
            copyBoxInto(this.target, this.layout.layoutBox);
          }
          applyBoxDelta(this.target, this.targetDelta);
        } else {
          /**
           * If no target, use own layout as target
           */
          copyBoxInto(this.target, this.layout.layoutBox);
        }
        /**
         * If we've been told to attempt to resolve a relative target, do so.
         */
        if (this.attemptToResolveRelativeTarget) {
          this.attemptToResolveRelativeTarget = false;
          const relativeParent = this.getClosestProjectingParent();
          if (
            relativeParent &&
            Boolean(relativeParent.resumingFrom) === Boolean(this.resumingFrom) &&
            !relativeParent.options.layoutScroll &&
            relativeParent.target &&
            this.animationProgress !== 1
          ) {
            this.relativeParent = relativeParent;
            this.forceRelativeParentToResolveTarget();
            this.relativeTarget = createBox();
            this.relativeTargetOrigin = createBox();
            calcRelativePosition(this.relativeTargetOrigin, this.target, relativeParent.target);
            copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
          } else {
            this.relativeParent = this.relativeTarget = undefined;
          }
        }
        /**
         * Increase debug counter for resolved target deltas
         */
        if (statsBuffer.value) {
          metrics.calculatedTargetDeltas++;
        }
      }
      getClosestProjectingParent() {
        if (
          !this.parent ||
          hasScale(this.parent.latestValues) ||
          has2DTranslate(this.parent.latestValues)
        ) {
          return undefined;
        }
        if (this.parent.isProjecting()) {
          return this.parent;
        } else {
          return this.parent.getClosestProjectingParent();
        }
      }
      isProjecting() {
        return Boolean(
          (this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout
        );
      }
      calcProjection() {
        const lead = this.getLead();
        const isShared = Boolean(this.resumingFrom) || this !== lead;
        let canSkip = true;
        /**
         * If this is a normal layout animation and neither this node nor its nearest projecting
         * is dirty then we can't skip.
         */
        if (this.isProjectionDirty || this.parent?.isProjectionDirty) {
          canSkip = false;
        }
        /**
         * If this is a shared layout animation and this node's shared projection is dirty then
         * we can't skip.
         */
        if (isShared && (this.isSharedProjectionDirty || this.isTransformDirty)) {
          canSkip = false;
        }
        /**
         * If we have resolved the target this frame we must recalculate the
         * projection to ensure it visually represents the internal calculations.
         */
        if (this.resolvedRelativeTargetAt === frameData.timestamp) {
          canSkip = false;
        }
        if (canSkip) return;
        const { layout, layoutId } = this.options;
        /**
         * If this section of the tree isn't animating we can
         * delete our target sources for the following frame.
         */
        this.isTreeAnimating = Boolean(
          (this.parent && this.parent.isTreeAnimating) ||
            this.currentAnimation ||
            this.pendingAnimation
        );
        if (!this.isTreeAnimating) {
          this.targetDelta = this.relativeTarget = undefined;
        }
        if (!this.layout || !(layout || layoutId)) return;
        /**
         * Reset the corrected box with the latest values from box, as we're then going
         * to perform mutative operations on it.
         */
        copyBoxInto(this.layoutCorrected, this.layout.layoutBox);
        /**
         * Record previous tree scales before updating.
         */
        const prevTreeScaleX = this.treeScale.x;
        const prevTreeScaleY = this.treeScale.y;
        /**
         * Apply all the parent deltas to this box to produce the corrected box. This
         * is the layout box, as it will appear on screen as a result of the transforms of its parents.
         */
        applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, isShared);
        /**
         * If this layer needs to perform scale correction but doesn't have a target,
         * use the layout as the target.
         */
        if (lead.layout && !lead.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1)) {
          lead.target = lead.layout.layoutBox;
          lead.targetWithTransforms = createBox();
        }
        const { target } = lead;
        if (!target) {
          /**
           * If we don't have a target to project into, but we were previously
           * projecting, we want to remove the stored transform and schedule
           * a render to ensure the elements reflect the removed transform.
           */
          if (this.prevProjectionDelta) {
            this.createProjectionDeltas();
            this.scheduleRender();
          }
          return;
        }
        if (!this.projectionDelta || !this.prevProjectionDelta) {
          this.createProjectionDeltas();
        } else {
          copyAxisDeltaInto(this.prevProjectionDelta.x, this.projectionDelta.x);
          copyAxisDeltaInto(this.prevProjectionDelta.y, this.projectionDelta.y);
        }
        /**
         * Update the delta between the corrected box and the target box before user-set transforms were applied.
         * This will allow us to calculate the corrected borderRadius and boxShadow to compensate
         * for our layout reprojection, but still allow them to be scaled correctly by the user.
         * It might be that to simplify this we may want to accept that user-set scale is also corrected
         * and we wouldn't have to keep and calc both deltas, OR we could support a user setting
         * to allow people to choose whether these styles are corrected based on just the
         * layout reprojection or the final bounding box.
         */
        calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);
        if (
          this.treeScale.x !== prevTreeScaleX ||
          this.treeScale.y !== prevTreeScaleY ||
          !axisDeltaEquals(this.projectionDelta.x, this.prevProjectionDelta.x) ||
          !axisDeltaEquals(this.projectionDelta.y, this.prevProjectionDelta.y)
        ) {
          this.hasProjected = true;
          this.scheduleRender();
          this.notifyListeners('projectionUpdate', target);
        }
        /**
         * Increase debug counter for recalculated projections
         */
        if (statsBuffer.value) {
          metrics.calculatedProjections++;
        }
      }
      hide() {
        this.isVisible = false;
        // TODO: Schedule render
      }
      show() {
        this.isVisible = true;
        // TODO: Schedule render
      }
      scheduleRender(notifyAll = true) {
        this.options.visualElement?.scheduleRender();
        if (notifyAll) {
          const stack = this.getStack();
          stack && stack.scheduleRender();
        }
        if (this.resumingFrom && !this.resumingFrom.instance) {
          this.resumingFrom = undefined;
        }
      }
      createProjectionDeltas() {
        this.prevProjectionDelta = createDelta();
        this.projectionDelta = createDelta();
        this.projectionDeltaWithTransform = createDelta();
      }
      setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = false) {
        const snapshot = this.snapshot;
        const snapshotLatestValues = snapshot ? snapshot.latestValues : {};
        const mixedValues = { ...this.latestValues };
        const targetDelta = createDelta();
        if (!this.relativeParent || !this.relativeParent.options.layoutRoot) {
          this.relativeTarget = this.relativeTargetOrigin = undefined;
        }
        this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;
        const relativeLayout = createBox();
        const snapshotSource = snapshot ? snapshot.source : undefined;
        const layoutSource = this.layout ? this.layout.source : undefined;
        const isSharedLayoutAnimation = snapshotSource !== layoutSource;
        const stack = this.getStack();
        const isOnlyMember = !stack || stack.members.length <= 1;
        const shouldCrossfadeOpacity = Boolean(
          isSharedLayoutAnimation &&
            !isOnlyMember &&
            this.options.crossfade === true &&
            !this.path.some(hasOpacityCrossfade)
        );
        this.animationProgress = 0;
        let prevRelativeTarget;
        this.mixTargetDelta = (latest) => {
          const progress = latest / 1000;
          mixAxisDelta(targetDelta.x, delta.x, progress);
          mixAxisDelta(targetDelta.y, delta.y, progress);
          this.setTargetDelta(targetDelta);
          if (
            this.relativeTarget &&
            this.relativeTargetOrigin &&
            this.layout &&
            this.relativeParent &&
            this.relativeParent.layout
          ) {
            calcRelativePosition(
              relativeLayout,
              this.layout.layoutBox,
              this.relativeParent.layout.layoutBox
            );
            mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress);
            /**
             * If this is an unchanged relative target we can consider the
             * projection not dirty.
             */
            if (prevRelativeTarget && boxEquals(this.relativeTarget, prevRelativeTarget)) {
              this.isProjectionDirty = false;
            }
            if (!prevRelativeTarget) prevRelativeTarget = createBox();
            copyBoxInto(prevRelativeTarget, this.relativeTarget);
          }
          if (isSharedLayoutAnimation) {
            this.animationValues = mixedValues;
            mixValues(
              mixedValues,
              snapshotLatestValues,
              this.latestValues,
              progress,
              shouldCrossfadeOpacity,
              isOnlyMember
            );
          }
          this.root.scheduleUpdateProjection();
          this.scheduleRender();
          this.animationProgress = progress;
        };
        this.mixTargetDelta(this.options.layoutRoot ? 1000 : 0);
      }
      startAnimation(options) {
        this.notifyListeners('animationStart');
        this.currentAnimation?.stop();
        this.resumingFrom?.currentAnimation?.stop();
        if (this.pendingAnimation) {
          cancelFrame(this.pendingAnimation);
          this.pendingAnimation = undefined;
        }
        /**
         * Start the animation in the next frame to have a frame with progress 0,
         * where the target is the same as when the animation started, so we can
         * calculate the relative positions correctly for instant transitions.
         */
        this.pendingAnimation = frame_frame.update(() => {
          globalProjectionState.hasAnimatedSinceResize = true;
          activeAnimations.layout++;
          this.motionValue || (this.motionValue = motionValue(0));
          this.currentAnimation = animateSingleValue(this.motionValue, [0, 1000], {
            ...options,
            velocity: 0,
            isSync: true,
            onUpdate: (latest) => {
              this.mixTargetDelta(latest);
              options.onUpdate && options.onUpdate(latest);
            },
            onStop: () => {
              activeAnimations.layout--;
            },
            onComplete: () => {
              activeAnimations.layout--;
              options.onComplete && options.onComplete();
              this.completeAnimation();
            },
          });
          if (this.resumingFrom) {
            this.resumingFrom.currentAnimation = this.currentAnimation;
          }
          this.pendingAnimation = undefined;
        });
      }
      completeAnimation() {
        if (this.resumingFrom) {
          this.resumingFrom.currentAnimation = undefined;
          this.resumingFrom.preserveOpacity = undefined;
        }
        const stack = this.getStack();
        stack && stack.exitAnimationComplete();
        this.resumingFrom = this.currentAnimation = this.animationValues = undefined;
        this.notifyListeners('animationComplete');
      }
      finishAnimation() {
        if (this.currentAnimation) {
          this.mixTargetDelta && this.mixTargetDelta(animationTarget);
          this.currentAnimation.stop();
        }
        this.completeAnimation();
      }
      applyTransformsToTarget() {
        const lead = this.getLead();
        let { targetWithTransforms, target, layout, latestValues } = lead;
        if (!targetWithTransforms || !target || !layout) return;
        /**
         * If we're only animating position, and this element isn't the lead element,
         * then instead of projecting into the lead box we instead want to calculate
         * a new target that aligns the two boxes but maintains the layout shape.
         */
        if (
          this !== lead &&
          this.layout &&
          layout &&
          shouldAnimatePositionOnly(
            this.options.animationType,
            this.layout.layoutBox,
            layout.layoutBox
          )
        ) {
          target = this.target || createBox();
          const xLength = calcLength(this.layout.layoutBox.x);
          target.x.min = lead.target.x.min;
          target.x.max = target.x.min + xLength;
          const yLength = calcLength(this.layout.layoutBox.y);
          target.y.min = lead.target.y.min;
          target.y.max = target.y.min + yLength;
        }
        copyBoxInto(targetWithTransforms, target);
        /**
         * Apply the latest user-set transforms to the targetBox to produce the targetBoxFinal.
         * This is the final box that we will then project into by calculating a transform delta and
         * applying it to the corrected box.
         */
        transformBox(targetWithTransforms, latestValues);
        /**
         * Update the delta between the corrected box and the final target box, after
         * user-set transforms are applied to it. This will be used by the renderer to
         * create a transform style that will reproject the element from its layout layout
         * into the desired bounding box.
         */
        calcBoxDelta(
          this.projectionDeltaWithTransform,
          this.layoutCorrected,
          targetWithTransforms,
          latestValues
        );
      }
      registerSharedNode(layoutId, node) {
        if (!this.sharedNodes.has(layoutId)) {
          this.sharedNodes.set(layoutId, new NodeStack());
        }
        const stack = this.sharedNodes.get(layoutId);
        stack.add(node);
        const config = node.options.initialPromotionConfig;
        node.promote({
          transition: config ? config.transition : undefined,
          preserveFollowOpacity:
            config && config.shouldPreserveFollowOpacity
              ? config.shouldPreserveFollowOpacity(node)
              : undefined,
        });
      }
      isLead() {
        const stack = this.getStack();
        return stack ? stack.lead === this : true;
      }
      getLead() {
        const { layoutId } = this.options;
        return layoutId ? this.getStack()?.lead || this : this;
      }
      getPrevLead() {
        const { layoutId } = this.options;
        return layoutId ? this.getStack()?.prevLead : undefined;
      }
      getStack() {
        const { layoutId } = this.options;
        if (layoutId) return this.root.sharedNodes.get(layoutId);
      }
      promote({ needsReset, transition, preserveFollowOpacity } = {}) {
        const stack = this.getStack();
        if (stack) stack.promote(this, preserveFollowOpacity);
        if (needsReset) {
          this.projectionDelta = undefined;
          this.needsReset = true;
        }
        if (transition) this.setOptions({ transition });
      }
      relegate() {
        const stack = this.getStack();
        if (stack) {
          return stack.relegate(this);
        } else {
          return false;
        }
      }
      resetSkewAndRotation() {
        const { visualElement } = this.options;
        if (!visualElement) return;
        // If there's no detected skew or rotation values, we can early return without a forced render.
        let hasDistortingTransform = false;
        /**
         * An unrolled check for rotation values. Most elements don't have any rotation and
         * skipping the nested loop and new object creation is 50% faster.
         */
        const { latestValues } = visualElement;
        if (
          latestValues.z ||
          latestValues.rotate ||
          latestValues.rotateX ||
          latestValues.rotateY ||
          latestValues.rotateZ ||
          latestValues.skewX ||
          latestValues.skewY
        ) {
          hasDistortingTransform = true;
        }
        // If there's no distorting values, we don't need to do any more.
        if (!hasDistortingTransform) return;
        const resetValues = {};
        if (latestValues.z) {
          resetDistortingTransform('z', visualElement, resetValues, this.animationValues);
        }
        // Check the skew and rotate value of all axes and reset to 0
        for (let i = 0; i < transformAxes.length; i++) {
          resetDistortingTransform(
            `rotate${transformAxes[i]}`,
            visualElement,
            resetValues,
            this.animationValues
          );
          resetDistortingTransform(
            `skew${transformAxes[i]}`,
            visualElement,
            resetValues,
            this.animationValues
          );
        }
        // Force a render of this element to apply the transform with all skews and rotations
        // set to 0.
        visualElement.render();
        // Put back all the values we reset
        for (const key in resetValues) {
          visualElement.setStaticValue(key, resetValues[key]);
          if (this.animationValues) {
            this.animationValues[key] = resetValues[key];
          }
        }
        // Schedule a render for the next frame. This ensures we won't visually
        // see the element with the reset rotate value applied.
        visualElement.scheduleRender();
      }
      getProjectionStyles(styleProp) {
        if (!this.instance || this.isSVG) return undefined;
        if (!this.isVisible) {
          return hiddenVisibility;
        }
        const styles = {
          visibility: '',
        };
        const transformTemplate = this.getTransformTemplate();
        if (this.needsReset) {
          this.needsReset = false;
          styles.opacity = '';
          styles.pointerEvents = resolveMotionValue(styleProp?.pointerEvents) || '';
          styles.transform = transformTemplate ? transformTemplate(this.latestValues, '') : 'none';
          return styles;
        }
        const lead = this.getLead();
        if (!this.projectionDelta || !this.layout || !lead.target) {
          const emptyStyles = {};
          if (this.options.layoutId) {
            emptyStyles.opacity =
              this.latestValues.opacity !== undefined ? this.latestValues.opacity : 1;
            emptyStyles.pointerEvents = resolveMotionValue(styleProp?.pointerEvents) || '';
          }
          if (this.hasProjected && !hasTransform(this.latestValues)) {
            emptyStyles.transform = transformTemplate ? transformTemplate({}, '') : 'none';
            this.hasProjected = false;
          }
          return emptyStyles;
        }
        const valuesToRender = lead.animationValues || lead.latestValues;
        this.applyTransformsToTarget();
        styles.transform = buildProjectionTransform(
          this.projectionDeltaWithTransform,
          this.treeScale,
          valuesToRender
        );
        if (transformTemplate) {
          styles.transform = transformTemplate(valuesToRender, styles.transform);
        }
        const { x, y } = this.projectionDelta;
        styles.transformOrigin = `${x.origin * 100}% ${y.origin * 100}% 0`;
        if (lead.animationValues) {
          /**
           * If the lead component is animating, assign this either the entering/leaving
           * opacity
           */
          styles.opacity =
            lead === this
              ? (valuesToRender.opacity ?? this.latestValues.opacity ?? 1)
              : this.preserveOpacity
                ? this.latestValues.opacity
                : valuesToRender.opacityExit;
        } else {
          /**
           * Or we're not animating at all, set the lead component to its layout
           * opacity and other components to hidden.
           */
          styles.opacity =
            lead === this
              ? valuesToRender.opacity !== undefined
                ? valuesToRender.opacity
                : ''
              : valuesToRender.opacityExit !== undefined
                ? valuesToRender.opacityExit
                : 0;
        }
        /**
         * Apply scale correction
         */
        for (const key in scaleCorrectors) {
          if (valuesToRender[key] === undefined) continue;
          const { correct, applyTo, isCSSVariable } = scaleCorrectors[key];
          /**
           * Only apply scale correction to the value if we have an
           * active projection transform. Otherwise these values become
           * vulnerable to distortion if the element changes size without
           * a corresponding layout animation.
           */
          const corrected =
            styles.transform === 'none' ? valuesToRender[key] : correct(valuesToRender[key], lead);
          if (applyTo) {
            const num = applyTo.length;
            for (let i = 0; i < num; i++) {
              styles[applyTo[i]] = corrected;
            }
          } else {
            // If this is a CSS variable, set it directly on the instance.
            // Replacing this function from creating styles to setting them
            // would be a good place to remove per frame object creation
            if (isCSSVariable) {
              this.options.visualElement.renderState.vars[key] = corrected;
            } else {
              styles[key] = corrected;
            }
          }
        }
        /**
         * Disable pointer events on follow components. This is to ensure
         * that if a follow component covers a lead component it doesn't block
         * pointer events on the lead.
         */
        if (this.options.layoutId) {
          styles.pointerEvents =
            lead === this ? resolveMotionValue(styleProp?.pointerEvents) || '' : 'none';
        }
        return styles;
      }
      clearSnapshot() {
        this.resumeFrom = this.snapshot = undefined;
      }
      // Only run on root
      resetTree() {
        this.root.nodes.forEach((node) => node.currentAnimation?.stop());
        this.root.nodes.forEach(clearMeasurements);
        this.root.sharedNodes.clear();
      }
    };
  }
  function updateLayout(node) {
    node.updateLayout();
  }
  function notifyLayoutUpdate(node) {
    const snapshot = node.resumeFrom?.snapshot || node.snapshot;
    if (node.isLead() && node.layout && snapshot && node.hasListeners('didUpdate')) {
      const { layoutBox: layout, measuredBox: measuredLayout } = node.layout;
      const { animationType } = node.options;
      const isShared = snapshot.source !== node.layout.source;
      // TODO Maybe we want to also resize the layout snapshot so we don't trigger
      // animations for instance if layout="size" and an element has only changed position
      if (animationType === 'size') {
        eachAxis((axis) => {
          const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
          const length = calcLength(axisSnapshot);
          axisSnapshot.min = layout[axis].min;
          axisSnapshot.max = axisSnapshot.min + length;
        });
      } else if (shouldAnimatePositionOnly(animationType, snapshot.layoutBox, layout)) {
        eachAxis((axis) => {
          const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
          const length = calcLength(layout[axis]);
          axisSnapshot.max = axisSnapshot.min + length;
          /**
           * Ensure relative target gets resized and rerendererd
           */
          if (node.relativeTarget && !node.currentAnimation) {
            node.isProjectionDirty = true;
            node.relativeTarget[axis].max = node.relativeTarget[axis].min + length;
          }
        });
      }
      const layoutDelta = createDelta();
      calcBoxDelta(layoutDelta, layout, snapshot.layoutBox);
      const visualDelta = createDelta();
      if (isShared) {
        calcBoxDelta(visualDelta, node.applyTransform(measuredLayout, true), snapshot.measuredBox);
      } else {
        calcBoxDelta(visualDelta, layout, snapshot.layoutBox);
      }
      const hasLayoutChanged = !isDeltaZero(layoutDelta);
      let hasRelativeLayoutChanged = false;
      if (!node.resumeFrom) {
        const relativeParent = node.getClosestProjectingParent();
        /**
         * If the relativeParent is itself resuming from a different element then
         * the relative snapshot is not relavent
         */
        if (relativeParent && !relativeParent.resumeFrom) {
          const { snapshot: parentSnapshot, layout: parentLayout } = relativeParent;
          if (parentSnapshot && parentLayout) {
            const relativeSnapshot = createBox();
            calcRelativePosition(relativeSnapshot, snapshot.layoutBox, parentSnapshot.layoutBox);
            const relativeLayout = createBox();
            calcRelativePosition(relativeLayout, layout, parentLayout.layoutBox);
            if (!boxEqualsRounded(relativeSnapshot, relativeLayout)) {
              hasRelativeLayoutChanged = true;
            }
            if (relativeParent.options.layoutRoot) {
              node.relativeTarget = relativeLayout;
              node.relativeTargetOrigin = relativeSnapshot;
              node.relativeParent = relativeParent;
            }
          }
        }
      }
      node.notifyListeners('didUpdate', {
        layout,
        snapshot,
        delta: visualDelta,
        layoutDelta,
        hasLayoutChanged,
        hasRelativeLayoutChanged,
      });
    } else if (node.isLead()) {
      const { onExitComplete } = node.options;
      onExitComplete && onExitComplete();
    }
    /**
     * Clearing transition
     * TODO: Investigate why this transition is being passed in as {type: false } from Framer
     * and why we need it at all
     */
    node.options.transition = undefined;
  }
  function propagateDirtyNodes(node) {
    /**
     * Increase debug counter for nodes encountered this frame
     */
    if (statsBuffer.value) {
      metrics.nodes++;
    }
    if (!node.parent) return;
    /**
     * If this node isn't projecting, propagate isProjectionDirty. It will have
     * no performance impact but it will allow the next child that *is* projecting
     * but *isn't* dirty to just check its parent to see if *any* ancestor needs
     * correcting.
     */
    if (!node.isProjecting()) {
      node.isProjectionDirty = node.parent.isProjectionDirty;
    }
    /**
     * Propagate isSharedProjectionDirty and isTransformDirty
     * throughout the whole tree. A future revision can take another look at
     * this but for safety we still recalcualte shared nodes.
     */
    node.isSharedProjectionDirty ||
      (node.isSharedProjectionDirty = Boolean(
        node.isProjectionDirty ||
          node.parent.isProjectionDirty ||
          node.parent.isSharedProjectionDirty
      ));
    node.isTransformDirty || (node.isTransformDirty = node.parent.isTransformDirty);
  }
  function cleanDirtyNodes(node) {
    node.isProjectionDirty = node.isSharedProjectionDirty = node.isTransformDirty = false;
  }
  function clearSnapshot(node) {
    node.clearSnapshot();
  }
  function clearMeasurements(node) {
    node.clearMeasurements();
  }
  function clearIsLayoutDirty(node) {
    node.isLayoutDirty = false;
  }
  function resetTransformStyle(node) {
    const { visualElement } = node.options;
    if (visualElement && visualElement.getProps().onBeforeLayoutMeasure) {
      visualElement.notify('BeforeLayoutMeasure');
    }
    node.resetTransform();
  }
  function finishAnimation(node) {
    node.finishAnimation();
    node.targetDelta = node.relativeTarget = node.target = undefined;
    node.isProjectionDirty = true;
  }
  function resolveTargetDelta(node) {
    node.resolveTargetDelta();
  }
  function calcProjection(node) {
    node.calcProjection();
  }
  function resetSkewAndRotation(node) {
    node.resetSkewAndRotation();
  }
  function removeLeadSnapshots(stack) {
    stack.removeLeadSnapshot();
  }
  function mixAxisDelta(output, delta, p) {
    output.translate = mixNumber(delta.translate, 0, p);
    output.scale = mixNumber(delta.scale, 1, p);
    output.origin = delta.origin;
    output.originPoint = delta.originPoint;
  }
  function mixAxis(output, from, to, p) {
    output.min = mixNumber(from.min, to.min, p);
    output.max = mixNumber(from.max, to.max, p);
  }
  function mixBox(output, from, to, p) {
    mixAxis(output.x, from.x, to.x, p);
    mixAxis(output.y, from.y, to.y, p);
  }
  function hasOpacityCrossfade(node) {
    return node.animationValues && node.animationValues.opacityExit !== undefined;
  }
  const defaultLayoutTransition = {
    duration: 0.45,
    ease: [0.4, 0, 0.1, 1],
  };
  const userAgentContains = (string) =>
    typeof navigator !== 'undefined' &&
    navigator.userAgent &&
    navigator.userAgent.toLowerCase().includes(string);
  /**
   * Measured bounding boxes must be rounded in Safari and
   * left untouched in Chrome, otherwise non-integer layouts within scaled-up elements
   * can appear to jump.
   */
  const roundPoint =
    userAgentContains('applewebkit/') && !userAgentContains('chrome/') ? Math.round : noop;
  function roundAxis(axis) {
    // Round to the nearest .5 pixels to support subpixel layouts
    axis.min = roundPoint(axis.min);
    axis.max = roundPoint(axis.max);
  }
  function roundBox(box) {
    roundAxis(box.x);
    roundAxis(box.y);
  }
  function shouldAnimatePositionOnly(animationType, snapshot, layout) {
    return (
      animationType === 'position' ||
      (animationType === 'preserve-aspect' &&
        !isNear(aspectRatio(snapshot), aspectRatio(layout), 0.2))
    );
  }
  function checkNodeWasScrollRoot(node) {
    return node !== node.root && node.scroll?.wasRoot;
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/projection/node/DocumentProjectionNode.mjs

  const DocumentProjectionNode = createProjectionNode({
    attachResizeListener: (ref, notify) => addDomEvent(ref, 'resize', notify),
    measureScroll: () => ({
      x: document.documentElement.scrollLeft || document.body.scrollLeft,
      y: document.documentElement.scrollTop || document.body.scrollTop,
    }),
    checkIsScrollRoot: () => true,
  }); // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/projection/node/HTMLProjectionNode.mjs

  const rootProjectionNode = {
    current: undefined,
  };
  const HTMLProjectionNode = createProjectionNode({
    measureScroll: (instance) => ({
      x: instance.scrollLeft,
      y: instance.scrollTop,
    }),
    defaultParent: () => {
      if (!rootProjectionNode.current) {
        const documentNode = new DocumentProjectionNode({});
        documentNode.mount(window);
        documentNode.setOptions({ layoutScroll: true });
        rootProjectionNode.current = documentNode;
      }
      return rootProjectionNode.current;
    },
    resetTransform: (instance, value) => {
      instance.style.transform = value !== undefined ? value : 'none';
    },
    checkIsScrollRoot: (instance) =>
      Boolean(window.getComputedStyle(instance).position === 'fixed'),
  }); // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/motion/features/drag.mjs

  const drag = {
    pan: {
      Feature: PanGesture,
    },
    drag: {
      Feature: DragGesture,
      ProjectionNode: HTMLProjectionNode,
      MeasureLayout: MeasureLayout,
    },
  }; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/utils/resolve-elements.mjs

  function resolveElements(elementOrSelector, scope, selectorCache) {
    if (elementOrSelector instanceof EventTarget) {
      return [elementOrSelector];
    } else if (typeof elementOrSelector === 'string') {
      let root = document;
      if (scope) {
        root = scope.current;
      }
      const elements =
        selectorCache?.[elementOrSelector] ?? root.querySelectorAll(elementOrSelector);
      return elements ? Array.from(elements) : [];
    }
    return Array.from(elementOrSelector);
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/gestures/utils/setup.mjs

  function setupGesture(elementOrSelector, options) {
    const elements = resolveElements(elementOrSelector);
    const gestureAbortController = new AbortController();
    const eventOptions = {
      passive: true,
      ...options,
      signal: gestureAbortController.signal,
    };
    const cancel = () => gestureAbortController.abort();
    return [elements, eventOptions, cancel];
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/gestures/hover.mjs

  function isValidHover(event) {
    return !(event.pointerType === 'touch' || isDragActive());
  }
  /**
   * Create a hover gesture. hover() is different to .addEventListener("pointerenter")
   * in that it has an easier syntax, filters out polyfilled touch events, interoperates
   * with drag gestures, and automatically removes the "pointerennd" event listener when the hover ends.
   *
   * @public
   */
  function hover(elementOrSelector, onHoverStart, options = {}) {
    const [elements, eventOptions, cancel] = setupGesture(elementOrSelector, options);
    const onPointerEnter = (enterEvent) => {
      if (!isValidHover(enterEvent)) return;
      const { target } = enterEvent;
      const onHoverEnd = onHoverStart(target, enterEvent);
      if (typeof onHoverEnd !== 'function' || !target) return;
      const onPointerLeave = (leaveEvent) => {
        if (!isValidHover(leaveEvent)) return;
        onHoverEnd(leaveEvent);
        target.removeEventListener('pointerleave', onPointerLeave);
      };
      target.addEventListener('pointerleave', onPointerLeave, eventOptions);
    };
    elements.forEach((element) => {
      element.addEventListener('pointerenter', onPointerEnter, eventOptions);
    });
    return cancel;
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/gestures/hover.mjs

  function handleHoverEvent(node, event, lifecycle) {
    const { props } = node;
    if (node.animationState && props.whileHover) {
      node.animationState.setActive('whileHover', lifecycle === 'Start');
    }
    const eventName = 'onHover' + lifecycle;
    const callback = props[eventName];
    if (callback) {
      frame_frame.postRender(() => callback(event, extractEventInfo(event)));
    }
  }
  class HoverGesture extends Feature {
    mount() {
      const { current } = this.node;
      if (!current) return;
      this.unmount = hover(current, (_element, startEvent) => {
        handleHoverEvent(this.node, startEvent, 'Start');
        return (endEvent) => handleHoverEvent(this.node, endEvent, 'End');
      });
    }
    unmount() {}
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/gestures/focus.mjs

  class FocusGesture extends Feature {
    constructor() {
      super(...arguments);
      this.isActive = false;
    }
    onFocus() {
      let isFocusVisible = false;
      /**
       * If this element doesn't match focus-visible then don't
       * apply whileHover. But, if matches throws that focus-visible
       * is not a valid selector then in that browser outline styles will be applied
       * to the element by default and we want to match that behaviour with whileFocus.
       */
      try {
        isFocusVisible = this.node.current.matches(':focus-visible');
      } catch (e) {
        isFocusVisible = true;
      }
      if (!isFocusVisible || !this.node.animationState) return;
      this.node.animationState.setActive('whileFocus', true);
      this.isActive = true;
    }
    onBlur() {
      if (!this.isActive || !this.node.animationState) return;
      this.node.animationState.setActive('whileFocus', false);
      this.isActive = false;
    }
    mount() {
      this.unmount = pipe(
        addDomEvent(this.node.current, 'focus', () => this.onFocus()),
        addDomEvent(this.node.current, 'blur', () => this.onBlur())
      );
    }
    unmount() {}
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/gestures/utils/is-node-or-child.mjs

  /**
   * Recursively traverse up the tree to check whether the provided child node
   * is the parent or a descendant of it.
   *
   * @param parent - Element to find
   * @param child - Element to test against parent
   */
  const isNodeOrChild = (parent, child) => {
    if (!child) {
      return false;
    } else if (parent === child) {
      return true;
    } else {
      return isNodeOrChild(parent, child.parentElement);
    }
  }; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/gestures/press/utils/is-keyboard-accessible.mjs

  const focusableElements = new Set(['BUTTON', 'INPUT', 'SELECT', 'TEXTAREA', 'A']);
  function isElementKeyboardAccessible(element) {
    return focusableElements.has(element.tagName) || element.tabIndex !== -1;
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/gestures/press/utils/state.mjs

  const isPressing = new WeakSet(); // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/gestures/press/utils/keyboard.mjs

  /**
   * Filter out events that are not "Enter" keys.
   */
  function filterEvents(callback) {
    return (event) => {
      if (event.key !== 'Enter') return;
      callback(event);
    };
  }
  function firePointerEvent(target, type) {
    target.dispatchEvent(new PointerEvent('pointer' + type, { isPrimary: true, bubbles: true }));
  }
  const enableKeyboardPress = (focusEvent, eventOptions) => {
    const element = focusEvent.currentTarget;
    if (!element) return;
    const handleKeydown = filterEvents(() => {
      if (isPressing.has(element)) return;
      firePointerEvent(element, 'down');
      const handleKeyup = filterEvents(() => {
        firePointerEvent(element, 'up');
      });
      const handleBlur = () => firePointerEvent(element, 'cancel');
      element.addEventListener('keyup', handleKeyup, eventOptions);
      element.addEventListener('blur', handleBlur, eventOptions);
    });
    element.addEventListener('keydown', handleKeydown, eventOptions);
    /**
     * Add an event listener that fires on blur to remove the keydown events.
     */
    element.addEventListener(
      'blur',
      () => element.removeEventListener('keydown', handleKeydown),
      eventOptions
    );
  }; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/gestures/press/index.mjs

  /**
   * Filter out events that are not primary pointer events, or are triggering
   * while a Motion gesture is active.
   */
  function isValidPressEvent(event) {
    return isPrimaryPointer(event) && !isDragActive();
  }
  /**
   * Create a press gesture.
   *
   * Press is different to `"pointerdown"`, `"pointerup"` in that it
   * automatically filters out secondary pointer events like right
   * click and multitouch.
   *
   * It also adds accessibility support for keyboards, where
   * an element with a press gesture will receive focus and
   *  trigger on Enter `"keydown"` and `"keyup"` events.
   *
   * This is different to a browser's `"click"` event, which does
   * respond to keyboards but only for the `"click"` itself, rather
   * than the press start and end/cancel. The element also needs
   * to be focusable for this to work, whereas a press gesture will
   * make an element focusable by default.
   *
   * @public
   */
  function press(targetOrSelector, onPressStart, options = {}) {
    const [targets, eventOptions, cancelEvents] = setupGesture(targetOrSelector, options);
    const startPress = (startEvent) => {
      const target = startEvent.currentTarget;
      if (!isValidPressEvent(startEvent)) return;
      isPressing.add(target);
      const onPressEnd = onPressStart(target, startEvent);
      const onPointerEnd = (endEvent, success) => {
        window.removeEventListener('pointerup', onPointerUp);
        window.removeEventListener('pointercancel', onPointerCancel);
        if (isPressing.has(target)) {
          isPressing.delete(target);
        }
        if (!isValidPressEvent(endEvent)) {
          return;
        }
        if (typeof onPressEnd === 'function') {
          onPressEnd(endEvent, { success });
        }
      };
      const onPointerUp = (upEvent) => {
        onPointerEnd(
          upEvent,
          target === window ||
            target === document ||
            options.useGlobalTarget ||
            isNodeOrChild(target, upEvent.target)
        );
      };
      const onPointerCancel = (cancelEvent) => {
        onPointerEnd(cancelEvent, false);
      };
      window.addEventListener('pointerup', onPointerUp, eventOptions);
      window.addEventListener('pointercancel', onPointerCancel, eventOptions);
    };
    targets.forEach((target) => {
      const pointerDownTarget = options.useGlobalTarget ? window : target;
      pointerDownTarget.addEventListener('pointerdown', startPress, eventOptions);
      if (isHTMLElement(target)) {
        target.addEventListener('focus', (event) => enableKeyboardPress(event, eventOptions));
        if (!isElementKeyboardAccessible(target) && !target.hasAttribute('tabindex')) {
          target.tabIndex = 0;
        }
      }
    });
    return cancelEvents;
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/gestures/press.mjs

  function handlePressEvent(node, event, lifecycle) {
    const { props } = node;
    if (node.current instanceof HTMLButtonElement && node.current.disabled) {
      return;
    }
    if (node.animationState && props.whileTap) {
      node.animationState.setActive('whileTap', lifecycle === 'Start');
    }
    const eventName = 'onTap' + (lifecycle === 'End' ? '' : lifecycle);
    const callback = props[eventName];
    if (callback) {
      frame_frame.postRender(() => callback(event, extractEventInfo(event)));
    }
  }
  class PressGesture extends Feature {
    mount() {
      const { current } = this.node;
      if (!current) return;
      this.unmount = press(
        current,
        (_element, startEvent) => {
          handlePressEvent(this.node, startEvent, 'Start');
          return (endEvent, { success }) =>
            handlePressEvent(this.node, endEvent, success ? 'End' : 'Cancel');
        },
        { useGlobalTarget: this.node.props.globalTapTarget }
      );
    }
    unmount() {}
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/motion/features/viewport/observers.mjs

  /**
   * Map an IntersectionHandler callback to an element. We only ever make one handler for one
   * element, so even though these handlers might all be triggered by different
   * observers, we can keep them in the same map.
   */
  const observerCallbacks = new WeakMap();
  /**
   * Multiple observers can be created for multiple element/document roots. Each with
   * different settings. So here we store dictionaries of observers to each root,
   * using serialised settings (threshold/margin) as lookup keys.
   */
  const observers = new WeakMap();
  const fireObserverCallback = (entry) => {
    const callback = observerCallbacks.get(entry.target);
    callback && callback(entry);
  };
  const fireAllObserverCallbacks = (entries) => {
    entries.forEach(fireObserverCallback);
  };
  function initIntersectionObserver({ root, ...options }) {
    const lookupRoot = root || document;
    /**
     * If we don't have an observer lookup map for this root, create one.
     */
    if (!observers.has(lookupRoot)) {
      observers.set(lookupRoot, {});
    }
    const rootObservers = observers.get(lookupRoot);
    const key = JSON.stringify(options);
    /**
     * If we don't have an observer for this combination of root and settings,
     * create one.
     */
    if (!rootObservers[key]) {
      rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, { root, ...options });
    }
    return rootObservers[key];
  }
  function observeIntersection(element, options, callback) {
    const rootInteresectionObserver = initIntersectionObserver(options);
    observerCallbacks.set(element, callback);
    rootInteresectionObserver.observe(element);
    return () => {
      observerCallbacks.delete(element);
      rootInteresectionObserver.unobserve(element);
    };
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/motion/features/viewport/index.mjs

  const thresholdNames = {
    some: 0,
    all: 1,
  };
  class InViewFeature extends Feature {
    constructor() {
      super(...arguments);
      this.hasEnteredView = false;
      this.isInView = false;
    }
    startObserver() {
      this.unmount();
      const { viewport = {} } = this.node.getProps();
      const { root, margin: rootMargin, amount = 'some', once } = viewport;
      const options = {
        root: root ? root.current : undefined,
        rootMargin,
        threshold: typeof amount === 'number' ? amount : thresholdNames[amount],
      };
      const onIntersectionUpdate = (entry) => {
        const { isIntersecting } = entry;
        /**
         * If there's been no change in the viewport state, early return.
         */
        if (this.isInView === isIntersecting) return;
        this.isInView = isIntersecting;
        /**
         * Handle hasEnteredView. If this is only meant to run once, and
         * element isn't visible, early return. Otherwise set hasEnteredView to true.
         */
        if (once && !isIntersecting && this.hasEnteredView) {
          return;
        } else if (isIntersecting) {
          this.hasEnteredView = true;
        }
        if (this.node.animationState) {
          this.node.animationState.setActive('whileInView', isIntersecting);
        }
        /**
         * Use the latest committed props rather than the ones in scope
         * when this observer is created
         */
        const { onViewportEnter, onViewportLeave } = this.node.getProps();
        const callback = isIntersecting ? onViewportEnter : onViewportLeave;
        callback && callback(entry);
      };
      return observeIntersection(this.node.current, options, onIntersectionUpdate);
    }
    mount() {
      this.startObserver();
    }
    update() {
      if (typeof IntersectionObserver === 'undefined') return;
      const { props, prevProps } = this.node;
      const hasOptionsChanged = ['amount', 'margin', 'root'].some(
        hasViewportOptionChanged(props, prevProps)
      );
      if (hasOptionsChanged) {
        this.startObserver();
      }
    }
    unmount() {}
  }
  function hasViewportOptionChanged({ viewport = {} }, { viewport: prevViewport = {} } = {}) {
    return (name) => viewport[name] !== prevViewport[name];
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/motion/features/gestures.mjs

  const gestureAnimations = {
    inView: {
      Feature: InViewFeature,
    },
    tap: {
      Feature: PressGesture,
    },
    focus: {
      Feature: FocusGesture,
    },
    hover: {
      Feature: HoverGesture,
    },
  }; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/motion/features/layout.mjs

  const layout = {
    layout: {
      ProjectionNode: HTMLProjectionNode,
      MeasureLayout: MeasureLayout,
    },
  }; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/context/LazyContext.mjs

  ('use client');

  const LazyContext = (0, react.createContext)({ strict: false }); // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/context/MotionConfigContext.mjs

  ('use client');

  /**
   * @public
   */
  const MotionConfigContext = (0, react.createContext)({
    transformPagePoint: (p) => p,
    isStatic: false,
    reducedMotion: 'never',
  }); // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/context/MotionContext/index.mjs

  ('use client');

  const MotionContext = /* @__PURE__ */ (0, react.createContext)({}); // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/render/utils/is-controlling-variants.mjs

  function isControllingVariants(props) {
    return (
      isAnimationControls(props.animate) || variantProps.some((name) => isVariantLabel(props[name]))
    );
  }
  function isVariantNode(props) {
    return Boolean(isControllingVariants(props) || props.variants);
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/context/MotionContext/utils.mjs

  function getCurrentTreeVariants(props, context) {
    if (isControllingVariants(props)) {
      const { initial, animate } = props;
      return {
        initial: initial === false || isVariantLabel(initial) ? initial : undefined,
        animate: isVariantLabel(animate) ? animate : undefined,
      };
    }
    return props.inherit !== false ? context : {};
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/context/MotionContext/create.mjs

  function useCreateMotionContext(props) {
    const { initial, animate } = getCurrentTreeVariants(
      props,
      (0, react.useContext)(MotionContext)
    );
    return (0, react.useMemo)(
      () => ({ initial, animate }),
      [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate)]
    );
  }
  function variantLabelsAsDependency(prop) {
    return Array.isArray(prop) ? prop.join(' ') : prop;
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/utils/is-browser.mjs

  const isBrowser = typeof window !== 'undefined'; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/motion/features/definitions.mjs

  const featureProps = {
    animation: [
      'animate',
      'variants',
      'whileHover',
      'whileTap',
      'exit',
      'whileInView',
      'whileFocus',
      'whileDrag',
    ],
    exit: ['exit'],
    drag: ['drag', 'dragControls'],
    focus: ['whileFocus'],
    hover: ['whileHover', 'onHoverStart', 'onHoverEnd'],
    tap: ['whileTap', 'onTap', 'onTapStart', 'onTapCancel'],
    pan: ['onPan', 'onPanStart', 'onPanSessionStart', 'onPanEnd'],
    inView: ['whileInView', 'onViewportEnter', 'onViewportLeave'],
    layout: ['layout', 'layoutId'],
  };
  const featureDefinitions = {};
  for (const key in featureProps) {
    featureDefinitions[key] = {
      isEnabled: (props) => featureProps[key].some((name) => !!props[name]),
    };
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/motion/features/load-features.mjs

  function loadFeatures(features) {
    for (const key in features) {
      featureDefinitions[key] = {
        ...featureDefinitions[key],
        ...features[key],
      };
    }
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/motion/utils/symbol.mjs

  const motionComponentSymbol = Symbol.for('motionComponentSymbol'); // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/motion/utils/use-motion-ref.mjs

  /**
   * Creates a ref function that, when called, hydrates the provided
   * external ref and VisualElement.
   */
  function useMotionRef(visualState, visualElement, externalRef) {
    return (0, react.useCallback)(
      (instance) => {
        if (instance) {
          visualState.onMount && visualState.onMount(instance);
        }
        if (visualElement) {
          if (instance) {
            visualElement.mount(instance);
          } else {
            visualElement.unmount();
          }
        }
        if (externalRef) {
          if (typeof externalRef === 'function') {
            externalRef(instance);
          } else if (isRefObject(externalRef)) {
            externalRef.current = instance;
          }
        }
      },
      /**
       * Only pass a new ref callback to React if we've received a visual element
       * factory. Otherwise we'll be mounting/remounting every time externalRef
       * or other dependencies change.
       */
      [visualElement]
    );
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/utils/use-isomorphic-effect.mjs

  const useIsomorphicLayoutEffect = isBrowser ? react.useLayoutEffect : react.useEffect; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/motion/utils/use-visual-element.mjs

  function useVisualElement(
    Component,
    visualState,
    props,
    createVisualElement,
    ProjectionNodeConstructor
  ) {
    const { visualElement: parent } = (0, react.useContext)(MotionContext);
    const lazyContext = (0, react.useContext)(LazyContext);
    const presenceContext = (0, react.useContext)(PresenceContext_PresenceContext);
    const reducedMotionConfig = (0, react.useContext)(MotionConfigContext).reducedMotion;
    const visualElementRef = (0, react.useRef)(null);
    /**
     * If we haven't preloaded a renderer, check to see if we have one lazy-loaded
     */
    createVisualElement = createVisualElement || lazyContext.renderer;
    if (!visualElementRef.current && createVisualElement) {
      visualElementRef.current = createVisualElement(Component, {
        visualState,
        parent,
        props,
        presenceContext,
        blockInitialAnimation: presenceContext ? presenceContext.initial === false : false,
        reducedMotionConfig,
      });
    }
    const visualElement = visualElementRef.current;
    /**
     * Load Motion gesture and animation features. These are rendered as renderless
     * components so each feature can optionally make use of React lifecycle methods.
     */
    const initialLayoutGroupConfig = (0, react.useContext)(SwitchLayoutGroupContext);
    if (
      visualElement &&
      !visualElement.projection &&
      ProjectionNodeConstructor &&
      (visualElement.type === 'html' || visualElement.type === 'svg')
    ) {
      use_visual_element_createProjectionNode(
        visualElementRef.current,
        props,
        ProjectionNodeConstructor,
        initialLayoutGroupConfig
      );
    }
    const isMounted = (0, react.useRef)(false);
    (0, react.useInsertionEffect)(() => {
      /**
       * Check the component has already mounted before calling
       * `update` unnecessarily. This ensures we skip the initial update.
       */
      if (visualElement && isMounted.current) {
        visualElement.update(props, presenceContext);
      }
    });
    /**
     * Cache this value as we want to know whether HandoffAppearAnimations
     * was present on initial render - it will be deleted after this.
     */
    const optimisedAppearId = props[optimizedAppearDataAttribute];
    const wantsHandoff = (0, react.useRef)(
      Boolean(optimisedAppearId) &&
        !window.MotionHandoffIsComplete?.(optimisedAppearId) &&
        window.MotionHasOptimisedAnimation?.(optimisedAppearId)
    );
    useIsomorphicLayoutEffect(() => {
      if (!visualElement) return;
      isMounted.current = true;
      window.MotionIsMounted = true;
      visualElement.updateFeatures();
      microtask.render(visualElement.render);
      /**
       * Ideally this function would always run in a useEffect.
       *
       * However, if we have optimised appear animations to handoff from,
       * it needs to happen synchronously to ensure there's no flash of
       * incorrect styles in the event of a hydration error.
       *
       * So if we detect a situtation where optimised appear animations
       * are running, we use useLayoutEffect to trigger animations.
       */
      if (wantsHandoff.current && visualElement.animationState) {
        visualElement.animationState.animateChanges();
      }
    });
    (0, react.useEffect)(() => {
      if (!visualElement) return;
      if (!wantsHandoff.current && visualElement.animationState) {
        visualElement.animationState.animateChanges();
      }
      if (wantsHandoff.current) {
        // This ensures all future calls to animateChanges() in this component will run in useEffect
        queueMicrotask(() => {
          window.MotionHandoffMarkAsComplete?.(optimisedAppearId);
        });
        wantsHandoff.current = false;
      }
    });
    return visualElement;
  }
  function use_visual_element_createProjectionNode(
    visualElement,
    props,
    ProjectionNodeConstructor,
    initialPromotionConfig
  ) {
    const { layoutId, layout, drag, dragConstraints, layoutScroll, layoutRoot, layoutCrossfade } =
      props;
    visualElement.projection = new ProjectionNodeConstructor(
      visualElement.latestValues,
      props['data-framer-portal-id'] ? undefined : getClosestProjectingNode(visualElement.parent)
    );
    visualElement.projection.setOptions({
      layoutId,
      layout,
      alwaysMeasureLayout: Boolean(drag) || (dragConstraints && isRefObject(dragConstraints)),
      visualElement,
      /**
       * TODO: Update options in an effect. This could be tricky as it'll be too late
       * to update by the time layout animations run.
       * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
       * ensuring it gets called if there's no potential layout animations.
       *
       */
      animationType: typeof layout === 'string' ? layout : 'both',
      initialPromotionConfig,
      crossfade: layoutCrossfade,
      layoutScroll,
      layoutRoot,
    });
  }
  function getClosestProjectingNode(visualElement) {
    if (!visualElement) return undefined;
    return visualElement.options.allowProjection !== false
      ? visualElement.projection
      : getClosestProjectingNode(visualElement.parent);
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/motion/index.mjs

  ('use client');

  /**
   * Create a `motion` component.
   *
   * This function accepts a Component argument, which can be either a string (ie "div"
   * for `motion.div`), or an actual React component.
   *
   * Alongside this is a config option which provides a way of rendering the provided
   * component "offline", or outside the React render cycle.
   */
  function createRendererMotionComponent({
    preloadedFeatures,
    createVisualElement,
    useRender,
    useVisualState,
    Component,
  }) {
    preloadedFeatures && loadFeatures(preloadedFeatures);
    function MotionComponent(props, externalRef) {
      /**
       * If we need to measure the element we load this functionality in a
       * separate class component in order to gain access to getSnapshotBeforeUpdate.
       */
      let MeasureLayout;
      const configAndProps = {
        ...(0, react.useContext)(MotionConfigContext),
        ...props,
        layoutId: useLayoutId(props),
      };
      const { isStatic } = configAndProps;
      const context = useCreateMotionContext(props);
      const visualState = useVisualState(props, isStatic);
      if (!isStatic && isBrowser) {
        useStrictMode(configAndProps, preloadedFeatures);
        const layoutProjection = getProjectionFunctionality(configAndProps);
        MeasureLayout = layoutProjection.MeasureLayout;
        /**
         * Create a VisualElement for this component. A VisualElement provides a common
         * interface to renderer-specific APIs (ie DOM/Three.js etc) as well as
         * providing a way of rendering to these APIs outside of the React render loop
         * for more performant animations and interactions
         */
        context.visualElement = useVisualElement(
          Component,
          visualState,
          configAndProps,
          createVisualElement,
          layoutProjection.ProjectionNode
        );
      }
      /**
       * The mount order and hierarchy is specific to ensure our element ref
       * is hydrated by the time features fire their effects.
       */
      return (0, jsx_runtime.jsxs)(MotionContext.Provider, {
        value: context,
        children: [
          MeasureLayout && context.visualElement
            ? (0, jsx_runtime.jsx)(MeasureLayout, {
                visualElement: context.visualElement,
                ...configAndProps,
              })
            : null,
          useRender(
            Component,
            props,
            useMotionRef(visualState, context.visualElement, externalRef),
            visualState,
            isStatic,
            context.visualElement
          ),
        ],
      });
    }
    MotionComponent.displayName = `motion.${
      typeof Component === 'string'
        ? Component
        : `create(${Component.displayName ?? Component.name ?? ''})`
    }`;
    const ForwardRefMotionComponent = (0, react.forwardRef)(MotionComponent);
    ForwardRefMotionComponent[motionComponentSymbol] = Component;
    return ForwardRefMotionComponent;
  }
  function useLayoutId({ layoutId }) {
    const layoutGroupId = (0, react.useContext)(LayoutGroupContext).id;
    return layoutGroupId && layoutId !== undefined ? layoutGroupId + '-' + layoutId : layoutId;
  }
  function useStrictMode(configAndProps, preloadedFeatures) {
    const isStrict = (0, react.useContext)(LazyContext).strict;
    /**
     * If we're in development mode, check to make sure we're not rendering a motion component
     * as a child of LazyMotion, as this will break the file-size benefits of using it.
     */
    if (false) {
      // removed by dead control flow
    }
  }
  function getProjectionFunctionality(props) {
    const { drag, layout } = featureDefinitions;
    if (!drag && !layout) return {};
    const combined = { ...drag, ...layout };
    return {
      MeasureLayout:
        drag?.isEnabled(props) || layout?.isEnabled(props) ? combined.MeasureLayout : undefined,
      ProjectionNode: combined.ProjectionNode,
    };
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/motion/utils/is-forced-motion-value.mjs

  function isForcedMotionValue(key, { layout, layoutId }) {
    return (
      transformProps.has(key) ||
      key.startsWith('origin') ||
      ((layout || layoutId !== undefined) && (!!scaleCorrectors[key] || key === 'opacity'))
    );
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/value/types/utils/get-as-type.mjs

  /**
   * Provided a value and a ValueType, returns the value as that value type.
   */
  const getValueAsType = (value, type) => {
    return type && typeof value === 'number' ? type.transform(value) : value;
  }; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/value/types/int.mjs

  const int_int = {
    ...number,
    transform: Math.round,
  }; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/value/types/maps/transform.mjs

  const transformValueTypes = {
    rotate: degrees,
    rotateX: degrees,
    rotateY: degrees,
    rotateZ: degrees,
    scale: scale,
    scaleX: scale,
    scaleY: scale,
    scaleZ: scale,
    skew: degrees,
    skewX: degrees,
    skewY: degrees,
    distance: px,
    translateX: px,
    translateY: px,
    translateZ: px,
    x: px,
    y: px,
    z: px,
    perspective: px,
    transformPerspective: px,
    opacity: alpha,
    originX: progressPercentage,
    originY: progressPercentage,
    originZ: px,
  }; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/value/types/maps/number.mjs

  const numberValueTypes = {
    // Border props
    borderWidth: px,
    borderTopWidth: px,
    borderRightWidth: px,
    borderBottomWidth: px,
    borderLeftWidth: px,
    borderRadius: px,
    radius: px,
    borderTopLeftRadius: px,
    borderTopRightRadius: px,
    borderBottomRightRadius: px,
    borderBottomLeftRadius: px,
    // Positioning props
    width: px,
    maxWidth: px,
    height: px,
    maxHeight: px,
    top: px,
    right: px,
    bottom: px,
    left: px,
    // Spacing props
    padding: px,
    paddingTop: px,
    paddingRight: px,
    paddingBottom: px,
    paddingLeft: px,
    margin: px,
    marginTop: px,
    marginRight: px,
    marginBottom: px,
    marginLeft: px,
    // Misc
    backgroundPositionX: px,
    backgroundPositionY: px,
    ...transformValueTypes,
    zIndex: int_int,
    // SVG
    fillOpacity: alpha,
    strokeOpacity: alpha,
    numOctaves: int_int,
  }; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/render/html/utils/build-transform.mjs

  const translateAlias = {
    x: 'translateX',
    y: 'translateY',
    z: 'translateZ',
    transformPerspective: 'perspective',
  };
  const numTransforms = transformPropOrder.length;
  /**
   * Build a CSS transform style from individual x/y/scale etc properties.
   *
   * This outputs with a default order of transforms/scales/rotations, this can be customised by
   * providing a transformTemplate function.
   */
  function buildTransform(latestValues, transform, transformTemplate) {
    // The transform string we're going to build into.
    let transformString = '';
    let transformIsDefault = true;
    /**
     * Loop over all possible transforms in order, adding the ones that
     * are present to the transform string.
     */
    for (let i = 0; i < numTransforms; i++) {
      const key = transformPropOrder[i];
      const value = latestValues[key];
      if (value === undefined) continue;
      let valueIsDefault = true;
      if (typeof value === 'number') {
        valueIsDefault = value === (key.startsWith('scale') ? 1 : 0);
      } else {
        valueIsDefault = parseFloat(value) === 0;
      }
      if (!valueIsDefault || transformTemplate) {
        const valueAsType = getValueAsType(value, numberValueTypes[key]);
        if (!valueIsDefault) {
          transformIsDefault = false;
          const transformName = translateAlias[key] || key;
          transformString += `${transformName}(${valueAsType}) `;
        }
        if (transformTemplate) {
          transform[key] = valueAsType;
        }
      }
    }
    transformString = transformString.trim();
    // If we have a custom `transform` template, pass our transform values and
    // generated transformString to that before returning
    if (transformTemplate) {
      transformString = transformTemplate(transform, transformIsDefault ? '' : transformString);
    } else if (transformIsDefault) {
      transformString = 'none';
    }
    return transformString;
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/render/html/utils/build-styles.mjs

  function buildHTMLStyles(state, latestValues, transformTemplate) {
    const { style, vars, transformOrigin } = state;
    // Track whether we encounter any transform or transformOrigin values.
    let hasTransform = false;
    let hasTransformOrigin = false;
    /**
     * Loop over all our latest animated values and decide whether to handle them
     * as a style or CSS variable.
     *
     * Transforms and transform origins are kept separately for further processing.
     */
    for (const key in latestValues) {
      const value = latestValues[key];
      if (transformProps.has(key)) {
        // If this is a transform, flag to enable further transform processing
        hasTransform = true;
        continue;
      } else if (isCSSVariableName(key)) {
        vars[key] = value;
        continue;
      } else {
        // Convert the value to its default value type, ie 0 -> "0px"
        const valueAsType = getValueAsType(value, numberValueTypes[key]);
        if (key.startsWith('origin')) {
          // If this is a transform origin, flag and enable further transform-origin processing
          hasTransformOrigin = true;
          transformOrigin[key] = valueAsType;
        } else {
          style[key] = valueAsType;
        }
      }
    }
    if (!latestValues.transform) {
      if (hasTransform || transformTemplate) {
        style.transform = buildTransform(latestValues, state.transform, transformTemplate);
      } else if (style.transform) {
        /**
         * If we have previously created a transform but currently don't have any,
         * reset transform style to none.
         */
        style.transform = 'none';
      }
    }
    /**
     * Build a transformOrigin style. Uses the same defaults as the browser for
     * undefined origins.
     */
    if (hasTransformOrigin) {
      const { originX = '50%', originY = '50%', originZ = 0 } = transformOrigin;
      style.transformOrigin = `${originX} ${originY} ${originZ}`;
    }
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/render/html/utils/create-render-state.mjs

  const createHtmlRenderState = () => ({
    style: {},
    transform: {},
    transformOrigin: {},
    vars: {},
  }); // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/render/html/use-props.mjs

  function copyRawValuesOnly(target, source, props) {
    for (const key in source) {
      if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {
        target[key] = source[key];
      }
    }
  }
  function useInitialMotionValues({ transformTemplate }, visualState) {
    return (0, react.useMemo)(() => {
      const state = createHtmlRenderState();
      buildHTMLStyles(state, visualState, transformTemplate);
      return Object.assign({}, state.vars, state.style);
    }, [visualState]);
  }
  function useStyle(props, visualState) {
    const styleProp = props.style || {};
    const style = {};
    /**
     * Copy non-Motion Values straight into style
     */
    copyRawValuesOnly(style, styleProp, props);
    Object.assign(style, useInitialMotionValues(props, visualState));
    return style;
  }
  function useHTMLProps(props, visualState) {
    // The `any` isn't ideal but it is the type of createElement props argument
    const htmlProps = {};
    const style = useStyle(props, visualState);
    if (props.drag && props.dragListener !== false) {
      // Disable the ghost element when a user drags
      htmlProps.draggable = false;
      // Disable text selection
      style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout = 'none';
      // Disable scrolling on the draggable direction
      style.touchAction = props.drag === true ? 'none' : `pan-${props.drag === 'x' ? 'y' : 'x'}`;
    }
    if (props.tabIndex === undefined && (props.onTap || props.onTapStart || props.whileTap)) {
      htmlProps.tabIndex = 0;
    }
    htmlProps.style = style;
    return htmlProps;
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/render/svg/utils/path.mjs

  const dashKeys = {
    offset: 'stroke-dashoffset',
    array: 'stroke-dasharray',
  };
  const camelKeys = {
    offset: 'strokeDashoffset',
    array: 'strokeDasharray',
  };
  /**
   * Build SVG path properties. Uses the path's measured length to convert
   * our custom pathLength, pathSpacing and pathOffset into stroke-dashoffset
   * and stroke-dasharray attributes.
   *
   * This function is mutative to reduce per-frame GC.
   */
  function buildSVGPath(attrs, length, spacing = 1, offset = 0, useDashCase = true) {
    // Normalise path length by setting SVG attribute pathLength to 1
    attrs.pathLength = 1;
    // We use dash case when setting attributes directly to the DOM node and camel case
    // when defining props on a React component.
    const keys = useDashCase ? dashKeys : camelKeys;
    // Build the dash offset
    attrs[keys.offset] = px.transform(-offset);
    // Build the dash array
    const pathLength = px.transform(length);
    const pathSpacing = px.transform(spacing);
    attrs[keys.array] = `${pathLength} ${pathSpacing}`;
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/render/svg/utils/build-attrs.mjs

  /**
   * Build SVG visual attrbutes, like cx and style.transform
   */
  function buildSVGAttrs(
    state,
    {
      attrX,
      attrY,
      attrScale,
      pathLength,
      pathSpacing = 1,
      pathOffset = 0,
      // This is object creation, which we try to avoid per-frame.
      ...latest
    },
    isSVGTag,
    transformTemplate,
    styleProp
  ) {
    buildHTMLStyles(state, latest, transformTemplate);
    /**
     * For svg tags we just want to make sure viewBox is animatable and treat all the styles
     * as normal HTML tags.
     */
    if (isSVGTag) {
      if (state.style.viewBox) {
        state.attrs.viewBox = state.style.viewBox;
      }
      return;
    }
    state.attrs = state.style;
    state.style = {};
    const { attrs, style } = state;
    /**
     * However, we apply transforms as CSS transforms.
     * So if we detect a transform, transformOrigin we take it from attrs and copy it into style.
     */
    if (attrs.transform) {
      style.transform = attrs.transform;
      delete attrs.transform;
    }
    if (style.transform || attrs.transformOrigin) {
      style.transformOrigin = attrs.transformOrigin ?? '50% 50%';
      delete attrs.transformOrigin;
    }
    if (style.transform) {
      /**
       * SVG's element transform-origin uses its own median as a reference.
       * Therefore, transformBox becomes a fill-box
       */
      style.transformBox = styleProp?.transformBox ?? 'fill-box';
      delete attrs.transformBox;
    }
    // Render attrX/attrY/attrScale as attributes
    if (attrX !== undefined) attrs.x = attrX;
    if (attrY !== undefined) attrs.y = attrY;
    if (attrScale !== undefined) attrs.scale = attrScale;
    // Build SVG path if one has been defined
    if (pathLength !== undefined) {
      buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);
    }
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/render/svg/utils/create-render-state.mjs

  const createSvgRenderState = () => ({
    ...createHtmlRenderState(),
    attrs: {},
  }); // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/render/svg/utils/is-svg-tag.mjs

  const isSVGTag = (tag) => typeof tag === 'string' && tag.toLowerCase() === 'svg'; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/render/svg/use-props.mjs

  function useSVGProps(props, visualState, _isStatic, Component) {
    const visualProps = (0, react.useMemo)(() => {
      const state = createSvgRenderState();
      buildSVGAttrs(state, visualState, isSVGTag(Component), props.transformTemplate, props.style);
      return {
        ...state.attrs,
        style: { ...state.style },
      };
    }, [visualState]);
    if (props.style) {
      const rawStyles = {};
      copyRawValuesOnly(rawStyles, props.style, props);
      visualProps.style = { ...rawStyles, ...visualProps.style };
    }
    return visualProps;
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/motion/utils/valid-prop.mjs

  /**
   * A list of all valid MotionProps.
   *
   * @privateRemarks
   * This doesn't throw if a `MotionProp` name is missing - it should.
   */
  const validMotionProps = new Set([
    'animate',
    'exit',
    'variants',
    'initial',
    'style',
    'values',
    'variants',
    'transition',
    'transformTemplate',
    'custom',
    'inherit',
    'onBeforeLayoutMeasure',
    'onAnimationStart',
    'onAnimationComplete',
    'onUpdate',
    'onDragStart',
    'onDrag',
    'onDragEnd',
    'onMeasureDragConstraints',
    'onDirectionLock',
    'onDragTransitionEnd',
    '_dragX',
    '_dragY',
    'onHoverStart',
    'onHoverEnd',
    'onViewportEnter',
    'onViewportLeave',
    'globalTapTarget',
    'ignoreStrict',
    'viewport',
  ]);
  /**
   * Check whether a prop name is a valid `MotionProp` key.
   *
   * @param key - Name of the property to check
   * @returns `true` is key is a valid `MotionProp`.
   *
   * @public
   */
  function isValidMotionProp(key) {
    return (
      key.startsWith('while') ||
      (key.startsWith('drag') && key !== 'draggable') ||
      key.startsWith('layout') ||
      key.startsWith('onTap') ||
      key.startsWith('onPan') ||
      key.startsWith('onLayout') ||
      validMotionProps.has(key)
    );
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/render/dom/utils/filter-props.mjs

  let shouldForward = (key) => !isValidMotionProp(key);
  function loadExternalIsValidProp(isValidProp) {
    if (!isValidProp) return;
    // Explicitly filter our events
    shouldForward = (key) => (key.startsWith('on') ? !isValidMotionProp(key) : isValidProp(key));
  }
  /**
   * Emotion and Styled Components both allow users to pass through arbitrary props to their components
   * to dynamically generate CSS. They both use the `@emotion/is-prop-valid` package to determine which
   * of these should be passed to the underlying DOM node.
   *
   * However, when styling a Motion component `styled(motion.div)`, both packages pass through *all* props
   * as it's seen as an arbitrary component rather than a DOM node. Motion only allows arbitrary props
   * passed through the `custom` prop so it doesn't *need* the payload or computational overhead of
   * `@emotion/is-prop-valid`, however to fix this problem we need to use it.
   *
   * By making it an optionalDependency we can offer this functionality only in the situations where it's
   * actually required.
   */
  try {
    /**
     * We attempt to import this package but require won't be defined in esm environments, in that case
     * isPropValid will have to be provided via `MotionContext`. In a 6.0.0 this should probably be removed
     * in favour of explicit injection.
     */
    loadExternalIsValidProp(require('@emotion/is-prop-valid').default);
  } catch {
    // We don't need to actually do anything here - the fallback is the existing `isPropValid`.
  }
  function filterProps(props, isDom, forwardMotionProps) {
    const filteredProps = {};
    for (const key in props) {
      /**
       * values is considered a valid prop by Emotion, so if it's present
       * this will be rendered out to the DOM unless explicitly filtered.
       *
       * We check the type as it could be used with the `feColorMatrix`
       * element, which we support.
       */
      if (key === 'values' && typeof props.values === 'object') continue;
      if (
        shouldForward(key) ||
        (forwardMotionProps === true && isValidMotionProp(key)) ||
        (!isDom && !isValidMotionProp(key)) ||
        // If trying to use native HTML drag events, forward drag listeners
        (props['draggable'] && key.startsWith('onDrag'))
      ) {
        filteredProps[key] = props[key];
      }
    }
    return filteredProps;
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/render/svg/lowercase-elements.mjs

  /**
   * We keep these listed separately as we use the lowercase tag names as part
   * of the runtime bundle to detect SVG components
   */
  const lowercaseSVGElements = [
    'animate',
    'circle',
    'defs',
    'desc',
    'ellipse',
    'g',
    'image',
    'line',
    'filter',
    'marker',
    'mask',
    'metadata',
    'path',
    'pattern',
    'polygon',
    'polyline',
    'rect',
    'stop',
    'switch',
    'symbol',
    'svg',
    'text',
    'tspan',
    'use',
    'view',
  ]; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/render/dom/utils/is-svg-component.mjs

  function isSVGComponent(Component) {
    if (
      /**
       * If it's not a string, it's a custom React component. Currently we only support
       * HTML custom React components.
       */
      typeof Component !== 'string' ||
      /**
       * If it contains a dash, the element is a custom HTML webcomponent.
       */
      Component.includes('-')
    ) {
      return false;
    } else if (
      /**
       * If it's in our list of lowercase SVG tags, it's an SVG component
       */
      lowercaseSVGElements.indexOf(Component) > -1 ||
      /**
       * If it contains a capital letter, it's an SVG component
       */
      /[A-Z]/u.test(Component)
    ) {
      return true;
    }
    return false;
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/render/dom/use-render.mjs

  function createUseRender(forwardMotionProps = false) {
    const useRender = (Component, props, ref, { latestValues }, isStatic) => {
      const useVisualProps = isSVGComponent(Component) ? useSVGProps : useHTMLProps;
      const visualProps = useVisualProps(props, latestValues, isStatic, Component);
      const filteredProps = filterProps(props, typeof Component === 'string', forwardMotionProps);
      const elementProps =
        Component !== react.Fragment ? { ...filteredProps, ...visualProps, ref } : {};
      /**
       * If component has been handed a motion value as its child,
       * memoise its initial value and render that. Subsequent updates
       * will be handled by the onChange handler
       */
      const { children } = props;
      const renderedChildren = (0, react.useMemo)(
        () => (isMotionValue(children) ? children.get() : children),
        [children]
      );
      return (0, react.createElement)(Component, {
        ...elementProps,
        children: renderedChildren,
      });
    };
    return useRender;
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/utils/use-constant.mjs

  /**
   * Creates a constant value over the lifecycle of a component.
   *
   * Even if `useMemo` is provided an empty array as its final argument, it doesn't offer
   * a guarantee that it won't re-run for performance reasons later on. By using `useConstant`
   * you can ensure that initialisers don't execute twice or more.
   */
  function useConstant(init) {
    const ref = (0, react.useRef)(null);
    if (ref.current === null) {
      ref.current = init();
    }
    return ref.current;
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/motion/utils/use-visual-state.mjs

  function makeState(
    { scrapeMotionValuesFromProps, createRenderState },
    props,
    context,
    presenceContext
  ) {
    const state = {
      latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps),
      renderState: createRenderState(),
    };
    return state;
  }
  const makeUseVisualState = (config) => (props, isStatic) => {
    const context = (0, react.useContext)(MotionContext);
    const presenceContext = (0, react.useContext)(PresenceContext_PresenceContext);
    const make = () => makeState(config, props, context, presenceContext);
    return isStatic ? make() : useConstant(make);
  };
  function makeLatestValues(props, context, presenceContext, scrapeMotionValues) {
    const values = {};
    const motionValues = scrapeMotionValues(props, {});
    for (const key in motionValues) {
      values[key] = resolveMotionValue(motionValues[key]);
    }
    let { initial, animate } = props;
    const isControllingVariants$1 = isControllingVariants(props);
    const isVariantNode$1 = isVariantNode(props);
    if (context && isVariantNode$1 && !isControllingVariants$1 && props.inherit !== false) {
      if (initial === undefined) initial = context.initial;
      if (animate === undefined) animate = context.animate;
    }
    let isInitialAnimationBlocked = presenceContext ? presenceContext.initial === false : false;
    isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;
    const variantToSet = isInitialAnimationBlocked ? animate : initial;
    if (variantToSet && typeof variantToSet !== 'boolean' && !isAnimationControls(variantToSet)) {
      const list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];
      for (let i = 0; i < list.length; i++) {
        const resolved = resolveVariantFromProps(props, list[i]);
        if (resolved) {
          const { transitionEnd, transition, ...target } = resolved;
          for (const key in target) {
            let valueTarget = target[key];
            if (Array.isArray(valueTarget)) {
              /**
               * Take final keyframe if the initial animation is blocked because
               * we want to initialise at the end of that blocked animation.
               */
              const index = isInitialAnimationBlocked ? valueTarget.length - 1 : 0;
              valueTarget = valueTarget[index];
            }
            if (valueTarget !== null) {
              values[key] = valueTarget;
            }
          }
          for (const key in transitionEnd) {
            values[key] = transitionEnd[key];
          }
        }
      }
    }
    return values;
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/render/html/utils/scrape-motion-values.mjs

  function scrapeMotionValuesFromProps(props, prevProps, visualElement) {
    const { style } = props;
    const newValues = {};
    for (const key in style) {
      if (
        isMotionValue(style[key]) ||
        (prevProps.style && isMotionValue(prevProps.style[key])) ||
        isForcedMotionValue(key, props) ||
        visualElement?.getValue(key)?.liveStyle !== undefined
      ) {
        newValues[key] = style[key];
      }
    }
    return newValues;
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/render/html/config-motion.mjs

  const htmlMotionConfig = {
    useVisualState: makeUseVisualState({
      scrapeMotionValuesFromProps: scrapeMotionValuesFromProps,
      createRenderState: createHtmlRenderState,
    }),
  }; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/render/svg/utils/scrape-motion-values.mjs

  function scrape_motion_values_scrapeMotionValuesFromProps(props, prevProps, visualElement) {
    const newValues = scrapeMotionValuesFromProps(props, prevProps, visualElement);
    for (const key in props) {
      if (isMotionValue(props[key]) || isMotionValue(prevProps[key])) {
        const targetKey =
          transformPropOrder.indexOf(key) !== -1
            ? 'attr' + key.charAt(0).toUpperCase() + key.substring(1)
            : key;
        newValues[targetKey] = props[key];
      }
    }
    return newValues;
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/render/svg/config-motion.mjs

  const svgMotionConfig = {
    useVisualState: makeUseVisualState({
      scrapeMotionValuesFromProps: scrape_motion_values_scrapeMotionValuesFromProps,
      createRenderState: createSvgRenderState,
    }),
  }; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/render/components/create-factory.mjs

  function createMotionComponentFactory(preloadedFeatures, createVisualElement) {
    return function createMotionComponent(
      Component,
      { forwardMotionProps } = { forwardMotionProps: false }
    ) {
      const baseConfig = isSVGComponent(Component) ? svgMotionConfig : htmlMotionConfig;
      const config = {
        ...baseConfig,
        preloadedFeatures,
        useRender: createUseRender(forwardMotionProps),
        createVisualElement,
        Component,
      };
      return createRendererMotionComponent(config);
    };
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/utils/reduced-motion/state.mjs

  // Does this device prefer reduced motion? Returns `null` server-side.
  const prefersReducedMotion = { current: null };
  const hasReducedMotionListener = { current: false }; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/utils/reduced-motion/index.mjs

  function initPrefersReducedMotion() {
    hasReducedMotionListener.current = true;
    if (!isBrowser) return;
    if (window.matchMedia) {
      const motionMediaQuery = window.matchMedia('(prefers-reduced-motion)');
      const setReducedMotionPreferences = () =>
        (prefersReducedMotion.current = motionMediaQuery.matches);
      motionMediaQuery.addListener(setReducedMotionPreferences);
      setReducedMotionPreferences();
    } else {
      prefersReducedMotion.current = false;
    }
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/render/store.mjs

  const visualElementStore = new WeakMap(); // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/render/utils/motion-values.mjs

  function updateMotionValuesFromProps(element, next, prev) {
    for (const key in next) {
      const nextValue = next[key];
      const prevValue = prev[key];
      if (isMotionValue(nextValue)) {
        /**
         * If this is a motion value found in props or style, we want to add it
         * to our visual element's motion value map.
         */
        element.addValue(key, nextValue);
      } else if (isMotionValue(prevValue)) {
        /**
         * If we're swapping from a motion value to a static value,
         * create a new motion value from that
         */
        element.addValue(key, motionValue(nextValue, { owner: element }));
      } else if (prevValue !== nextValue) {
        /**
         * If this is a flat value that has changed, update the motion value
         * or create one if it doesn't exist. We only want to do this if we're
         * not handling the value with our animation state.
         */
        if (element.hasValue(key)) {
          const existingValue = element.getValue(key);
          if (existingValue.liveStyle === true) {
            existingValue.jump(nextValue);
          } else if (!existingValue.hasAnimated) {
            existingValue.set(nextValue);
          }
        } else {
          const latestValue = element.getStaticValue(key);
          element.addValue(
            key,
            motionValue(latestValue !== undefined ? latestValue : nextValue, { owner: element })
          );
        }
      }
    }
    // Handle removed values
    for (const key in prev) {
      if (next[key] === undefined) element.removeValue(key);
    }
    return next;
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-utils/dist/es/is-numerical-string.mjs

  /**
   * Check if value is a numerical string, ie a string that is purely a number eg "100" or "-100.1"
   */
  const isNumericalString = (v) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(v); // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-utils/dist/es/is-zero-value-string.mjs

  /**
   * Check if the value is a zero value string like "0px" or "0%"
   */
  const isZeroValueString = (v) => /^0[^.\s]+$/u.test(v); // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/value/types/auto.mjs

  /**
   * ValueType for "auto"
   */
  const auto = {
    test: (v) => v === 'auto',
    parse: (v) => v,
  }; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/value/types/test.mjs

  /**
   * Tests a provided value against a ValueType
   */
  const testValueType = (v) => (type) => type.test(v); // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/value/types/dimensions.mjs

  /**
   * A list of value types commonly used for dimensions
   */
  const dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];
  /**
   * Tests a dimensional value against the list of dimension ValueTypes
   */
  const findDimensionValueType = (v) => dimensionValueTypes.find(testValueType(v)); // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/value/types/utils/find.mjs

  /**
   * A list of all ValueTypes
   */
  const valueTypes = [...dimensionValueTypes, color, complex];
  /**
   * Tests a value against the list of ValueTypes
   */
  const findValueType = (v) => valueTypes.find(testValueType(v)); // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/value/types/complex/filter.mjs

  /**
   * Properties that should default to 1 or 100%
   */
  const maxDefaults = new Set(['brightness', 'contrast', 'saturate', 'opacity']);
  function applyDefaultFilter(v) {
    const [name, value] = v.slice(0, -1).split('(');
    if (name === 'drop-shadow') return v;
    const [number] = value.match(floatRegex) || [];
    if (!number) return v;
    const unit = value.replace(number, '');
    let defaultValue = maxDefaults.has(name) ? 1 : 0;
    if (number !== value) defaultValue *= 100;
    return name + '(' + defaultValue + unit + ')';
  }
  const functionRegex = /\b([a-z-]*)\(.*?\)/gu;
  const filter = {
    ...complex,
    getAnimatableNone: (v) => {
      const functions = v.match(functionRegex);
      return functions ? functions.map(applyDefaultFilter).join(' ') : v;
    },
  }; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/value/types/maps/defaults.mjs

  /**
   * A map of default value types for common values
   */
  const defaultValueTypes = {
    ...numberValueTypes,
    // Color props
    color: color,
    backgroundColor: color,
    outlineColor: color,
    fill: color,
    stroke: color,
    // Border props
    borderColor: color,
    borderTopColor: color,
    borderRightColor: color,
    borderBottomColor: color,
    borderLeftColor: color,
    filter: filter,
    WebkitFilter: filter,
  };
  /**
   * Gets the default ValueType for the provided value key
   */
  const getDefaultValueType = (key) => defaultValueTypes[key]; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/value/types/utils/animatable-none.mjs

  function animatable_none_getAnimatableNone(key, value) {
    let defaultValueType = getDefaultValueType(key);
    if (defaultValueType !== filter) defaultValueType = complex;
    // If value is not recognised as animatable, ie "none", create an animatable version origin based on the target
    return defaultValueType.getAnimatableNone
      ? defaultValueType.getAnimatableNone(value)
      : undefined;
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/render/VisualElement.mjs

  const propEventHandlers = [
    'AnimationStart',
    'AnimationComplete',
    'Update',
    'BeforeLayoutMeasure',
    'LayoutMeasure',
    'LayoutAnimationStart',
    'LayoutAnimationComplete',
  ];
  /**
   * A VisualElement is an imperative abstraction around UI elements such as
   * HTMLElement, SVGElement, Three.Object3D etc.
   */
  class VisualElement {
    /**
     * This method takes React props and returns found MotionValues. For example, HTML
     * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
     *
     * This isn't an abstract method as it needs calling in the constructor, but it is
     * intended to be one.
     */
    scrapeMotionValuesFromProps(_props, _prevProps, _visualElement) {
      return {};
    }
    constructor(
      { parent, props, presenceContext, reducedMotionConfig, blockInitialAnimation, visualState },
      options = {}
    ) {
      /**
       * A reference to the current underlying Instance, e.g. a HTMLElement
       * or Three.Mesh etc.
       */
      this.current = null;
      /**
       * A set containing references to this VisualElement's children.
       */
      this.children = new Set();
      /**
       * Determine what role this visual element should take in the variant tree.
       */
      this.isVariantNode = false;
      this.isControllingVariants = false;
      /**
       * Decides whether this VisualElement should animate in reduced motion
       * mode.
       *
       * TODO: This is currently set on every individual VisualElement but feels
       * like it could be set globally.
       */
      this.shouldReduceMotion = null;
      /**
       * A map of all motion values attached to this visual element. Motion
       * values are source of truth for any given animated value. A motion
       * value might be provided externally by the component via props.
       */
      this.values = new Map();
      this.KeyframeResolver = KeyframeResolver;
      /**
       * Cleanup functions for active features (hover/tap/exit etc)
       */
      this.features = {};
      /**
       * A map of every subscription that binds the provided or generated
       * motion values onChange listeners to this visual element.
       */
      this.valueSubscriptions = new Map();
      /**
       * A reference to the previously-provided motion values as returned
       * from scrapeMotionValuesFromProps. We use the keys in here to determine
       * if any motion values need to be removed after props are updated.
       */
      this.prevMotionValues = {};
      /**
       * An object containing a SubscriptionManager for each active event.
       */
      this.events = {};
      /**
       * An object containing an unsubscribe function for each prop event subscription.
       * For example, every "Update" event can have multiple subscribers via
       * VisualElement.on(), but only one of those can be defined via the onUpdate prop.
       */
      this.propEventSubscriptions = {};
      this.notifyUpdate = () => this.notify('Update', this.latestValues);
      this.render = () => {
        if (!this.current) return;
        this.triggerBuild();
        this.renderInstance(this.current, this.renderState, this.props.style, this.projection);
      };
      this.renderScheduledAt = 0.0;
      this.scheduleRender = () => {
        const now = time.now();
        if (this.renderScheduledAt < now) {
          this.renderScheduledAt = now;
          frame_frame.render(this.render, false, true);
        }
      };
      const { latestValues, renderState } = visualState;
      this.latestValues = latestValues;
      this.baseTarget = { ...latestValues };
      this.initialValues = props.initial ? { ...latestValues } : {};
      this.renderState = renderState;
      this.parent = parent;
      this.props = props;
      this.presenceContext = presenceContext;
      this.depth = parent ? parent.depth + 1 : 0;
      this.reducedMotionConfig = reducedMotionConfig;
      this.options = options;
      this.blockInitialAnimation = Boolean(blockInitialAnimation);
      this.isControllingVariants = isControllingVariants(props);
      this.isVariantNode = isVariantNode(props);
      if (this.isVariantNode) {
        this.variantChildren = new Set();
      }
      this.manuallyAnimateOnMount = Boolean(parent && parent.current);
      /**
       * Any motion values that are provided to the element when created
       * aren't yet bound to the element, as this would technically be impure.
       * However, we iterate through the motion values and set them to the
       * initial values for this component.
       *
       * TODO: This is impure and we should look at changing this to run on mount.
       * Doing so will break some tests but this isn't necessarily a breaking change,
       * more a reflection of the test.
       */
      const { willChange, ...initialMotionValues } = this.scrapeMotionValuesFromProps(
        props,
        {},
        this
      );
      for (const key in initialMotionValues) {
        const value = initialMotionValues[key];
        if (latestValues[key] !== undefined && isMotionValue(value)) {
          value.set(latestValues[key], false);
        }
      }
    }
    mount(instance) {
      this.current = instance;
      visualElementStore.set(instance, this);
      if (this.projection && !this.projection.instance) {
        this.projection.mount(instance);
      }
      if (this.parent && this.isVariantNode && !this.isControllingVariants) {
        this.removeFromVariantTree = this.parent.addVariantChild(this);
      }
      this.values.forEach((value, key) => this.bindToMotionValue(key, value));
      if (!hasReducedMotionListener.current) {
        initPrefersReducedMotion();
      }
      this.shouldReduceMotion =
        this.reducedMotionConfig === 'never'
          ? false
          : this.reducedMotionConfig === 'always'
            ? true
            : prefersReducedMotion.current;
      if (false) {
        // removed by dead control flow
      }
      if (this.parent) this.parent.children.add(this);
      this.update(this.props, this.presenceContext);
    }
    unmount() {
      this.projection && this.projection.unmount();
      cancelFrame(this.notifyUpdate);
      cancelFrame(this.render);
      this.valueSubscriptions.forEach((remove) => remove());
      this.valueSubscriptions.clear();
      this.removeFromVariantTree && this.removeFromVariantTree();
      this.parent && this.parent.children.delete(this);
      for (const key in this.events) {
        this.events[key].clear();
      }
      for (const key in this.features) {
        const feature = this.features[key];
        if (feature) {
          feature.unmount();
          feature.isMounted = false;
        }
      }
      this.current = null;
    }
    bindToMotionValue(key, value) {
      if (this.valueSubscriptions.has(key)) {
        this.valueSubscriptions.get(key)();
      }
      const valueIsTransform = transformProps.has(key);
      if (valueIsTransform && this.onBindTransform) {
        this.onBindTransform();
      }
      const removeOnChange = value.on('change', (latestValue) => {
        this.latestValues[key] = latestValue;
        this.props.onUpdate && frame_frame.preRender(this.notifyUpdate);
        if (valueIsTransform && this.projection) {
          this.projection.isTransformDirty = true;
        }
      });
      const removeOnRenderRequest = value.on('renderRequest', this.scheduleRender);
      let removeSyncCheck;
      if (window.MotionCheckAppearSync) {
        removeSyncCheck = window.MotionCheckAppearSync(this, key, value);
      }
      this.valueSubscriptions.set(key, () => {
        removeOnChange();
        removeOnRenderRequest();
        if (removeSyncCheck) removeSyncCheck();
        if (value.owner) value.stop();
      });
    }
    sortNodePosition(other) {
      /**
       * If these nodes aren't even of the same type we can't compare their depth.
       */
      if (!this.current || !this.sortInstanceNodePosition || this.type !== other.type) {
        return 0;
      }
      return this.sortInstanceNodePosition(this.current, other.current);
    }
    updateFeatures() {
      let key = 'animation';
      for (key in featureDefinitions) {
        const featureDefinition = featureDefinitions[key];
        if (!featureDefinition) continue;
        const { isEnabled, Feature: FeatureConstructor } = featureDefinition;
        /**
         * If this feature is enabled but not active, make a new instance.
         */
        if (!this.features[key] && FeatureConstructor && isEnabled(this.props)) {
          this.features[key] = new FeatureConstructor(this);
        }
        /**
         * If we have a feature, mount or update it.
         */
        if (this.features[key]) {
          const feature = this.features[key];
          if (feature.isMounted) {
            feature.update();
          } else {
            feature.mount();
            feature.isMounted = true;
          }
        }
      }
    }
    triggerBuild() {
      this.build(this.renderState, this.latestValues, this.props);
    }
    /**
     * Measure the current viewport box with or without transforms.
     * Only measures axis-aligned boxes, rotate and skew must be manually
     * removed with a re-render to work.
     */
    measureViewportBox() {
      return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox();
    }
    getStaticValue(key) {
      return this.latestValues[key];
    }
    setStaticValue(key, value) {
      this.latestValues[key] = value;
    }
    /**
     * Update the provided props. Ensure any newly-added motion values are
     * added to our map, old ones removed, and listeners updated.
     */
    update(props, presenceContext) {
      if (props.transformTemplate || this.props.transformTemplate) {
        this.scheduleRender();
      }
      this.prevProps = this.props;
      this.props = props;
      this.prevPresenceContext = this.presenceContext;
      this.presenceContext = presenceContext;
      /**
       * Update prop event handlers ie onAnimationStart, onAnimationComplete
       */
      for (let i = 0; i < propEventHandlers.length; i++) {
        const key = propEventHandlers[i];
        if (this.propEventSubscriptions[key]) {
          this.propEventSubscriptions[key]();
          delete this.propEventSubscriptions[key];
        }
        const listenerName = 'on' + key;
        const listener = props[listenerName];
        if (listener) {
          this.propEventSubscriptions[key] = this.on(key, listener);
        }
      }
      this.prevMotionValues = updateMotionValuesFromProps(
        this,
        this.scrapeMotionValuesFromProps(props, this.prevProps, this),
        this.prevMotionValues
      );
      if (this.handleChildMotionValue) {
        this.handleChildMotionValue();
      }
    }
    getProps() {
      return this.props;
    }
    /**
     * Returns the variant definition with a given name.
     */
    getVariant(name) {
      return this.props.variants ? this.props.variants[name] : undefined;
    }
    /**
     * Returns the defined default transition on this component.
     */
    getDefaultTransition() {
      return this.props.transition;
    }
    getTransformPagePoint() {
      return this.props.transformPagePoint;
    }
    getClosestVariantNode() {
      return this.isVariantNode
        ? this
        : this.parent
          ? this.parent.getClosestVariantNode()
          : undefined;
    }
    /**
     * Add a child visual element to our set of children.
     */
    addVariantChild(child) {
      const closestVariantNode = this.getClosestVariantNode();
      if (closestVariantNode) {
        closestVariantNode.variantChildren && closestVariantNode.variantChildren.add(child);
        return () => closestVariantNode.variantChildren.delete(child);
      }
    }
    /**
     * Add a motion value and bind it to this visual element.
     */
    addValue(key, value) {
      // Remove existing value if it exists
      const existingValue = this.values.get(key);
      if (value !== existingValue) {
        if (existingValue) this.removeValue(key);
        this.bindToMotionValue(key, value);
        this.values.set(key, value);
        this.latestValues[key] = value.get();
      }
    }
    /**
     * Remove a motion value and unbind any active subscriptions.
     */
    removeValue(key) {
      this.values.delete(key);
      const unsubscribe = this.valueSubscriptions.get(key);
      if (unsubscribe) {
        unsubscribe();
        this.valueSubscriptions.delete(key);
      }
      delete this.latestValues[key];
      this.removeValueFromRenderState(key, this.renderState);
    }
    /**
     * Check whether we have a motion value for this key
     */
    hasValue(key) {
      return this.values.has(key);
    }
    getValue(key, defaultValue) {
      if (this.props.values && this.props.values[key]) {
        return this.props.values[key];
      }
      let value = this.values.get(key);
      if (value === undefined && defaultValue !== undefined) {
        value = motionValue(defaultValue === null ? undefined : defaultValue, { owner: this });
        this.addValue(key, value);
      }
      return value;
    }
    /**
     * If we're trying to animate to a previously unencountered value,
     * we need to check for it in our state and as a last resort read it
     * directly from the instance (which might have performance implications).
     */
    readValue(key, target) {
      let value =
        this.latestValues[key] !== undefined || !this.current
          ? this.latestValues[key]
          : (this.getBaseTargetFromProps(this.props, key) ??
            this.readValueFromInstance(this.current, key, this.options));
      if (value !== undefined && value !== null) {
        if (typeof value === 'string' && (isNumericalString(value) || isZeroValueString(value))) {
          // If this is a number read as a string, ie "0" or "200", convert it to a number
          value = parseFloat(value);
        } else if (!findValueType(value) && complex.test(target)) {
          value = animatable_none_getAnimatableNone(key, target);
        }
        this.setBaseTarget(key, isMotionValue(value) ? value.get() : value);
      }
      return isMotionValue(value) ? value.get() : value;
    }
    /**
     * Set the base target to later animate back to. This is currently
     * only hydrated on creation and when we first read a value.
     */
    setBaseTarget(key, value) {
      this.baseTarget[key] = value;
    }
    /**
     * Find the base target for a value thats been removed from all animation
     * props.
     */
    getBaseTarget(key) {
      const { initial } = this.props;
      let valueFromInitial;
      if (typeof initial === 'string' || typeof initial === 'object') {
        const variant = resolveVariantFromProps(this.props, initial, this.presenceContext?.custom);
        if (variant) {
          valueFromInitial = variant[key];
        }
      }
      /**
       * If this value still exists in the current initial variant, read that.
       */
      if (initial && valueFromInitial !== undefined) {
        return valueFromInitial;
      }
      /**
       * Alternatively, if this VisualElement config has defined a getBaseTarget
       * so we can read the value from an alternative source, try that.
       */
      const target = this.getBaseTargetFromProps(this.props, key);
      if (target !== undefined && !isMotionValue(target)) return target;
      /**
       * If the value was initially defined on initial, but it doesn't any more,
       * return undefined. Otherwise return the value as initially read from the DOM.
       */
      return this.initialValues[key] !== undefined && valueFromInitial === undefined
        ? undefined
        : this.baseTarget[key];
    }
    on(eventName, callback) {
      if (!this.events[eventName]) {
        this.events[eventName] = new SubscriptionManager();
      }
      return this.events[eventName].add(callback);
    }
    notify(eventName, ...args) {
      if (this.events[eventName]) {
        this.events[eventName].notify(...args);
      }
    }
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/animation/utils/css-variables-conversion.mjs

  /**
   * Parse Framer's special CSS variable format into a CSS token and a fallback.
   *
   * ```
   * `var(--foo, #fff)` => [`--foo`, '#fff']
   * ```
   *
   * @param current
   */
  const splitCSSVariableRegex =
    // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words
    /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;
  function parseCSSVariable(current) {
    const match = splitCSSVariableRegex.exec(current);
    if (!match) return [,];
    const [, token1, token2, fallback] = match;
    return [`--${token1 ?? token2}`, fallback];
  }
  const maxDepth = 4;
  function getVariableValue(current, element, depth = 1) {
    invariant(
      depth <= maxDepth,
      `Max CSS variable fallback depth detected in property "${current}". This may indicate a circular fallback dependency.`
    );
    const [token, fallback] = parseCSSVariable(current);
    // No CSS variable detected
    if (!token) return;
    // Attempt to read this CSS variable off the element
    const resolved = window.getComputedStyle(element).getPropertyValue(token);
    if (resolved) {
      const trimmed = resolved.trim();
      return isNumericalString(trimmed) ? parseFloat(trimmed) : trimmed;
    }
    return isCSSVariableToken(fallback) ? getVariableValue(fallback, element, depth + 1) : fallback;
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/animation/keyframes/utils/is-none.mjs

  function isNone(value) {
    if (typeof value === 'number') {
      return value === 0;
    } else if (value !== null) {
      return value === 'none' || value === '0' || isZeroValueString(value);
    } else {
      return true;
    }
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/animation/keyframes/utils/make-none-animatable.mjs

  /**
   * If we encounter keyframes like "none" or "0" and we also have keyframes like
   * "#fff" or "200px 200px" we want to find a keyframe to serve as a template for
   * the "none" keyframes. In this case "#fff" or "200px 200px" - then these get turned into
   * zero equivalents, i.e. "#fff0" or "0px 0px".
   */
  const invalidTemplates = new Set(['auto', 'none', '0']);
  function makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name) {
    let i = 0;
    let animatableTemplate = undefined;
    while (i < unresolvedKeyframes.length && !animatableTemplate) {
      const keyframe = unresolvedKeyframes[i];
      if (
        typeof keyframe === 'string' &&
        !invalidTemplates.has(keyframe) &&
        analyseComplexValue(keyframe).values.length
      ) {
        animatableTemplate = unresolvedKeyframes[i];
      }
      i++;
    }
    if (animatableTemplate && name) {
      for (const noneIndex of noneKeyframeIndexes) {
        unresolvedKeyframes[noneIndex] = animatable_none_getAnimatableNone(
          name,
          animatableTemplate
        );
      }
    }
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/motion-dom/dist/es/animation/keyframes/DOMKeyframesResolver.mjs

  class DOMKeyframesResolver extends KeyframeResolver {
    constructor(unresolvedKeyframes, onComplete, name, motionValue, element) {
      super(unresolvedKeyframes, onComplete, name, motionValue, element, true);
    }
    readKeyframes() {
      const { unresolvedKeyframes, element, name } = this;
      if (!element || !element.current) return;
      super.readKeyframes();
      /**
       * If any keyframe is a CSS variable, we need to find its value by sampling the element
       */
      for (let i = 0; i < unresolvedKeyframes.length; i++) {
        let keyframe = unresolvedKeyframes[i];
        if (typeof keyframe === 'string') {
          keyframe = keyframe.trim();
          if (isCSSVariableToken(keyframe)) {
            const resolved = getVariableValue(keyframe, element.current);
            if (resolved !== undefined) {
              unresolvedKeyframes[i] = resolved;
            }
            if (i === unresolvedKeyframes.length - 1) {
              this.finalKeyframe = keyframe;
            }
          }
        }
      }
      /**
       * Resolve "none" values. We do this potentially twice - once before and once after measuring keyframes.
       * This could be seen as inefficient but it's a trade-off to avoid measurements in more situations, which
       * have a far bigger performance impact.
       */
      this.resolveNoneKeyframes();
      /**
       * Check to see if unit type has changed. If so schedule jobs that will
       * temporarily set styles to the destination keyframes.
       * Skip if we have more than two keyframes or this isn't a positional value.
       * TODO: We can throw if there are multiple keyframes and the value type changes.
       */
      if (!positionalKeys.has(name) || unresolvedKeyframes.length !== 2) {
        return;
      }
      const [origin, target] = unresolvedKeyframes;
      const originType = findDimensionValueType(origin);
      const targetType = findDimensionValueType(target);
      /**
       * Either we don't recognise these value types or we can animate between them.
       */
      if (originType === targetType) return;
      /**
       * If both values are numbers or pixels, we can animate between them by
       * converting them to numbers.
       */
      if (isNumOrPxType(originType) && isNumOrPxType(targetType)) {
        for (let i = 0; i < unresolvedKeyframes.length; i++) {
          const value = unresolvedKeyframes[i];
          if (typeof value === 'string') {
            unresolvedKeyframes[i] = parseFloat(value);
          }
        }
      } else if (positionalValues[name]) {
        /**
         * Else, the only way to resolve this is by measuring the element.
         */
        this.needsMeasurement = true;
      }
    }
    resolveNoneKeyframes() {
      const { unresolvedKeyframes, name } = this;
      const noneKeyframeIndexes = [];
      for (let i = 0; i < unresolvedKeyframes.length; i++) {
        if (unresolvedKeyframes[i] === null || isNone(unresolvedKeyframes[i])) {
          noneKeyframeIndexes.push(i);
        }
      }
      if (noneKeyframeIndexes.length) {
        makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name);
      }
    }
    measureInitialState() {
      const { element, unresolvedKeyframes, name } = this;
      if (!element || !element.current) return;
      if (name === 'height') {
        this.suspendedScrollY = window.pageYOffset;
      }
      this.measuredOrigin = positionalValues[name](
        element.measureViewportBox(),
        window.getComputedStyle(element.current)
      );
      unresolvedKeyframes[0] = this.measuredOrigin;
      // Set final key frame to measure after next render
      const measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
      if (measureKeyframe !== undefined) {
        element.getValue(name, measureKeyframe).jump(measureKeyframe, false);
      }
    }
    measureEndState() {
      const { element, name, unresolvedKeyframes } = this;
      if (!element || !element.current) return;
      const value = element.getValue(name);
      value && value.jump(this.measuredOrigin, false);
      const finalKeyframeIndex = unresolvedKeyframes.length - 1;
      const finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];
      unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](
        element.measureViewportBox(),
        window.getComputedStyle(element.current)
      );
      if (finalKeyframe !== null && this.finalKeyframe === undefined) {
        this.finalKeyframe = finalKeyframe;
      }
      // If we removed transform values, reapply them before the next render
      if (this.removedTransforms?.length) {
        this.removedTransforms.forEach(([unsetTransformName, unsetTransformValue]) => {
          element.getValue(unsetTransformName).set(unsetTransformValue);
        });
      }
      this.resolveNoneKeyframes();
    }
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/render/dom/DOMVisualElement.mjs

  class DOMVisualElement extends VisualElement {
    constructor() {
      super(...arguments);
      this.KeyframeResolver = DOMKeyframesResolver;
    }
    sortInstanceNodePosition(a, b) {
      /**
       * compareDocumentPosition returns a bitmask, by using the bitwise &
       * we're returning true if 2 in that bitmask is set to true. 2 is set
       * to true if b preceeds a.
       */
      return a.compareDocumentPosition(b) & 2 ? 1 : -1;
    }
    getBaseTargetFromProps(props, key) {
      return props.style ? props.style[key] : undefined;
    }
    removeValueFromRenderState(key, { vars, style }) {
      delete vars[key];
      delete style[key];
    }
    handleChildMotionValue() {
      if (this.childSubscription) {
        this.childSubscription();
        delete this.childSubscription;
      }
      const { children } = this.props;
      if (isMotionValue(children)) {
        this.childSubscription = children.on('change', (latest) => {
          if (this.current) {
            this.current.textContent = `${latest}`;
          }
        });
      }
    }
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/render/html/utils/render.mjs

  function renderHTML(element, { style, vars }, styleProp, projection) {
    Object.assign(element.style, style, projection && projection.getProjectionStyles(styleProp));
    // Loop over any CSS variables and assign those.
    for (const key in vars) {
      element.style.setProperty(key, vars[key]);
    }
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/render/html/HTMLVisualElement.mjs

  function HTMLVisualElement_getComputedStyle(element) {
    return window.getComputedStyle(element);
  }
  class HTMLVisualElement extends DOMVisualElement {
    constructor() {
      super(...arguments);
      this.type = 'html';
      this.renderInstance = renderHTML;
    }
    readValueFromInstance(instance, key) {
      if (transformProps.has(key)) {
        return this.projection?.isProjecting
          ? defaultTransformValue(key)
          : readTransformValue(instance, key);
      } else {
        const computedStyle = HTMLVisualElement_getComputedStyle(instance);
        const value =
          (isCSSVariableName(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;
        return typeof value === 'string' ? value.trim() : value;
      }
    }
    measureInstanceViewportBox(instance, { transformPagePoint }) {
      return measureViewportBox(instance, transformPagePoint);
    }
    build(renderState, latestValues, props) {
      buildHTMLStyles(renderState, latestValues, props.transformTemplate);
    }
    scrapeMotionValuesFromProps(props, prevProps, visualElement) {
      return scrapeMotionValuesFromProps(props, prevProps, visualElement);
    }
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/render/svg/utils/camel-case-attrs.mjs

  /**
   * A set of attribute names that are always read/written as camel case.
   */
  const camelCaseAttributes = new Set([
    'baseFrequency',
    'diffuseConstant',
    'kernelMatrix',
    'kernelUnitLength',
    'keySplines',
    'keyTimes',
    'limitingConeAngle',
    'markerHeight',
    'markerWidth',
    'numOctaves',
    'targetX',
    'targetY',
    'surfaceScale',
    'specularConstant',
    'specularExponent',
    'stdDeviation',
    'tableValues',
    'viewBox',
    'gradientTransform',
    'pathLength',
    'startOffset',
    'textLength',
    'lengthAdjust',
  ]); // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/render/svg/utils/render.mjs

  function renderSVG(element, renderState, _styleProp, projection) {
    renderHTML(element, renderState, undefined, projection);
    for (const key in renderState.attrs) {
      element.setAttribute(
        !camelCaseAttributes.has(key) ? camelToDash(key) : key,
        renderState.attrs[key]
      );
    }
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/render/svg/SVGVisualElement.mjs

  class SVGVisualElement extends DOMVisualElement {
    constructor() {
      super(...arguments);
      this.type = 'svg';
      this.isSVGTag = false;
      this.measureInstanceViewportBox = createBox;
    }
    getBaseTargetFromProps(props, key) {
      return props[key];
    }
    readValueFromInstance(instance, key) {
      if (transformProps.has(key)) {
        const defaultType = getDefaultValueType(key);
        return defaultType ? defaultType.default || 0 : 0;
      }
      key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;
      return instance.getAttribute(key);
    }
    scrapeMotionValuesFromProps(props, prevProps, visualElement) {
      return scrape_motion_values_scrapeMotionValuesFromProps(props, prevProps, visualElement);
    }
    build(renderState, latestValues, props) {
      buildSVGAttrs(renderState, latestValues, this.isSVGTag, props.transformTemplate, props.style);
    }
    renderInstance(instance, renderState, styleProp, projection) {
      renderSVG(instance, renderState, styleProp, projection);
    }
    mount(instance) {
      this.isSVGTag = isSVGTag(instance.tagName);
      super.mount(instance);
    }
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/render/dom/create-visual-element.mjs

  const createDomVisualElement = (Component, options) => {
    return isSVGComponent(Component)
      ? new SVGVisualElement(options)
      : new HTMLVisualElement(options, {
          allowProjection: Component !== react.Fragment,
        });
  }; // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/render/components/motion/create.mjs

  const createMotionComponent = /*@__PURE__*/ createMotionComponentFactory(
    {
      ...animations,
      ...gestureAnimations,
      ...drag,
      ...layout,
    },
    createDomVisualElement
  ); // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/render/components/motion/proxy.mjs

  const motion = /*@__PURE__*/ createDOMMotionComponentProxy(createMotionComponent); // ./node_modules/.pnpm/@livekit+components-react@2.9.15_@livekit+krisp-noise-filter@0.2.16_livekit-client@2.15.8_@ty_yekyi6zrdl5hlnuib5mo4n56ga/node_modules/@livekit/components-react/dist/contexts-BGRNBsB8.mjs

  const contexts_BGRNBsB8_De = Math.min,
    contexts_BGRNBsB8_ae = Math.max,
    contexts_BGRNBsB8_$e = Math.round,
    contexts_BGRNBsB8_e = Math.floor,
    contexts_BGRNBsB8_Q = (e) => ({
      x: e,
      y: e,
    }),
    qn = {
      left: 'right',
      right: 'left',
      bottom: 'top',
      top: 'bottom',
    },
    Kn = {
      start: 'end',
      end: 'start',
    };
  function Et(e, t, n) {
    return contexts_BGRNBsB8_ae(e, contexts_BGRNBsB8_De(t, n));
  }
  function contexts_BGRNBsB8_He(e, t) {
    return typeof e == 'function' ? e(t) : e;
  }
  function contexts_BGRNBsB8_ce(e) {
    return e.split('-')[0];
  }
  function contexts_BGRNBsB8_ze(e) {
    return e.split('-')[1];
  }
  function qt(e) {
    return e === 'x' ? 'y' : 'x';
  }
  function Kt(e) {
    return e === 'y' ? 'height' : 'width';
  }
  function contexts_BGRNBsB8_ve(e) {
    return ['top', 'bottom'].includes(contexts_BGRNBsB8_ce(e)) ? 'y' : 'x';
  }
  function Gt(e) {
    return qt(contexts_BGRNBsB8_ve(e));
  }
  function Gn(e, t, n) {
    n === void 0 && (n = !1);
    const r = contexts_BGRNBsB8_ze(e),
      i = Gt(e),
      o = Kt(i);
    let s =
      i === 'x'
        ? r === (n ? 'end' : 'start')
          ? 'right'
          : 'left'
        : r === 'start'
          ? 'bottom'
          : 'top';
    return (t.reference[o] > t.floating[o] && (s = Ne(s)), [s, Ne(s)]);
  }
  function Qn(e) {
    const t = Ne(e);
    return [contexts_BGRNBsB8_ot(e), t, contexts_BGRNBsB8_ot(t)];
  }
  function contexts_BGRNBsB8_ot(e) {
    return e.replace(/start|end/g, (t) => Kn[t]);
  }
  function Jn(e, t, n) {
    const r = ['left', 'right'],
      i = ['right', 'left'],
      o = ['top', 'bottom'],
      s = ['bottom', 'top'];
    switch (e) {
      case 'top':
      case 'bottom':
        return n ? (t ? i : r) : t ? r : i;
      case 'left':
      case 'right':
        return t ? o : s;
      default:
        return [];
    }
  }
  function Xn(e, t, n, r) {
    const i = contexts_BGRNBsB8_ze(e);
    let o = Jn(contexts_BGRNBsB8_ce(e), n === 'start', r);
    return (
      i && ((o = o.map((s) => s + '-' + i)), t && (o = o.concat(o.map(contexts_BGRNBsB8_ot)))),
      o
    );
  }
  function Ne(e) {
    return e.replace(/left|right|bottom|top/g, (t) => qn[t]);
  }
  function Zn(e) {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      ...e,
    };
  }
  function er(e) {
    return typeof e != 'number'
      ? Zn(e)
      : {
          top: e,
          right: e,
          bottom: e,
          left: e,
        };
  }
  function contexts_BGRNBsB8_Fe(e) {
    const { x: t, y: n, width: r, height: i } = e;
    return {
      width: r,
      height: i,
      top: n,
      left: t,
      right: t + r,
      bottom: n + i,
      x: t,
      y: n,
    };
  }
  function Ct(e, t, n) {
    let { reference: r, floating: i } = e;
    const o = contexts_BGRNBsB8_ve(t),
      s = Gt(t),
      a = Kt(s),
      c = contexts_BGRNBsB8_ce(t),
      u = o === 'y',
      l = r.x + r.width / 2 - i.width / 2,
      f = r.y + r.height / 2 - i.height / 2,
      v = r[a] / 2 - i[a] / 2;
    let d;
    switch (c) {
      case 'top':
        d = {
          x: l,
          y: r.y - i.height,
        };
        break;
      case 'bottom':
        d = {
          x: l,
          y: r.y + r.height,
        };
        break;
      case 'right':
        d = {
          x: r.x + r.width,
          y: f,
        };
        break;
      case 'left':
        d = {
          x: r.x - i.width,
          y: f,
        };
        break;
      default:
        d = {
          x: r.x,
          y: r.y,
        };
    }
    switch (contexts_BGRNBsB8_ze(t)) {
      case 'start':
        d[s] -= v * (n && u ? -1 : 1);
        break;
      case 'end':
        d[s] += v * (n && u ? -1 : 1);
        break;
    }
    return d;
  }
  const tr = async (e, t, n) => {
    const {
        placement: r = 'bottom',
        strategy: i = 'absolute',
        middleware: o = [],
        platform: s,
      } = n,
      a = o.filter(Boolean),
      c = await (s.isRTL == null ? void 0 : s.isRTL(t));
    let u = await s.getElementRects({
        reference: e,
        floating: t,
        strategy: i,
      }),
      { x: l, y: f } = Ct(u, r, c),
      v = r,
      d = {},
      m = 0;
    for (let p = 0; p < a.length; p++) {
      const { name: g, fn: h } = a[p],
        {
          x,
          y: E,
          data: A,
          reset: b,
        } = await h({
          x: l,
          y: f,
          initialPlacement: r,
          placement: v,
          strategy: i,
          middlewareData: d,
          rects: u,
          platform: s,
          elements: {
            reference: e,
            floating: t,
          },
        });
      ((l = x ?? l),
        (f = E ?? f),
        (d = {
          ...d,
          [g]: {
            ...d[g],
            ...A,
          },
        }),
        b &&
          m <= 50 &&
          (m++,
          typeof b == 'object' &&
            (b.placement && (v = b.placement),
            b.rects &&
              (u =
                b.rects === !0
                  ? await s.getElementRects({
                      reference: e,
                      floating: t,
                      strategy: i,
                    })
                  : b.rects),
            ({ x: l, y: f } = Ct(u, v, c))),
          (p = -1)));
    }
    return {
      x: l,
      y: f,
      placement: v,
      strategy: i,
      middlewareData: d,
    };
  };
  async function Qt(e, t) {
    var n;
    t === void 0 && (t = {});
    const { x: r, y: i, platform: o, rects: s, elements: a, strategy: c } = e,
      {
        boundary: u = 'clippingAncestors',
        rootBoundary: l = 'viewport',
        elementContext: f = 'floating',
        altBoundary: v = !1,
        padding: d = 0,
      } = contexts_BGRNBsB8_He(t, e),
      m = er(d),
      g = a[v ? (f === 'floating' ? 'reference' : 'floating') : f],
      h = contexts_BGRNBsB8_Fe(
        await o.getClippingRect({
          element:
            (n = await (o.isElement == null ? void 0 : o.isElement(g))) == null || n
              ? g
              : g.contextElement ||
                (await (o.getDocumentElement == null ? void 0 : o.getDocumentElement(a.floating))),
          boundary: u,
          rootBoundary: l,
          strategy: c,
        })
      ),
      x =
        f === 'floating'
          ? {
              x: r,
              y: i,
              width: s.floating.width,
              height: s.floating.height,
            }
          : s.reference,
      E = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(a.floating)),
      A = (await (o.isElement == null ? void 0 : o.isElement(E)))
        ? (await (o.getScale == null ? void 0 : o.getScale(E))) || {
            x: 1,
            y: 1,
          }
        : {
            x: 1,
            y: 1,
          },
      b = contexts_BGRNBsB8_Fe(
        o.convertOffsetParentRelativeRectToViewportRelativeRect
          ? await o.convertOffsetParentRelativeRectToViewportRelativeRect({
              elements: a,
              rect: x,
              offsetParent: E,
              strategy: c,
            })
          : x
      );
    return {
      top: (h.top - b.top + m.top) / A.y,
      bottom: (b.bottom - h.bottom + m.bottom) / A.y,
      left: (h.left - b.left + m.left) / A.x,
      right: (b.right - h.right + m.right) / A.x,
    };
  }
  const nr = function (e) {
    return (
      e === void 0 && (e = {}),
      {
        name: 'flip',
        options: e,
        async fn(t) {
          var n, r;
          const {
              placement: i,
              middlewareData: o,
              rects: s,
              initialPlacement: a,
              platform: c,
              elements: u,
            } = t,
            {
              mainAxis: l = !0,
              crossAxis: f = !0,
              fallbackPlacements: v,
              fallbackStrategy: d = 'bestFit',
              fallbackAxisSideDirection: m = 'none',
              flipAlignment: p = !0,
              ...g
            } = contexts_BGRNBsB8_He(e, t);
          if ((n = o.arrow) != null && n.alignmentOffset) return {};
          const h = contexts_BGRNBsB8_ce(i),
            x = contexts_BGRNBsB8_ve(a),
            E = contexts_BGRNBsB8_ce(a) === a,
            A = await (c.isRTL == null ? void 0 : c.isRTL(u.floating)),
            b = v || (E || !p ? [Ne(a)] : Qn(a)),
            S = m !== 'none';
          !v && S && b.push(...Xn(a, p, m, A));
          const C = [a, ...b],
            $ = await Qt(t, g),
            I = [];
          let z = ((r = o.flip) == null ? void 0 : r.overflows) || [];
          if ((l && I.push($[h]), f)) {
            const G = Gn(i, s, A);
            I.push($[G[0]], $[G[1]]);
          }
          if (
            ((z = [
              ...z,
              {
                placement: i,
                overflows: I,
              },
            ]),
            !I.every((G) => G <= 0))
          ) {
            var T, _;
            const G = (((T = o.flip) == null ? void 0 : T.index) || 0) + 1,
              ke = C[G];
            if (ke)
              return {
                data: {
                  index: G,
                  overflows: z,
                },
                reset: {
                  placement: ke,
                },
              };
            let Se =
              (_ = z
                .filter((de) => de.overflows[0] <= 0)
                .sort((de, ne) => de.overflows[1] - ne.overflows[1])[0]) == null
                ? void 0
                : _.placement;
            if (!Se)
              switch (d) {
                case 'bestFit': {
                  var Z;
                  const de =
                    (Z = z
                      .filter((ne) => {
                        if (S) {
                          const re = contexts_BGRNBsB8_ve(ne.placement);
                          return (
                            re === x || // Create a bias to the `y` side axis due to horizontal
                            // reading directions favoring greater width.
                            re === 'y'
                          );
                        }
                        return !0;
                      })
                      .map((ne) => [
                        ne.placement,
                        ne.overflows.filter((re) => re > 0).reduce((re, Bn) => re + Bn, 0),
                      ])
                      .sort((ne, re) => ne[1] - re[1])[0]) == null
                      ? void 0
                      : Z[0];
                  de && (Se = de);
                  break;
                }
                case 'initialPlacement':
                  Se = a;
                  break;
              }
            if (i !== Se)
              return {
                reset: {
                  placement: Se,
                },
              };
          }
          return {};
        },
      }
    );
  };
  async function rr(e, t) {
    const { placement: n, platform: r, elements: i } = e,
      o = await (r.isRTL == null ? void 0 : r.isRTL(i.floating)),
      s = contexts_BGRNBsB8_ce(n),
      a = contexts_BGRNBsB8_ze(n),
      c = contexts_BGRNBsB8_ve(n) === 'y',
      u = ['left', 'top'].includes(s) ? -1 : 1,
      l = o && c ? -1 : 1,
      f = contexts_BGRNBsB8_He(t, e);
    let {
      mainAxis: v,
      crossAxis: d,
      alignmentAxis: m,
    } = typeof f == 'number'
      ? {
          mainAxis: f,
          crossAxis: 0,
          alignmentAxis: null,
        }
      : {
          mainAxis: f.mainAxis || 0,
          crossAxis: f.crossAxis || 0,
          alignmentAxis: f.alignmentAxis,
        };
    return (
      a && typeof m == 'number' && (d = a === 'end' ? m * -1 : m),
      c
        ? {
            x: d * l,
            y: v * u,
          }
        : {
            x: v * u,
            y: d * l,
          }
    );
  }
  const ir = function (e) {
      return (
        e === void 0 && (e = 0),
        {
          name: 'offset',
          options: e,
          async fn(t) {
            var n, r;
            const { x: i, y: o, placement: s, middlewareData: a } = t,
              c = await rr(t, e);
            return s === ((n = a.offset) == null ? void 0 : n.placement) &&
              (r = a.arrow) != null &&
              r.alignmentOffset
              ? {}
              : {
                  x: i + c.x,
                  y: o + c.y,
                  data: {
                    ...c,
                    placement: s,
                  },
                };
          },
        }
      );
    },
    or = function (e) {
      return (
        e === void 0 && (e = {}),
        {
          name: 'shift',
          options: e,
          async fn(t) {
            const { x: n, y: r, placement: i } = t,
              {
                mainAxis: o = !0,
                crossAxis: s = !1,
                limiter: a = {
                  fn: (g) => {
                    let { x: h, y: x } = g;
                    return {
                      x: h,
                      y: x,
                    };
                  },
                },
                ...c
              } = contexts_BGRNBsB8_He(e, t),
              u = {
                x: n,
                y: r,
              },
              l = await Qt(t, c),
              f = contexts_BGRNBsB8_ve(contexts_BGRNBsB8_ce(i)),
              v = qt(f);
            let d = u[v],
              m = u[f];
            if (o) {
              const g = v === 'y' ? 'top' : 'left',
                h = v === 'y' ? 'bottom' : 'right',
                x = d + l[g],
                E = d - l[h];
              d = Et(x, d, E);
            }
            if (s) {
              const g = f === 'y' ? 'top' : 'left',
                h = f === 'y' ? 'bottom' : 'right',
                x = m + l[g],
                E = m - l[h];
              m = Et(x, m, E);
            }
            const p = a.fn({
              ...t,
              [v]: d,
              [f]: m,
            });
            return {
              ...p,
              data: {
                x: p.x - n,
                y: p.y - r,
                enabled: {
                  [v]: o,
                  [f]: s,
                },
              },
            };
          },
        }
      );
    };
  function contexts_BGRNBsB8_Ye() {
    return typeof window < 'u';
  }
  function contexts_BGRNBsB8_ye(e) {
    return Jt(e) ? (e.nodeName || '').toLowerCase() : '#document';
  }
  function W(e) {
    var t;
    return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
  }
  function contexts_BGRNBsB8_X(e) {
    var t;
    return (t = (Jt(e) ? e.ownerDocument : e.document) || window.document) == null
      ? void 0
      : t.documentElement;
  }
  function Jt(e) {
    return contexts_BGRNBsB8_Ye() ? e instanceof Node || e instanceof W(e).Node : !1;
  }
  function contexts_BGRNBsB8_q(e) {
    return contexts_BGRNBsB8_Ye() ? e instanceof Element || e instanceof W(e).Element : !1;
  }
  function J(e) {
    return contexts_BGRNBsB8_Ye() ? e instanceof HTMLElement || e instanceof W(e).HTMLElement : !1;
  }
  function Pt(e) {
    return !contexts_BGRNBsB8_Ye() || typeof ShadowRoot > 'u'
      ? !1
      : e instanceof ShadowRoot || e instanceof W(e).ShadowRoot;
  }
  function Ae(e) {
    const { overflow: t, overflowX: n, overflowY: r, display: i } = K(e);
    return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && !['inline', 'contents'].includes(i);
  }
  function sr(e) {
    return ['table', 'td', 'th'].includes(contexts_BGRNBsB8_ye(e));
  }
  function contexts_BGRNBsB8_qe(e) {
    return [':popover-open', ':modal'].some((t) => {
      try {
        return e.matches(t);
      } catch {
        return !1;
      }
    });
  }
  function contexts_BGRNBsB8_dt(e) {
    const t = pt(),
      n = contexts_BGRNBsB8_q(e) ? K(e) : e;
    return (
      ['transform', 'translate', 'scale', 'rotate', 'perspective'].some((r) =>
        n[r] ? n[r] !== 'none' : !1
      ) ||
      (n.containerType ? n.containerType !== 'normal' : !1) ||
      (!t && (n.backdropFilter ? n.backdropFilter !== 'none' : !1)) ||
      (!t && (n.filter ? n.filter !== 'none' : !1)) ||
      ['transform', 'translate', 'scale', 'rotate', 'perspective', 'filter'].some((r) =>
        (n.willChange || '').includes(r)
      ) ||
      ['paint', 'layout', 'strict', 'content'].some((r) => (n.contain || '').includes(r))
    );
  }
  function ar(e) {
    let t = contexts_BGRNBsB8_oe(e);
    for (; J(t) && !contexts_BGRNBsB8_me(t); ) {
      if (contexts_BGRNBsB8_dt(t)) return t;
      if (contexts_BGRNBsB8_qe(t)) return null;
      t = contexts_BGRNBsB8_oe(t);
    }
    return null;
  }
  function pt() {
    return typeof CSS > 'u' || !CSS.supports ? !1 : CSS.supports('-webkit-backdrop-filter', 'none');
  }
  function contexts_BGRNBsB8_me(e) {
    return ['html', 'body', '#document'].includes(contexts_BGRNBsB8_ye(e));
  }
  function K(e) {
    return W(e).getComputedStyle(e);
  }
  function Ke(e) {
    return contexts_BGRNBsB8_q(e)
      ? {
          scrollLeft: e.scrollLeft,
          scrollTop: e.scrollTop,
        }
      : {
          scrollLeft: e.scrollX,
          scrollTop: e.scrollY,
        };
  }
  function contexts_BGRNBsB8_oe(e) {
    if (contexts_BGRNBsB8_ye(e) === 'html') return e;
    const t =
      // Step into the shadow DOM of the parent of a slotted node.
      e.assignedSlot || // DOM Element detected.
      e.parentNode || // ShadowRoot detected.
      (Pt(e) && e.host) || // Fallback.
      contexts_BGRNBsB8_X(e);
    return Pt(t) ? t.host : t;
  }
  function Xt(e) {
    const t = contexts_BGRNBsB8_oe(e);
    return contexts_BGRNBsB8_me(t)
      ? e.ownerDocument
        ? e.ownerDocument.body
        : e.body
      : J(t) && Ae(t)
        ? t
        : Xt(t);
  }
  function contexts_BGRNBsB8_Ee(e, t, n) {
    var r;
    (t === void 0 && (t = []), n === void 0 && (n = !0));
    const i = Xt(e),
      o = i === ((r = e.ownerDocument) == null ? void 0 : r.body),
      s = W(i);
    if (o) {
      const a = contexts_BGRNBsB8_st(s);
      return t.concat(
        s,
        s.visualViewport || [],
        Ae(i) ? i : [],
        a && n ? contexts_BGRNBsB8_Ee(a) : []
      );
    }
    return t.concat(i, contexts_BGRNBsB8_Ee(i, [], n));
  }
  function contexts_BGRNBsB8_st(e) {
    return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null;
  }
  function Zt(e) {
    const t = K(e);
    let n = parseFloat(t.width) || 0,
      r = parseFloat(t.height) || 0;
    const i = J(e),
      o = i ? e.offsetWidth : n,
      s = i ? e.offsetHeight : r,
      a = contexts_BGRNBsB8_$e(n) !== o || contexts_BGRNBsB8_$e(r) !== s;
    return (
      a && ((n = o), (r = s)),
      {
        width: n,
        height: r,
        $: a,
      }
    );
  }
  function contexts_BGRNBsB8_ht(e) {
    return contexts_BGRNBsB8_q(e) ? e : e.contextElement;
  }
  function contexts_BGRNBsB8_pe(e) {
    const t = contexts_BGRNBsB8_ht(e);
    if (!J(t)) return contexts_BGRNBsB8_Q(1);
    const n = t.getBoundingClientRect(),
      { width: r, height: i, $: o } = Zt(t);
    let s = (o ? contexts_BGRNBsB8_$e(n.width) : n.width) / r,
      a = (o ? contexts_BGRNBsB8_$e(n.height) : n.height) / i;
    return (
      (!s || !Number.isFinite(s)) && (s = 1),
      (!a || !Number.isFinite(a)) && (a = 1),
      {
        x: s,
        y: a,
      }
    );
  }
  const cr = /* @__PURE__ */ contexts_BGRNBsB8_Q(0);
  function en(e) {
    const t = W(e);
    return !pt() || !t.visualViewport
      ? cr
      : {
          x: t.visualViewport.offsetLeft,
          y: t.visualViewport.offsetTop,
        };
  }
  function ur(e, t, n) {
    return (t === void 0 && (t = !1), !n || (t && n !== W(e)) ? !1 : t);
  }
  function contexts_BGRNBsB8_ue(e, t, n, r) {
    (t === void 0 && (t = !1), n === void 0 && (n = !1));
    const i = e.getBoundingClientRect(),
      o = contexts_BGRNBsB8_ht(e);
    let s = contexts_BGRNBsB8_Q(1);
    t &&
      (r ? contexts_BGRNBsB8_q(r) && (s = contexts_BGRNBsB8_pe(r)) : (s = contexts_BGRNBsB8_pe(e)));
    const a = ur(o, n, r) ? en(o) : contexts_BGRNBsB8_Q(0);
    let c = (i.left + a.x) / s.x,
      u = (i.top + a.y) / s.y,
      l = i.width / s.x,
      f = i.height / s.y;
    if (o) {
      const v = W(o),
        d = r && contexts_BGRNBsB8_q(r) ? W(r) : r;
      let m = v,
        p = contexts_BGRNBsB8_st(m);
      for (; p && r && d !== m; ) {
        const g = contexts_BGRNBsB8_pe(p),
          h = p.getBoundingClientRect(),
          x = K(p),
          E = h.left + (p.clientLeft + parseFloat(x.paddingLeft)) * g.x,
          A = h.top + (p.clientTop + parseFloat(x.paddingTop)) * g.y;
        ((c *= g.x),
          (u *= g.y),
          (l *= g.x),
          (f *= g.y),
          (c += E),
          (u += A),
          (m = W(p)),
          (p = contexts_BGRNBsB8_st(m)));
      }
    }
    return contexts_BGRNBsB8_Fe({
      width: l,
      height: f,
      x: c,
      y: u,
    });
  }
  function vt(e, t) {
    const n = Ke(e).scrollLeft;
    return t ? t.left + n : contexts_BGRNBsB8_ue(contexts_BGRNBsB8_X(e)).left + n;
  }
  function tn(e, t, n) {
    n === void 0 && (n = !1);
    const r = e.getBoundingClientRect(),
      i =
        r.left +
        t.scrollLeft -
        (n
          ? 0
          : // RTL <body> scrollbar.
            vt(e, r)),
      o = r.top + t.scrollTop;
    return {
      x: i,
      y: o,
    };
  }
  function lr(e) {
    let { elements: t, rect: n, offsetParent: r, strategy: i } = e;
    const o = i === 'fixed',
      s = contexts_BGRNBsB8_X(r),
      a = t ? contexts_BGRNBsB8_qe(t.floating) : !1;
    if (r === s || (a && o)) return n;
    let c = {
        scrollLeft: 0,
        scrollTop: 0,
      },
      u = contexts_BGRNBsB8_Q(1);
    const l = contexts_BGRNBsB8_Q(0),
      f = J(r);
    if ((f || (!f && !o)) && ((contexts_BGRNBsB8_ye(r) !== 'body' || Ae(s)) && (c = Ke(r)), J(r))) {
      const d = contexts_BGRNBsB8_ue(r);
      ((u = contexts_BGRNBsB8_pe(r)), (l.x = d.x + r.clientLeft), (l.y = d.y + r.clientTop));
    }
    const v = s && !f && !o ? tn(s, c, !0) : contexts_BGRNBsB8_Q(0);
    return {
      width: n.width * u.x,
      height: n.height * u.y,
      x: n.x * u.x - c.scrollLeft * u.x + l.x + v.x,
      y: n.y * u.y - c.scrollTop * u.y + l.y + v.y,
    };
  }
  function fr(e) {
    return Array.from(e.getClientRects());
  }
  function dr(e) {
    const t = contexts_BGRNBsB8_X(e),
      n = Ke(e),
      r = e.ownerDocument.body,
      i = contexts_BGRNBsB8_ae(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth),
      o = contexts_BGRNBsB8_ae(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight);
    let s = -n.scrollLeft + vt(e);
    const a = -n.scrollTop;
    return (
      K(r).direction === 'rtl' && (s += contexts_BGRNBsB8_ae(t.clientWidth, r.clientWidth) - i),
      {
        width: i,
        height: o,
        x: s,
        y: a,
      }
    );
  }
  function pr(e, t) {
    const n = W(e),
      r = contexts_BGRNBsB8_X(e),
      i = n.visualViewport;
    let o = r.clientWidth,
      s = r.clientHeight,
      a = 0,
      c = 0;
    if (i) {
      ((o = i.width), (s = i.height));
      const u = pt();
      (!u || (u && t === 'fixed')) && ((a = i.offsetLeft), (c = i.offsetTop));
    }
    return {
      width: o,
      height: s,
      x: a,
      y: c,
    };
  }
  function hr(e, t) {
    const n = contexts_BGRNBsB8_ue(e, !0, t === 'fixed'),
      r = n.top + e.clientTop,
      i = n.left + e.clientLeft,
      o = J(e) ? contexts_BGRNBsB8_pe(e) : contexts_BGRNBsB8_Q(1),
      s = e.clientWidth * o.x,
      a = e.clientHeight * o.y,
      c = i * o.x,
      u = r * o.y;
    return {
      width: s,
      height: a,
      x: c,
      y: u,
    };
  }
  function At(e, t, n) {
    let r;
    if (t === 'viewport') r = pr(e, n);
    else if (t === 'document') r = dr(contexts_BGRNBsB8_X(e));
    else if (contexts_BGRNBsB8_q(t)) r = hr(t, n);
    else {
      const i = en(e);
      r = {
        x: t.x - i.x,
        y: t.y - i.y,
        width: t.width,
        height: t.height,
      };
    }
    return contexts_BGRNBsB8_Fe(r);
  }
  function nn(e, t) {
    const n = contexts_BGRNBsB8_oe(e);
    return n === t || !contexts_BGRNBsB8_q(n) || contexts_BGRNBsB8_me(n)
      ? !1
      : K(n).position === 'fixed' || nn(n, t);
  }
  function vr(e, t) {
    const n = t.get(e);
    if (n) return n;
    let r = contexts_BGRNBsB8_Ee(e, [], !1).filter(
        (a) => contexts_BGRNBsB8_q(a) && contexts_BGRNBsB8_ye(a) !== 'body'
      ),
      i = null;
    const o = K(e).position === 'fixed';
    let s = o ? contexts_BGRNBsB8_oe(e) : e;
    for (; contexts_BGRNBsB8_q(s) && !contexts_BGRNBsB8_me(s); ) {
      const a = K(s),
        c = contexts_BGRNBsB8_dt(s);
      (!c && a.position === 'fixed' && (i = null),
        (
          o
            ? !c && !i
            : (!c &&
                a.position === 'static' &&
                !!i &&
                ['absolute', 'fixed'].includes(i.position)) ||
              (Ae(s) && !c && nn(e, s))
        )
          ? (r = r.filter((l) => l !== s))
          : (i = a),
        (s = contexts_BGRNBsB8_oe(s)));
    }
    return (t.set(e, r), r);
  }
  function mr(e) {
    let { element: t, boundary: n, rootBoundary: r, strategy: i } = e;
    const s = [
        ...(n === 'clippingAncestors'
          ? contexts_BGRNBsB8_qe(t)
            ? []
            : vr(t, this._c)
          : [].concat(n)),
        r,
      ],
      a = s[0],
      c = s.reduce(
        (u, l) => {
          const f = At(t, l, i);
          return (
            (u.top = contexts_BGRNBsB8_ae(f.top, u.top)),
            (u.right = contexts_BGRNBsB8_De(f.right, u.right)),
            (u.bottom = contexts_BGRNBsB8_De(f.bottom, u.bottom)),
            (u.left = contexts_BGRNBsB8_ae(f.left, u.left)),
            u
          );
        },
        At(t, a, i)
      );
    return {
      width: c.right - c.left,
      height: c.bottom - c.top,
      x: c.left,
      y: c.top,
    };
  }
  function gr(e) {
    const { width: t, height: n } = Zt(e);
    return {
      width: t,
      height: n,
    };
  }
  function br(e, t, n) {
    const r = J(t),
      i = contexts_BGRNBsB8_X(t),
      o = n === 'fixed',
      s = contexts_BGRNBsB8_ue(e, !0, o, t);
    let a = {
      scrollLeft: 0,
      scrollTop: 0,
    };
    const c = contexts_BGRNBsB8_Q(0);
    if (r || (!r && !o))
      if (((contexts_BGRNBsB8_ye(t) !== 'body' || Ae(i)) && (a = Ke(t)), r)) {
        const v = contexts_BGRNBsB8_ue(t, !0, o, t);
        ((c.x = v.x + t.clientLeft), (c.y = v.y + t.clientTop));
      } else i && (c.x = vt(i));
    const u = i && !r && !o ? tn(i, a) : contexts_BGRNBsB8_Q(0),
      l = s.left + a.scrollLeft - c.x - u.x,
      f = s.top + a.scrollTop - c.y - u.y;
    return {
      x: l,
      y: f,
      width: s.width,
      height: s.height,
    };
  }
  function contexts_BGRNBsB8_Ze(e) {
    return K(e).position === 'static';
  }
  function Ot(e, t) {
    if (!J(e) || K(e).position === 'fixed') return null;
    if (t) return t(e);
    let n = e.offsetParent;
    return (contexts_BGRNBsB8_X(e) === n && (n = n.ownerDocument.body), n);
  }
  function rn(e, t) {
    const n = W(e);
    if (contexts_BGRNBsB8_qe(e)) return n;
    if (!J(e)) {
      let i = contexts_BGRNBsB8_oe(e);
      for (; i && !contexts_BGRNBsB8_me(i); ) {
        if (contexts_BGRNBsB8_q(i) && !contexts_BGRNBsB8_Ze(i)) return i;
        i = contexts_BGRNBsB8_oe(i);
      }
      return n;
    }
    let r = Ot(e, t);
    for (; r && sr(r) && contexts_BGRNBsB8_Ze(r); ) r = Ot(r, t);
    return r && contexts_BGRNBsB8_me(r) && contexts_BGRNBsB8_Ze(r) && !contexts_BGRNBsB8_dt(r)
      ? n
      : r || ar(e) || n;
  }
  const yr = async function (e) {
    const t = this.getOffsetParent || rn,
      n = this.getDimensions,
      r = await n(e.floating);
    return {
      reference: br(e.reference, await t(e.floating), e.strategy),
      floating: {
        x: 0,
        y: 0,
        width: r.width,
        height: r.height,
      },
    };
  };
  function wr(e) {
    return K(e).direction === 'rtl';
  }
  const xr = {
    convertOffsetParentRelativeRectToViewportRelativeRect: lr,
    getDocumentElement: contexts_BGRNBsB8_X,
    getClippingRect: mr,
    getOffsetParent: rn,
    getElementRects: yr,
    getClientRects: fr,
    getDimensions: gr,
    getScale: contexts_BGRNBsB8_pe,
    isElement: contexts_BGRNBsB8_q,
    isRTL: wr,
  };
  function on(e, t) {
    return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height;
  }
  function Sr(e, t) {
    let n = null,
      r;
    const i = contexts_BGRNBsB8_X(e);
    function o() {
      var a;
      (clearTimeout(r), (a = n) == null || a.disconnect(), (n = null));
    }
    function s(a, c) {
      (a === void 0 && (a = !1), c === void 0 && (c = 1), o());
      const u = e.getBoundingClientRect(),
        { left: l, top: f, width: v, height: d } = u;
      if ((a || t(), !v || !d)) return;
      const m = contexts_BGRNBsB8_e(f),
        p = contexts_BGRNBsB8_e(i.clientWidth - (l + v)),
        g = contexts_BGRNBsB8_e(i.clientHeight - (f + d)),
        h = contexts_BGRNBsB8_e(l),
        E = {
          rootMargin: -m + 'px ' + -p + 'px ' + -g + 'px ' + -h + 'px',
          threshold: contexts_BGRNBsB8_ae(0, contexts_BGRNBsB8_De(1, c)) || 1,
        };
      let A = !0;
      function b(S) {
        const C = S[0].intersectionRatio;
        if (C !== c) {
          if (!A) return s();
          C
            ? s(!1, C)
            : (r = setTimeout(() => {
                s(!1, 1e-7);
              }, 1e3));
        }
        (C === 1 && !on(u, e.getBoundingClientRect()) && s(), (A = !1));
      }
      try {
        n = new IntersectionObserver(b, {
          ...E,
          // Handle <iframe>s
          root: i.ownerDocument,
        });
      } catch {
        n = new IntersectionObserver(b, E);
      }
      n.observe(e);
    }
    return (s(!0), o);
  }
  function Tr(e, t, n, r) {
    r === void 0 && (r = {});
    const {
        ancestorScroll: i = !0,
        ancestorResize: o = !0,
        elementResize: s = typeof ResizeObserver == 'function',
        layoutShift: a = typeof IntersectionObserver == 'function',
        animationFrame: c = !1,
      } = r,
      u = contexts_BGRNBsB8_ht(e),
      l = i || o ? [...(u ? contexts_BGRNBsB8_Ee(u) : []), ...contexts_BGRNBsB8_Ee(t)] : [];
    l.forEach((h) => {
      (i &&
        h.addEventListener('scroll', n, {
          passive: !0,
        }),
        o && h.addEventListener('resize', n));
    });
    const f = u && a ? Sr(u, n) : null;
    let v = -1,
      d = null;
    s &&
      ((d = new ResizeObserver((h) => {
        let [x] = h;
        (x &&
          x.target === u &&
          d &&
          (d.unobserve(t),
          cancelAnimationFrame(v),
          (v = requestAnimationFrame(() => {
            var E;
            (E = d) == null || E.observe(t);
          }))),
          n());
      })),
      u && !c && d.observe(u),
      d.observe(t));
    let m,
      p = c ? contexts_BGRNBsB8_ue(e) : null;
    c && g();
    function g() {
      const h = contexts_BGRNBsB8_ue(e);
      (p && !on(p, h) && n(), (p = h), (m = requestAnimationFrame(g)));
    }
    return (
      n(),
      () => {
        var h;
        (l.forEach((x) => {
          (i && x.removeEventListener('scroll', n), o && x.removeEventListener('resize', n));
        }),
          f == null || f(),
          (h = d) == null || h.disconnect(),
          (d = null),
          c && cancelAnimationFrame(m));
      }
    );
  }
  const Er = /* unused pure expression or super */ null && ir,
    Cr = /* unused pure expression or super */ null && or,
    Pr = /* unused pure expression or super */ null && nr,
    Ar = (e, t, n) => {
      const r = /* @__PURE__ */ new Map(),
        i = {
          platform: xr,
          ...n,
        },
        o = {
          ...i.platform,
          _c: r,
        };
      return tr(e, t, {
        ...i,
        platform: o,
      });
    };
  var $o =
    typeof globalThis < 'u'
      ? globalThis
      : typeof window < 'u'
        ? window
        : typeof global < 'u'
          ? global
          : typeof self < 'u'
            ? self
            : {};
  function Or(e) {
    return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, 'default') ? e.default : e;
  }
  var contexts_BGRNBsB8_Me = { exports: {} },
    kr = contexts_BGRNBsB8_Me.exports,
    kt;
  function _r() {
    return (
      kt ||
        ((kt = 1),
        (function (e) {
          (function (t, n) {
            e.exports ? (e.exports = n()) : (t.log = n());
          })(kr, function () {
            var t = function () {},
              n = 'undefined',
              r =
                typeof window !== n &&
                typeof window.navigator !== n &&
                /Trident\/|MSIE /.test(window.navigator.userAgent),
              i = ['trace', 'debug', 'info', 'warn', 'error'],
              o = {},
              s = null;
            function a(p, g) {
              var h = p[g];
              if (typeof h.bind == 'function') return h.bind(p);
              try {
                return Function.prototype.bind.call(h, p);
              } catch {
                return function () {
                  return Function.prototype.apply.apply(h, [p, arguments]);
                };
              }
            }
            function c() {
              (console.log &&
                (console.log.apply
                  ? console.log.apply(console, arguments)
                  : Function.prototype.apply.apply(console.log, [console, arguments])),
                console.trace && console.trace());
            }
            function u(p) {
              return (
                p === 'debug' && (p = 'log'),
                typeof console === n
                  ? !1
                  : p === 'trace' && r
                    ? c
                    : console[p] !== void 0
                      ? a(console, p)
                      : console.log !== void 0
                        ? a(console, 'log')
                        : t
              );
            }
            function l() {
              for (var p = this.getLevel(), g = 0; g < i.length; g++) {
                var h = i[g];
                this[h] = g < p ? t : this.methodFactory(h, p, this.name);
              }
              if (((this.log = this.debug), typeof console === n && p < this.levels.SILENT))
                return 'No console available for logging';
            }
            function f(p) {
              return function () {
                typeof console !== n && (l.call(this), this[p].apply(this, arguments));
              };
            }
            function v(p, g, h) {
              return u(p) || f.apply(this, arguments);
            }
            function d(p, g) {
              var h = this,
                x,
                E,
                A,
                b = 'loglevel';
              typeof p == 'string' ? (b += ':' + p) : typeof p == 'symbol' && (b = void 0);
              function S(T) {
                var _ = (i[T] || 'silent').toUpperCase();
                if (!(typeof window === n || !b)) {
                  try {
                    window.localStorage[b] = _;
                    return;
                  } catch {}
                  try {
                    window.document.cookie = encodeURIComponent(b) + '=' + _ + ';';
                  } catch {}
                }
              }
              function C() {
                var T;
                if (!(typeof window === n || !b)) {
                  try {
                    T = window.localStorage[b];
                  } catch {}
                  if (typeof T === n)
                    try {
                      var _ = window.document.cookie,
                        Z = encodeURIComponent(b),
                        G = _.indexOf(Z + '=');
                      G !== -1 && (T = /^([^;]+)/.exec(_.slice(G + Z.length + 1))[1]);
                    } catch {}
                  return (h.levels[T] === void 0 && (T = void 0), T);
                }
              }
              function $() {
                if (!(typeof window === n || !b)) {
                  try {
                    window.localStorage.removeItem(b);
                  } catch {}
                  try {
                    window.document.cookie =
                      encodeURIComponent(b) + '=; expires=Thu, 01 Jan 1970 00:00:00 UTC';
                  } catch {}
                }
              }
              function I(T) {
                var _ = T;
                if (
                  (typeof _ == 'string' &&
                    h.levels[_.toUpperCase()] !== void 0 &&
                    (_ = h.levels[_.toUpperCase()]),
                  typeof _ == 'number' && _ >= 0 && _ <= h.levels.SILENT)
                )
                  return _;
                throw new TypeError('log.setLevel() called with invalid level: ' + T);
              }
              ((h.name = p),
                (h.levels = {
                  TRACE: 0,
                  DEBUG: 1,
                  INFO: 2,
                  WARN: 3,
                  ERROR: 4,
                  SILENT: 5,
                }),
                (h.methodFactory = g || v),
                (h.getLevel = function () {
                  return A ?? E ?? x;
                }),
                (h.setLevel = function (T, _) {
                  return ((A = I(T)), _ !== !1 && S(A), l.call(h));
                }),
                (h.setDefaultLevel = function (T) {
                  ((E = I(T)), C() || h.setLevel(T, !1));
                }),
                (h.resetLevel = function () {
                  ((A = null), $(), l.call(h));
                }),
                (h.enableAll = function (T) {
                  h.setLevel(h.levels.TRACE, T);
                }),
                (h.disableAll = function (T) {
                  h.setLevel(h.levels.SILENT, T);
                }),
                (h.rebuild = function () {
                  if ((s !== h && (x = I(s.getLevel())), l.call(h), s === h))
                    for (var T in o) o[T].rebuild();
                }),
                (x = I(s ? s.getLevel() : 'WARN')));
              var z = C();
              (z != null && (A = I(z)), l.call(h));
            }
            ((s = new d()),
              (s.getLogger = function (g) {
                if ((typeof g != 'symbol' && typeof g != 'string') || g === '')
                  throw new TypeError('You must supply a name when creating a logger.');
                var h = o[g];
                return (h || (h = o[g] = new d(g, s.methodFactory)), h);
              }));
            var m = typeof window !== n ? window.log : void 0;
            return (
              (s.noConflict = function () {
                return (typeof window !== n && window.log === s && (window.log = m), s);
              }),
              (s.getLoggers = function () {
                return o;
              }),
              (s.default = s),
              s
            );
          });
        })(contexts_BGRNBsB8_Me)),
      contexts_BGRNBsB8_Me.exports
    );
  }
  var Lr = _r();
  const Ir = /* @__PURE__ */ Or(Lr);
  var contexts_BGRNBsB8_at = function (e, t) {
    return (
      (contexts_BGRNBsB8_at =
        Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array &&
          function (n, r) {
            n.__proto__ = r;
          }) ||
        function (n, r) {
          for (var i in r) Object.prototype.hasOwnProperty.call(r, i) && (n[i] = r[i]);
        }),
      contexts_BGRNBsB8_at(e, t)
    );
  };
  function contexts_BGRNBsB8_te(e, t) {
    if (typeof t != 'function' && t !== null)
      throw new TypeError('Class extends value ' + String(t) + ' is not a constructor or null');
    contexts_BGRNBsB8_at(e, t);
    function n() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : ((n.prototype = t.prototype), new n());
  }
  function Mr(e, t, n, r) {
    function i(o) {
      return o instanceof n
        ? o
        : new n(function (s) {
            s(o);
          });
    }
    return new (n || (n = Promise))(function (o, s) {
      function a(l) {
        try {
          u(r.next(l));
        } catch (f) {
          s(f);
        }
      }
      function c(l) {
        try {
          u(r.throw(l));
        } catch (f) {
          s(f);
        }
      }
      function u(l) {
        l.done ? o(l.value) : i(l.value).then(a, c);
      }
      u((r = r.apply(e, t || [])).next());
    });
  }
  function sn(e, t) {
    var n = {
        label: 0,
        sent: function () {
          if (o[0] & 1) throw o[1];
          return o[1];
        },
        trys: [],
        ops: [],
      },
      r,
      i,
      o,
      s = Object.create((typeof Iterator == 'function' ? Iterator : Object).prototype);
    return (
      (s.next = a(0)),
      (s.throw = a(1)),
      (s.return = a(2)),
      typeof Symbol == 'function' &&
        (s[Symbol.iterator] = function () {
          return this;
        }),
      s
    );
    function a(u) {
      return function (l) {
        return c([u, l]);
      };
    }
    function c(u) {
      if (r) throw new TypeError('Generator is already executing.');
      for (; s && ((s = 0), u[0] && (n = 0)), n; )
        try {
          if (
            ((r = 1),
            i &&
              (o =
                u[0] & 2
                  ? i.return
                  : u[0]
                    ? i.throw || ((o = i.return) && o.call(i), 0)
                    : i.next) &&
              !(o = o.call(i, u[1])).done)
          )
            return o;
          switch (((i = 0), o && (u = [u[0] & 2, o.value]), u[0])) {
            case 0:
            case 1:
              o = u;
              break;
            case 4:
              return (n.label++, { value: u[1], done: !1 });
            case 5:
              (n.label++, (i = u[1]), (u = [0]));
              continue;
            case 7:
              ((u = n.ops.pop()), n.trys.pop());
              continue;
            default:
              if (
                ((o = n.trys), !(o = o.length > 0 && o[o.length - 1]) && (u[0] === 6 || u[0] === 2))
              ) {
                n = 0;
                continue;
              }
              if (u[0] === 3 && (!o || (u[1] > o[0] && u[1] < o[3]))) {
                n.label = u[1];
                break;
              }
              if (u[0] === 6 && n.label < o[1]) {
                ((n.label = o[1]), (o = u));
                break;
              }
              if (o && n.label < o[2]) {
                ((n.label = o[2]), n.ops.push(u));
                break;
              }
              (o[2] && n.ops.pop(), n.trys.pop());
              continue;
          }
          u = t.call(e, n);
        } catch (l) {
          ((u = [6, l]), (i = 0));
        } finally {
          r = o = 0;
        }
      if (u[0] & 5) throw u[1];
      return { value: u[0] ? u[1] : void 0, done: !0 };
    }
  }
  function contexts_BGRNBsB8_ge(e) {
    var t = typeof Symbol == 'function' && Symbol.iterator,
      n = t && e[t],
      r = 0;
    if (n) return n.call(e);
    if (e && typeof e.length == 'number')
      return {
        next: function () {
          return (e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e });
        },
      };
    throw new TypeError(t ? 'Object is not iterable.' : 'Symbol.iterator is not defined.');
  }
  function contexts_BGRNBsB8_le(e, t) {
    var n = typeof Symbol == 'function' && e[Symbol.iterator];
    if (!n) return e;
    var r = n.call(e),
      i,
      o = [],
      s;
    try {
      for (; (t === void 0 || t-- > 0) && !(i = r.next()).done; ) o.push(i.value);
    } catch (a) {
      s = { error: a };
    } finally {
      try {
        i && !i.done && (n = r.return) && n.call(r);
      } finally {
        if (s) throw s.error;
      }
    }
    return o;
  }
  function contexts_BGRNBsB8_be(e, t, n) {
    if (n || arguments.length === 2)
      for (var r = 0, i = t.length, o; r < i; r++)
        (o || !(r in t)) && (o || (o = Array.prototype.slice.call(t, 0, r)), (o[r] = t[r]));
    return e.concat(o || Array.prototype.slice.call(t));
  }
  function contexts_BGRNBsB8_he(e) {
    return this instanceof contexts_BGRNBsB8_he
      ? ((this.v = e), this)
      : new contexts_BGRNBsB8_he(e);
  }
  function Rr(e, t, n) {
    if (!Symbol.asyncIterator) throw new TypeError('Symbol.asyncIterator is not defined.');
    var r = n.apply(e, t || []),
      i,
      o = [];
    return (
      (i = Object.create((typeof AsyncIterator == 'function' ? AsyncIterator : Object).prototype)),
      a('next'),
      a('throw'),
      a('return', s),
      (i[Symbol.asyncIterator] = function () {
        return this;
      }),
      i
    );
    function s(d) {
      return function (m) {
        return Promise.resolve(m).then(d, f);
      };
    }
    function a(d, m) {
      r[d] &&
        ((i[d] = function (p) {
          return new Promise(function (g, h) {
            o.push([d, p, g, h]) > 1 || c(d, p);
          });
        }),
        m && (i[d] = m(i[d])));
    }
    function c(d, m) {
      try {
        u(r[d](m));
      } catch (p) {
        v(o[0][3], p);
      }
    }
    function u(d) {
      d.value instanceof contexts_BGRNBsB8_he
        ? Promise.resolve(d.value.v).then(l, f)
        : v(o[0][2], d);
    }
    function l(d) {
      c('next', d);
    }
    function f(d) {
      c('throw', d);
    }
    function v(d, m) {
      (d(m), o.shift(), o.length && c(o[0][0], o[0][1]));
    }
  }
  function Dr(e) {
    if (!Symbol.asyncIterator) throw new TypeError('Symbol.asyncIterator is not defined.');
    var t = e[Symbol.asyncIterator],
      n;
    return t
      ? t.call(e)
      : ((e =
          typeof contexts_BGRNBsB8_ge == 'function'
            ? contexts_BGRNBsB8_ge(e)
            : e[Symbol.iterator]()),
        (n = {}),
        r('next'),
        r('throw'),
        r('return'),
        (n[Symbol.asyncIterator] = function () {
          return this;
        }),
        n);
    function r(o) {
      n[o] =
        e[o] &&
        function (s) {
          return new Promise(function (a, c) {
            ((s = e[o](s)), i(a, c, s.done, s.value));
          });
        };
    }
    function i(o, s, a, c) {
      Promise.resolve(c).then(function (u) {
        o({ value: u, done: a });
      }, s);
    }
  }
  function contexts_BGRNBsB8_P(e) {
    return typeof e == 'function';
  }
  function contexts_BGRNBsB8_mt(e) {
    var t = function (r) {
        (Error.call(r), (r.stack = new Error().stack));
      },
      n = e(t);
    return ((n.prototype = Object.create(Error.prototype)), (n.prototype.constructor = n), n);
  }
  var contexts_BGRNBsB8_et = contexts_BGRNBsB8_mt(function (e) {
    return function (n) {
      (e(this),
        (this.message = n
          ? n.length +
            ` errors occurred during unsubscription:
` +
            n.map(function (r, i) {
              return i + 1 + ') ' + r.toString();
            }).join(`
  `)
          : ''),
        (this.name = 'UnsubscriptionError'),
        (this.errors = n));
    };
  });
  function contexts_BGRNBsB8_Ue(e, t) {
    if (e) {
      var n = e.indexOf(t);
      0 <= n && e.splice(n, 1);
    }
  }
  var contexts_BGRNBsB8_Oe = (function () {
      function e(t) {
        ((this.initialTeardown = t),
          (this.closed = !1),
          (this._parentage = null),
          (this._finalizers = null));
      }
      return (
        (e.prototype.unsubscribe = function () {
          var t, n, r, i, o;
          if (!this.closed) {
            this.closed = !0;
            var s = this._parentage;
            if (s)
              if (((this._parentage = null), Array.isArray(s)))
                try {
                  for (var a = contexts_BGRNBsB8_ge(s), c = a.next(); !c.done; c = a.next()) {
                    var u = c.value;
                    u.remove(this);
                  }
                } catch (p) {
                  t = { error: p };
                } finally {
                  try {
                    c && !c.done && (n = a.return) && n.call(a);
                  } finally {
                    if (t) throw t.error;
                  }
                }
              else s.remove(this);
            var l = this.initialTeardown;
            if (contexts_BGRNBsB8_P(l))
              try {
                l();
              } catch (p) {
                o = p instanceof contexts_BGRNBsB8_et ? p.errors : [p];
              }
            var f = this._finalizers;
            if (f) {
              this._finalizers = null;
              try {
                for (var v = contexts_BGRNBsB8_ge(f), d = v.next(); !d.done; d = v.next()) {
                  var m = d.value;
                  try {
                    _t(m);
                  } catch (p) {
                    ((o = o ?? []),
                      p instanceof contexts_BGRNBsB8_et
                        ? (o = contexts_BGRNBsB8_be(
                            contexts_BGRNBsB8_be([], contexts_BGRNBsB8_le(o)),
                            contexts_BGRNBsB8_le(p.errors)
                          ))
                        : o.push(p));
                  }
                }
              } catch (p) {
                r = { error: p };
              } finally {
                try {
                  d && !d.done && (i = v.return) && i.call(v);
                } finally {
                  if (r) throw r.error;
                }
              }
            }
            if (o) throw new contexts_BGRNBsB8_et(o);
          }
        }),
        (e.prototype.add = function (t) {
          var n;
          if (t && t !== this)
            if (this.closed) _t(t);
            else {
              if (t instanceof e) {
                if (t.closed || t._hasParent(this)) return;
                t._addParent(this);
              }
              (this._finalizers = (n = this._finalizers) !== null && n !== void 0 ? n : []).push(t);
            }
        }),
        (e.prototype._hasParent = function (t) {
          var n = this._parentage;
          return n === t || (Array.isArray(n) && n.includes(t));
        }),
        (e.prototype._addParent = function (t) {
          var n = this._parentage;
          this._parentage = Array.isArray(n) ? (n.push(t), n) : n ? [n, t] : t;
        }),
        (e.prototype._removeParent = function (t) {
          var n = this._parentage;
          n === t ? (this._parentage = null) : Array.isArray(n) && contexts_BGRNBsB8_Ue(n, t);
        }),
        (e.prototype.remove = function (t) {
          var n = this._finalizers;
          (n && contexts_BGRNBsB8_Ue(n, t), t instanceof e && t._removeParent(this));
        }),
        (e.EMPTY = (function () {
          var t = new e();
          return ((t.closed = !0), t);
        })()),
        e
      );
    })(),
    an = contexts_BGRNBsB8_Oe.EMPTY;
  function contexts_BGRNBsB8_cn(e) {
    return (
      e instanceof contexts_BGRNBsB8_Oe ||
      (e &&
        'closed' in e &&
        contexts_BGRNBsB8_P(e.remove) &&
        contexts_BGRNBsB8_P(e.add) &&
        contexts_BGRNBsB8_P(e.unsubscribe))
    );
  }
  function _t(e) {
    contexts_BGRNBsB8_P(e) ? e() : e.unsubscribe();
  }
  var $r = {
      Promise: void 0,
    },
    Nr = {
      setTimeout: function (e, t) {
        for (var n = [], r = 2; r < arguments.length; r++) n[r - 2] = arguments[r];
        return setTimeout.apply(void 0, contexts_BGRNBsB8_be([e, t], contexts_BGRNBsB8_le(n)));
      },
      clearTimeout: function (e) {
        return clearTimeout(e);
      },
      delegate: void 0,
    };
  function un(e) {
    Nr.setTimeout(function () {
      throw e;
    });
  }
  function contexts_BGRNBsB8_je() {}
  function contexts_BGRNBsB8_Re(e) {
    e();
  }
  var gt = (function (e) {
      contexts_BGRNBsB8_te(t, e);
      function t(n) {
        var r = e.call(this) || this;
        return (
          (r.isStopped = !1),
          n ? ((r.destination = n), contexts_BGRNBsB8_cn(n) && n.add(r)) : (r.destination = jr),
          r
        );
      }
      return (
        (t.create = function (n, r, i) {
          return new contexts_BGRNBsB8_Ce(n, r, i);
        }),
        (t.prototype.next = function (n) {
          this.isStopped || this._next(n);
        }),
        (t.prototype.error = function (n) {
          this.isStopped || ((this.isStopped = !0), this._error(n));
        }),
        (t.prototype.complete = function () {
          this.isStopped || ((this.isStopped = !0), this._complete());
        }),
        (t.prototype.unsubscribe = function () {
          this.closed ||
            ((this.isStopped = !0), e.prototype.unsubscribe.call(this), (this.destination = null));
        }),
        (t.prototype._next = function (n) {
          this.destination.next(n);
        }),
        (t.prototype._error = function (n) {
          try {
            this.destination.error(n);
          } finally {
            this.unsubscribe();
          }
        }),
        (t.prototype._complete = function () {
          try {
            this.destination.complete();
          } finally {
            this.unsubscribe();
          }
        }),
        t
      );
    })(contexts_BGRNBsB8_Oe),
    Fr = (function () {
      function e(t) {
        this.partialObserver = t;
      }
      return (
        (e.prototype.next = function (t) {
          var n = this.partialObserver;
          if (n.next)
            try {
              n.next(t);
            } catch (r) {
              Le(r);
            }
        }),
        (e.prototype.error = function (t) {
          var n = this.partialObserver;
          if (n.error)
            try {
              n.error(t);
            } catch (r) {
              Le(r);
            }
          else Le(t);
        }),
        (e.prototype.complete = function () {
          var t = this.partialObserver;
          if (t.complete)
            try {
              t.complete();
            } catch (n) {
              Le(n);
            }
        }),
        e
      );
    })(),
    contexts_BGRNBsB8_Ce = (function (e) {
      contexts_BGRNBsB8_te(t, e);
      function t(n, r, i) {
        var o = e.call(this) || this,
          s;
        return (
          contexts_BGRNBsB8_P(n) || !n
            ? (s = {
                next: n ?? void 0,
                error: r ?? void 0,
                complete: i ?? void 0,
              })
            : (s = n),
          (o.destination = new Fr(s)),
          o
        );
      }
      return t;
    })(gt);
  function Le(e) {
    un(e);
  }
  function Ur(e) {
    throw e;
  }
  var jr = {
      closed: !0,
      next: contexts_BGRNBsB8_je,
      error: Ur,
      complete: contexts_BGRNBsB8_je,
    },
    bt = (function () {
      return (typeof Symbol == 'function' && Symbol.observable) || '@@observable';
    })();
  function contexts_BGRNBsB8_Ge(e) {
    return e;
  }
  function Wr(e) {
    return e.length === 0
      ? contexts_BGRNBsB8_Ge
      : e.length === 1
        ? e[0]
        : function (n) {
            return e.reduce(function (r, i) {
              return i(r);
            }, n);
          };
  }
  var contexts_BGRNBsB8_k = (function () {
    function e(t) {
      t && (this._subscribe = t);
    }
    return (
      (e.prototype.lift = function (t) {
        var n = new e();
        return ((n.source = this), (n.operator = t), n);
      }),
      (e.prototype.subscribe = function (t, n, r) {
        var i = this,
          o = Vr(t) ? t : new contexts_BGRNBsB8_Ce(t, n, r);
        return (
          contexts_BGRNBsB8_Re(function () {
            var s = i,
              a = s.operator,
              c = s.source;
            o.add(a ? a.call(o, c) : c ? i._subscribe(o) : i._trySubscribe(o));
          }),
          o
        );
      }),
      (e.prototype._trySubscribe = function (t) {
        try {
          return this._subscribe(t);
        } catch (n) {
          t.error(n);
        }
      }),
      (e.prototype.forEach = function (t, n) {
        var r = this;
        return (
          (n = Lt(n)),
          new n(function (i, o) {
            var s = new contexts_BGRNBsB8_Ce({
              next: function (a) {
                try {
                  t(a);
                } catch (c) {
                  (o(c), s.unsubscribe());
                }
              },
              error: o,
              complete: i,
            });
            r.subscribe(s);
          })
        );
      }),
      (e.prototype._subscribe = function (t) {
        var n;
        return (n = this.source) === null || n === void 0 ? void 0 : n.subscribe(t);
      }),
      (e.prototype[bt] = function () {
        return this;
      }),
      (e.prototype.pipe = function () {
        for (var t = [], n = 0; n < arguments.length; n++) t[n] = arguments[n];
        return Wr(t)(this);
      }),
      (e.prototype.toPromise = function (t) {
        var n = this;
        return (
          (t = Lt(t)),
          new t(function (r, i) {
            var o;
            n.subscribe(
              function (s) {
                return (o = s);
              },
              function (s) {
                return i(s);
              },
              function () {
                return r(o);
              }
            );
          })
        );
      }),
      (e.create = function (t) {
        return new e(t);
      }),
      e
    );
  })();
  function Lt(e) {
    var t;
    return (t = e ?? $r.Promise) !== null && t !== void 0 ? t : Promise;
  }
  function Br(e) {
    return (
      e &&
      contexts_BGRNBsB8_P(e.next) &&
      contexts_BGRNBsB8_P(e.error) &&
      contexts_BGRNBsB8_P(e.complete)
    );
  }
  function Vr(e) {
    return (e && e instanceof gt) || (Br(e) && contexts_BGRNBsB8_cn(e));
  }
  function Hr(e) {
    return contexts_BGRNBsB8_P(e == null ? void 0 : e.lift);
  }
  function contexts_BGRNBsB8_j(e) {
    return function (t) {
      if (Hr(t))
        return t.lift(function (n) {
          try {
            return e(n, this);
          } catch (r) {
            this.error(r);
          }
        });
      throw new TypeError('Unable to lift unknown Observable type');
    };
  }
  function contexts_BGRNBsB8_F(e, t, n, r, i) {
    return new zr(e, t, n, r, i);
  }
  var zr = (function (e) {
      contexts_BGRNBsB8_te(t, e);
      function t(n, r, i, o, s, a) {
        var c = e.call(this, n) || this;
        return (
          (c.onFinalize = s),
          (c.shouldUnsubscribe = a),
          (c._next = r
            ? function (u) {
                try {
                  r(u);
                } catch (l) {
                  n.error(l);
                }
              }
            : e.prototype._next),
          (c._error = o
            ? function (u) {
                try {
                  o(u);
                } catch (l) {
                  n.error(l);
                } finally {
                  this.unsubscribe();
                }
              }
            : e.prototype._error),
          (c._complete = i
            ? function () {
                try {
                  i();
                } catch (u) {
                  n.error(u);
                } finally {
                  this.unsubscribe();
                }
              }
            : e.prototype._complete),
          c
        );
      }
      return (
        (t.prototype.unsubscribe = function () {
          var n;
          if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
            var r = this.closed;
            (e.prototype.unsubscribe.call(this),
              !r && ((n = this.onFinalize) === null || n === void 0 || n.call(this)));
          }
        }),
        t
      );
    })(gt),
    Yr = contexts_BGRNBsB8_mt(function (e) {
      return function () {
        (e(this), (this.name = 'ObjectUnsubscribedError'), (this.message = 'object unsubscribed'));
      };
    }),
    contexts_BGRNBsB8_ee = (function (e) {
      contexts_BGRNBsB8_te(t, e);
      function t() {
        var n = e.call(this) || this;
        return (
          (n.closed = !1),
          (n.currentObservers = null),
          (n.observers = []),
          (n.isStopped = !1),
          (n.hasError = !1),
          (n.thrownError = null),
          n
        );
      }
      return (
        (t.prototype.lift = function (n) {
          var r = new It(this, this);
          return ((r.operator = n), r);
        }),
        (t.prototype._throwIfClosed = function () {
          if (this.closed) throw new Yr();
        }),
        (t.prototype.next = function (n) {
          var r = this;
          contexts_BGRNBsB8_Re(function () {
            var i, o;
            if ((r._throwIfClosed(), !r.isStopped)) {
              r.currentObservers || (r.currentObservers = Array.from(r.observers));
              try {
                for (
                  var s = contexts_BGRNBsB8_ge(r.currentObservers), a = s.next();
                  !a.done;
                  a = s.next()
                ) {
                  var c = a.value;
                  c.next(n);
                }
              } catch (u) {
                i = { error: u };
              } finally {
                try {
                  a && !a.done && (o = s.return) && o.call(s);
                } finally {
                  if (i) throw i.error;
                }
              }
            }
          });
        }),
        (t.prototype.error = function (n) {
          var r = this;
          contexts_BGRNBsB8_Re(function () {
            if ((r._throwIfClosed(), !r.isStopped)) {
              ((r.hasError = r.isStopped = !0), (r.thrownError = n));
              for (var i = r.observers; i.length; ) i.shift().error(n);
            }
          });
        }),
        (t.prototype.complete = function () {
          var n = this;
          contexts_BGRNBsB8_Re(function () {
            if ((n._throwIfClosed(), !n.isStopped)) {
              n.isStopped = !0;
              for (var r = n.observers; r.length; ) r.shift().complete();
            }
          });
        }),
        (t.prototype.unsubscribe = function () {
          ((this.isStopped = this.closed = !0), (this.observers = this.currentObservers = null));
        }),
        Object.defineProperty(t.prototype, 'observed', {
          get: function () {
            var n;
            return ((n = this.observers) === null || n === void 0 ? void 0 : n.length) > 0;
          },
          enumerable: !1,
          configurable: !0,
        }),
        (t.prototype._trySubscribe = function (n) {
          return (this._throwIfClosed(), e.prototype._trySubscribe.call(this, n));
        }),
        (t.prototype._subscribe = function (n) {
          return (this._throwIfClosed(), this._checkFinalizedStatuses(n), this._innerSubscribe(n));
        }),
        (t.prototype._innerSubscribe = function (n) {
          var r = this,
            i = this,
            o = i.hasError,
            s = i.isStopped,
            a = i.observers;
          return o || s
            ? an
            : ((this.currentObservers = null),
              a.push(n),
              new contexts_BGRNBsB8_Oe(function () {
                ((r.currentObservers = null), contexts_BGRNBsB8_Ue(a, n));
              }));
        }),
        (t.prototype._checkFinalizedStatuses = function (n) {
          var r = this,
            i = r.hasError,
            o = r.thrownError,
            s = r.isStopped;
          i ? n.error(o) : s && n.complete();
        }),
        (t.prototype.asObservable = function () {
          var n = new contexts_BGRNBsB8_k();
          return ((n.source = this), n);
        }),
        (t.create = function (n, r) {
          return new It(n, r);
        }),
        t
      );
    })(contexts_BGRNBsB8_k),
    It = (function (e) {
      contexts_BGRNBsB8_te(t, e);
      function t(n, r) {
        var i = e.call(this) || this;
        return ((i.destination = n), (i.source = r), i);
      }
      return (
        (t.prototype.next = function (n) {
          var r, i;
          (i = (r = this.destination) === null || r === void 0 ? void 0 : r.next) === null ||
            i === void 0 ||
            i.call(r, n);
        }),
        (t.prototype.error = function (n) {
          var r, i;
          (i = (r = this.destination) === null || r === void 0 ? void 0 : r.error) === null ||
            i === void 0 ||
            i.call(r, n);
        }),
        (t.prototype.complete = function () {
          var n, r;
          (r = (n = this.destination) === null || n === void 0 ? void 0 : n.complete) === null ||
            r === void 0 ||
            r.call(n);
        }),
        (t.prototype._subscribe = function (n) {
          var r, i;
          return (i = (r = this.source) === null || r === void 0 ? void 0 : r.subscribe(n)) !==
            null && i !== void 0
            ? i
            : an;
        }),
        t
      );
    })(contexts_BGRNBsB8_ee),
    ln = (function (e) {
      contexts_BGRNBsB8_te(t, e);
      function t(n) {
        var r = e.call(this) || this;
        return ((r._value = n), r);
      }
      return (
        Object.defineProperty(t.prototype, 'value', {
          get: function () {
            return this.getValue();
          },
          enumerable: !1,
          configurable: !0,
        }),
        (t.prototype._subscribe = function (n) {
          var r = e.prototype._subscribe.call(this, n);
          return (!r.closed && n.next(this._value), r);
        }),
        (t.prototype.getValue = function () {
          var n = this,
            r = n.hasError,
            i = n.thrownError,
            o = n._value;
          if (r) throw i;
          return (this._throwIfClosed(), o);
        }),
        (t.prototype.next = function (n) {
          e.prototype.next.call(this, (this._value = n));
        }),
        t
      );
    })(contexts_BGRNBsB8_ee),
    qr = {
      now: function () {
        return Date.now();
      },
    },
    Kr = (function (e) {
      contexts_BGRNBsB8_te(t, e);
      function t(n, r) {
        return e.call(this) || this;
      }
      return (
        (t.prototype.schedule = function (n, r) {
          return this;
        }),
        t
      );
    })(contexts_BGRNBsB8_Oe),
    Mt = {
      setInterval: function (e, t) {
        for (var n = [], r = 2; r < arguments.length; r++) n[r - 2] = arguments[r];
        return setInterval.apply(void 0, contexts_BGRNBsB8_be([e, t], contexts_BGRNBsB8_le(n)));
      },
      clearInterval: function (e) {
        return clearInterval(e);
      },
      delegate: void 0,
    },
    Gr = (function (e) {
      contexts_BGRNBsB8_te(t, e);
      function t(n, r) {
        var i = e.call(this, n, r) || this;
        return ((i.scheduler = n), (i.work = r), (i.pending = !1), i);
      }
      return (
        (t.prototype.schedule = function (n, r) {
          var i;
          if ((r === void 0 && (r = 0), this.closed)) return this;
          this.state = n;
          var o = this.id,
            s = this.scheduler;
          return (
            o != null && (this.id = this.recycleAsyncId(s, o, r)),
            (this.pending = !0),
            (this.delay = r),
            (this.id =
              (i = this.id) !== null && i !== void 0 ? i : this.requestAsyncId(s, this.id, r)),
            this
          );
        }),
        (t.prototype.requestAsyncId = function (n, r, i) {
          return (i === void 0 && (i = 0), Mt.setInterval(n.flush.bind(n, this), i));
        }),
        (t.prototype.recycleAsyncId = function (n, r, i) {
          if ((i === void 0 && (i = 0), i != null && this.delay === i && this.pending === !1))
            return r;
          r != null && Mt.clearInterval(r);
        }),
        (t.prototype.execute = function (n, r) {
          if (this.closed) return new Error('executing a cancelled action');
          this.pending = !1;
          var i = this._execute(n, r);
          if (i) return i;
          this.pending === !1 &&
            this.id != null &&
            (this.id = this.recycleAsyncId(this.scheduler, this.id, null));
        }),
        (t.prototype._execute = function (n, r) {
          var i = !1,
            o;
          try {
            this.work(n);
          } catch (s) {
            ((i = !0), (o = s || new Error('Scheduled action threw falsy error')));
          }
          if (i) return (this.unsubscribe(), o);
        }),
        (t.prototype.unsubscribe = function () {
          if (!this.closed) {
            var n = this,
              r = n.id,
              i = n.scheduler,
              o = i.actions;
            ((this.work = this.state = this.scheduler = null),
              (this.pending = !1),
              contexts_BGRNBsB8_Ue(o, this),
              r != null && (this.id = this.recycleAsyncId(i, r, null)),
              (this.delay = null),
              e.prototype.unsubscribe.call(this));
          }
        }),
        t
      );
    })(Kr),
    Rt = (function () {
      function e(t, n) {
        (n === void 0 && (n = e.now), (this.schedulerActionCtor = t), (this.now = n));
      }
      return (
        (e.prototype.schedule = function (t, n, r) {
          return (n === void 0 && (n = 0), new this.schedulerActionCtor(this, t).schedule(r, n));
        }),
        (e.now = qr.now),
        e
      );
    })(),
    Qr = (function (e) {
      contexts_BGRNBsB8_te(t, e);
      function t(n, r) {
        r === void 0 && (r = Rt.now);
        var i = e.call(this, n, r) || this;
        return ((i.actions = []), (i._active = !1), i);
      }
      return (
        (t.prototype.flush = function (n) {
          var r = this.actions;
          if (this._active) {
            r.push(n);
            return;
          }
          var i;
          this._active = !0;
          do if ((i = n.execute(n.state, n.delay))) break;
          while ((n = r.shift()));
          if (((this._active = !1), i)) {
            for (; (n = r.shift()); ) n.unsubscribe();
            throw i;
          }
        }),
        t
      );
    })(Rt),
    Jr = new Qr(Gr);
  function Xr(e) {
    return e && contexts_BGRNBsB8_P(e.schedule);
  }
  function Zr(e) {
    return e[e.length - 1];
  }
  function yt(e) {
    return Xr(Zr(e)) ? e.pop() : void 0;
  }
  var wt = function (e) {
    return e && typeof e.length == 'number' && typeof e != 'function';
  };
  function fn(e) {
    return contexts_BGRNBsB8_P(e == null ? void 0 : e.then);
  }
  function dn(e) {
    return contexts_BGRNBsB8_P(e[bt]);
  }
  function pn(e) {
    return (
      Symbol.asyncIterator && contexts_BGRNBsB8_P(e == null ? void 0 : e[Symbol.asyncIterator])
    );
  }
  function hn(e) {
    return new TypeError(
      'You provided ' +
        (e !== null && typeof e == 'object' ? 'an invalid object' : "'" + e + "'") +
        ' where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.'
    );
  }
  function ei() {
    return typeof Symbol != 'function' || !Symbol.iterator ? '@@iterator' : Symbol.iterator;
  }
  var vn = ei();
  function mn(e) {
    return contexts_BGRNBsB8_P(e == null ? void 0 : e[vn]);
  }
  function gn(e) {
    return Rr(this, arguments, function () {
      var n, r, i, o;
      return sn(this, function (s) {
        switch (s.label) {
          case 0:
            ((n = e.getReader()), (s.label = 1));
          case 1:
            (s.trys.push([1, , 9, 10]), (s.label = 2));
          case 2:
            return [4, contexts_BGRNBsB8_he(n.read())];
          case 3:
            return (
              (r = s.sent()),
              (i = r.value),
              (o = r.done),
              o ? [4, contexts_BGRNBsB8_he(void 0)] : [3, 5]
            );
          case 4:
            return [2, s.sent()];
          case 5:
            return [4, contexts_BGRNBsB8_he(i)];
          case 6:
            return [4, s.sent()];
          case 7:
            return (s.sent(), [3, 2]);
          case 8:
            return [3, 10];
          case 9:
            return (n.releaseLock(), [7]);
          case 10:
            return [2];
        }
      });
    });
  }
  function bn(e) {
    return contexts_BGRNBsB8_P(e == null ? void 0 : e.getReader);
  }
  function H(e) {
    if (e instanceof contexts_BGRNBsB8_k) return e;
    if (e != null) {
      if (dn(e)) return ti(e);
      if (wt(e)) return ni(e);
      if (fn(e)) return ri(e);
      if (pn(e)) return yn(e);
      if (mn(e)) return ii(e);
      if (bn(e)) return oi(e);
    }
    throw hn(e);
  }
  function ti(e) {
    return new contexts_BGRNBsB8_k(function (t) {
      var n = e[bt]();
      if (contexts_BGRNBsB8_P(n.subscribe)) return n.subscribe(t);
      throw new TypeError('Provided object does not correctly implement Symbol.observable');
    });
  }
  function ni(e) {
    return new contexts_BGRNBsB8_k(function (t) {
      for (var n = 0; n < e.length && !t.closed; n++) t.next(e[n]);
      t.complete();
    });
  }
  function ri(e) {
    return new contexts_BGRNBsB8_k(function (t) {
      e.then(
        function (n) {
          t.closed || (t.next(n), t.complete());
        },
        function (n) {
          return t.error(n);
        }
      ).then(null, un);
    });
  }
  function ii(e) {
    return new contexts_BGRNBsB8_k(function (t) {
      var n, r;
      try {
        for (var i = contexts_BGRNBsB8_ge(e), o = i.next(); !o.done; o = i.next()) {
          var s = o.value;
          if ((t.next(s), t.closed)) return;
        }
      } catch (a) {
        n = { error: a };
      } finally {
        try {
          o && !o.done && (r = i.return) && r.call(i);
        } finally {
          if (n) throw n.error;
        }
      }
      t.complete();
    });
  }
  function yn(e) {
    return new contexts_BGRNBsB8_k(function (t) {
      si(e, t).catch(function (n) {
        return t.error(n);
      });
    });
  }
  function oi(e) {
    return yn(gn(e));
  }
  function si(e, t) {
    var n, r, i, o;
    return Mr(this, void 0, void 0, function () {
      var s, a;
      return sn(this, function (c) {
        switch (c.label) {
          case 0:
            (c.trys.push([0, 5, 6, 11]), (n = Dr(e)), (c.label = 1));
          case 1:
            return [4, n.next()];
          case 2:
            if (((r = c.sent()), !!r.done)) return [3, 4];
            if (((s = r.value), t.next(s), t.closed)) return [2];
            c.label = 3;
          case 3:
            return [3, 1];
          case 4:
            return [3, 11];
          case 5:
            return ((a = c.sent()), (i = { error: a }), [3, 11]);
          case 6:
            return (
              c.trys.push([6, , 9, 10]),
              r && !r.done && (o = n.return) ? [4, o.call(n)] : [3, 8]
            );
          case 7:
            (c.sent(), (c.label = 8));
          case 8:
            return [3, 10];
          case 9:
            if (i) throw i.error;
            return [7];
          case 10:
            return [7];
          case 11:
            return (t.complete(), [2]);
        }
      });
    });
  }
  function contexts_BGRNBsB8_ie(e, t, n, r, i) {
    (r === void 0 && (r = 0), i === void 0 && (i = !1));
    var o = t.schedule(function () {
      (n(), i ? e.add(this.schedule(null, r)) : this.unsubscribe());
    }, r);
    if ((e.add(o), !i)) return o;
  }
  function wn(e, t) {
    return (
      t === void 0 && (t = 0),
      contexts_BGRNBsB8_j(function (n, r) {
        n.subscribe(
          contexts_BGRNBsB8_F(
            r,
            function (i) {
              return contexts_BGRNBsB8_ie(
                r,
                e,
                function () {
                  return r.next(i);
                },
                t
              );
            },
            function () {
              return contexts_BGRNBsB8_ie(
                r,
                e,
                function () {
                  return r.complete();
                },
                t
              );
            },
            function (i) {
              return contexts_BGRNBsB8_ie(
                r,
                e,
                function () {
                  return r.error(i);
                },
                t
              );
            }
          )
        );
      })
    );
  }
  function xn(e, t) {
    return (
      t === void 0 && (t = 0),
      contexts_BGRNBsB8_j(function (n, r) {
        r.add(
          e.schedule(function () {
            return n.subscribe(r);
          }, t)
        );
      })
    );
  }
  function ai(e, t) {
    return H(e).pipe(xn(t), wn(t));
  }
  function ci(e, t) {
    return H(e).pipe(xn(t), wn(t));
  }
  function ui(e, t) {
    return new contexts_BGRNBsB8_k(function (n) {
      var r = 0;
      return t.schedule(function () {
        r === e.length ? n.complete() : (n.next(e[r++]), n.closed || this.schedule());
      });
    });
  }
  function li(e, t) {
    return new contexts_BGRNBsB8_k(function (n) {
      var r;
      return (
        contexts_BGRNBsB8_ie(n, t, function () {
          ((r = e[vn]()),
            contexts_BGRNBsB8_ie(
              n,
              t,
              function () {
                var i, o, s;
                try {
                  ((i = r.next()), (o = i.value), (s = i.done));
                } catch (a) {
                  n.error(a);
                  return;
                }
                s ? n.complete() : n.next(o);
              },
              0,
              !0
            ));
        }),
        function () {
          return contexts_BGRNBsB8_P(r == null ? void 0 : r.return) && r.return();
        }
      );
    });
  }
  function Sn(e, t) {
    if (!e) throw new Error('Iterable cannot be null');
    return new contexts_BGRNBsB8_k(function (n) {
      contexts_BGRNBsB8_ie(n, t, function () {
        var r = e[Symbol.asyncIterator]();
        contexts_BGRNBsB8_ie(
          n,
          t,
          function () {
            r.next().then(function (i) {
              i.done ? n.complete() : n.next(i.value);
            });
          },
          0,
          !0
        );
      });
    });
  }
  function fi(e, t) {
    return Sn(gn(e), t);
  }
  function di(e, t) {
    if (e != null) {
      if (dn(e)) return ai(e, t);
      if (wt(e)) return ui(e, t);
      if (fn(e)) return ci(e, t);
      if (pn(e)) return Sn(e, t);
      if (mn(e)) return li(e, t);
      if (bn(e)) return fi(e, t);
    }
    throw hn(e);
  }
  function contexts_BGRNBsB8_Qe(e, t) {
    return t ? di(e, t) : H(e);
  }
  function Dt() {
    for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
    var n = yt(e);
    return contexts_BGRNBsB8_Qe(e, n);
  }
  function pi(e) {
    return e instanceof Date && !isNaN(e);
  }
  var hi = contexts_BGRNBsB8_mt(function (e) {
    return function (n) {
      (n === void 0 && (n = null),
        e(this),
        (this.message = 'Timeout has occurred'),
        (this.name = 'TimeoutError'),
        (this.info = n));
    };
  });
  function vi(e, t) {
    var n = pi(e) ? { first: e } : typeof e == 'number' ? { each: e } : e,
      r = n.first,
      i = n.each,
      o = n.with,
      s = o === void 0 ? mi : o,
      a = n.scheduler,
      c = a === void 0 ? Jr : a,
      u = n.meta,
      l = u === void 0 ? null : u;
    if (r == null && i == null) throw new TypeError('No timeout provided.');
    return contexts_BGRNBsB8_j(function (f, v) {
      var d,
        m,
        p = null,
        g = 0,
        h = function (x) {
          m = contexts_BGRNBsB8_ie(
            v,
            c,
            function () {
              try {
                (d.unsubscribe(),
                  H(
                    s({
                      meta: l,
                      lastValue: p,
                      seen: g,
                    })
                  ).subscribe(v));
              } catch (E) {
                v.error(E);
              }
            },
            x
          );
        };
      ((d = f.subscribe(
        contexts_BGRNBsB8_F(
          v,
          function (x) {
            (m == null || m.unsubscribe(), g++, v.next((p = x)), i > 0 && h(i));
          },
          void 0,
          void 0,
          function () {
            ((m != null && m.closed) || m == null || m.unsubscribe(), (p = null));
          }
        )
      )),
        !g && h(r != null ? (typeof r == 'number' ? r : +r - c.now()) : i));
    });
  }
  function mi(e) {
    throw new hi(e);
  }
  function O(e, t) {
    return contexts_BGRNBsB8_j(function (n, r) {
      var i = 0;
      n.subscribe(
        contexts_BGRNBsB8_F(r, function (o) {
          r.next(e.call(t, o, i++));
        })
      );
    });
  }
  var gi = Array.isArray;
  function bi(e, t) {
    return gi(t) ? e.apply(void 0, contexts_BGRNBsB8_be([], contexts_BGRNBsB8_le(t))) : e(t);
  }
  function yi(e) {
    return O(function (t) {
      return bi(e, t);
    });
  }
  function wi(e, t, n, r, i, o, s, a) {
    var c = [],
      u = 0,
      l = 0,
      f = !1,
      v = function () {
        f && !c.length && !u && t.complete();
      },
      d = function (p) {
        return u < r ? m(p) : c.push(p);
      },
      m = function (p) {
        u++;
        var g = !1;
        H(n(p, l++)).subscribe(
          contexts_BGRNBsB8_F(
            t,
            function (h) {
              t.next(h);
            },
            function () {
              g = !0;
            },
            void 0,
            function () {
              if (g)
                try {
                  u--;
                  for (
                    var h = function () {
                      var x = c.shift();
                      s || m(x);
                    };
                    c.length && u < r;

                  )
                    h();
                  v();
                } catch (x) {
                  t.error(x);
                }
            }
          )
        );
      };
    return (
      e.subscribe(
        contexts_BGRNBsB8_F(t, d, function () {
          ((f = !0), v());
        })
      ),
      function () {}
    );
  }
  function xt(e, t, n) {
    return (
      n === void 0 && (n = 1 / 0),
      contexts_BGRNBsB8_P(t)
        ? xt(function (r, i) {
            return O(function (o, s) {
              return t(r, o, i, s);
            })(H(e(r, i)));
          }, n)
        : (typeof t == 'number' && (n = t),
          contexts_BGRNBsB8_j(function (r, i) {
            return wi(r, i, e, n);
          }))
    );
  }
  function xi(e) {
    return xt(contexts_BGRNBsB8_Ge, e);
  }
  function Si() {
    return xi(1);
  }
  function contexts_BGRNBsB8_We() {
    for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
    return Si()(contexts_BGRNBsB8_Qe(e, yt(e)));
  }
  var Ti = /* unused pure expression or super */ null && ['addListener', 'removeListener'],
    Ei = /* unused pure expression or super */ null && ['addEventListener', 'removeEventListener'],
    Ci = /* unused pure expression or super */ null && ['on', 'off'];
  function ct(e, t, n, r) {
    if ((contexts_BGRNBsB8_P(n) && ((r = n), (n = void 0)), r)) return ct(e, t, n).pipe(yi(r));
    var i = contexts_BGRNBsB8_le(
        Oi(e)
          ? Ei.map(function (a) {
              return function (c) {
                return e[a](t, c, n);
              };
            })
          : Pi(e)
            ? Ti.map($t(e, t))
            : Ai(e)
              ? Ci.map($t(e, t))
              : [],
        2
      ),
      o = i[0],
      s = i[1];
    if (!o && wt(e))
      return xt(function (a) {
        return ct(a, t, n);
      })(H(e));
    if (!o) throw new TypeError('Invalid event target');
    return new contexts_BGRNBsB8_k(function (a) {
      var c = function () {
        for (var u = [], l = 0; l < arguments.length; l++) u[l] = arguments[l];
        return a.next(1 < u.length ? u : u[0]);
      };
      return (
        o(c),
        function () {
          return s(c);
        }
      );
    });
  }
  function $t(e, t) {
    return function (n) {
      return function (r) {
        return e[n](t, r);
      };
    };
  }
  function Pi(e) {
    return contexts_BGRNBsB8_P(e.addListener) && contexts_BGRNBsB8_P(e.removeListener);
  }
  function Ai(e) {
    return contexts_BGRNBsB8_P(e.on) && contexts_BGRNBsB8_P(e.off);
  }
  function Oi(e) {
    return contexts_BGRNBsB8_P(e.addEventListener) && contexts_BGRNBsB8_P(e.removeEventListener);
  }
  function contexts_BGRNBsB8_Je(e, t) {
    return contexts_BGRNBsB8_j(function (n, r) {
      var i = 0;
      n.subscribe(
        contexts_BGRNBsB8_F(r, function (o) {
          return e.call(t, o, i++) && r.next(o);
        })
      );
    });
  }
  function ki(e, t, n, r, i) {
    return function (o, s) {
      var a = n,
        c = t,
        u = 0;
      o.subscribe(
        contexts_BGRNBsB8_F(
          s,
          function (l) {
            var f = u++;
            ((c = a ? e(c, l, f) : ((a = !0), l)), s.next(c));
          },
          i
        )
      );
    };
  }
  function _i(e, t) {
    return (
      t === void 0 && (t = contexts_BGRNBsB8_Ge),
      (e = e ?? Li),
      contexts_BGRNBsB8_j(function (n, r) {
        var i,
          o = !0;
        n.subscribe(
          contexts_BGRNBsB8_F(r, function (s) {
            var a = t(s);
            (o || !e(i, a)) && ((o = !1), (i = a), r.next(s));
          })
        );
      })
    );
  }
  function Li(e, t) {
    return e === t;
  }
  function contexts_BGRNBsB8_ut(e, t) {
    return contexts_BGRNBsB8_j(ki(e, t, arguments.length >= 2, !0));
  }
  function Ii(e) {
    e === void 0 && (e = {});
    var t = e.connector,
      n =
        t === void 0
          ? function () {
              return new contexts_BGRNBsB8_ee();
            }
          : t,
      r = e.resetOnError,
      i = r === void 0 ? !0 : r,
      o = e.resetOnComplete,
      s = o === void 0 ? !0 : o,
      a = e.resetOnRefCountZero,
      c = a === void 0 ? !0 : a;
    return function (u) {
      var l,
        f,
        v,
        d = 0,
        m = !1,
        p = !1,
        g = function () {
          (f == null || f.unsubscribe(), (f = void 0));
        },
        h = function () {
          (g(), (l = v = void 0), (m = p = !1));
        },
        x = function () {
          var E = l;
          (h(), E == null || E.unsubscribe());
        };
      return contexts_BGRNBsB8_j(function (E, A) {
        (d++, !p && !m && g());
        var b = (v = v ?? n());
        (A.add(function () {
          (d--, d === 0 && !p && !m && (f = contexts_BGRNBsB8_tt(x, c)));
        }),
          b.subscribe(A),
          !l &&
            d > 0 &&
            ((l = new contexts_BGRNBsB8_Ce({
              next: function (S) {
                return b.next(S);
              },
              error: function (S) {
                ((p = !0), g(), (f = contexts_BGRNBsB8_tt(h, i, S)), b.error(S));
              },
              complete: function () {
                ((m = !0), g(), (f = contexts_BGRNBsB8_tt(h, s)), b.complete());
              },
            })),
            H(E).subscribe(l)));
      })(u);
    };
  }
  function contexts_BGRNBsB8_tt(e, t) {
    for (var n = [], r = 2; r < arguments.length; r++) n[r - 2] = arguments[r];
    if (t === !0) {
      e();
      return;
    }
    if (t !== !1) {
      var i = new contexts_BGRNBsB8_Ce({
        next: function () {
          (i.unsubscribe(), e());
        },
      });
      return H(t.apply(void 0, contexts_BGRNBsB8_be([], contexts_BGRNBsB8_le(n)))).subscribe(i);
    }
  }
  function Mi(e) {
    return contexts_BGRNBsB8_j(function (t, n) {
      var r = !1,
        i = contexts_BGRNBsB8_F(
          n,
          function () {
            (i == null || i.unsubscribe(), (r = !0));
          },
          contexts_BGRNBsB8_je
        );
      (H(e).subscribe(i),
        t.subscribe(
          contexts_BGRNBsB8_F(n, function (o) {
            return r && n.next(o);
          })
        ));
    });
  }
  function contexts_BGRNBsB8_D() {
    for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
    var n = yt(e);
    return contexts_BGRNBsB8_j(function (r, i) {
      (n ? contexts_BGRNBsB8_We(e, r, n) : contexts_BGRNBsB8_We(e, r)).subscribe(i);
    });
  }
  function Tn(e, t) {
    return contexts_BGRNBsB8_j(function (n, r) {
      var i = null,
        o = 0,
        s = !1,
        a = function () {
          return s && !i && r.complete();
        };
      n.subscribe(
        contexts_BGRNBsB8_F(
          r,
          function (c) {
            i == null || i.unsubscribe();
            var u = 0,
              l = o++;
            H(e(c, l)).subscribe(
              (i = contexts_BGRNBsB8_F(
                r,
                function (f) {
                  return r.next(t ? t(c, f, l, u++) : f);
                },
                function () {
                  ((i = null), a());
                }
              ))
            );
          },
          function () {
            ((s = !0), a());
          }
        )
      );
    });
  }
  function Nt(e) {
    return contexts_BGRNBsB8_j(function (t, n) {
      (H(e).subscribe(
        contexts_BGRNBsB8_F(
          n,
          function () {
            return n.complete();
          },
          contexts_BGRNBsB8_je
        )
      ),
        !n.closed && t.subscribe(n));
    });
  }
  function Ri(e, t, n) {
    var r = contexts_BGRNBsB8_P(e) || t || n ? { next: e, error: t, complete: n } : e;
    return r
      ? contexts_BGRNBsB8_j(function (i, o) {
          var s;
          (s = r.subscribe) === null || s === void 0 || s.call(r);
          var a = !0;
          i.subscribe(
            contexts_BGRNBsB8_F(
              o,
              function (c) {
                var u;
                ((u = r.next) === null || u === void 0 || u.call(r, c), o.next(c));
              },
              function () {
                var c;
                ((a = !1), (c = r.complete) === null || c === void 0 || c.call(r), o.complete());
              },
              function (c) {
                var u;
                ((a = !1), (u = r.error) === null || u === void 0 || u.call(r, c), o.error(c));
              },
              function () {
                var c, u;
                (a && ((c = r.unsubscribe) === null || c === void 0 || c.call(r)),
                  (u = r.finalize) === null || u === void 0 || u.call(r));
              }
            )
          );
        })
      : contexts_BGRNBsB8_Ge;
  }
  var Di = Object.defineProperty,
    $i = Object.defineProperties,
    Ni = Object.getOwnPropertyDescriptors,
    Ft = Object.getOwnPropertySymbols,
    Fi = Object.prototype.hasOwnProperty,
    Ui = Object.prototype.propertyIsEnumerable,
    Ut = (e, t, n) =>
      t in e ? Di(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (e[t] = n),
    contexts_BGRNBsB8_Y = (e, t) => {
      for (var n in t || (t = {})) Fi.call(t, n) && Ut(e, n, t[n]);
      if (Ft) for (var n of Ft(t)) Ui.call(t, n) && Ut(e, n, t[n]);
      return e;
    },
    contexts_BGRNBsB8_se = (e, t) => $i(e, Ni(t)),
    contexts_BGRNBsB8_V = (e, t, n) =>
      new Promise((r, i) => {
        var o = (c) => {
            try {
              a(n.next(c));
            } catch (u) {
              i(u);
            }
          },
          s = (c) => {
            try {
              a(n.throw(c));
            } catch (u) {
              i(u);
            }
          },
          a = (c) => (c.done ? r(c.value) : Promise.resolve(c.value).then(o, s));
        a((n = n.apply(e, t)).next());
      }),
    En = 'lk';
  function B(e) {
    return typeof e > 'u' ? !1 : ji(e) || Wi(e);
  }
  function ji(e) {
    var t;
    return e
      ? e.hasOwnProperty('participant') &&
          e.hasOwnProperty('source') &&
          e.hasOwnProperty('track') &&
          typeof ((t = e.publication) == null ? void 0 : t.track) < 'u'
      : !1;
  }
  function Wi(e) {
    return e
      ? e.hasOwnProperty('participant') &&
          e.hasOwnProperty('source') &&
          e.hasOwnProperty('publication') &&
          typeof e.publication < 'u'
      : !1;
  }
  function contexts_BGRNBsB8_Pe(e) {
    return e
      ? e.hasOwnProperty('participant') && e.hasOwnProperty('source') && typeof e.publication > 'u'
      : !1;
  }
  function contexts_BGRNBsB8_N(e) {
    if (typeof e == 'string' || typeof e == 'number') return `${e}`;
    if (contexts_BGRNBsB8_Pe(e)) return `${e.participant.identity}_${e.source}_placeholder`;
    if (B(e)) return `${e.participant.identity}_${e.publication.source}_${e.publication.trackSid}`;
    throw new Error(`Can't generate a id for the given track reference: ${e}`);
  }
  function No(e, t) {
    return e === void 0 || t === void 0
      ? !1
      : B(e) && B(t)
        ? e.publication.trackSid === t.publication.trackSid
        : contexts_BGRNBsB8_N(e) === contexts_BGRNBsB8_N(t);
  }
  function Fo(e, t) {
    return typeof t > 'u'
      ? !1
      : B(e)
        ? t.some(
            (n) =>
              n.participant.identity === e.participant.identity &&
              B(n) &&
              n.publication.trackSid === e.publication.trackSid
          )
        : contexts_BGRNBsB8_Pe(e)
          ? t.some(
              (n) =>
                n.participant.identity === e.participant.identity &&
                contexts_BGRNBsB8_Pe(n) &&
                n.source === e.source
            )
          : !1;
  }
  function Bi(e, t) {
    return (
      contexts_BGRNBsB8_Pe(e) &&
      B(t) &&
      t.participant.identity === e.participant.identity &&
      t.source === e.source
    );
  }
  function Uo() {
    const e = document.createElement('p');
    ((e.style.width = '100%'), (e.style.height = '200px'));
    const t = document.createElement('div');
    ((t.style.position = 'absolute'),
      (t.style.top = '0px'),
      (t.style.left = '0px'),
      (t.style.visibility = 'hidden'),
      (t.style.width = '200px'),
      (t.style.height = '150px'),
      (t.style.overflow = 'hidden'),
      t.appendChild(e),
      document.body.appendChild(t));
    const n = e.offsetWidth;
    t.style.overflow = 'scroll';
    let r = e.offsetWidth;
    return (n === r && (r = t.clientWidth), document.body.removeChild(t), n - r);
  }
  function jo() {
    return typeof document < 'u';
  }
  function Vi(e) {
    e = contexts_BGRNBsB8_Y({}, e);
    const t = '(?:(?:[a-z]+:)?//)?',
      n = '(?:\\S+(?::\\S*)?@)?',
      r = new RegExp(
        '(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}',
        'g'
      ).source,
      u = `(?:${t}|www\\.)${n}(?:localhost|${r}|(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))\\.?)(?::\\d{2,5})?(?:[/?#][^\\s"]*)?`;
    return e.exact ? new RegExp(`(?:^${u}$)`, 'i') : new RegExp(u, 'ig');
  }
  var jt = '[^\\.\\s@:](?:[^\\s@:]*[^\\s@:\\.])?@[^\\.\\s@]+(?:\\.[^\\.\\s@]+)*';
  function Hi({ exact: e } = {}) {
    return e ? new RegExp(`^${jt}$`) : new RegExp(jt, 'g');
  }
  function Wo(e, t, n) {
    return Tr(e, t, () =>
      contexts_BGRNBsB8_V(this, null, function* () {
        const { x: i, y: o } = yield Ar(e, t, {
          placement: 'top',
          middleware: [Er(6), Pr(), Cr({ padding: 5 })],
        });
        n == null || n(i, o);
      })
    );
  }
  function Bo(e, t) {
    return !e.contains(t.target);
  }
  var Vo = () => ({
    email: Hi(),
    url: Vi({}),
  });
  function Ho(e, t) {
    const n = Object.entries(t)
        .map(([o, s], a) =>
          Array.from(e.matchAll(s)).map(({ index: c, 0: u }) => ({
            type: o,
            weight: a,
            content: u,
            index: c ?? 0,
          }))
        )
        .flat()
        .sort((o, s) => {
          const a = o.index - s.index;
          return a !== 0 ? a : o.weight - s.weight;
        })
        .filter(({ index: o }, s, a) => {
          if (s === 0) return !0;
          const c = a[s - 1];
          return c.index + c.content.length <= o;
        }),
      r = [];
    let i = 0;
    for (const { type: o, content: s, index: a } of n)
      (a > i && r.push(e.substring(i, a)), r.push({ type: o, content: s }), (i = a + s.length));
    return (e.length > i && r.push(e.substring(i)), r);
  }
  var zi = [
      RoomEvent.ConnectionStateChanged,
      RoomEvent.RoomMetadataChanged,
      RoomEvent.ActiveSpeakersChanged,
      RoomEvent.ConnectionQualityChanged,
      RoomEvent.ParticipantConnected,
      RoomEvent.ParticipantDisconnected,
      RoomEvent.ParticipantPermissionsChanged,
      RoomEvent.ParticipantMetadataChanged,
      RoomEvent.ParticipantNameChanged,
      RoomEvent.ParticipantAttributesChanged,
      RoomEvent.TrackMuted,
      RoomEvent.TrackUnmuted,
      RoomEvent.TrackPublished,
      RoomEvent.TrackUnpublished,
      RoomEvent.TrackStreamStateChanged,
      RoomEvent.TrackSubscriptionFailed,
      RoomEvent.TrackSubscriptionPermissionChanged,
      RoomEvent.TrackSubscriptionStatusChanged,
    ],
    Cn = [...zi, RoomEvent.LocalTrackPublished, RoomEvent.LocalTrackUnpublished],
    Yi = [
      ParticipantEvent.TrackPublished,
      ParticipantEvent.TrackUnpublished,
      ParticipantEvent.TrackMuted,
      ParticipantEvent.TrackUnmuted,
      ParticipantEvent.TrackStreamStateChanged,
      ParticipantEvent.TrackSubscribed,
      ParticipantEvent.TrackUnsubscribed,
      ParticipantEvent.TrackSubscriptionPermissionChanged,
      ParticipantEvent.TrackSubscriptionFailed,
      ParticipantEvent.LocalTrackPublished,
      ParticipantEvent.LocalTrackUnpublished,
    ],
    qi = [
      ParticipantEvent.ConnectionQualityChanged,
      ParticipantEvent.IsSpeakingChanged,
      ParticipantEvent.ParticipantMetadataChanged,
      ParticipantEvent.ParticipantPermissionsChanged,
      ParticipantEvent.TrackMuted,
      ParticipantEvent.TrackUnmuted,
      ParticipantEvent.TrackPublished,
      ParticipantEvent.TrackUnpublished,
      ParticipantEvent.TrackStreamStateChanged,
      ParticipantEvent.TrackSubscriptionFailed,
      ParticipantEvent.TrackSubscriptionPermissionChanged,
      ParticipantEvent.TrackSubscriptionStatusChanged,
    ],
    Pn = [...qi, ParticipantEvent.LocalTrackPublished, ParticipantEvent.LocalTrackUnpublished],
    contexts_BGRNBsB8_L = Ir.getLogger('lk-components-js');
  contexts_BGRNBsB8_L.setDefaultLevel('WARN');
  function zo(e, t = {}) {
    var n;
    (contexts_BGRNBsB8_L.setLevel(e), Vn((n = t.liveKitClientLogLevel) != null ? n : e));
  }
  function Yo(e, t = {}) {
    var n;
    const r = contexts_BGRNBsB8_L.methodFactory;
    ((contexts_BGRNBsB8_L.methodFactory = (i, o, s) => {
      const a = r(i, o, s),
        c = St[i],
        u = c >= o && c < St.silent;
      return (l, f) => {
        (f ? a(l, f) : a(l), u && e(c, l, f));
      };
    }),
      contexts_BGRNBsB8_L.setLevel(contexts_BGRNBsB8_L.getLevel()),
      Hn((n = t.liveKitClientLogExtension) != null ? n : e));
  }
  var qo = [
    {
      columns: 1,
      rows: 1,
    },
    {
      columns: 1,
      rows: 2,
      orientation: 'portrait',
    },
    {
      columns: 2,
      rows: 1,
      orientation: 'landscape',
    },
    {
      columns: 2,
      rows: 2,
      minWidth: 560,
    },
    {
      columns: 3,
      rows: 3,
      minWidth: 700,
    },
    {
      columns: 4,
      rows: 4,
      minWidth: 960,
    },
    {
      columns: 5,
      rows: 5,
      minWidth: 1100,
    },
  ];
  function Ki(e, t, n, r) {
    if (e.length < 1) throw new Error('At least one grid layout definition must be provided.');
    const i = Gi(e);
    if (n <= 0 || r <= 0) return i[0];
    let o = 0;
    const s = n / r > 1 ? 'landscape' : 'portrait';
    let a = i.find((c, u, l) => {
      o = u;
      const f =
        l.findIndex((v, d) => {
          const m = !v.orientation || v.orientation === s,
            p = d > u,
            g = v.maxTiles === c.maxTiles;
          return p && g && m;
        }) !== -1;
      return c.maxTiles >= t && !f;
    });
    if (a === void 0)
      if (((a = i[i.length - 1]), a))
        contexts_BGRNBsB8_L.warn(
          `No layout found for: participantCount: ${t}, width/height: ${n}/${r} fallback to biggest available layout (${a}).`
        );
      else throw new Error('No layout or fallback layout found.');
    if ((n < a.minWidth || r < a.minHeight) && o > 0) {
      const c = i[o - 1];
      a = Ki(i.slice(0, o), c.maxTiles, n, r);
    }
    return a;
  }
  function Gi(e) {
    return [...e]
      .map((t) => {
        var n, r;
        return {
          name: `${t.columns}x${t.rows}`,
          columns: t.columns,
          rows: t.rows,
          maxTiles: t.columns * t.rows,
          minWidth: (n = t.minWidth) != null ? n : 0,
          minHeight: (r = t.minHeight) != null ? r : 0,
          orientation: t.orientation,
        };
      })
      .sort((t, n) =>
        t.maxTiles !== n.maxTiles
          ? t.maxTiles - n.maxTiles
          : t.minWidth !== 0 || n.minWidth !== 0
            ? t.minWidth - n.minWidth
            : t.minHeight !== 0 || n.minHeight !== 0
              ? t.minHeight - n.minHeight
              : 0
      );
  }
  function Ko() {
    return (
      typeof navigator < 'u' && navigator.mediaDevices && !!navigator.mediaDevices.getDisplayMedia
    );
  }
  function Go(e, t) {
    var n;
    return contexts_BGRNBsB8_se(contexts_BGRNBsB8_Y({}, e), {
      receivedAtMediaTimestamp: (n = t.rtpTimestamp) != null ? n : 0,
      receivedAt: t.timestamp,
    });
  }
  function Qo(e, t, n) {
    return [...e, ...t]
      .reduceRight((r, i) => (r.find((o) => o.id === i.id) || r.unshift(i), r), [])
      .slice(0 - n);
  }
  var An = /* unused pure expression or super */ null && [],
    On = {
      showChat: !1,
      unreadMessages: 0,
      showSettings: !1,
    };
  function Qi(e) {
    return typeof e == 'object';
  }
  function Jo(e) {
    return Array.isArray(e) && e.filter(Qi).length > 0;
  }
  function kn(e, t) {
    return t.audioLevel - e.audioLevel;
  }
  function _n(e, t) {
    return e.isSpeaking === t.isSpeaking ? 0 : e.isSpeaking ? -1 : 1;
  }
  function Ln(e, t) {
    var n, r, i, o;
    return e.lastSpokeAt !== void 0 || t.lastSpokeAt !== void 0
      ? ((r = (n = t.lastSpokeAt) == null ? void 0 : n.getTime()) != null ? r : 0) -
          ((o = (i = e.lastSpokeAt) == null ? void 0 : i.getTime()) != null ? o : 0)
      : 0;
  }
  function contexts_BGRNBsB8_Be(e, t) {
    var n, r, i, o;
    return (
      ((r = (n = e.joinedAt) == null ? void 0 : n.getTime()) != null ? r : 0) -
      ((o = (i = t.joinedAt) == null ? void 0 : i.getTime()) != null ? o : 0)
    );
  }
  function Ji(e, t) {
    return B(e) ? (B(t) ? 0 : -1) : B(t) ? 1 : 0;
  }
  function Xi(e, t) {
    const n = e.participant.isCameraEnabled,
      r = t.participant.isCameraEnabled;
    return n !== r ? (n ? -1 : 1) : 0;
  }
  function Xo(e) {
    const t = [],
      n = [],
      r = [],
      i = [];
    e.forEach((a) => {
      a.participant.isLocal && a.source === R.Source.Camera
        ? t.push(a)
        : a.source === R.Source.ScreenShare
          ? n.push(a)
          : a.source === R.Source.Camera
            ? r.push(a)
            : i.push(a);
    });
    const o = Zi(n),
      s = eo(r);
    return [...t, ...o, ...s, ...i];
  }
  function Zi(e) {
    const t = [],
      n = [];
    return (
      e.forEach((i) => {
        i.participant.isLocal ? t.push(i) : n.push(i);
      }),
      t.sort((i, o) => contexts_BGRNBsB8_Be(i.participant, o.participant)),
      n.sort((i, o) => contexts_BGRNBsB8_Be(i.participant, o.participant)),
      [...n, ...t]
    );
  }
  function eo(e) {
    const t = [],
      n = [];
    return (
      e.forEach((r) => {
        r.participant.isLocal ? t.push(r) : n.push(r);
      }),
      n.sort((r, i) =>
        r.participant.isSpeaking && i.participant.isSpeaking
          ? kn(r.participant, i.participant)
          : r.participant.isSpeaking !== i.participant.isSpeaking
            ? _n(r.participant, i.participant)
            : r.participant.lastSpokeAt !== i.participant.lastSpokeAt
              ? Ln(r.participant, i.participant)
              : B(r) !== B(i)
                ? Ji(r, i)
                : r.participant.isCameraEnabled !== i.participant.isCameraEnabled
                  ? Xi(r, i)
                  : contexts_BGRNBsB8_Be(r.participant, i.participant)
      ),
      [...t, ...n]
    );
  }
  function Zo(e) {
    const t = [...e];
    t.sort((r, i) => {
      if (r.isSpeaking && i.isSpeaking) return kn(r, i);
      if (r.isSpeaking !== i.isSpeaking) return _n(r, i);
      if (r.lastSpokeAt !== i.lastSpokeAt) return Ln(r, i);
      const o = r.videoTrackPublications.size > 0,
        s = i.videoTrackPublications.size > 0;
      return o !== s ? (o ? -1 : 1) : contexts_BGRNBsB8_Be(r, i);
    });
    const n = t.find((r) => r.isLocal);
    if (n) {
      const r = t.indexOf(n);
      r >= 0 && (t.splice(r, 1), t.length > 0 ? t.splice(0, 0, n) : t.push(n));
    }
    return t;
  }
  function to(e, t) {
    return e.reduce(
      (n, r, i) => (i % t === 0 ? [...n, [r]] : [...n.slice(0, -1), [...n.slice(-1)[0], r]]),
      []
    );
  }
  function Wt(e, t) {
    const n = Math.max(e.length, t.length);
    return new Array(n).fill([]).map((r, i) => [e[i], t[i]]);
  }
  function contexts_BGRNBsB8_Ve(e, t, n) {
    return e.filter((r) => !t.map((i) => n(i)).includes(n(r)));
  }
  function contexts_BGRNBsB8_lt(e) {
    return e.map((t) =>
      typeof t == 'string' || typeof t == 'number' ? `${t}` : contexts_BGRNBsB8_N(t)
    );
  }
  function no(e, t) {
    return {
      dropped: contexts_BGRNBsB8_Ve(e, t, contexts_BGRNBsB8_N),
      added: contexts_BGRNBsB8_Ve(t, e, contexts_BGRNBsB8_N),
    };
  }
  function ro(e) {
    return e.added.length !== 0 || e.dropped.length !== 0;
  }
  function contexts_BGRNBsB8_ft(e, t) {
    const n = t.findIndex((r) => contexts_BGRNBsB8_N(r) === contexts_BGRNBsB8_N(e));
    if (n === -1)
      throw new Error(
        `Element not part of the array: ${contexts_BGRNBsB8_N(e)} not in ${contexts_BGRNBsB8_lt(t)}`
      );
    return n;
  }
  function io(e, t, n) {
    const r = contexts_BGRNBsB8_ft(e, n),
      i = contexts_BGRNBsB8_ft(t, n);
    return (n.splice(r, 1, t), n.splice(i, 1, e), n);
  }
  function oo(e, t) {
    const n = contexts_BGRNBsB8_ft(e, t);
    return (t.splice(n, 1), t);
  }
  function so(e, t) {
    return [...t, e];
  }
  function nt(e, t) {
    return to(e, t);
  }
  function es(e, t, n) {
    let r = ao(e, t);
    if (r.length < t.length) {
      const s = contexts_BGRNBsB8_Ve(t, r, contexts_BGRNBsB8_N);
      r = [...r, ...s];
    }
    const i = nt(r, n),
      o = nt(t, n);
    if (
      (Wt(i, o).forEach(([s, a], c) => {
        if (s && a) {
          const u = nt(r, n)[c],
            l = no(u, a);
          ro(l) &&
            (contexts_BGRNBsB8_L.debug(
              `Detected visual changes on page: ${c}, current: ${contexts_BGRNBsB8_lt(
                s
              )}, next: ${contexts_BGRNBsB8_lt(a)}`,
              { changes: l }
            ),
            l.added.length === l.dropped.length &&
              Wt(l.added, l.dropped).forEach(([f, v]) => {
                if (f && v) r = io(f, v, r);
                else
                  throw new Error(
                    `For a swap action we need a addition and a removal one is missing: ${f}, ${v}`
                  );
              }),
            l.added.length === 0 &&
              l.dropped.length > 0 &&
              l.dropped.forEach((f) => {
                r = oo(f, r);
              }),
            l.added.length > 0 &&
              l.dropped.length === 0 &&
              l.added.forEach((f) => {
                r = so(f, r);
              }));
        }
      }),
      r.length > t.length)
    ) {
      const s = contexts_BGRNBsB8_Ve(r, t, contexts_BGRNBsB8_N);
      r = r.filter((a) => !s.map(contexts_BGRNBsB8_N).includes(contexts_BGRNBsB8_N(a)));
    }
    return r;
  }
  function ao(e, t) {
    return e.map((n) => {
      const r = t.find(
        (i) =>
          // If the IDs match or ..
          contexts_BGRNBsB8_N(n) === contexts_BGRNBsB8_N(i) || // ... if the current item is a placeholder and the new item is the track reference can replace it.
          (typeof n != 'number' && contexts_BGRNBsB8_Pe(n) && B(i) && Bi(n, i))
      );
      return r ?? n;
    });
  }
  function contexts_BGRNBsB8_U(e) {
    return `${En}-${e}`;
  }
  function ts(e) {
    const t = Bt(e),
      n = In(e.participant).pipe(
        O(() => Bt(e)),
        contexts_BGRNBsB8_D(t)
      );
    return {
      className: contexts_BGRNBsB8_U(
        e.source === Track.Source.Camera || e.source === Track.Source.ScreenShare
          ? 'participant-media-video'
          : 'participant-media-audio'
      ),
      trackObserver: n,
    };
  }
  function Bt(e) {
    if (B(e)) return e.publication;
    {
      const { source: t, name: n, participant: r } = e;
      if (t && n) return r.getTrackPublications().find((i) => i.source === t && i.trackName === n);
      if (n) return r.getTrackPublicationByName(n);
      if (t) return r.getTrackPublication(t);
      throw new Error('At least one of source and name needs to be defined');
    }
  }
  function contexts_BGRNBsB8_fe(e, ...t) {
    return new contexts_BGRNBsB8_k((r) => {
      const i = () => {
        r.next(e);
      };
      return (
        t.forEach((s) => {
          e.on(s, i);
        }),
        () => {
          t.forEach((s) => {
            e.off(s, i);
          });
        }
      );
    }).pipe(contexts_BGRNBsB8_D(e));
  }
  function contexts_BGRNBsB8_we(e, t) {
    return new contexts_BGRNBsB8_k((r) => {
      const i = (...s) => {
        r.next(s);
      };
      return (
        e.on(t, i),
        () => {
          e.off(t, i);
        }
      );
    });
  }
  function ns(e) {
    return contexts_BGRNBsB8_we(e, RoomEvent.ConnectionStateChanged).pipe(
      O(([t]) => t),
      contexts_BGRNBsB8_D(e.state)
    );
  }
  function rs(e) {
    return contexts_BGRNBsB8_fe(e, y.RoomMetadataChanged, y.ConnectionStateChanged).pipe(
      O((n) => ({ name: n.name, metadata: n.metadata }))
    );
  }
  function is(e) {
    return contexts_BGRNBsB8_we(e, y.ActiveSpeakersChanged).pipe(O(([t]) => t));
  }
  function os(e, t, n = !0) {
    const r = new contexts_BGRNBsB8_k((o) => {
        Room.getLocalDevices(e, n)
          .then((s) => {
            (o.next(s), o.complete());
          })
          .catch((s) => {
            (t == null || t(s), o.next([]), o.complete());
          });
      }),
      i = new contexts_BGRNBsB8_k((o) => {
        var s;
        const a = () =>
          contexts_BGRNBsB8_V(this, null, function* () {
            try {
              const c = yield Room.getLocalDevices(e, n);
              o.next(c);
            } catch (c) {
              t == null || t(c);
            }
          });
        if (typeof window < 'u') {
          if (!window.isSecureContext)
            throw new Error(
              'Accessing media devices is available only in secure contexts (HTTPS and localhost), in some or all supporting browsers. See: https://developer.mozilla.org/en-US/docs/Web/API/Navigator/mediaDevices'
            );
          (s = navigator == null ? void 0 : navigator.mediaDevices) == null ||
            s.addEventListener('devicechange', a);
        }
        return () => {
          var c;
          (c = navigator == null ? void 0 : navigator.mediaDevices) == null ||
            c.removeEventListener('devicechange', a);
        };
      });
    return contexts_BGRNBsB8_We(r, i);
  }
  function co(e) {
    return contexts_BGRNBsB8_we(e, RoomEvent.DataReceived);
  }
  function uo(e) {
    return contexts_BGRNBsB8_fe(e, RoomEvent.AudioPlaybackStatusChanged).pipe(
      O((n) => ({ canPlayAudio: n.canPlaybackAudio }))
    );
  }
  function lo(e) {
    return contexts_BGRNBsB8_fe(e, y.VideoPlaybackStatusChanged).pipe(
      O((n) => ({ canPlayVideo: n.canPlaybackVideo }))
    );
  }
  function fo(e, t) {
    return contexts_BGRNBsB8_we(e, RoomEvent.ActiveDeviceChanged).pipe(
      contexts_BGRNBsB8_Je(([n]) => n === t),
      O(
        ([n, r]) => (
          contexts_BGRNBsB8_L.debug('activeDeviceObservable | RoomEvent.ActiveDeviceChanged', {
            kind: n,
            deviceId: r,
          }),
          r
        )
      )
    );
  }
  function ss(e, t) {
    return contexts_BGRNBsB8_we(e, y.ParticipantEncryptionStatusChanged).pipe(
      contexts_BGRNBsB8_Je(
        ([, n]) =>
          (t == null ? void 0 : t.identity) === (n == null ? void 0 : n.identity) ||
          (!n && (t == null ? void 0 : t.identity) === e.localParticipant.identity)
      ),
      O(([n]) => n),
      contexts_BGRNBsB8_D(t != null && t.isLocal ? t.isE2EEEnabled : !!(t != null && t.isEncrypted))
    );
  }
  function as(e) {
    return contexts_BGRNBsB8_we(e, y.RecordingStatusChanged).pipe(
      O(([t]) => t),
      contexts_BGRNBsB8_D(e.isRecording)
    );
  }
  function contexts_BGRNBsB8_xe(e, ...t) {
    return new contexts_BGRNBsB8_k((r) => {
      const i = () => {
        r.next(e);
      };
      return (
        t.forEach((s) => {
          e.on(s, i);
        }),
        () => {
          t.forEach((s) => {
            e.off(s, i);
          });
        }
      );
    }).pipe(contexts_BGRNBsB8_D(e));
  }
  function In(e) {
    return contexts_BGRNBsB8_xe(
      e,
      ParticipantEvent.TrackMuted,
      ParticipantEvent.TrackUnmuted,
      ParticipantEvent.ParticipantPermissionsChanged,
      // ParticipantEvent.IsSpeakingChanged,
      ParticipantEvent.TrackPublished,
      ParticipantEvent.TrackUnpublished,
      ParticipantEvent.LocalTrackPublished,
      ParticipantEvent.LocalTrackUnpublished,
      ParticipantEvent.MediaDevicesError,
      ParticipantEvent.TrackSubscriptionStatusChanged
      // ParticipantEvent.ConnectionQualityChanged,
    ).pipe(
      O((n) => {
        const { isMicrophoneEnabled: r, isCameraEnabled: i, isScreenShareEnabled: o } = n,
          s = n.getTrackPublication(Track.Source.Microphone),
          a = n.getTrackPublication(Track.Source.Camera);
        return {
          isCameraEnabled: i,
          isMicrophoneEnabled: r,
          isScreenShareEnabled: o,
          cameraTrack: a,
          microphoneTrack: s,
          participant: n,
        };
      })
    );
  }
  function po(e) {
    return e
      ? contexts_BGRNBsB8_xe(e, w.ParticipantMetadataChanged, w.ParticipantNameChanged).pipe(
          O(({ name: n, identity: r, metadata: i }) => ({
            name: n,
            identity: r,
            metadata: i,
          })),
          contexts_BGRNBsB8_D({
            name: e.name,
            identity: e.identity,
            metadata: e.metadata,
          })
        )
      : void 0;
  }
  function ho(e) {
    return contexts_BGRNBsB8_Xe(e, w.ConnectionQualityChanged).pipe(
      O(([n]) => n),
      contexts_BGRNBsB8_D(e.connectionQuality)
    );
  }
  function contexts_BGRNBsB8_Xe(e, t) {
    return new contexts_BGRNBsB8_k((r) => {
      const i = (...s) => {
        r.next(s);
      };
      return (
        e.on(t, i),
        () => {
          e.off(t, i);
        }
      );
    });
  }
  function vo(e) {
    var t, n, r, i;
    return contexts_BGRNBsB8_xe(
      e.participant,
      w.TrackMuted,
      w.TrackUnmuted,
      w.TrackSubscribed,
      w.TrackUnsubscribed,
      w.LocalTrackPublished,
      w.LocalTrackUnpublished
    ).pipe(
      O((o) => {
        var s, a;
        const c = (s = e.publication) != null ? s : o.getTrackPublication(e.source);
        return (a = c == null ? void 0 : c.isMuted) != null ? a : !0;
      }),
      contexts_BGRNBsB8_D(
        (i =
          (r = (t = e.publication) == null ? void 0 : t.isMuted) != null
            ? r
            : (n = e.participant.getTrackPublication(e.source)) == null
              ? void 0
              : n.isMuted) != null
          ? i
          : !0
      )
    );
  }
  function cs(e) {
    return contexts_BGRNBsB8_Xe(e, w.IsSpeakingChanged).pipe(O(([t]) => t));
  }
  function us(e, t = {}) {
    var n;
    let r;
    const i = new contexts_BGRNBsB8_k((c) => ((r = c), () => a.unsubscribe())).pipe(
        contexts_BGRNBsB8_D(Array.from(e.remoteParticipants.values()))
      ),
      o = (n = t.additionalRoomEvents) != null ? n : Cn,
      s = Array.from(
        /* @__PURE__ */ new Set([
          RoomEvent.ParticipantConnected,
          RoomEvent.ParticipantDisconnected,
          RoomEvent.ConnectionStateChanged,
          ...o,
        ])
      ),
      a = contexts_BGRNBsB8_fe(e, ...s).subscribe((c) =>
        r == null ? void 0 : r.next(Array.from(c.remoteParticipants.values()))
      );
    return (
      e.remoteParticipants.size > 0 &&
        (r == null || r.next(Array.from(e.remoteParticipants.values()))),
      i
    );
  }
  function ls(e, t, n = {}) {
    var r;
    const i = (r = n.additionalEvents) != null ? r : Pn;
    return contexts_BGRNBsB8_fe(
      e,
      y.ParticipantConnected,
      y.ParticipantDisconnected,
      y.ConnectionStateChanged
    ).pipe(
      Tn((s) => {
        const a = s.getParticipantByIdentity(t);
        return a ? contexts_BGRNBsB8_xe(a, ...i) : new contexts_BGRNBsB8_k((c) => c.next(void 0));
      }),
      contexts_BGRNBsB8_D(e.getParticipantByIdentity(t))
    );
  }
  function fs(e) {
    return contexts_BGRNBsB8_Xe(e, ParticipantEvent.ParticipantPermissionsChanged).pipe(
      O(() => e.permissions),
      contexts_BGRNBsB8_D(e.permissions)
    );
  }
  function ds(e, { kind: t, identity: n }, r = {}) {
    var i;
    const o = (i = r.additionalEvents) != null ? i : Pn,
      s = (c) => {
        let u = !0;
        return (t && (u = u && c.kind === t), n && (u = u && c.identity === n), u);
      };
    return contexts_BGRNBsB8_fe(
      e,
      y.ParticipantConnected,
      y.ParticipantDisconnected,
      y.ConnectionStateChanged
    ).pipe(
      Tn((c) => {
        const u = Array.from(c.remoteParticipants.values()).find((l) => s(l));
        return u ? contexts_BGRNBsB8_xe(u, ...o) : new contexts_BGRNBsB8_k((l) => l.next(void 0));
      }),
      contexts_BGRNBsB8_D(Array.from(e.remoteParticipants.values()).find((c) => s(c)))
    );
  }
  function ps(e) {
    return typeof e > 'u'
      ? new contexts_BGRNBsB8_k()
      : contexts_BGRNBsB8_Xe(e, ParticipantEvent.AttributesChanged).pipe(
          O(([t]) => ({
            changed: t,
            attributes: e.attributes,
          })),
          contexts_BGRNBsB8_D({ changed: e.attributes, attributes: e.attributes })
        );
  }
  function hs(e, t, n, r, i) {
    const { localParticipant: o } = t,
      s = (f, v) => {
        let d = !1;
        switch (f) {
          case Track.Source.Camera:
            d = v.isCameraEnabled;
            break;
          case Track.Source.Microphone:
            d = v.isMicrophoneEnabled;
            break;
          case Track.Source.ScreenShare:
            d = v.isScreenShareEnabled;
            break;
        }
        return d;
      },
      a = In(o).pipe(
        O((f) => s(e, f.participant)),
        contexts_BGRNBsB8_D(s(e, o))
      ),
      c = new contexts_BGRNBsB8_ee(),
      u = (f, v) =>
        contexts_BGRNBsB8_V(this, null, function* () {
          try {
            switch ((v ?? (v = n), c.next(!0), e)) {
              case Track.Source.Camera:
                return (yield o.setCameraEnabled(f ?? !o.isCameraEnabled, v, r), o.isCameraEnabled);
              case Track.Source.Microphone:
                return (
                  yield o.setMicrophoneEnabled(f ?? !o.isMicrophoneEnabled, v, r),
                  o.isMicrophoneEnabled
                );
              case Track.Source.ScreenShare:
                return (
                  yield o.setScreenShareEnabled(f ?? !o.isScreenShareEnabled, v, r),
                  o.isScreenShareEnabled
                );
              default:
                throw new TypeError('Tried to toggle unsupported source');
            }
          } catch (d) {
            if (i && d instanceof Error) {
              i == null || i(d);
              return;
            } else throw d;
          } finally {
            c.next(!1);
          }
        });
    return {
      className: contexts_BGRNBsB8_U('button'),
      toggle: u,
      enabledObserver: a,
      pendingObserver: c.asObservable(),
    };
  }
  function vs() {
    let e = !1;
    const t = new contexts_BGRNBsB8_ee(),
      n = new contexts_BGRNBsB8_ee(),
      r = (o) =>
        contexts_BGRNBsB8_V(this, null, function* () {
          (n.next(!0), (e = o ?? !e), t.next(e), n.next(!1));
        });
    return {
      className: contexts_BGRNBsB8_U('button'),
      toggle: r,
      enabledObserver: t.asObservable(),
      pendingObserver: n.asObservable(),
    };
  }
  function ms(e, t, n) {
    const r = new ln(void 0),
      i = fo(t, e),
      o = (a, ...c) =>
        contexts_BGRNBsB8_V(this, [a, ...c], function* (u, l = {}) {
          var f, v, d;
          if (t) {
            const m = getBrowser();
            if (
              e === 'audiooutput' &&
              ((m == null ? void 0 : m.name) === 'Safari' || (m == null ? void 0 : m.os) === 'iOS')
            ) {
              contexts_BGRNBsB8_L.warn(
                'Switching audio output device is not supported on Safari and iOS.'
              );
              return;
            }
            (contexts_BGRNBsB8_L.debug(`Switching active device of kind "${e}" with id ${u}.`),
              yield t.switchActiveDevice(e, u, l.exact));
            const p = (f = t.getActiveDevice(e)) != null ? f : u;
            p !== u &&
              u !== 'default' &&
              contexts_BGRNBsB8_L.info(
                `We tried to select the device with id (${u}), but the browser decided to select the device with id (${p}) instead.`
              );
            let g;
            e === 'audioinput'
              ? (g =
                  (v = t.localParticipant.getTrackPublication(Track.Source.Microphone)) == null
                    ? void 0
                    : v.track)
              : e === 'videoinput' &&
                (g =
                  (d = t.localParticipant.getTrackPublication(Track.Source.Camera)) == null
                    ? void 0
                    : d.track);
            const h =
              (u === 'default' && !g) ||
              (u === 'default' &&
                (g == null ? void 0 : g.mediaStreamTrack.label.startsWith('Default')));
            r.next(h ? u : p);
          }
        });
    return {
      className: contexts_BGRNBsB8_U('media-device-select'),
      activeDeviceObservable: i,
      setActiveMediaDevice: o,
    };
  }
  function gs(e) {
    const t = (r) => {
      e.disconnect(r);
    };
    return { className: contexts_BGRNBsB8_U('disconnect-button'), disconnect: t };
  }
  function bs(e) {
    const t = contexts_BGRNBsB8_U('connection-quality'),
      n = ho(e);
    return { className: t, connectionQualityObserver: n };
  }
  function ys(e) {
    let t = 'track-muted-indicator-camera';
    switch (e.source) {
      case R.Source.Camera:
        t = 'track-muted-indicator-camera';
        break;
      case R.Source.Microphone:
        t = 'track-muted-indicator-microphone';
        break;
    }
    const n = contexts_BGRNBsB8_U(t),
      r = vo(e);
    return { className: n, mediaMutedObserver: r };
  }
  function ws(e) {
    return { className: 'lk-participant-name', infoObserver: po(e) };
  }
  function xs() {
    return {
      className: contexts_BGRNBsB8_U('participant-tile'),
    };
  }
  var mo = {
      CHAT: 'lk.chat',
      TRANSCRIPTION: 'lk.transcription',
    },
    go = {
      CHAT: 'lk-chat-topic',
    };
  function Mn(e, t) {
    return contexts_BGRNBsB8_V(this, arguments, function* (n, r, i = {}) {
      const { reliable: o, destinationIdentities: s, topic: a } = i;
      yield n.publishData(r, {
        destinationIdentities: s,
        topic: a,
        reliable: o,
      });
    });
  }
  function bo(e, t, n) {
    const r = Array.isArray(t) ? t : [t],
      i = co(e).pipe(
        contexts_BGRNBsB8_Je(([, , , c]) => t === void 0 || (c !== void 0 && r.includes(c))),
        O(([c, u, , l]) => {
          const f = {
            payload: c,
            topic: l,
            from: u,
          };
          return (n == null || n(f), f);
        })
      );
    let o;
    const s = new contexts_BGRNBsB8_k((c) => {
      o = c;
    });
    return {
      messageObservable: i,
      isSendingObservable: s,
      send: (c, ...u) =>
        contexts_BGRNBsB8_V(this, [c, ...u], function* (l, f = {}) {
          o.next(!0);
          try {
            yield Mn(e.localParticipant, l, contexts_BGRNBsB8_Y({ topic: r[0] }, f));
          } finally {
            o.next(!1);
          }
        }),
    };
  }
  var contexts_BGRNBsB8_Ie = /* @__PURE__ */ new WeakMap();
  function yo(e) {
    return e.ignoreLegacy == !0;
  }
  var wo = (e) => JSON.parse(new TextDecoder().decode(e)),
    xo = (e) => new TextEncoder().encode(JSON.stringify(e));
  function Ss(e, t) {
    var n, r, i, o, s, a;
    const c = () => {
        var b, S, C;
        return (
          ((b = e.serverInfo) == null ? void 0 : b.edition) === 1 ||
          (!!((S = e.serverInfo) != null && S.version) &&
            compareVersions((C = e.serverInfo) == null ? void 0 : C.version, '1.8.2') > 0)
        );
      },
      u = new contexts_BGRNBsB8_ee(),
      l = (n = t == null ? void 0 : t.channelTopic) != null ? n : mo.CHAT,
      f = (r = t == null ? void 0 : t.channelTopic) != null ? r : go.CHAT;
    let v = !1;
    contexts_BGRNBsB8_Ie.has(e) || (v = !0);
    const d = (i = contexts_BGRNBsB8_Ie.get(e)) != null ? i : /* @__PURE__ */ new Map(),
      m = (o = d.get(l)) != null ? o : new contexts_BGRNBsB8_ee();
    (d.set(l, m), contexts_BGRNBsB8_Ie.set(e, d));
    const p = (s = t == null ? void 0 : t.messageDecoder) != null ? s : wo;
    if (v) {
      e.registerTextStreamHandler(l, (S, C) =>
        contexts_BGRNBsB8_V(this, null, function* () {
          const { id: $, timestamp: I } = S.info;
          contexts_BGRNBsB8_Qe(S)
            .pipe(
              contexts_BGRNBsB8_ut((T, _) => T + _),
              O((T) => ({
                id: $,
                timestamp: I,
                message: T,
                from: e.getParticipantByIdentity(C.identity),
                // editTimestamp: type === 'update' ? timestamp : undefined,
              }))
            )
            .subscribe({
              next: (T) => m.next(T),
            });
        })
      );
      const { messageObservable: b } = bo(e, [f]);
      b.pipe(
        O((S) => {
          const C = p(S.payload);
          return yo(C)
            ? void 0
            : contexts_BGRNBsB8_se(contexts_BGRNBsB8_Y({}, C), { from: S.from });
        }),
        contexts_BGRNBsB8_Je((S) => !!S),
        Nt(u)
      ).subscribe(m);
    }
    const g = m.pipe(
        contexts_BGRNBsB8_ut((b, S) => {
          if (
            'id' in S &&
            b.find((C) => {
              var $, I;
              return (
                (($ = C.from) == null ? void 0 : $.identity) ===
                  ((I = S.from) == null ? void 0 : I.identity) && C.id === S.id
              );
            })
          ) {
            const C = b.findIndex(($) => $.id === S.id);
            if (C > -1) {
              const $ = b[C];
              b[C] = contexts_BGRNBsB8_se(contexts_BGRNBsB8_Y({}, S), {
                timestamp: $.timestamp,
                editTimestamp: S.timestamp,
              });
            }
            return [...b];
          }
          return [...b, S];
        }, []),
        Nt(u)
      ),
      h = new ln(!1),
      x = (a = t == null ? void 0 : t.messageEncoder) != null ? a : xo,
      E = (b, S) =>
        contexts_BGRNBsB8_V(this, null, function* () {
          var C;
          (S || (S = {}), (C = S.topic) != null || (S.topic = l), h.next(!0));
          try {
            const I = {
                id: (yield e.localParticipant.sendText(b, S)).id,
                timestamp: Date.now(),
                message: b,
              },
              z = contexts_BGRNBsB8_se(contexts_BGRNBsB8_Y({}, I), {
                attachedFiles: S.attachments,
              }),
              T = contexts_BGRNBsB8_se(contexts_BGRNBsB8_Y({}, z), {
                from: e.localParticipant,
                attributes: S.attributes,
              });
            m.next(T);
            const _ = x(
              contexts_BGRNBsB8_se(contexts_BGRNBsB8_Y({}, I), {
                ignoreLegacy: c(),
              })
            );
            try {
              yield Mn(e.localParticipant, _, {
                reliable: !0,
                topic: f,
              });
            } catch (Z) {
              contexts_BGRNBsB8_L.info('could not send message in legacy chat format', Z);
            }
            return T;
          } finally {
            h.next(!1);
          }
        });
    function A() {
      (u.next(),
        u.complete(),
        m.complete(),
        contexts_BGRNBsB8_Ie.delete(e),
        e.unregisterTextStreamHandler(l));
    }
    return (
      e.once(RoomEvent.Disconnected, A),
      {
        messageObservable: g,
        isSendingObservable: h,
        send: E,
      }
    );
  }
  function Ts() {
    const e = (n) =>
      contexts_BGRNBsB8_V(this, null, function* () {
        (contexts_BGRNBsB8_L.info('Start Audio for room: ', n), yield n.startAudio());
      });
    return {
      className: contexts_BGRNBsB8_U('start-audio-button'),
      roomAudioPlaybackAllowedObservable: uo,
      handleStartAudioPlayback: e,
    };
  }
  function Es() {
    const e = (n) =>
      contexts_BGRNBsB8_V(this, null, function* () {
        (contexts_BGRNBsB8_L.info('Start Video for room: ', n), yield n.startVideo());
      });
    return {
      className: contexts_BGRNBsB8_U('start-audio-button'),
      roomVideoPlaybackAllowedObservable: lo,
      handleStartVideoPlayback: e,
    };
  }
  function Cs() {
    return {
      className: [contexts_BGRNBsB8_U('button'), contexts_BGRNBsB8_U('chat-toggle')].join(' '),
    };
  }
  function Ps() {
    return {
      className: [contexts_BGRNBsB8_U('button'), contexts_BGRNBsB8_U('focus-toggle-button')].join(
        ' '
      ),
    };
  }
  function As() {
    return { className: 'lk-clear-pin-button lk-button' };
  }
  function Os() {
    return { className: 'lk-room-container' };
  }
  function Vt(e, t, n = !0) {
    const i = [e.localParticipant, ...Array.from(e.remoteParticipants.values())],
      o = [];
    return (
      i.forEach((s) => {
        t.forEach((a) => {
          const c = Array.from(s.trackPublications.values())
            .filter(
              (u) =>
                u.source === a && // either return all or only the ones that are subscribed
                (!n || u.track)
            )
            .map((u) => ({
              participant: s,
              publication: u,
              source: u.source,
            }));
          o.push(...c);
        });
      }),
      { trackReferences: o, participants: i }
    );
  }
  function Ht(e, t, n = !1) {
    const { sources: r, kind: i, name: o } = t;
    return Array.from(e.trackPublications.values())
      .filter(
        (a) =>
          (!r || r.includes(a.source)) &&
          (!i || a.kind === i) &&
          (!o || a.trackName === o) && // either return all or only the ones that are subscribed
          (!n || a.track)
      )
      .map((a) => ({
        participant: e,
        publication: a,
        source: a.source,
      }));
  }
  function ks(e, t, n) {
    var r, i;
    const o = (r = n.additionalRoomEvents) != null ? r : Cn,
      s = (i = n.onlySubscribed) != null ? i : !0,
      a = Array.from(
        /* @__PURE__ */ new Set([
          RoomEvent.ParticipantConnected,
          RoomEvent.ParticipantDisconnected,
          RoomEvent.ConnectionStateChanged,
          RoomEvent.LocalTrackPublished,
          RoomEvent.LocalTrackUnpublished,
          RoomEvent.TrackPublished,
          RoomEvent.TrackUnpublished,
          RoomEvent.TrackSubscriptionStatusChanged,
          ...o,
        ]).values()
      );
    return contexts_BGRNBsB8_fe(e, ...a).pipe(
      O((u) => {
        const l = Vt(u, t, s);
        return (
          contexts_BGRNBsB8_L.debug(
            `TrackReference[] was updated. (length ${l.trackReferences.length})`,
            l
          ),
          l
        );
      }),
      contexts_BGRNBsB8_D(Vt(e, t, s))
    );
  }
  function _s(e, t) {
    return contexts_BGRNBsB8_xe(e, ...Yi).pipe(
      O((r) => {
        const i = Ht(r, t);
        return (
          contexts_BGRNBsB8_L.debug(`TrackReference[] was updated. (length ${i.length})`, i),
          i
        );
      }),
      contexts_BGRNBsB8_D(Ht(e, t))
    );
  }
  function Rn(e, t) {
    return new contexts_BGRNBsB8_k((r) => {
      const i = (...s) => {
        r.next(s);
      };
      return (
        e.on(t, i),
        () => {
          e.off(t, i);
        }
      );
    });
  }
  function Ls(e) {
    return Rn(e, TrackEvent.TranscriptionReceived);
  }
  function Is(e) {
    return Rn(e, TrackEvent.TimeSyncUpdate).pipe(O(([t]) => t));
  }
  function Ms(e, t = 1e3) {
    if (e === null) return Dt(!1);
    const n = ct(e, 'mousemove', { passive: !0 }).pipe(O(() => !0)),
      r = n.pipe(
        vi({
          each: t,
          with: () => contexts_BGRNBsB8_We(Dt(!1), r.pipe(Mi(n))),
        }),
        _i()
      );
    return r;
  }
  function So(e, t) {
    if (typeof localStorage > 'u') {
      contexts_BGRNBsB8_L.error('Local storage is not available.');
      return;
    }
    try {
      if (t) {
        const n = Object.fromEntries(Object.entries(t).filter(([, r]) => r !== ''));
        localStorage.setItem(e, JSON.stringify(n));
      }
    } catch (n) {
      contexts_BGRNBsB8_L.error(`Error setting item to local storage: ${n}`);
    }
  }
  function To(e) {
    if (typeof localStorage > 'u') {
      contexts_BGRNBsB8_L.error('Local storage is not available.');
      return;
    }
    try {
      const t = localStorage.getItem(e);
      if (!t) {
        contexts_BGRNBsB8_L.warn(`Item with key ${e} does not exist in local storage.`);
        return;
      }
      return JSON.parse(t);
    } catch (t) {
      contexts_BGRNBsB8_L.error(`Error getting item from local storage: ${t}`);
      return;
    }
  }
  function Eo(e) {
    return {
      load: () => To(e),
      save: (t) => So(e, t),
    };
  }
  var Co = `${En}-user-choices`,
    Te = {
      videoEnabled: !0,
      audioEnabled: !0,
      videoDeviceId: 'default',
      audioDeviceId: 'default',
      username: '',
    },
    { load: Po, save: Ao } = Eo(Co);
  function Rs(e, t = !1) {
    t !== !0 && Ao(e);
  }
  function Ds(e, t = !1) {
    var n, r, i, o, s;
    const a = {
      videoEnabled: (n = e == null ? void 0 : e.videoEnabled) != null ? n : Te.videoEnabled,
      audioEnabled: (r = e == null ? void 0 : e.audioEnabled) != null ? r : Te.audioEnabled,
      videoDeviceId: (i = e == null ? void 0 : e.videoDeviceId) != null ? i : Te.videoDeviceId,
      audioDeviceId: (o = e == null ? void 0 : e.audioDeviceId) != null ? o : Te.audioDeviceId,
      username: (s = e == null ? void 0 : e.username) != null ? s : Te.username,
    };
    if (t) return a;
    {
      const c = Po();
      return contexts_BGRNBsB8_Y(contexts_BGRNBsB8_Y({}, a), c ?? {});
    }
  }
  var rt = null,
    contexts_BGRNBsB8_it = null,
    Oo = 0;
  function zt() {
    return (rt || (rt = /* @__PURE__ */ new Map()), rt);
  }
  function ko() {
    return (
      contexts_BGRNBsB8_it || (contexts_BGRNBsB8_it = /* @__PURE__ */ new WeakMap()),
      contexts_BGRNBsB8_it
    );
  }
  function _o(e, t) {
    const n = ko();
    let r = n.get(e);
    return (r || ((r = `room_${Oo++}`), n.set(e, r)), `${r}:${t}`);
  }
  function $s(e, t) {
    const n = _o(e, t),
      r = zt(),
      i = r.get(n);
    if (i) return i;
    const o = new contexts_BGRNBsB8_ee();
    let s = [];
    const a = 'lk.segment_id',
      c = o.pipe(
        Ri({
          subscribe: () => {
            e.registerTextStreamHandler(t, (u, l) =>
              contexts_BGRNBsB8_V(this, null, function* () {
                var f;
                const v = contexts_BGRNBsB8_Qe(u).pipe(contexts_BGRNBsB8_ut((m, p) => m + p, '')),
                  d = !!((f = u.info.attributes) != null && f[a]);
                v.subscribe((m) => {
                  const p = s.findIndex((g) => {
                    var h, x;
                    return (
                      g.streamInfo.id === u.info.id ||
                      (d &&
                        ((h = g.streamInfo.attributes) == null ? void 0 : h[a]) ===
                          ((x = u.info.attributes) == null ? void 0 : x[a]))
                    );
                  });
                  p !== -1
                    ? ((s[p] = contexts_BGRNBsB8_se(contexts_BGRNBsB8_Y({}, s[p]), {
                        text: m,
                      })),
                      o.next([...s]))
                    : (s.push({
                        text: m,
                        participantInfo: l,
                        streamInfo: u.info,
                      }),
                      o.next([...s]));
                });
              })
            );
          },
          finalize: () => {
            e.unregisterTextStreamHandler(t);
          },
        }),
        Ii()
      );
    return (
      r.set(n, c),
      e.on(RoomEvent.Disconnected, () => {
        (zt().delete(n), (s = []), o.next([]));
      }),
      c
    );
  }
  function Dn(e, t) {
    if (t.msg === 'show_chat') return { ...e, showChat: !0, unreadMessages: 0 };
    if (t.msg === 'hide_chat') return { ...e, showChat: !1 };
    if (t.msg === 'toggle_chat') {
      const n = { ...e, showChat: !e.showChat };
      return (n.showChat === !0 && (n.unreadMessages = 0), n);
    } else
      return t.msg === 'unread_msg'
        ? { ...e, unreadMessages: t.count }
        : t.msg === 'toggle_settings'
          ? { ...e, showSettings: !e.showSettings }
          : { ...e };
  }
  function $n(e, t) {
    return t.msg === 'set_pin' ? [t.trackReference] : t.msg === 'clear_pin' ? [] : { ...e };
  }
  const Nn = react.createContext(void 0);
  function Ns() {
    const e = M.useContext(Nn);
    if (!e)
      throw Error(
        'Tried to access LayoutContext context outside a LayoutContextProvider provider.'
      );
    return e;
  }
  function Fs(e) {
    const t = Lo();
    if ((e ?? (e = t), !e))
      throw Error(
        'Tried to access LayoutContext context outside a LayoutContextProvider provider.'
      );
    return e;
  }
  function Us() {
    const [e, t] = M.useReducer($n, An),
      [n, r] = M.useReducer(Dn, On);
    return {
      pin: { dispatch: t, state: e },
      widget: { dispatch: r, state: n },
    };
  }
  function js(e) {
    const [t, n] = M.useReducer($n, An),
      [r, i] = M.useReducer(Dn, On);
    return (
      e ?? {
        pin: { dispatch: n, state: t },
        widget: { dispatch: i, state: r },
      }
    );
  }
  function Lo() {
    return M.useContext(Nn);
  }
  const Fn = react.createContext(void 0);
  function Ws() {
    const e = M.useContext(Fn);
    if (!e) throw Error('tried to access track context outside of track context provider');
    return e;
  }
  function Un() {
    return react.useContext(Fn);
  }
  function Bs(e) {
    const t = Un(),
      n = e ?? t;
    if (!n)
      throw new Error(
        'No TrackRef, make sure you are inside a TrackRefContext or pass the TrackRef explicitly'
      );
    return n;
  }
  const jn = react.createContext(void 0);
  function Vs() {
    const e = M.useContext(jn);
    if (!e)
      throw Error('tried to access participant context outside of participant context provider');
    return e;
  }
  function Io() {
    return react.useContext(jn);
  }
  function Hs(e) {
    const t = Io(),
      n = Un(),
      r = e ?? t ?? (n == null ? void 0 : n.participant);
    if (!r)
      throw new Error(
        'No participant provided, make sure you are inside a participant context or pass the participant explicitly'
      );
    return r;
  }
  const Wn = react.createContext(void 0);
  function zs() {
    const e = react.useContext(Wn);
    if (!e) throw Error('tried to access room context outside of livekit room component');
    return e;
  }
  function Mo() {
    return react.useContext(Wn);
  }
  function Ys(e) {
    const t = Mo(),
      n = e ?? t;
    if (!n)
      throw new Error(
        'No room provided, make sure you are inside a Room context or pass the room explicitly'
      );
    return n;
  }
  const Ro = react.createContext(void 0);
  function qs(e) {
    const t = M.useContext(Ro);
    if (e === !0) {
      if (t) return t;
      throw Error('tried to access feature context, but none is present');
    }
    return t;
  } // ./node_modules/.pnpm/@livekit+components-react@2.9.15_@livekit+krisp-noise-filter@0.2.16_livekit-client@2.15.8_@ty_yekyi6zrdl5hlnuib5mo4n56ga/node_modules/@livekit/components-react/dist/room-BRK61eNB.mjs

  //# sourceMappingURL=contexts-BGRNBsB8.mjs.map

  function room_BRK61eNB_L(n) {
    var e,
      o,
      t = '';
    if (typeof n == 'string' || typeof n == 'number') t += n;
    else if (typeof n == 'object')
      if (Array.isArray(n)) {
        var r = n.length;
        for (e = 0; e < r; e++) n[e] && (o = room_BRK61eNB_L(n[e])) && (t && (t += ' '), (t += o));
      } else for (o in n) n[o] && (t && (t += ' '), (t += o));
    return t;
  }
  function room_BRK61eNB_A() {
    for (var n, e, o = 0, t = '', r = arguments.length; o < r; o++)
      (n = arguments[o]) && (e = room_BRK61eNB_L(n)) && (t && (t += ' '), (t += e));
    return t;
  }
  function room_BRK61eNB_I(...n) {
    return (...e) => {
      for (const o of n)
        if (typeof o == 'function')
          try {
            o(...e);
          } catch (t) {
            console.error(t);
          }
    };
  }
  function room_BRK61eNB_M(...n) {
    const e = { ...n[0] };
    for (let o = 1; o < n.length; o++) {
      const t = n[o];
      for (const r in t) {
        const d = e[r],
          a = t[r];
        typeof d == 'function' &&
        typeof a == 'function' && // This is a lot faster than a regex.
        r[0] === 'o' &&
        r[1] === 'n' &&
        r.charCodeAt(2) /* 'A' */ >= 65 &&
        r.charCodeAt(2) /* 'Z' */ <= 90
          ? (e[r] = room_BRK61eNB_I(d, a))
          : (r === 'className' || r === 'UNSAFE_className') &&
              typeof d == 'string' &&
              typeof a == 'string'
            ? (e[r] = room_BRK61eNB_A(d, a))
            : (e[r] = a !== void 0 ? a : d);
      }
    }
    return e;
  }
  function room_BRK61eNB_J(n) {
    return n !== void 0;
  }
  function G(...n) {
    return room_BRK61eNB_M(...n.filter(room_BRK61eNB_J));
  }
  function room_BRK61eNB_H(n, e, o) {
    return react.Children.map(n, (t) =>
      react.isValidElement(t) && react.Children.only(n)
        ? (t.props.className &&
            (e ?? (e = {}),
            (e.className = room_BRK61eNB_A(t.props.className, e.className)),
            (e.style = { ...t.props.style, ...e.style })),
          react.cloneElement(t, { ...e, key: o }))
        : t
    );
  }
  function room_BRK61eNB_Q(n) {
    var e, o;
    if (
      typeof window < 'u' &&
      typeof process < 'u' && // eslint-disable-next-line turbo/no-undeclared-env-vars
      (((e = process == null ? void 0 : 'MISSING_ENV_VAR') == null ? void 0 : e.NODE_ENV) ===
        'dev' || // eslint-disable-next-line turbo/no-undeclared-env-vars
        ((o = process == null ? void 0 : 'MISSING_ENV_VAR') == null ? void 0 : o.NODE_ENV) ===
          'development')
    ) {
      const t = document.querySelector('.lk-room-container');
      t &&
        !getComputedStyle(t).getPropertyValue('--lk-has-imported-styles') &&
        u.warn(
          "It looks like you're not using the `@livekit/components-styles package`. To render the UI with the default styling, please import it in your layout or page."
        );
    }
  }
  function T(n, e) {
    return n === 'processor' && e && typeof e == 'object' && 'name' in e
      ? e.name
      : n === 'e2ee' && e
        ? 'e2ee-enabled'
        : e;
  }
  const room_BRK61eNB_q = {
    connect: !0,
    audio: !1,
    video: !1,
  };
  function room_BRK61eNB_$(n) {
    const {
      token: e,
      serverUrl: o,
      options: t,
      room: r,
      connectOptions: d,
      connect: a,
      audio: p,
      video: y,
      screen: g,
      onConnected: v,
      onDisconnected: h,
      onError: c,
      onMediaDeviceFailure: b,
      onEncryptionError: E,
      simulateParticipants: w,
      ...N
    } = { ...room_BRK61eNB_q, ...n };
    t &&
      r &&
      u.warn(
        'when using a manually created room, the options object will be ignored. set the desired options directly when creating the room instead.'
      );
    const [s, O] = i.useState(),
      C = i.useRef(a);
    i.useEffect(() => {
      O(r ?? new U(t));
    }, [r, JSON.stringify(t, T)]);
    const F = i.useMemo(() => {
      const { className: m } = x();
      return room_BRK61eNB_M(N, { className: m });
    }, [N]);
    return (
      i.useEffect(() => {
        if (!s) return;
        const m = () => {
            const f = s.localParticipant;
            (u.debug('trying to publish local tracks'),
              Promise.all([
                f.setMicrophoneEnabled(!!p, typeof p != 'boolean' ? p : void 0),
                f.setCameraEnabled(!!y, typeof y != 'boolean' ? y : void 0),
                f.setScreenShareEnabled(!!g, typeof g != 'boolean' ? g : void 0),
              ]).catch((R) => {
                (u.warn(R), c == null || c(R));
              }));
          },
          P = (f, R) => {
            const K = _.getFailure(f);
            b == null || b(K, R);
          },
          S = (f) => {
            E == null || E(f);
          },
          k = (f) => {
            h == null || h(f);
          },
          D = () => {
            v == null || v();
          };
        return (
          s
            .on(l.SignalConnected, m)
            .on(l.MediaDevicesError, P)
            .on(l.EncryptionError, S)
            .on(l.Disconnected, k)
            .on(l.Connected, D),
          () => {
            s.off(l.SignalConnected, m)
              .off(l.MediaDevicesError, P)
              .off(l.EncryptionError, S)
              .off(l.Disconnected, k)
              .off(l.Connected, D);
          }
        );
      }, [s, p, y, g, c, E, b, v, h]),
      i.useEffect(() => {
        if (s) {
          if (w) {
            s.simulateParticipants({
              participants: {
                count: w,
              },
              publish: {
                audio: !0,
                useRealTracks: !0,
              },
            });
            return;
          }
          if (a) {
            if (((C.current = !0), u.debug('connecting'), !e)) {
              u.debug('no token yet');
              return;
            }
            if (!o) {
              (u.warn('no livekit url provided'), c == null || c(Error('no livekit url provided')));
              return;
            }
            s.connect(o, e, d).catch((m) => {
              (u.warn(m), C.current === !0 && (c == null || c(m)));
            });
          } else
            (u.debug('disconnecting because connect is false'), (C.current = !1), s.disconnect());
        }
      }, [a, e, JSON.stringify(d), s, c, o, w]),
      i.useEffect(() => {
        if (s)
          return () => {
            (u.info('disconnecting on onmount'), s.disconnect());
          };
      }, [s]),
      { room: s, htmlProps: F }
    );
  }
  const room_BRK61eNB_W =
    /* @__PURE__ */ /* unused pure expression or super */ null &&
    i.forwardRef(function (e, o) {
      const { room: t, htmlProps: r } = room_BRK61eNB_$(e);
      return /* @__PURE__ */ i.createElement(
        'div',
        { ref: o, ...r },
        t &&
          /* @__PURE__ */ i.createElement(
            V.Provider,
            { value: t },
            /* @__PURE__ */ i.createElement(j.Provider, { value: e.featureFlags }, e.children)
          )
      );
    }); // ./node_modules/.pnpm/@livekit+components-react@2.9.15_@livekit+krisp-noise-filter@0.2.16_livekit-client@2.15.8_@ty_yekyi6zrdl5hlnuib5mo4n56ga/node_modules/@livekit/components-react/dist/hooks-4Z76Vz30.mjs

  //# sourceMappingURL=room-BRK61eNB.mjs.map

  const hooks_4Z76Vz30_tt = (e) => {
    const t = c.useRef(e);
    return (
      c.useEffect(() => {
        t.current = e;
      }),
      t
    );
  };
  function hooks_4Z76Vz30_nt(e, t) {
    const n = hooks_4Z76Vz30_at(),
      s = hooks_4Z76Vz30_tt(t);
    return (
      c.useLayoutEffect(() => {
        let a = !1;
        const r = e.current;
        if (!r) return;
        function o(i, u) {
          a || s.current(i, u);
        }
        return (
          n == null || n.subscribe(r, o),
          () => {
            ((a = !0), n == null || n.unsubscribe(r, o));
          }
        );
      }, [e.current, n, s]),
      n == null ? void 0 : n.observer
    );
  }
  function hooks_4Z76Vz30_st() {
    let e = !1,
      t = [];
    const n = /* @__PURE__ */ new Map();
    if (typeof window > 'u') return;
    const s = new ResizeObserver((a, r) => {
      ((t = t.concat(a)),
        e ||
          window.requestAnimationFrame(() => {
            const o = /* @__PURE__ */ new Set();
            for (let i = 0; i < t.length; i++) {
              if (o.has(t[i].target)) continue;
              o.add(t[i].target);
              const u = n.get(t[i].target);
              u == null || u.forEach((l) => l(t[i], r));
            }
            ((t = []), (e = !1));
          }),
        (e = !0));
    });
    return {
      observer: s,
      subscribe(a, r) {
        s.observe(a);
        const o = n.get(a) ?? [];
        (o.push(r), n.set(a, o));
      },
      unsubscribe(a, r) {
        const o = n.get(a) ?? [];
        if (o.length === 1) {
          (s.unobserve(a), n.delete(a));
          return;
        }
        const i = o.indexOf(r);
        (i !== -1 && o.splice(i, 1), n.set(a, o));
      },
    };
  }
  let hooks_4Z76Vz30_R;
  const hooks_4Z76Vz30_at = () => hooks_4Z76Vz30_R || (hooks_4Z76Vz30_R = hooks_4Z76Vz30_st()),
    hooks_4Z76Vz30_ct = (e) => {
      const [t, n] = c.useState({ width: 0, height: 0 });
      c.useLayoutEffect(() => {
        if (e.current) {
          const { width: a, height: r } = e.current.getBoundingClientRect();
          n({ width: a, height: r });
        }
      }, [e.current]);
      const s = c.useCallback((a) => n(a.contentRect), []);
      return (hooks_4Z76Vz30_nt(e, s), t);
    };
  function b(e, t, n = !0) {
    const [s, a] = react.useState(t);
    return (
      react.useEffect(() => {
        if ((n && a(t), typeof window > 'u' || !e)) return;
        const r = e.subscribe(a);
        return () => r.unsubscribe();
      }, [e, n]),
      s
    );
  }
  function hooks_4Z76Vz30_Dt(e) {
    const t = (r) => (typeof window < 'u' ? window.matchMedia(r).matches : !1),
      [n, s] = c.useState(t(e));
    function a() {
      s(t(e));
    }
    return (
      c.useEffect(() => {
        const r = window.matchMedia(e);
        return (
          a(),
          r.addListener ? r.addListener(a) : r.addEventListener('change', a),
          () => {
            r.removeListener ? r.removeListener(a) : r.removeEventListener('change', a);
          }
        );
      }, [e]),
      n
    );
  }
  function hooks_4Z76Vz30_Ot(e) {
    const t = k(e),
      n = c.useCallback(async () => {
        await t.startAudio();
      }, [t]),
      s = c.useMemo(() => se(t), [t]),
      { canPlayAudio: a } = b(s, {
        canPlayAudio: t.canPlaybackAudio,
      });
    return { canPlayAudio: a, startAudio: n };
  }
  function hooks_4Z76Vz30_It(e) {
    const { state: t, dispatch: n } = j().pin;
    return {
      buttonProps: c.useMemo(() => {
        const { className: a } = ae();
        return E(e, {
          className: a,
          disabled: !(t != null && t.length),
          onClick: () => {
            n && n({ msg: 'clear_pin' });
          },
        });
      }, [e, n, t]),
    };
  }
  function hooks_4Z76Vz30_Nt(e = {}) {
    const t = w(e.participant),
      { className: n, connectionQualityObserver: s } = c.useMemo(() => ce(t), [t]),
      a = b(s, t.connectionQuality);
    return { className: n, quality: a };
  }
  function hooks_4Z76Vz30_O(e) {
    const t = Ys(e),
      n = react.useMemo(() => ns(t), [t]);
    return b(n, t.state);
  }
  function hooks_4Z76Vz30_Rt(e, t) {
    const n = typeof e == 'function' ? e : t,
      s = typeof e == 'string' ? e : void 0,
      a = C(),
      {
        send: r,
        messageObservable: o,
        isSendingObservable: i,
      } = c.useMemo(() => oe(a, s, n), [a, s, n]),
      u = b(o, void 0),
      l = b(i, !1);
    return {
      message: u,
      send: r,
      isSending: l,
    };
  }
  function hooks_4Z76Vz30_Lt(e) {
    const t = C(),
      n = hooks_4Z76Vz30_O(t);
    return {
      buttonProps: c.useMemo(() => {
        const { className: a, disconnect: r } = ie(t);
        return E(e, {
          className: a,
          onClick: () => r(e.stopTracks ?? !0),
          disabled: n === D.Disconnected,
        });
      }, [t, e, n]),
    };
  }
  function hooks_4Z76Vz30_rt(e) {
    if (e.publication instanceof Xe) {
      const t = e.publication.track;
      if (t) {
        const { facingMode: n } = Ze(t);
        return n;
      }
    }
    return 'undefined';
  }
  function hooks_4Z76Vz30_t({ trackRef: e, props: t }) {
    const n = _(e),
      s = ue(),
      { className: a } = c.useMemo(() => de(), []),
      r = c.useMemo(
        () => le(n, s == null ? void 0 : s.pin.state),
        [n, s == null ? void 0 : s.pin.state]
      );
    return {
      mergedProps: c.useMemo(
        () =>
          E(t, {
            className: a,
            onClick: (i) => {
              var u, l, f, d, p;
              ((u = t.onClick) == null || u.call(t, i),
                r
                  ? (f = s == null ? void 0 : (l = s.pin).dispatch) == null ||
                    f.call(l, {
                      msg: 'clear_pin',
                    })
                  : (p = s == null ? void 0 : (d = s.pin).dispatch) == null ||
                    p.call(d, {
                      msg: 'set_pin',
                      trackReference: n,
                    }));
            },
          }),
        [t, a, n, r, s == null ? void 0 : s.pin]
      ),
      inFocus: r,
    };
  }
  function hooks_4Z76Vz30_Ft(e, t, n = {}) {
    const s = n.gridLayouts ?? fe,
      { width: a, height: r } = hooks_4Z76Vz30_ct(e),
      o = pe(s, t, a, r);
    return (
      c.useEffect(() => {
        e.current &&
          o &&
          (e.current.style.setProperty('--lk-col-count', o == null ? void 0 : o.columns.toString()),
          e.current.style.setProperty('--lk-row-count', o == null ? void 0 : o.rows.toString()));
      }, [e, o]),
      {
        layout: o,
        containerWidth: a,
        containerHeight: r,
      }
    );
  }
  function hooks_4Z76Vz30_B(e, t = {}) {
    var i, u;
    const n = typeof e == 'string' ? t.participant : e.participant,
      s = w(n),
      a = typeof e == 'string' ? { participant: s, source: e } : e,
      [r, o] = c.useState(
        !!(
          ((i = a.publication) != null && i.isMuted) ||
          ((u = s.getTrackPublication(a.source)) != null && u.isMuted)
        )
      );
    return (
      c.useEffect(() => {
        const l = me(a).subscribe(o);
        return () => l.unsubscribe();
      }, [F(a)]),
      r
    );
  }
  function hooks_4Z76Vz30_ot(e) {
    const t = w(e),
      n = c.useMemo(() => be(t), [t]);
    return b(n, t.isSpeaking);
  }
  function hooks_4Z76Vz30_it(e = {}) {
    const t = Ys(e.room),
      [n, s] = react.useState(t.localParticipant),
      [a, r] = react.useState(n.isMicrophoneEnabled),
      [o, i] = react.useState(n.isCameraEnabled),
      [u, l] = react.useState(n.isScreenShareEnabled),
      [f, d] = react.useState(n.lastMicrophoneError),
      [p, m] = react.useState(n.lastCameraError),
      [g, S] = react.useState(void 0),
      [y, v] = react.useState(void 0),
      T = (M) => {
        (i(M.isCameraEnabled),
          r(M.isMicrophoneEnabled),
          l(M.isScreenShareEnabled),
          v(M.cameraTrack),
          S(M.microphoneTrack),
          d(M.participant.lastMicrophoneError),
          m(M.participant.lastCameraError),
          s(M.participant));
      };
    return (
      react.useEffect(() => {
        const M = In(t.localParticipant).subscribe(T);
        return () => M.unsubscribe();
      }, [t]),
      {
        isMicrophoneEnabled: a,
        isScreenShareEnabled: u,
        isCameraEnabled: o,
        microphoneTrack: g,
        cameraTrack: y,
        lastMicrophoneError: f,
        lastCameraError: p,
        localParticipant: n,
      }
    );
  }
  function hooks_4Z76Vz30_Vt() {
    const e = zs(),
      t = react.useMemo(() => fs(e.localParticipant), [e]);
    return b(t, e.localParticipant.permissions);
  }
  function hooks_4Z76Vz30_qt({ kind: e, room: t, track: n, requestPermissions: s, onError: a }) {
    const r = Mo(),
      o = react.useMemo(() => t ?? r ?? new Room(), [t, r]),
      i = react.useMemo(() => os(e, a, s), [e, s, a]),
      u = b(i, []),
      [l, f] = react.useState((o == null ? void 0 : o.getActiveDevice(e)) ?? 'default'),
      {
        className: d,
        activeDeviceObservable: p,
        setActiveMediaDevice: m,
      } = react.useMemo(() => ms(e, o), [e, o, n]);
    return (
      react.useEffect(() => {
        const g = p.subscribe((S) => {
          S && (contexts_BGRNBsB8_L.info('setCurrentDeviceId', S), f(S));
        });
        return () => {
          g == null || g.unsubscribe();
        };
      }, [p]),
      { devices: u, className: d, activeDeviceId: l, setActiveMediaDevice: m }
    );
  }
  function hooks_4Z76Vz30_Ut({ kind: e, onError: t }) {
    const n = c.useMemo(() => Z(e, t), [e, t]);
    return b(n, []);
  }
  function hooks_4Z76Vz30_ut(e, t, n = {}) {
    const s = c.useRef([]),
      a = c.useRef(-1),
      r = t !== a.current,
      o = typeof n.customSortFunction == 'function' ? n.customSortFunction(e) : he(e);
    let i = [...o];
    if (r === !1)
      try {
        i = ve(s.current, o, t);
      } catch (u) {
        P.error('Error while running updatePages(): ', u);
      }
    return (r ? (s.current = o) : (s.current = i), (a.current = t), i);
  }
  function hooks_4Z76Vz30_zt(e, t) {
    const [n, s] = c.useState(1),
      a = Math.max(Math.ceil(t.length / e), 1);
    n > a && s(a);
    const r = n * e,
      o = r - e,
      i = (d) => {
        s((p) => (d === 'next' ? (p === a ? p : p + 1) : p === 1 ? p : p - 1));
      },
      u = (d) => {
        d > a ? s(a) : d < 1 ? s(1) : s(d);
      },
      f = hooks_4Z76Vz30_ut(t, e).slice(o, r);
    return {
      totalPageCount: a,
      nextPage: () => i('next'),
      prevPage: () => i('previous'),
      setPage: u,
      firstItemIndex: o,
      lastItemIndex: r,
      tracks: f,
      currentPage: n,
    };
  }
  function hooks_4Z76Vz30_Bt(e = {}) {
    let t = V();
    e.participant && (t = e.participant);
    const n = c.useMemo(() => Me(t), [t]),
      {
        identity: s,
        name: a,
        metadata: r,
      } = b(n, {
        name: t == null ? void 0 : t.name,
        identity: t == null ? void 0 : t.identity,
        metadata: t == null ? void 0 : t.metadata,
      });
    return { identity: s, name: a, metadata: r };
  }
  function hooks_4Z76Vz30_xt(e = {}) {
    const t = w(e.participant),
      n = c.useMemo(() => Y(t), [t]);
    return b(n, t.permissions);
  }
  function hooks_4Z76Vz30_Ht({
    trackRef: e,
    onParticipantClick: t,
    disableSpeakingIndicator: n,
    htmlProps: s,
  }) {
    const a = _(e),
      r = c.useMemo(() => {
        const { className: p } = ye();
        return E(s, {
          className: p,
          onClick: (m) => {
            var g;
            if (((g = s.onClick) == null || g.call(s, m), typeof t == 'function')) {
              const S = a.publication ?? a.participant.getTrackPublication(a.source);
              t({ participant: a.participant, track: S });
            }
          },
        });
      }, [s, t, a.publication, a.source, a.participant]),
      o = a.participant.getTrackPublication(h.Source.Microphone),
      i = c.useMemo(
        () => ({
          participant: a.participant,
          source: h.Source.Microphone,
          publication: o,
        }),
        [o, a.participant]
      ),
      u = hooks_4Z76Vz30_B(a),
      l = hooks_4Z76Vz30_B(i),
      f = hooks_4Z76Vz30_ot(a.participant),
      d = hooks_4Z76Vz30_rt(a);
    return {
      elementProps: {
        'data-lk-audio-muted': l,
        'data-lk-video-muted': u,
        'data-lk-speaking': n === !0 ? !1 : f,
        'data-lk-local-participant': a.participant.isLocal,
        'data-lk-source': a.source,
        'data-lk-facing-mode': d,
        ...r,
      },
    };
  }
  function hooks_4Z76Vz30_ee(e = {}) {
    const t = Ys(e.room),
      [n, s] = react.useState([]);
    return (
      react.useEffect(() => {
        const a = us(t, {
          additionalRoomEvents: e.updateOnlyOn,
        }).subscribe(s);
        return () => a.unsubscribe();
      }, [t, JSON.stringify(e.updateOnlyOn)]),
      n
    );
  }
  function hooks_4Z76Vz30_dt(e = {}) {
    const t = hooks_4Z76Vz30_ee(e),
      { localParticipant: n } = hooks_4Z76Vz30_it(e);
    return react.useMemo(() => [n, ...t], [n, t]);
  }
  function hooks_4Z76Vz30_Wt(e) {
    return (
      (e = ke(e)),
      c.useMemo(
        () =>
          (e == null ? void 0 : e.pin.state) !== void 0 && e.pin.state.length >= 1
            ? e.pin.state
            : [],
        [e.pin.state]
      )
    );
  }
  function hooks_4Z76Vz30_Jt(e, t = {}) {
    const n = C(),
      [s] = c.useState(t.updateOnlyOn),
      a = c.useMemo(
        () =>
          typeof e == 'string'
            ? Pe(n, e, {
                additionalEvents: s,
              })
            : Ee(n, e, {
                additionalEvents: s,
              }),
        [n, JSON.stringify(e), s]
      ),
      [r, o] = c.useState({
        p: void 0,
      });
    return (
      c.useEffect(() => {
        const i = a.subscribe((u) => o({ p: u }));
        return () => i.unsubscribe();
      }, [a]),
      r.p
    );
  }
  function hooks_4Z76Vz30_Gt(e = {}) {
    const t = k(e.room),
      n = c.useMemo(() => we(t), [t]),
      { name: s, metadata: a } = b(n, {
        name: t.name,
        metadata: t.metadata,
      });
    return { name: s, metadata: a };
  }
  function hooks_4Z76Vz30_lt() {
    const e = C(),
      t = c.useMemo(() => Ce(e), [e]);
    return b(t, e.activeSpeakers);
  }
  function hooks_4Z76Vz30_$t(e) {
    const [t, n] = c.useState(U(e)),
      s = hooks_4Z76Vz30_lt();
    return (
      c.useEffect(() => {
        n(U(e));
      }, [s, e]),
      t
    );
  }
  function hooks_4Z76Vz30_Qt({ room: e, props: t }) {
    const n = Ys(e),
      {
        className: s,
        roomAudioPlaybackAllowedObservable: a,
        handleStartAudioPlayback: r,
      } = react.useMemo(() => Ts(), []),
      o = react.useMemo(() => a(n), [n, a]),
      { canPlayAudio: i } = b(o, {
        canPlayAudio: n.canPlaybackAudio,
      });
    return {
      mergedProps: react.useMemo(
        () =>
          room_BRK61eNB_M(t, {
            className: s,
            onClick: () => {
              r(n);
            },
            style: { display: i ? 'none' : 'block' },
          }),
        [t, s, i, r, n]
      ),
      canPlayAudio: i,
    };
  }
  function hooks_4Z76Vz30_jt({ room: e, props: t }) {
    const n = k(e),
      {
        className: s,
        roomVideoPlaybackAllowedObservable: a,
        handleStartVideoPlayback: r,
      } = c.useMemo(() => De(), []),
      o = c.useMemo(() => a(n), [n, a]),
      { canPlayVideo: i } = b(o, {
        canPlayVideo: n.canPlaybackVideo,
      });
    return {
      mergedProps: c.useMemo(
        () =>
          E(t, {
            className: s,
            onClick: () => {
              r(n);
            },
            style: { display: i ? 'none' : 'block' },
          }),
        [t, s, i, r, n]
      ),
      canPlayVideo: i,
    };
  }
  function Yt(e, t = {}) {
    const n = c.useRef(null),
      s = c.useRef(null),
      a = t.minSwipeDistance ?? 50,
      r = (u) => {
        ((s.current = null), (n.current = u.targetTouches[0].clientX));
      },
      o = (u) => {
        s.current = u.targetTouches[0].clientX;
      },
      i = c.useCallback(() => {
        if (!n.current || !s.current) return;
        const u = n.current - s.current,
          l = u > a,
          f = u < -a;
        (l && t.onLeftSwipe && t.onLeftSwipe(), f && t.onRightSwipe && t.onRightSwipe());
      }, [a, t]);
    c.useEffect(() => {
      const u = e.current;
      return (
        u &&
          (u.addEventListener('touchstart', r, { passive: !0 }),
          u.addEventListener('touchmove', o, { passive: !0 }),
          u.addEventListener('touchend', i, { passive: !0 })),
        () => {
          u &&
            (u.removeEventListener('touchstart', r),
            u.removeEventListener('touchmove', o),
            u.removeEventListener('touchend', i));
        }
      );
    }, [e, i]);
  }
  function hooks_4Z76Vz30_Xt({ props: e }) {
    const { dispatch: t, state: n } = j().widget,
      { className: s } = c.useMemo(() => Oe(), []);
    return {
      mergedProps: c.useMemo(
        () =>
          E(e, {
            className: s,
            onClick: () => {
              t && t({ msg: 'toggle_chat' });
            },
            'aria-pressed': n != null && n.showChat ? 'true' : 'false',
            'data-lk-unread-msgs': n
              ? n.unreadMessages < 10
                ? n.unreadMessages.toFixed(0)
                : '9+'
              : '0',
          }),
        [e, s, t, n]
      ),
    };
  }
  function hooks_4Z76Vz30_Zt(e, t, n = {}) {
    const [s, a] = c.useState(void 0);
    return (
      c.useEffect(() => {
        var o;
        if (e === void 0) throw Error('token endpoint needs to be defined');
        if (((o = n.userInfo) == null ? void 0 : o.identity) === void 0) return;
        (async () => {
          P.debug('fetching token');
          const i = new URLSearchParams({ ...n.userInfo, roomName: t }),
            u = await fetch(`${e}?${i.toString()}`);
          if (!u.ok) {
            P.error(
              `Could not fetch token. Server responded with status ${u.status}: ${u.statusText}`
            );
            return;
          }
          const { accessToken: l } = await u.json();
          a(l);
        })();
      }, [e, t, JSON.stringify(n)]),
      s
    );
  }
  function hooks_4Z76Vz30_Kt(e) {
    var r, o;
    const t = _(e),
      { className: n, mediaMutedObserver: s } = c.useMemo(() => Ie(t), [F(t)]);
    return {
      isMuted: b(
        s,
        !!(
          ((r = t.publication) != null && r.isMuted) ||
          ((o = t.participant.getTrackPublication(t.source)) != null && o.isMuted)
        )
      ),
      className: n,
    };
  }
  function hooks_4Z76Vz30_en({
    source: e,
    onChange: t,
    initialState: n,
    captureOptions: s,
    publishOptions: a,
    onDeviceError: r,
    ...o
  }) {
    var T;
    const i = Mo(),
      u = (T = i == null ? void 0 : i.localParticipant) == null ? void 0 : T.getTrackPublication(e),
      l = react.useRef(!1),
      {
        toggle: f,
        className: d,
        pendingObserver: p,
        enabledObserver: m,
      } = react.useMemo(() => (i ? hs(e, i, s, a, r) : vs()), [i, e, JSON.stringify(s), a]),
      g = b(p, !1),
      S = b(m, n ?? !!(u != null && u.isEnabled));
    (react.useEffect(() => {
      (t == null || t(S, l.current), (l.current = !1));
    }, [S, t]),
      react.useEffect(() => {
        n !== void 0 && (contexts_BGRNBsB8_L.debug('forcing initial toggle state', e, n), f(n));
      }, []));
    const y = react.useMemo(() => room_BRK61eNB_M(o, { className: d }), [o, d]),
      v = react.useCallback(
        (M) => {
          var I;
          ((l.current = !0),
            f().catch(() => (l.current = !1)),
            (I = o.onClick) == null || I.call(o, M));
        },
        [o, f]
      );
    return {
      toggle: f,
      enabled: S,
      pending: g,
      track: u,
      buttonProps: {
        ...y,
        'aria-pressed': S,
        'data-lk-source': e,
        'data-lk-enabled': S,
        disabled: g,
        onClick: v,
      },
    };
  }
  function hooks_4Z76Vz30_tn(
    e = [
      Track.Source.Camera,
      Track.Source.Microphone,
      Track.Source.ScreenShare,
      Track.Source.ScreenShareAudio,
      Track.Source.Unknown,
    ],
    t = {}
  ) {
    const n = Ys(t.room),
      [s, a] = react.useState([]),
      [r, o] = react.useState([]),
      i = react.useMemo(() => e.map((l) => (Qi(l) ? l.source : l)), [JSON.stringify(e)]);
    return (
      react.useEffect(() => {
        const l = ks(n, i, {
          additionalRoomEvents: t.updateOnlyOn,
          onlySubscribed: t.onlySubscribed,
        }).subscribe(({ trackReferences: f, participants: d }) => {
          (contexts_BGRNBsB8_L.debug('setting track bundles', f, d), a(f), o(d));
        });
        return () => l.unsubscribe();
      }, [n, JSON.stringify(t.onlySubscribed), JSON.stringify(t.updateOnlyOn), JSON.stringify(e)]),
      react.useMemo(() => {
        if (Jo(e)) {
          const l = hooks_4Z76Vz30_pt(e, r),
            f = Array.from(s);
          return (
            r.forEach((d) => {
              l.has(d.identity) &&
                (l.get(d.identity) ?? []).forEach((m) => {
                  if (
                    s.find(
                      ({ participant: S, publication: y }) =>
                        d.identity === S.identity && y.source === m
                    )
                  )
                    return;
                  contexts_BGRNBsB8_L.debug(`Add ${m} placeholder for participant ${d.identity}.`);
                  const g = {
                    participant: d,
                    source: m,
                  };
                  f.push(g);
                });
            }),
            f
          );
        } else return s;
      }, [s, r, e])
    );
  }
  function hooks_4Z76Vz30_ft(e, t) {
    const n = new Set(e);
    for (const s of t) n.delete(s);
    return n;
  }
  function hooks_4Z76Vz30_pt(e, t) {
    const n = /* @__PURE__ */ new Map();
    if (Jo(e)) {
      const s = e.filter((a) => a.withPlaceholder).map((a) => a.source);
      t.forEach((a) => {
        const r = a
            .getTrackPublications()
            .map((i) => {
              var u;
              return (u = i.track) == null ? void 0 : u.source;
            })
            .filter((i) => i !== void 0),
          o = Array.from(hooks_4Z76Vz30_ft(new Set(s), new Set(r)));
        o.length > 0 && n.set(a.identity, o);
      });
    }
    return n;
  }
  function hooks_4Z76Vz30_mt(e) {
    const [t, n] = c.useState(Fe(e)),
      { trackObserver: s } = c.useMemo(
        () => Ve(e),
        [e.participant.sid ?? e.participant.identity, e.source]
      );
    return (
      c.useEffect(() => {
        const a = s.subscribe((r) => {
          n(r);
        });
        return () => (a == null ? void 0 : a.unsubscribe());
      }, [s]),
      {
        participant: e.participant,
        source: e.source ?? h.Source.Unknown,
        publication: t,
      }
    );
  }
  function hooks_4Z76Vz30_nn(e, t) {
    const n = w(t);
    return hooks_4Z76Vz30_mt({ name: e, participant: n });
  }
  function hooks_4Z76Vz30_sn(e) {
    const t = zs(),
      n = hooks_4Z76Vz30_O(t),
      s = react.useMemo(() => n === ConnectionState.Disconnected, [n]),
      a = react.useMemo(() => Ss(t, e), [t, e, s]),
      r = b(a.isSendingObservable, !1),
      o = b(a.messageObservable, []);
    return { send: a.send, chatMessages: o, isSending: r };
  }
  function hooks_4Z76Vz30_an(e = {}) {
    const [t, n] = react.useState(Ds(e.defaults, e.preventLoad ?? !1)),
      s = react.useCallback((u) => {
        n((l) => ({ ...l, audioEnabled: u }));
      }, []),
      a = react.useCallback((u) => {
        n((l) => ({ ...l, videoEnabled: u }));
      }, []),
      r = react.useCallback((u) => {
        n((l) => ({ ...l, audioDeviceId: u }));
      }, []),
      o = react.useCallback((u) => {
        n((l) => ({ ...l, videoDeviceId: u }));
      }, []),
      i = react.useCallback((u) => {
        n((l) => ({ ...l, username: u }));
      }, []);
    return (
      react.useEffect(() => {
        Rs(t, e.preventSave ?? !1);
      }, [t, e.preventSave]),
      {
        userChoices: t,
        saveAudioInputEnabled: s,
        saveVideoInputEnabled: a,
        saveAudioInputDeviceId: r,
        saveVideoInputDeviceId: o,
        saveUsername: i,
      }
    );
  }
  function hooks_4Z76Vz30_cn(e, t = {}) {
    const n = w(e),
      s = k(t.room),
      a = c.useMemo(() => Be(s, n), [s, n]);
    return b(a, n.isLocal ? n.isE2EEEnabled : !!(n != null && n.isEncrypted));
  }
  function hooks_4Z76Vz30_rn(e, t = { fftSize: 32, smoothingTimeConstant: 0 }) {
    const n = xe(e) ? e.publication.track : e,
      [s, a] = c.useState(0);
    return (
      c.useEffect(() => {
        if (!n || !n.mediaStream) return;
        const { cleanup: r, analyser: o } = q(n, t),
          i = o.frequencyBinCount,
          u = new Uint8Array(i),
          f = setInterval(() => {
            o.getByteFrequencyData(u);
            let d = 0;
            for (let p = 0; p < u.length; p++) {
              const m = u[p];
              d += m * m;
            }
            a(Math.sqrt(d / u.length) / 255);
          }, 1e3 / 30);
        return () => {
          (r(), clearInterval(f));
        };
      }, [n, n == null ? void 0 : n.mediaStream, JSON.stringify(t)]),
      s
    );
  }
  const hooks_4Z76Vz30_bt = (e) => {
      const t = (n) => {
        let r = 1 - (Math.max(-100, Math.min(-10, n)) * -1) / 100;
        return ((r = Math.sqrt(r)), r);
      };
      return e.map((n) => (n === -1 / 0 ? 0 : t(n)));
    },
    hooks_4Z76Vz30_St = {
      bands: 5,
      loPass: 100,
      hiPass: 600,
      updateInterval: 32,
      analyserOptions: { fftSize: 2048 },
    };
  function hooks_4Z76Vz30_on(e, t = {}) {
    var o;
    const n =
        e instanceof Track
          ? e
          : (o = e == null ? void 0 : e.publication) == null
            ? void 0
            : o.track,
      s = { ...hooks_4Z76Vz30_St, ...t },
      [a, r] = react.useState(new Array(s.bands).fill(0));
    return (
      react.useEffect(() => {
        if (!n || !(n != null && n.mediaStream)) return;
        const { analyser: i, cleanup: u } = createAudioAnalyser(n, s.analyserOptions),
          l = i.frequencyBinCount,
          f = new Float32Array(l),
          p = setInterval(() => {
            i.getFloatFrequencyData(f);
            let m = new Float32Array(f.length);
            for (let v = 0; v < f.length; v++) m[v] = f[v];
            m = m.slice(t.loPass, t.hiPass);
            const g = hooks_4Z76Vz30_bt(m),
              S = Math.ceil(g.length / s.bands),
              y = [];
            for (let v = 0; v < s.bands; v++) {
              const T = g.slice(v * S, (v + 1) * S).reduce((M, I) => (M += I), 0);
              y.push(T / S);
            }
            r(y);
          }, s.updateInterval);
        return () => {
          (u(), clearInterval(p));
        };
      }, [n, n == null ? void 0 : n.mediaStream, JSON.stringify(t)]),
      a
    );
  }
  const hooks_4Z76Vz30_gt = {
    barCount: 120,
    volMultiplier: 5,
    updateInterval: 20,
  };
  function hooks_4Z76Vz30_un(e, t = {}) {
    var f;
    const n =
        e instanceof h ? e : (f = e == null ? void 0 : e.publication) == null ? void 0 : f.track,
      s = { ...hooks_4Z76Vz30_gt, ...t },
      a = c.useRef(new Float32Array()),
      r = c.useRef(performance.now()),
      o = c.useRef(0),
      [i, u] = c.useState([]),
      l = c.useCallback((d) => {
        u(
          Array.from(
            hooks_4Z76Vz30_vt(d, s.barCount).map((p) => Math.sqrt(p) * s.volMultiplier)
            // wave.slice(0, opts.barCount).map((v) => sigmoid(v * opts.volMultiplier, 0.08, 0.2)),
          )
        );
      }, []);
    return (
      c.useEffect(() => {
        if (!n || !(n != null && n.mediaStream)) return;
        const { analyser: d, cleanup: p } = q(n, {
            fftSize: hooks_4Z76Vz30_x(s.barCount),
          }),
          m = hooks_4Z76Vz30_x(s.barCount),
          g = new Float32Array(m),
          S = () => {
            if (
              ((y = requestAnimationFrame(S)),
              d.getFloatTimeDomainData(g),
              a.current.map((v, T) => v + g[T]),
              (o.current += 1),
              performance.now() - r.current >= s.updateInterval)
            ) {
              const v = g.map((T) => T / o.current);
              (l(v), (r.current = performance.now()), (o.current = 0));
            }
          };
        let y = requestAnimationFrame(S);
        return () => {
          (p(), cancelAnimationFrame(y));
        };
      }, [n, n == null ? void 0 : n.mediaStream, JSON.stringify(t), l]),
      {
        bars: i,
      }
    );
  }
  function hooks_4Z76Vz30_x(e) {
    return e < 32 ? 32 : hooks_4Z76Vz30_ht(e);
  }
  function hooks_4Z76Vz30_ht(e) {
    let t = 2;
    for (; (e >>= 1); ) t <<= 1;
    return t;
  }
  function hooks_4Z76Vz30_vt(e, t) {
    const n = Math.floor(e.length / t),
      s = new Float32Array(t);
    for (let a = 0; a < t; a++) {
      const r = n * a;
      let o = 0;
      for (let i = 0; i < n; i++) o = o + Math.abs(e[r + i]);
      s[a] = o / n;
    }
    return s;
  }
  function hooks_4Z76Vz30_H(e, t) {
    const n = Io(),
      s = hooks_4Z76Vz30_dt({ updateOnlyOn: [] }),
      a = react.useMemo(() => (t ? s.find((i) => i.identity === t) : n), [t, s, n]),
      r = react.useMemo(() => {
        if (a) return _s(a, { sources: e });
      }, [a, JSON.stringify(e)]);
    return b(r, []);
  }
  function hooks_4Z76Vz30_Mt(e) {
    var n, s, a;
    const t = react.useMemo(() => {
      var r;
      return (r = e == null ? void 0 : e.publication) != null && r.track
        ? Is(e == null ? void 0 : e.publication.track)
        : void 0;
    }, [(n = e == null ? void 0 : e.publication) == null ? void 0 : n.track]);
    return b(t, {
      timestamp: Date.now(),
      rtpTimestamp:
        (a = (s = e == null ? void 0 : e.publication) == null ? void 0 : s.track) == null
          ? void 0
          : a.rtpTimestamp,
    });
  }
  const hooks_4Z76Vz30_yt = {
    bufferSize: 100,
    // maxAge: 2_000,
  };
  function Tt(e, t) {
    const n = { ...hooks_4Z76Vz30_yt, ...t },
      [s, a] = react.useState([]),
      r = hooks_4Z76Vz30_Mt(e),
      o = (i) => {
        var u;
        ((u = n.onTranscription) == null || u.call(n, i),
          a((l) =>
            Qo(
              l,
              // when first receiving a segment, add the current media timestamp to it
              i.map((f) => Go(f, r)),
              n.bufferSize
            )
          ));
      };
    return (
      react.useEffect(() => {
        if (!(e != null && e.publication)) return;
        const i = Ls(e.publication).subscribe((u) => {
          o(...u);
        });
        return () => {
          i.unsubscribe();
        };
      }, [e && contexts_BGRNBsB8_N(e), o]),
      { segments: s }
    );
  }
  function hooks_4Z76Vz30_kt(e = {}) {
    const t = Io(),
      n = e.participant ?? t,
      s = react.useMemo(
        // weird typescript constraint
        () => (n ? ps(n) : ps(n)),
        [n]
      );
    return b(s, {
      attributes: n == null ? void 0 : n.attributes,
    });
  }
  function hooks_4Z76Vz30_dn(e, t = {}) {
    const n = w(t.participant),
      [s, a] = c.useState(n.attributes[e]);
    return (
      c.useEffect(() => {
        if (!n) return;
        const r = L(n).subscribe((o) => {
          o.changed[e] !== void 0 && a(o.attributes[e]);
        });
        return () => {
          r.unsubscribe();
        };
      }, [n, e]),
      s
    );
  }
  const hooks_4Z76Vz30_W = 'lk.agent.state';
  function hooks_4Z76Vz30_ln() {
    const e = hooks_4Z76Vz30_ee(),
      t = e.find(
        (d) => d.kind === ParticipantInfo_Kind.AGENT && !('lk.publish_on_behalf' in d.attributes)
      ),
      n = e.find(
        (d) =>
          d.kind === ParticipantInfo_Kind.AGENT &&
          d.attributes['lk.publish_on_behalf'] === (t == null ? void 0 : t.identity)
      ),
      s = hooks_4Z76Vz30_H(
        [Track.Source.Microphone, Track.Source.Camera],
        t == null ? void 0 : t.identity
      ),
      a = hooks_4Z76Vz30_H(
        [Track.Source.Microphone, Track.Source.Camera],
        n == null ? void 0 : n.identity
      ),
      r =
        s.find((d) => d.source === Track.Source.Microphone) ??
        a.find((d) => d.source === Track.Source.Microphone),
      o =
        s.find((d) => d.source === Track.Source.Camera) ??
        a.find((d) => d.source === Track.Source.Camera),
      { segments: i } = Tt(r),
      u = hooks_4Z76Vz30_O(),
      { attributes: l } = hooks_4Z76Vz30_kt({ participant: t }),
      f = react.useMemo(
        () =>
          u === ConnectionState.Disconnected
            ? 'disconnected'
            : u === ConnectionState.Connecting || !t || !(l != null && l[hooks_4Z76Vz30_W])
              ? 'connecting'
              : l[hooks_4Z76Vz30_W],
        [l, t, u]
      );
    return {
      agent: t,
      state: f,
      audioTrack: r,
      videoTrack: o,
      agentTranscriptions: i,
      agentAttributes: l,
    };
  }
  function hooks_4Z76Vz30_fn(e) {
    const t = k(e),
      n = hooks_4Z76Vz30_O(t),
      s = c.useMemo(() => Qe(t), [t, n]);
    return b(s, t.isRecording);
  }
  function hooks_4Z76Vz30_Pt(e) {
    const t = zs(),
      s = hooks_4Z76Vz30_O(t) === ConnectionState.Disconnected,
      a = react.useMemo(() => $s(t, e), [t, e]);
    return { textStreams: b(s ? void 0 : a, []) };
  }
  function hooks_4Z76Vz30_pn(e) {
    const { participantIdentities: t, trackSids: n } = e ?? {},
      { textStreams: s } = hooks_4Z76Vz30_Pt(mo.TRANSCRIPTION);
    return react.useMemo(
      () =>
        s
          .filter((r) => (t ? t.includes(r.participantInfo.identity) : !0))
          .filter((r) => {
            var o;
            return n
              ? n.includes(
                  ((o = r.streamInfo.attributes) == null ? void 0 : o['lk.transcribed_track_id']) ??
                    ''
                )
              : !0;
          }),
      [s, t, n]
    );
  }
  const hooks_4Z76Vz30_J = 2,
    hooks_4Z76Vz30_G = 400,
    hooks_4Z76Vz30_$ = 3,
    hooks_4Z76Vz30_Q = 1e3;
  function hooks_4Z76Vz30_mn(e) {
    const t = N([]),
      n = te(() => new et(), []),
      s = A(
        async () =>
          n.lock().then(async (f) => {
            for (;;) {
              const d = t.current.pop();
              if (!d) {
                f();
                break;
              }
              switch (d.type) {
                case 'connect':
                  await d.room
                    .connect(...d.args)
                    .then(d.resolve)
                    .catch(d.reject);
                  break;
                case 'disconnect':
                  await d.room
                    .disconnect(...d.args)
                    .then(d.resolve)
                    .catch(d.reject);
                  break;
              }
            }
          }),
        []
      ),
      a = N([]),
      r = A((f) => {
        let d = 0;
        ((a.current = a.current.filter((p) => {
          const m = f.getTime() - p.getTime() < hooks_4Z76Vz30_Q;
          return (m && (d += 1), m);
        })),
          d > hooks_4Z76Vz30_$ &&
            P.warn(
              `useSequentialRoomConnectDisconnect: room changed reference rapidly (over ${hooks_4Z76Vz30_$}x in ${hooks_4Z76Vz30_Q}ms). This is not recommended.`
            ));
      }, []);
    ne(() => {
      t.current = [];
      const f = /* @__PURE__ */ new Date();
      (a.current.push(f), r(f));
    }, [e, r]);
    const o = N([]),
      i = A((f) => {
        let d = 0;
        ((o.current = o.current.filter((p) => {
          const m = f.getTime() - p.getTime() < hooks_4Z76Vz30_G;
          return (m && (d += 1), m);
        })),
          d > hooks_4Z76Vz30_J &&
            P.warn(
              `useSequentialRoomConnectDisconnect: room connect / disconnect occurring in rapid sequence (over ${hooks_4Z76Vz30_J}x in ${hooks_4Z76Vz30_G}ms). This is not recommended and may be the sign of a bug like a useEffect dependency changing every render.`
            ));
      }, []),
      u = A(
        async (...f) =>
          new Promise((d, p) => {
            if (!e) throw new Error('Called connect(), but room was unset');
            const m = /* @__PURE__ */ new Date();
            (i(m),
              t.current.push({ type: 'connect', room: e, args: f, resolve: d, reject: p }),
              o.current.push(m),
              s());
          }),
        [e, i, s]
      ),
      l = A(
        async (...f) =>
          new Promise((d, p) => {
            if (!e) throw new Error('Called discconnect(), but room was unset');
            const m = /* @__PURE__ */ new Date();
            (i(m),
              t.current.push({ type: 'disconnect', room: e, args: f, resolve: d, reject: p }),
              o.current.push(m),
              s());
          }),
        [e, i, s]
      );
    return {
      connect: e ? u : null,
      disconnect: e ? l : null,
    };
  } // ./node_modules/.pnpm/@livekit+components-react@2.9.15_@livekit+krisp-noise-filter@0.2.16_livekit-client@2.15.8_@ty_yekyi6zrdl5hlnuib5mo4n56ga/node_modules/@livekit/components-react/dist/components-CwZ8kStA.mjs

  //# sourceMappingURL=hooks-4Z76Vz30.mjs.map

  const aa =
      /* @__PURE__ */ /* unused pure expression or super */ null &&
      e.forwardRef(function (n, a) {
        const { buttonProps: r } = ze(n);
        return /* @__PURE__ */ e.createElement('button', { ref: a, ...r }, n.children);
      }),
    na =
      /* @__PURE__ */ /* unused pure expression or super */ null &&
      e.forwardRef(function ({ room: n, ...a }, r) {
        const c = he(n);
        return /* @__PURE__ */ e.createElement('div', { ref: r, ...a }, c);
      }),
    ra =
      /* @__PURE__ */ /* unused pure expression or super */ null &&
      e.forwardRef(function (n, a) {
        const { mergedProps: r } = Ve({ props: n });
        return /* @__PURE__ */ e.createElement('button', { ref: a, ...r }, n.children);
      }),
    ca =
      /* @__PURE__ */ /* unused pure expression or super */ null &&
      e.forwardRef(function (n, a) {
        const { buttonProps: r } = Fe(n);
        return /* @__PURE__ */ e.createElement('button', { ref: a, ...r }, n.children);
      }),
    components_CwZ8kStA_gt = (t) =>
      /* @__PURE__ */ e.createElement(
        'svg',
        { xmlns: 'http://www.w3.org/2000/svg', width: 16, height: 16, fill: 'currentColor', ...t },
        /* @__PURE__ */ e.createElement('path', {
          d: 'M1.354.646a.5.5 0 1 0-.708.708l14 14a.5.5 0 0 0 .708-.708L11 10.293V4.5A1.5 1.5 0 0 0 9.5 3H3.707zM0 4.5a1.5 1.5 0 0 1 .943-1.393l9.532 9.533c-.262.224-.603.36-.975.36h-8A1.5 1.5 0 0 1 0 11.5z',
        }),
        /* @__PURE__ */ e.createElement('path', {
          d: 'm15.2 3.6-2.8 2.1a1 1 0 0 0-.4.8v3a1 1 0 0 0 .4.8l2.8 2.1a.5.5 0 0 0 .8-.4V4a.5.5 0 0 0-.8-.4z',
        })
      ),
    components_CwZ8kStA_vt = (t) =>
      /* @__PURE__ */ e.createElement(
        'svg',
        { xmlns: 'http://www.w3.org/2000/svg', width: 16, height: 16, fill: 'currentColor', ...t },
        /* @__PURE__ */ e.createElement('path', {
          d: 'M0 4.5A1.5 1.5 0 0 1 1.5 3h8A1.5 1.5 0 0 1 11 4.5v7A1.5 1.5 0 0 1 9.5 13h-8A1.5 1.5 0 0 1 0 11.5zM15.2 3.6l-2.8 2.1a1 1 0 0 0-.4.8v3a1 1 0 0 0 .4.8l2.8 2.1a.5.5 0 0 0 .8-.4V4a.5.5 0 0 0-.8-.4z',
        })
      ),
    la = (t) =>
      /* @__PURE__ */ e.createElement(
        'svg',
        { xmlns: 'http://www.w3.org/2000/svg', width: 16, height: 16, viewBox: '0 0 24 24', ...t },
        /* @__PURE__ */ e.createElement('path', {
          fill: '#FFF',
          d: 'M4.99 3.99a1 1 0 0 0-.697 1.717L10.586 12l-6.293 6.293a1 1 0 1 0 1.414 1.414L12 13.414l6.293 6.293a1 1 0 1 0 1.414-1.414L13.414 12l6.293-6.293a1 1 0 0 0-.727-1.717 1 1 0 0 0-.687.303L12 10.586 5.707 4.293a1 1 0 0 0-.717-.303z',
        })
      ),
    sa = (t) =>
      /* @__PURE__ */ e.createElement(
        'svg',
        { xmlns: 'http://www.w3.org/2000/svg', width: 16, height: 18, fill: 'none', ...t },
        /* @__PURE__ */ e.createElement('path', {
          fill: 'currentColor',
          fillRule: 'evenodd',
          d: 'M0 2.75A2.75 2.75 0 0 1 2.75 0h10.5A2.75 2.75 0 0 1 16 2.75v13.594a.75.75 0 0 1-1.234.572l-3.691-3.12a1.25 1.25 0 0 0-.807-.296H2.75A2.75 2.75 0 0 1 0 10.75v-8ZM2.75 1.5c-.69 0-1.25.56-1.25 1.25v8c0 .69.56 1.25 1.25 1.25h7.518c.65 0 1.279.23 1.775.65l2.457 2.077V2.75c0-.69-.56-1.25-1.25-1.25H2.75Z',
          clipRule: 'evenodd',
        }),
        /* @__PURE__ */ e.createElement('path', {
          fill: 'currentColor',
          fillRule: 'evenodd',
          d: 'M3 4.5a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5Zm0 2a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5Zm0 2a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 0 1h-5a.5.5 0 0 1-.5-.5Z',
          clipRule: 'evenodd',
        })
      ),
    components_CwZ8kStA_ie = (t) =>
      /* @__PURE__ */ e.createElement(
        'svg',
        { xmlns: 'http://www.w3.org/2000/svg', width: 16, height: 16, fill: 'none', ...t },
        /* @__PURE__ */ e.createElement('path', {
          fill: 'currentcolor',
          fillRule: 'evenodd',
          d: 'M5.293 2.293a1 1 0 0 1 1.414 0l4.823 4.823a1.25 1.25 0 0 1 0 1.768l-4.823 4.823a1 1 0 0 1-1.414-1.414L9.586 8 5.293 3.707a1 1 0 0 1 0-1.414z',
          clipRule: 'evenodd',
        })
      ),
    components_CwZ8kStA_Et = (t) =>
      /* @__PURE__ */ e.createElement(
        'svg',
        { xmlns: 'http://www.w3.org/2000/svg', width: 16, height: 16, fill: 'none', ...t },
        /* @__PURE__ */ e.createElement(
          'g',
          {
            stroke: 'currentColor',
            strokeLinecap: 'round',
            strokeLinejoin: 'round',
            strokeWidth: 1.5,
          },
          /* @__PURE__ */ e.createElement('path', {
            d: 'M10 1.75h4.25m0 0V6m0-4.25L9 7M6 14.25H1.75m0 0V10m0 4.25L7 9',
          })
        )
      ),
    ia = (t) =>
      /* @__PURE__ */ e.createElement(
        'svg',
        { xmlns: 'http://www.w3.org/2000/svg', width: 16, height: 16, fill: 'none', ...t },
        /* @__PURE__ */ e.createElement('path', {
          fill: 'currentcolor',
          fillRule: 'evenodd',
          d: 'M8.961.894C8.875-.298 7.125-.298 7.04.894c-.066.912-1.246 1.228-1.76.472-.67-.99-2.186-.115-1.664.96.399.824-.465 1.688-1.288 1.289-1.076-.522-1.95.994-.961 1.665.756.513.44 1.693-.472 1.759-1.192.086-1.192 1.836 0 1.922.912.066 1.228 1.246.472 1.76-.99.67-.115 2.186.96 1.664.824-.399 1.688.465 1.289 1.288-.522 1.076.994 1.95 1.665.961.513-.756 1.693-.44 1.759.472.086 1.192 1.836 1.192 1.922 0 .066-.912 1.246-1.228 1.76-.472.67.99 2.186.115 1.664-.96-.399-.824.465-1.688 1.288-1.289 1.076.522 1.95-.994.961-1.665-.756-.513-.44-1.693.472-1.759 1.192-.086 1.192-1.836 0-1.922-.912-.066-1.228-1.246-.472-1.76.99-.67.115-2.186-.96-1.664-.824.399-1.688-.465-1.289-1.288.522-1.076-.994-1.95-1.665-.961-.513.756-1.693.44-1.759-.472ZM8 13A5 5 0 1 0 8 3a5 5 0 0 0 0 10Z',
          clipRule: 'evenodd',
        })
      ),
    oa = (t) =>
      /* @__PURE__ */ e.createElement(
        'svg',
        { xmlns: 'http://www.w3.org/2000/svg', width: 16, height: 16, fill: 'none', ...t },
        /* @__PURE__ */ e.createElement('path', {
          fill: 'currentColor',
          fillRule: 'evenodd',
          d: 'M2 2.75A2.75 2.75 0 0 1 4.75 0h6.5A2.75 2.75 0 0 1 14 2.75v10.5A2.75 2.75 0 0 1 11.25 16h-6.5A2.75 2.75 0 0 1 2 13.25v-.5a.75.75 0 0 1 1.5 0v.5c0 .69.56 1.25 1.25 1.25h6.5c.69 0 1.25-.56 1.25-1.25V2.75c0-.69-.56-1.25-1.25-1.25h-6.5c-.69 0-1.25.56-1.25 1.25v.5a.75.75 0 0 1-1.5 0v-.5Z',
          clipRule: 'evenodd',
        }),
        /* @__PURE__ */ e.createElement('path', {
          fill: 'currentColor',
          fillRule: 'evenodd',
          d: 'M8.78 7.47a.75.75 0 0 1 0 1.06l-2.25 2.25a.75.75 0 1 1-1.06-1.06l.97-.97H1.75a.75.75 0 0 1 0-1.5h4.69l-.97-.97a.75.75 0 0 1 1.06-1.06l2.25 2.25Z',
          clipRule: 'evenodd',
        })
      ),
    components_CwZ8kStA_pt = (t) =>
      /* @__PURE__ */ e.createElement(
        'svg',
        { xmlns: 'http://www.w3.org/2000/svg', width: 16, height: 16, fill: 'none', ...t },
        /* @__PURE__ */ e.createElement('path', {
          fill: 'currentcolor',
          fillRule: 'evenodd',
          d: 'M4 6.104V4a4 4 0 1 1 8 0v2.104c1.154.326 2 1.387 2 2.646v4.5A2.75 2.75 0 0 1 11.25 16h-6.5A2.75 2.75 0 0 1 2 13.25v-4.5c0-1.259.846-2.32 2-2.646ZM5.5 4a2.5 2.5 0 0 1 5 0v2h-5V4Z',
          clipRule: 'evenodd',
        })
      ),
    components_CwZ8kStA_wt = (t) =>
      /* @__PURE__ */ e.createElement(
        'svg',
        { xmlns: 'http://www.w3.org/2000/svg', width: 16, height: 16, fill: 'currentColor', ...t },
        /* @__PURE__ */ e.createElement('path', {
          d: 'M12.227 11.52a5.477 5.477 0 0 0 1.246-2.97.5.5 0 0 0-.995-.1 4.478 4.478 0 0 1-.962 2.359l-1.07-1.07C10.794 9.247 11 8.647 11 8V3a3 3 0 0 0-6 0v1.293L1.354.646a.5.5 0 1 0-.708.708l14 14a.5.5 0 0 0 .708-.708zM8 12.5c.683 0 1.33-.152 1.911-.425l.743.743c-.649.359-1.378.59-2.154.66V15h2a.5.5 0 0 1 0 1h-5a.5.5 0 0 1 0-1h2v-1.522a5.502 5.502 0 0 1-4.973-4.929.5.5 0 0 1 .995-.098A4.5 4.5 0 0 0 8 12.5z',
        }),
        /* @__PURE__ */ e.createElement('path', {
          d: 'M8.743 10.907 5 7.164V8a3 3 0 0 0 3.743 2.907z',
        })
      ),
    components_CwZ8kStA_kt = (t) =>
      /* @__PURE__ */ e.createElement(
        'svg',
        { xmlns: 'http://www.w3.org/2000/svg', width: 16, height: 16, fill: 'currentColor', ...t },
        /* @__PURE__ */ e.createElement('path', {
          fillRule: 'evenodd',
          d: 'M2.975 8.002a.5.5 0 0 1 .547.449 4.5 4.5 0 0 0 8.956 0 .5.5 0 1 1 .995.098A5.502 5.502 0 0 1 8.5 13.478V15h2a.5.5 0 0 1 0 1h-5a.5.5 0 0 1 0-1h2v-1.522a5.502 5.502 0 0 1-4.973-4.929.5.5 0 0 1 .448-.547z',
          clipRule: 'evenodd',
        }),
        /* @__PURE__ */ e.createElement('path', { d: 'M5 3a3 3 0 1 1 6 0v5a3 3 0 0 1-6 0z' })
      ),
    components_CwZ8kStA_Rt = (t) =>
      /* @__PURE__ */ e.createElement(
        'svg',
        { xmlns: 'http://www.w3.org/2000/svg', width: 16, height: 16, fill: 'currentcolor', ...t },
        /* @__PURE__ */ e.createElement('path', {
          d: 'M0 11.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5zm6-5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v9a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5zm6-6a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v15a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5z',
        }),
        /* @__PURE__ */ e.createElement('path', {
          d: 'M0 11.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5zm6-5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v9a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5zm6-6a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v15a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5z',
        })
      ),
    components_CwZ8kStA_Mt = (t) =>
      /* @__PURE__ */ e.createElement(
        'svg',
        { xmlns: 'http://www.w3.org/2000/svg', width: 16, height: 16, fill: 'currentcolor', ...t },
        /* @__PURE__ */ e.createElement('path', {
          d: 'M0 11.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5zm6-5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v9a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5z',
        }),
        /* @__PURE__ */ e.createElement('path', {
          d: 'M0 11.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5zm6-5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v9a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5z',
        }),
        /* @__PURE__ */ e.createElement(
          'g',
          { opacity: 0.25 },
          /* @__PURE__ */ e.createElement('path', {
            d: 'M12 .5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v15a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5z',
          }),
          /* @__PURE__ */ e.createElement('path', {
            d: 'M12 .5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v15a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5z',
          })
        )
      ),
    components_CwZ8kStA_yt = (t) =>
      /* @__PURE__ */ e.createElement(
        'svg',
        { xmlns: 'http://www.w3.org/2000/svg', width: 16, height: 16, fill: 'currentcolor', ...t },
        /* @__PURE__ */ e.createElement('path', {
          d: 'M0 11.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5z',
        }),
        /* @__PURE__ */ e.createElement('path', {
          d: 'M0 11.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5z',
        }),
        /* @__PURE__ */ e.createElement(
          'g',
          { opacity: 0.25 },
          /* @__PURE__ */ e.createElement('path', {
            d: 'M6 6.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v9a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5z',
          }),
          /* @__PURE__ */ e.createElement('path', {
            d: 'M6 6.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v9a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5zm6-6a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v15a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5z',
          }),
          /* @__PURE__ */ e.createElement('path', {
            d: 'M12 .5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v15a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5z',
          })
        )
      ),
    components_CwZ8kStA_bt = (t) =>
      /* @__PURE__ */ e.createElement(
        'svg',
        { xmlns: 'http://www.w3.org/2000/svg', width: 16, height: 16, fill: 'currentColor', ...t },
        /* @__PURE__ */ e.createElement(
          'g',
          { opacity: 0.25 },
          /* @__PURE__ */ e.createElement('path', {
            d: 'M0 11.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-4Zm6-5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v9a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-9Zm6-6a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v15a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5V.5Z',
          }),
          /* @__PURE__ */ e.createElement('path', {
            d: 'M0 11.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-4Zm6-5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v9a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-9Zm6-6a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v15a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5V.5Z',
          })
        )
      ),
    components_CwZ8kStA_Me = (t) =>
      /* @__PURE__ */ e.createElement(
        'svg',
        { xmlns: 'http://www.w3.org/2000/svg', width: 20, height: 16, fill: 'none', ...t },
        /* @__PURE__ */ e.createElement('path', {
          fill: 'currentColor',
          fillRule: 'evenodd',
          d: 'M0 2.75A2.75 2.75 0 0 1 2.75 0h14.5A2.75 2.75 0 0 1 20 2.75v10.5A2.75 2.75 0 0 1 17.25 16H2.75A2.75 2.75 0 0 1 0 13.25V2.75ZM2.75 1.5c-.69 0-1.25.56-1.25 1.25v10.5c0 .69.56 1.25 1.25 1.25h14.5c.69 0 1.25-.56 1.25-1.25V2.75c0-.69-.56-1.25-1.25-1.25H2.75Z',
          clipRule: 'evenodd',
        }),
        /* @__PURE__ */ e.createElement('path', {
          fill: 'currentColor',
          fillRule: 'evenodd',
          d: 'M9.47 4.22a.75.75 0 0 1 1.06 0l2.25 2.25a.75.75 0 0 1-1.06 1.06l-.97-.97v4.69a.75.75 0 0 1-1.5 0V6.56l-.97.97a.75.75 0 0 1-1.06-1.06l2.25-2.25Z',
          clipRule: 'evenodd',
        })
      ),
    components_CwZ8kStA_St = (t) =>
      /* @__PURE__ */ e.createElement(
        'svg',
        { xmlns: 'http://www.w3.org/2000/svg', width: 20, height: 16, fill: 'none', ...t },
        /* @__PURE__ */ e.createElement(
          'g',
          { fill: 'currentColor' },
          /* @__PURE__ */ e.createElement('path', {
            d: 'M7.28 4.22a.75.75 0 0 0-1.06 1.06L8.94 8l-2.72 2.72a.75.75 0 1 0 1.06 1.06L10 9.06l2.72 2.72a.75.75 0 1 0 1.06-1.06L11.06 8l2.72-2.72a.75.75 0 0 0-1.06-1.06L10 6.94z',
          }),
          /* @__PURE__ */ e.createElement('path', {
            fillRule: 'evenodd',
            d: 'M2.75 0A2.75 2.75 0 0 0 0 2.75v10.5A2.75 2.75 0 0 0 2.75 16h14.5A2.75 2.75 0 0 0 20 13.25V2.75A2.75 2.75 0 0 0 17.25 0zM1.5 2.75c0-.69.56-1.25 1.25-1.25h14.5c.69 0 1.25.56 1.25 1.25v10.5c0 .69-.56 1.25-1.25 1.25H2.75c-.69 0-1.25-.56-1.25-1.25z',
            clipRule: 'evenodd',
          })
        )
      ),
    components_CwZ8kStA_oe = (t) =>
      /* @__PURE__ */ e.createElement(
        'svg',
        { xmlns: 'http://www.w3.org/2000/svg', width: 16, height: 16, fill: 'none', ...t },
        /* @__PURE__ */ e.createElement('path', {
          fill: 'currentColor',
          fillRule: 'evenodd',
          d: 'M8 0a.75.75 0 0 1 .75.75v2.5a.75.75 0 0 1-1.5 0V.75A.75.75 0 0 1 8 0Z',
          clipRule: 'evenodd',
        }),
        /* @__PURE__ */ e.createElement('path', {
          fill: 'currentColor',
          fillRule: 'evenodd',
          d: 'M8 12a.75.75 0 0 1 .75.75v2.5a.75.75 0 0 1-1.5 0v-2.5A.75.75 0 0 1 8 12Z',
          clipRule: 'evenodd',
          opacity: 0.7,
        }),
        /* @__PURE__ */ e.createElement('path', {
          fill: 'currentColor',
          fillRule: 'evenodd',
          d: 'M12 1.072a.75.75 0 0 1 .274 1.024l-1.25 2.165a.75.75 0 0 1-1.299-.75l1.25-2.165A.75.75 0 0 1 12 1.072Z',
          clipRule: 'evenodd',
        }),
        /* @__PURE__ */ e.createElement('path', {
          fill: 'currentColor',
          fillRule: 'evenodd',
          d: 'M6 11.464a.75.75 0 0 1 .274 1.025l-1.25 2.165a.75.75 0 0 1-1.299-.75l1.25-2.165A.75.75 0 0 1 6 11.464Z',
          clipRule: 'evenodd',
          opacity: 0.6,
        }),
        /* @__PURE__ */ e.createElement('path', {
          fill: 'currentColor',
          fillRule: 'evenodd',
          d: 'M14.928 4a.75.75 0 0 1-.274 1.025l-2.165 1.25a.75.75 0 1 1-.75-1.3l2.165-1.25A.75.75 0 0 1 14.928 4Z',
          clipRule: 'evenodd',
        }),
        /* @__PURE__ */ e.createElement('path', {
          fill: 'currentColor',
          fillRule: 'evenodd',
          d: 'M4.536 10a.75.75 0 0 1-.275 1.024l-2.165 1.25a.75.75 0 0 1-.75-1.298l2.165-1.25A.75.75 0 0 1 4.536 10Z',
          clipRule: 'evenodd',
          opacity: 0.5,
        }),
        /* @__PURE__ */ e.createElement('path', {
          fill: 'currentColor',
          fillRule: 'evenodd',
          d: 'M16 8a.75.75 0 0 1-.75.75h-2.5a.75.75 0 0 1 0-1.5h2.5A.75.75 0 0 1 16 8Z',
          clipRule: 'evenodd',
        }),
        /* @__PURE__ */ e.createElement('path', {
          fill: 'currentColor',
          fillRule: 'evenodd',
          d: 'M4 8a.75.75 0 0 1-.75.75H.75a.75.75 0 0 1 0-1.5h2.5A.75.75 0 0 1 4 8Z',
          clipRule: 'evenodd',
          opacity: 0.4,
        }),
        /* @__PURE__ */ e.createElement('path', {
          fill: 'currentColor',
          fillRule: 'evenodd',
          d: 'M14.928 12a.75.75 0 0 1-1.024.274l-2.165-1.25a.75.75 0 0 1 .75-1.299l2.165 1.25A.75.75 0 0 1 14.928 12Z',
          clipRule: 'evenodd',
          opacity: 0.9,
        }),
        /* @__PURE__ */ e.createElement('path', {
          fill: 'currentColor',
          fillRule: 'evenodd',
          d: 'M4.536 6a.75.75 0 0 1-1.025.275l-2.165-1.25a.75.75 0 1 1 .75-1.3l2.165 1.25A.75.75 0 0 1 4.536 6Z',
          clipRule: 'evenodd',
          opacity: 0.3,
        }),
        /* @__PURE__ */ e.createElement('path', {
          fill: 'currentColor',
          fillRule: 'evenodd',
          d: 'M12 14.928a.75.75 0 0 1-1.024-.274l-1.25-2.165a.75.75 0 0 1 1.298-.75l1.25 2.165A.75.75 0 0 1 12 14.928Z',
          clipRule: 'evenodd',
          opacity: 0.8,
        }),
        /* @__PURE__ */ e.createElement('path', {
          fill: 'currentColor',
          fillRule: 'evenodd',
          d: 'M6 4.536a.75.75 0 0 1-1.024-.275l-1.25-2.165a.75.75 0 1 1 1.299-.75l1.25 2.165A.75.75 0 0 1 6 4.536Z',
          clipRule: 'evenodd',
          opacity: 0.2,
        })
      ),
    components_CwZ8kStA_Ct = (t) =>
      /* @__PURE__ */ e.createElement(
        'svg',
        { xmlns: 'http://www.w3.org/2000/svg', width: 16, height: 16, fill: 'none', ...t },
        /* @__PURE__ */ e.createElement(
          'g',
          {
            stroke: 'currentColor',
            strokeLinecap: 'round',
            strokeLinejoin: 'round',
            strokeWidth: 1.5,
          },
          /* @__PURE__ */ e.createElement('path', {
            d: 'M13.25 7H9m0 0V2.75M9 7l5.25-5.25M2.75 9H7m0 0v4.25M7 9l-5.25 5.25',
          })
        )
      ),
    components_CwZ8kStA_It =
      /* @__PURE__ */ /* unused pure expression or super */ null &&
      e.forwardRef(function ({ trackRef: n, ...a }, r) {
        const c = te(),
          { mergedProps: s, inFocus: o } = Ze({
            trackRef: n ?? c,
            props: a,
          });
        return /* @__PURE__ */ e.createElement(
          pe.Consumer,
          null,
          (l) =>
            l !== void 0 &&
            /* @__PURE__ */ e.createElement(
              'button',
              { ref: r, ...s },
              a.children
                ? a.children
                : o
                  ? /* @__PURE__ */ e.createElement(components_CwZ8kStA_Ct, null)
                  : /* @__PURE__ */ e.createElement(components_CwZ8kStA_Et, null)
            )
        );
      }),
    ua =
      /* @__PURE__ */ /* unused pure expression or super */ null &&
      e.forwardRef(function (
        {
          kind: n,
          initialSelection: a,
          onActiveDeviceChange: r,
          onDeviceListChange: c,
          onDeviceSelectError: s,
          exactMatch: o,
          track: l,
          requestPermissions: i,
          onError: u,
          ...d
        },
        g
      ) {
        const f = et(),
          E = e.useRef('default'),
          p = e.useCallback(
            (w) => {
              (f && f.emit(Je.MediaDevicesError, w), u == null || u(w));
            },
            [f, u]
          ),
          {
            devices: m,
            activeDeviceId: h,
            setActiveMediaDevice: y,
            className: C,
          } = He({
            kind: n,
            room: f,
            track: l,
            requestPermissions: i,
            onError: p,
          });
        (e.useEffect(() => {
          a !== void 0 && y(a);
        }, [y]),
          e.useEffect(() => {
            typeof c == 'function' && c(m);
          }, [c, m]),
          e.useEffect(() => {
            (h !== E.current && (r == null || r(h)), (E.current = h));
          }, [h]));
        const A = async (w) => {
            try {
              await y(w, { exact: o ?? !0 });
            } catch (M) {
              if (M instanceof Error) s == null || s(M);
              else throw M;
            }
          },
          N = e.useMemo(() => I(d, { className: C }, { className: 'lk-list' }), [C, d]),
          v = !!m.find((w) => w.label.toLowerCase().startsWith('default'));
        function R(w, M, P) {
          return w === M || (!v && P === 0 && M === 'default');
        }
        return /* @__PURE__ */ e.createElement(
          'ul',
          { ref: g, ...N },
          m.map((w, M) =>
            /* @__PURE__ */ e.createElement(
              'li',
              {
                key: w.deviceId,
                id: w.deviceId,
                'data-lk-active': R(w.deviceId, h, M),
                'aria-selected': R(w.deviceId, h, M),
                role: 'option',
              },
              /* @__PURE__ */ e.createElement(
                'button',
                { className: 'lk-button', onClick: () => A(w.deviceId) },
                w.label
              )
            )
          )
        );
      }),
    da = /* @__PURE__ */ react.forwardRef(function ({ label: n = 'Allow Audio', ...a }, r) {
      const c = zs(),
        { mergedProps: s } = hooks_4Z76Vz30_Qt({ room: c, props: a });
      return /* @__PURE__ */ react.createElement('button', { ref: r, ...s }, n);
    }),
    ma =
      /* @__PURE__ */ /* unused pure expression or super */ null &&
      e.forwardRef(function ({ label: n, ...a }, r) {
        const c = we(),
          { mergedProps: s, canPlayAudio: o } = ge({ room: c, props: a }),
          { mergedProps: l, canPlayVideo: i } = Be({ room: c, props: s }),
          { style: u, ...d } = l;
        return (
          (u.display = o && i ? 'none' : 'block'),
          /* @__PURE__ */ e.createElement(
            'button',
            { ref: r, style: u, ...d },
            n ?? `Start ${o ? 'Video' : 'Audio'}`
          )
        );
      });
  function components_CwZ8kStA_ye(t, n) {
    switch (t) {
      case S.Source.Microphone:
        return n
          ? /* @__PURE__ */ e.createElement(components_CwZ8kStA_kt, null)
          : /* @__PURE__ */ e.createElement(components_CwZ8kStA_wt, null);
      case S.Source.Camera:
        return n
          ? /* @__PURE__ */ e.createElement(components_CwZ8kStA_vt, null)
          : /* @__PURE__ */ e.createElement(components_CwZ8kStA_gt, null);
      case S.Source.ScreenShare:
        return n
          ? /* @__PURE__ */ e.createElement(components_CwZ8kStA_St, null)
          : /* @__PURE__ */ e.createElement(components_CwZ8kStA_Me, null);
      default:
        return;
    }
  }
  function components_CwZ8kStA_xt(t) {
    switch (t) {
      case Q.Excellent:
        return /* @__PURE__ */ e.createElement(components_CwZ8kStA_Rt, null);
      case Q.Good:
        return /* @__PURE__ */ e.createElement(components_CwZ8kStA_Mt, null);
      case Q.Poor:
        return /* @__PURE__ */ e.createElement(components_CwZ8kStA_yt, null);
      default:
        return /* @__PURE__ */ e.createElement(components_CwZ8kStA_bt, null);
    }
  }
  const fa =
      /* @__PURE__ */ /* unused pure expression or super */ null &&
      e.forwardRef(function ({ showIcon: n, ...a }, r) {
        const { buttonProps: c, enabled: s } = je(a),
          [o, l] = e.useState(!1);
        return (
          e.useEffect(() => {
            l(!0);
          }, []),
          o &&
            /* @__PURE__ */ e.createElement(
              'button',
              { ref: r, ...c },
              (n ?? !0) && components_CwZ8kStA_ye(a.source, s),
              a.children
            )
        );
      }),
    components_CwZ8kStA_be =
      /* @__PURE__ */ /* unused pure expression or super */ null &&
      e.forwardRef(function (n, a) {
        const { className: r, quality: c } = _e(n),
          s = e.useMemo(() => ({ ...I(n, { className: r }), 'data-lk-quality': c }), [c, n, r]);
        return /* @__PURE__ */ e.createElement(
          'div',
          { ref: a, ...s },
          n.children ?? components_CwZ8kStA_xt(c)
        );
      }),
    components_CwZ8kStA_K =
      /* @__PURE__ */ /* unused pure expression or super */ null &&
      e.forwardRef(function ({ participant: n, ...a }, r) {
        const c = tt(n),
          { className: s, infoObserver: o } = e.useMemo(() => at(c), [c]),
          { identity: l, name: i } = Oe(o, {
            name: c.name,
            identity: c.identity,
            metadata: c.metadata,
          }),
          u = e.useMemo(() => I(a, { className: s, 'data-lk-participant-name': i }), [a, s, i]);
        return /* @__PURE__ */ e.createElement(
          'span',
          { ref: r, ...u },
          i !== '' ? i : l,
          a.children
        );
      }),
    Se =
      /* @__PURE__ */ /* unused pure expression or super */ null &&
      e.forwardRef(function ({ trackRef: n, show: a = 'always', ...r }, c) {
        const { className: s, isMuted: o } = We(n),
          l = a === 'always' || (a === 'muted' && o) || (a === 'unmuted' && !o),
          i = e.useMemo(
            () =>
              I(r, {
                className: s,
              }),
            [s, r]
          );
        return l
          ? /* @__PURE__ */ e.createElement(
              'div',
              { ref: c, ...i, 'data-lk-muted': o },
              r.children ?? components_CwZ8kStA_ye(n.source, !o)
            )
          : null;
      }),
    components_CwZ8kStA_Pt = (t) =>
      /* @__PURE__ */ e.createElement(
        'svg',
        {
          width: 320,
          height: 320,
          viewBox: '0 0 320 320',
          preserveAspectRatio: 'xMidYMid meet',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
          ...t,
        },
        /* @__PURE__ */ e.createElement('path', {
          d: 'M160 180C204.182 180 240 144.183 240 100C240 55.8172 204.182 20 160 20C115.817 20 79.9997 55.8172 79.9997 100C79.9997 144.183 115.817 180 160 180Z',
          fill: 'white',
          fillOpacity: 0.25,
        }),
        /* @__PURE__ */ e.createElement('path', {
          d: 'M97.6542 194.614C103.267 191.818 109.841 192.481 115.519 195.141C129.025 201.466 144.1 205 159.999 205C175.899 205 190.973 201.466 204.48 195.141C210.158 192.481 216.732 191.818 222.345 194.614C262.703 214.719 291.985 253.736 298.591 300.062C300.15 310.997 291.045 320 280 320H39.9997C28.954 320 19.8495 310.997 21.4087 300.062C28.014 253.736 57.2966 214.72 97.6542 194.614Z',
          fill: 'white',
          fillOpacity: 0.25,
        })
      );
  function components_CwZ8kStA_Ce(t, n = {}) {
    const [a, r] = react.useState(Bt(t)),
      [c, s] = react.useState(a == null ? void 0 : a.isMuted),
      [o, l] = react.useState(a == null ? void 0 : a.isSubscribed),
      [i, u] = react.useState(a == null ? void 0 : a.track),
      [d, g] = react.useState('landscape'),
      f = react.useRef(),
      { className: E, trackObserver: p } = react.useMemo(
        () => ts(t),
        [t.participant.sid ?? t.participant.identity, t.source, B(t) && t.publication.trackSid]
      );
    return (
      react.useEffect(() => {
        const m = p.subscribe((h) => {
          (contexts_BGRNBsB8_L.debug('update track', h),
            r(h),
            s(h == null ? void 0 : h.isMuted),
            l(h == null ? void 0 : h.isSubscribed),
            u(h == null ? void 0 : h.track));
        });
        return () => (m == null ? void 0 : m.unsubscribe());
      }, [p]),
      react.useEffect(() => {
        var m, h;
        return (
          i &&
            (f.current && i.detach(f.current),
            (m = n.element) != null &&
              m.current &&
              !(t.participant.isLocal && (i == null ? void 0 : i.kind) === 'audio') &&
              i.attach(n.element.current)),
          (f.current = (h = n.element) == null ? void 0 : h.current),
          () => {
            f.current && (i == null || i.detach(f.current));
          }
        );
      }, [i, n.element]),
      react.useEffect(() => {
        var m, h;
        if (
          typeof ((m = a == null ? void 0 : a.dimensions) == null ? void 0 : m.width) == 'number' &&
          typeof ((h = a == null ? void 0 : a.dimensions) == null ? void 0 : h.height) == 'number'
        ) {
          const y = a.dimensions.width > a.dimensions.height ? 'landscape' : 'portrait';
          g(y);
        }
      }, [a]),
      {
        publication: a,
        isMuted: c,
        isSubscribed: o,
        track: i,
        elementProps: G(n.props, {
          className: E,
          'data-lk-local-participant': t.participant.isLocal,
          'data-lk-source': a == null ? void 0 : a.source,
          ...((a == null ? void 0 : a.kind) === 'video' && { 'data-lk-orientation': d }),
        }),
      }
    );
  }
  var components_CwZ8kStA_Y, components_CwZ8kStA_ue;
  function components_CwZ8kStA_Tt() {
    if (components_CwZ8kStA_ue) return components_CwZ8kStA_Y;
    components_CwZ8kStA_ue = 1;
    var t = 'Expected a function',
      n = NaN,
      a = '[object Symbol]',
      r = /^\s+|\s+$/g,
      c = /^[-+]0x[0-9a-f]+$/i,
      s = /^0b[01]+$/i,
      o = /^0o[0-7]+$/i,
      l = parseInt,
      i = typeof $o == 'object' && $o && $o.Object === Object && $o,
      u = typeof self == 'object' && self && self.Object === Object && self,
      d = i || u || Function('return this')(),
      g = Object.prototype,
      f = g.toString,
      E = Math.max,
      p = Math.min,
      m = function () {
        return d.Date.now();
      };
    function h(v, R, w) {
      var M,
        P,
        O,
        L,
        b,
        T,
        F = 0,
        re = !1,
        Z = !1,
        D = !0;
      if (typeof v != 'function') throw new TypeError(t);
      ((R = N(R) || 0),
        y(w) &&
          ((re = !!w.leading),
          (Z = 'maxWait' in w),
          (O = Z ? E(N(w.maxWait) || 0, R) : O),
          (D = 'trailing' in w ? !!w.trailing : D)));
      function U(k) {
        var x = M,
          H = P;
        return ((M = P = void 0), (F = k), (L = v.apply(H, x)), L);
      }
      function Pe(k) {
        return ((F = k), (b = setTimeout(W, R)), re ? U(k) : L);
      }
      function Te(k) {
        var x = k - T,
          H = k - F,
          se = R - x;
        return Z ? p(se, O - H) : se;
      }
      function ce(k) {
        var x = k - T,
          H = k - F;
        return T === void 0 || x >= R || x < 0 || (Z && H >= O);
      }
      function W() {
        var k = m();
        if (ce(k)) return le(k);
        b = setTimeout(W, Te(k));
      }
      function le(k) {
        return ((b = void 0), D && M ? U(k) : ((M = P = void 0), L));
      }
      function Ae() {
        (b !== void 0 && clearTimeout(b), (F = 0), (M = T = P = b = void 0));
      }
      function Ne() {
        return b === void 0 ? L : le(m());
      }
      function G() {
        var k = m(),
          x = ce(k);
        if (((M = arguments), (P = this), (T = k), x)) {
          if (b === void 0) return Pe(T);
          if (Z) return ((b = setTimeout(W, R)), U(T));
        }
        return (b === void 0 && (b = setTimeout(W, R)), L);
      }
      return ((G.cancel = Ae), (G.flush = Ne), G);
    }
    function y(v) {
      var R = typeof v;
      return !!v && (R == 'object' || R == 'function');
    }
    function C(v) {
      return !!v && typeof v == 'object';
    }
    function A(v) {
      return typeof v == 'symbol' || (C(v) && f.call(v) == a);
    }
    function N(v) {
      if (typeof v == 'number') return v;
      if (A(v)) return n;
      if (y(v)) {
        var R = typeof v.valueOf == 'function' ? v.valueOf() : v;
        v = y(R) ? R + '' : R;
      }
      if (typeof v != 'string') return v === 0 ? v : +v;
      v = v.replace(r, '');
      var w = s.test(v);
      return w || o.test(v) ? l(v.slice(2), w ? 2 : 8) : c.test(v) ? n : +v;
    }
    return ((components_CwZ8kStA_Y = h), components_CwZ8kStA_Y);
  }
  var components_CwZ8kStA_At = components_CwZ8kStA_Tt();
  const components_CwZ8kStA_de = /* @__PURE__ */ Or(components_CwZ8kStA_At);
  function components_CwZ8kStA_Nt(t) {
    const n = (0, react.useRef)(t);
    ((n.current = t),
      (0, react.useEffect)(
        () => () => {
          n.current();
        },
        []
      ));
  }
  function components_CwZ8kStA_Lt(t, n = 500, a) {
    const r = (0, react.useRef)();
    components_CwZ8kStA_Nt(() => {
      r.current && r.current.cancel();
    });
    const c = (0, react.useMemo)(() => {
      const s = components_CwZ8kStA_de(t, n, a),
        o = (...l) => s(...l);
      return (
        (o.cancel = () => {
          s.cancel();
        }),
        (o.isPending = () => !!r.current),
        (o.flush = () => s.flush()),
        o
      );
    }, [t, n, a]);
    return (
      (0, react.useEffect)(() => {
        r.current = components_CwZ8kStA_de(t, n, a);
      }, [t, n, a]),
      c
    );
  }
  function components_CwZ8kStA_zt(t, n, a) {
    const r = (u, d) => u === d,
      c = t instanceof Function ? t() : t,
      [s, o] = (0, react.useState)(c),
      l = (0, react.useRef)(c),
      i = components_CwZ8kStA_Lt(o, n, a);
    return (r(l.current, c) || (i(c), (l.current = c)), [s, i]);
  }
  function components_CwZ8kStA_Vt({
    threshold: t = 0,
    root: n = null,
    rootMargin: a = '0%',
    freezeOnceVisible: r = !1,
    initialIsIntersecting: c = !1,
    onChange: s,
  } = {}) {
    var o;
    const [l, i] = (0, react.useState)(null),
      [u, d] = (0, react.useState)(() => ({
        isIntersecting: c,
        entry: void 0,
      })),
      g = (0, react.useRef)();
    g.current = s;
    const f = ((o = u.entry) == null ? void 0 : o.isIntersecting) && r;
    (0, react.useEffect)(() => {
      if (!l || !('IntersectionObserver' in window) || f) return;
      const m = new IntersectionObserver(
        (h) => {
          const y = Array.isArray(m.thresholds) ? m.thresholds : [m.thresholds];
          h.forEach((C) => {
            const A = C.isIntersecting && y.some((N) => C.intersectionRatio >= N);
            (d({ isIntersecting: A, entry: C }), g.current && g.current(A, C));
          });
        },
        { threshold: t, root: n, rootMargin: a }
      );
      return (
        m.observe(l),
        () => {
          m.disconnect();
        }
      );
    }, [
      l,
      // eslint-disable-next-line react-hooks/exhaustive-deps
      JSON.stringify(t),
      n,
      a,
      f,
      r,
    ]);
    const E = (0, react.useRef)(null);
    (0, react.useEffect)(() => {
      var m;
      !l &&
        (m = u.entry) != null &&
        m.target &&
        !r &&
        !f &&
        E.current !== u.entry.target &&
        ((E.current = u.entry.target), d({ isIntersecting: c, entry: void 0 }));
    }, [l, u.entry, r, f, c]);
    const p = [i, !!u.isIntersecting, u.entry];
    return ((p.ref = p[0]), (p.isIntersecting = p[1]), (p.entry = p[2]), p);
  }
  const components_CwZ8kStA_Ft = /* @__PURE__ */ react.forwardRef(function (
      {
        onTrackClick: n,
        onClick: a,
        onSubscriptionStatusChanged: r,
        trackRef: c,
        manageSubscription: s,
        ...o
      },
      l
    ) {
      const i = Bs(c),
        u = react.useRef(null);
      react.useImperativeHandle(l, () => u.current);
      const d = components_CwZ8kStA_Vt({ root: u.current }),
        [g] = components_CwZ8kStA_zt(d, 3e3);
      (react.useEffect(() => {
        s &&
          i.publication instanceof RemoteTrackPublication &&
          (g == null ? void 0 : g.isIntersecting) === !1 &&
          (d == null ? void 0 : d.isIntersecting) === !1 &&
          i.publication.setSubscribed(!1);
      }, [g, i, s]),
        react.useEffect(() => {
          s &&
            i.publication instanceof RemoteTrackPublication &&
            (d == null ? void 0 : d.isIntersecting) === !0 &&
            i.publication.setSubscribed(!0);
        }, [d, i, s]));
      const {
        elementProps: f,
        publication: E,
        isSubscribed: p,
      } = components_CwZ8kStA_Ce(i, {
        element: u,
        props: o,
      });
      react.useEffect(() => {
        r == null || r(!!p);
      }, [p, r]);
      const m = (h) => {
        (a == null || a(h),
          n == null || n({ participant: i == null ? void 0 : i.participant, track: E }));
      };
      return /* @__PURE__ */ react.createElement('video', { ref: u, ...f, muted: !0, onClick: m });
    }),
    components_CwZ8kStA_ne = /* @__PURE__ */ react.forwardRef(function (
      { trackRef: n, onSubscriptionStatusChanged: a, volume: r, ...c },
      s
    ) {
      const o = Bs(n),
        l = react.useRef(null);
      react.useImperativeHandle(s, () => l.current);
      const {
        elementProps: i,
        isSubscribed: u,
        track: d,
        publication: g,
      } = components_CwZ8kStA_Ce(o, {
        element: l,
        props: c,
      });
      return (
        react.useEffect(() => {
          a == null || a(!!u);
        }, [u, a]),
        react.useEffect(() => {
          d === void 0 ||
            r === void 0 ||
            (d instanceof RemoteAudioTrack
              ? d.setVolume(r)
              : contexts_BGRNBsB8_L.warn('Volume can only be set on remote audio tracks.'));
        }, [r, d]),
        react.useEffect(() => {
          g === void 0 ||
            c.muted === void 0 ||
            (g instanceof RemoteTrackPublication
              ? g.setEnabled(!c.muted)
              : contexts_BGRNBsB8_L.warn('Can only call setEnabled on remote track publications.'));
        }, [c.muted, g, d]),
        /* @__PURE__ */ react.createElement('audio', { ref: l, ...i })
      );
    });
  function components_CwZ8kStA_Zt(t) {
    const n = !!lt();
    return t.participant && !n
      ? /* @__PURE__ */ e.createElement(ke.Provider, { value: t.participant }, t.children)
      : /* @__PURE__ */ e.createElement(e.Fragment, null, t.children);
  }
  function components_CwZ8kStA_Ht(t) {
    const n = !!te();
    return t.trackRef && !n
      ? /* @__PURE__ */ e.createElement(ae.Provider, { value: t.trackRef }, t.children)
      : /* @__PURE__ */ e.createElement(e.Fragment, null, t.children);
  }
  const components_CwZ8kStA_Bt =
    /* @__PURE__ */ /* unused pure expression or super */ null &&
    e.forwardRef(function (
      { trackRef: n, children: a, onParticipantClick: r, disableSpeakingIndicator: c, ...s },
      o
    ) {
      var E, p;
      const l = _(n),
        { elementProps: i } = ve({
          htmlProps: s,
          disableSpeakingIndicator: c,
          onParticipantClick: r,
          trackRef: l,
        }),
        u = qe(l.participant),
        d = st(),
        g = (E = it()) == null ? void 0 : E.autoSubscription,
        f = e.useCallback(
          (m) => {
            l.source &&
              !m &&
              d &&
              d.pin.dispatch &&
              ot(l, d.pin.state) &&
              d.pin.dispatch({ msg: 'clear_pin' });
          },
          [l, d]
        );
      return /* @__PURE__ */ e.createElement(
        'div',
        { ref: o, style: { position: 'relative' }, ...i },
        /* @__PURE__ */ e.createElement(
          components_CwZ8kStA_Ht,
          { trackRef: l },
          /* @__PURE__ */ e.createElement(
            components_CwZ8kStA_Zt,
            { participant: l.participant },
            a ??
              /* @__PURE__ */ e.createElement(
                e.Fragment,
                null,
                $(l) &&
                  (((p = l.publication) == null ? void 0 : p.kind) === 'video' ||
                    l.source === S.Source.Camera ||
                    l.source === S.Source.ScreenShare)
                  ? /* @__PURE__ */ e.createElement(components_CwZ8kStA_Ft, {
                      trackRef: l,
                      onSubscriptionStatusChanged: f,
                      manageSubscription: g,
                    })
                  : $(l) &&
                      /* @__PURE__ */ e.createElement(components_CwZ8kStA_ne, {
                        trackRef: l,
                        onSubscriptionStatusChanged: f,
                      }),
                /* @__PURE__ */ e.createElement(
                  'div',
                  { className: 'lk-participant-placeholder' },
                  /* @__PURE__ */ e.createElement(components_CwZ8kStA_Pt, null)
                ),
                /* @__PURE__ */ e.createElement(
                  'div',
                  { className: 'lk-participant-metadata' },
                  /* @__PURE__ */ e.createElement(
                    'div',
                    { className: 'lk-participant-metadata-item' },
                    l.source === S.Source.Camera
                      ? /* @__PURE__ */ e.createElement(
                          e.Fragment,
                          null,
                          u &&
                            /* @__PURE__ */ e.createElement(components_CwZ8kStA_pt, {
                              style: { marginRight: '0.25rem' },
                            }),
                          /* @__PURE__ */ e.createElement(Se, {
                            trackRef: {
                              participant: l.participant,
                              source: S.Source.Microphone,
                            },
                            show: 'muted',
                          }),
                          /* @__PURE__ */ e.createElement(components_CwZ8kStA_K, null)
                        )
                      : /* @__PURE__ */ e.createElement(
                          e.Fragment,
                          null,
                          /* @__PURE__ */ e.createElement(components_CwZ8kStA_Me, {
                            style: { marginRight: '0.25rem' },
                          }),
                          /* @__PURE__ */ e.createElement(components_CwZ8kStA_K, null, "'s screen")
                        )
                  ),
                  /* @__PURE__ */ e.createElement(components_CwZ8kStA_be, {
                    className: 'lk-participant-metadata-item',
                  })
                )
              ),
            /* @__PURE__ */ e.createElement(components_CwZ8kStA_It, { trackRef: l })
          )
        )
      );
    });
  function ha(t) {
    const n = I(t, { className: 'lk-focus-layout' });
    return /* @__PURE__ */ e.createElement('div', { ...n }, t.children);
  }
  function ga({ trackRef: t, ...n }) {
    return /* @__PURE__ */ e.createElement(components_CwZ8kStA_Bt, { trackRef: t, ...n });
  }
  function components_CwZ8kStA_Ie({ tracks: t, ...n }) {
    return /* @__PURE__ */ e.createElement(
      e.Fragment,
      null,
      t.map((a) =>
        /* @__PURE__ */ e.createElement(
          ae.Provider,
          {
            value: a,
            key: Re(a),
          },
          ee(n.children)
        )
      )
    );
  }
  function components_CwZ8kStA_jt({
    totalPageCount: t,
    nextPage: n,
    prevPage: a,
    currentPage: r,
    pagesContainer: c,
  }) {
    const [s, o] = e.useState(!1);
    return (
      e.useEffect(() => {
        let l;
        return (
          c && (l = ut(c.current, 2e3).subscribe(o)),
          () => {
            l && l.unsubscribe();
          }
        );
      }, [c]),
      /* @__PURE__ */ e.createElement(
        'div',
        { className: 'lk-pagination-control', 'data-lk-user-interaction': s },
        /* @__PURE__ */ e.createElement(
          'button',
          { className: 'lk-button', onClick: a },
          /* @__PURE__ */ e.createElement(components_CwZ8kStA_ie, null)
        ),
        /* @__PURE__ */ e.createElement(
          'span',
          { className: 'lk-pagination-count' },
          `${r} of ${t}`
        ),
        /* @__PURE__ */ e.createElement(
          'button',
          { className: 'lk-button', onClick: n },
          /* @__PURE__ */ e.createElement(components_CwZ8kStA_ie, null)
        )
      )
    );
  }
  const components_CwZ8kStA_t =
    /* @__PURE__ */ /* unused pure expression or super */ null &&
    e.forwardRef(function ({ totalPageCount: n, currentPage: a }, r) {
      const c = new Array(n)
        .fill('')
        .map((s, o) =>
          o + 1 === a
            ? /* @__PURE__ */ e.createElement('span', { 'data-lk-active': !0, key: o })
            : /* @__PURE__ */ e.createElement('span', { key: o })
        );
      return /* @__PURE__ */ e.createElement(
        'div',
        { ref: r, className: 'lk-pagination-indicator' },
        c
      );
    });
  function va({ tracks: t, ...n }) {
    const a = e.createRef(),
      r = e.useMemo(() => I(n, { className: 'lk-grid-layout' }), [n]),
      { layout: c } = $e(a, t.length),
      s = De(c.maxTiles, t);
    return (
      Ue(a, {
        onLeftSwipe: s.nextPage,
        onRightSwipe: s.prevPage,
      }),
      /* @__PURE__ */ e.createElement(
        'div',
        { ref: a, 'data-lk-pagination': s.totalPageCount > 1, ...r },
        /* @__PURE__ */ e.createElement(components_CwZ8kStA_Ie, { tracks: s.tracks }, n.children),
        t.length > c.maxTiles &&
          /* @__PURE__ */ e.createElement(
            e.Fragment,
            null,
            /* @__PURE__ */ e.createElement(components_CwZ8kStA_t, {
              totalPageCount: s.totalPageCount,
              currentPage: s.currentPage,
            }),
            /* @__PURE__ */ e.createElement(components_CwZ8kStA_jt, { pagesContainer: a, ...s })
          )
      )
    );
  }
  const components_CwZ8kStA_Ot = 130,
    components_CwZ8kStA_Wt = 140,
    components_CwZ8kStA_me = 1,
    components_CwZ8kStA_xe = 16 / 10,
    components_CwZ8kStA_qt = (1 - components_CwZ8kStA_xe) * -1;
  function Ea({ tracks: t, orientation: n, ...a }) {
    const r = e.useRef(null),
      [c, s] = e.useState(0),
      { width: o, height: l } = Ge(r),
      i = n || (l >= o ? 'vertical' : 'horizontal'),
      u =
        i === 'vertical'
          ? Math.max(o * components_CwZ8kStA_qt, components_CwZ8kStA_Ot)
          : Math.max(l * components_CwZ8kStA_xe, components_CwZ8kStA_Wt),
      d = dt(),
      g = Math.max(i === 'vertical' ? (l - d) / u : (o - d) / u, components_CwZ8kStA_me);
    let f = Math.round(g);
    Math.abs(g - c) < 0.5 ? (f = Math.round(c)) : c !== g && s(g);
    const E = Qe(t, f);
    return (
      e.useLayoutEffect(() => {
        r.current &&
          ((r.current.dataset.lkOrientation = i),
          r.current.style.setProperty('--lk-max-visible-tiles', f.toString()));
      }, [f, i]),
      /* @__PURE__ */ e.createElement(
        'aside',
        { key: i, className: 'lk-carousel', ref: r, ...a },
        /* @__PURE__ */ e.createElement(components_CwZ8kStA_Ie, { tracks: E }, a.children)
      )
    );
  }
  function pa({ value: t, onPinChange: n, onWidgetChange: a, children: r }) {
    const c = mt(t);
    return (
      e.useEffect(() => {
        (j.debug('PinState Updated', { state: c.pin.state }), n && c.pin.state && n(c.pin.state));
      }, [c.pin.state, n]),
      e.useEffect(() => {
        (j.debug('Widget Updated', { widgetState: c.widget.state }),
          a && c.widget.state && a(c.widget.state));
      }, [a, c.widget.state]),
      /* @__PURE__ */ e.createElement(pe.Provider, { value: c }, r)
    );
  }
  const wa =
    /* @__PURE__ */ /* unused pure expression or super */ null &&
    e.forwardRef(function ({ trackRef: n, ...a }, r) {
      const d = _(n),
        g = Ee(d, { bands: 7, loPass: 300 });
      return /* @__PURE__ */ e.createElement(
        'svg',
        {
          ref: r,
          width: '100%',
          height: '100%',
          viewBox: '0 0 200 90',
          ...a,
          className: 'lk-audio-visualizer',
        },
        /* @__PURE__ */ e.createElement('rect', { x: '0', y: '0', width: '100%', height: '100%' }),
        /* @__PURE__ */ e.createElement(
          'g',
          {
            style: {
              transform: `translate(${130 / 2}px, 0)`,
            },
          },
          g.map((f, E) =>
            /* @__PURE__ */ e.createElement('rect', {
              key: E,
              x: E * 10,
              y: 90 / 2 - (f * 50) / 2,
              width: 6,
              height: f * 50,
            })
          )
        )
      );
    });
  function ka({ participants: t, ...n }) {
    return /* @__PURE__ */ e.createElement(
      e.Fragment,
      null,
      t.map((a) =>
        /* @__PURE__ */ e.createElement(ke.Provider, { value: a, key: a.identity }, ee(n.children))
      )
    );
  }
  function Ra({ volume: t, muted: n }) {
    const a = hooks_4Z76Vz30_tn(
      [Track.Source.Microphone, Track.Source.ScreenShareAudio, Track.Source.Unknown],
      {
        updateOnlyOn: [],
        onlySubscribed: !0,
      }
    ).filter((r) => !r.participant.isLocal && r.publication.kind === Track.Kind.Audio);
    return /* @__PURE__ */ react.createElement(
      'div',
      { style: { display: 'none' } },
      a.map((r) =>
        /* @__PURE__ */ react.createElement(components_CwZ8kStA_ne, {
          key: contexts_BGRNBsB8_N(r),
          trackRef: r,
          volume: t,
          muted: n,
        })
      )
    );
  }
  const Ma =
    /* @__PURE__ */ /* unused pure expression or super */ null &&
    e.forwardRef(function ({ childrenPosition: n = 'before', children: a, ...r }, c) {
      const { name: s } = Ye();
      return /* @__PURE__ */ e.createElement(
        'span',
        { ref: c, ...r },
        n === 'before' && a,
        s,
        n === 'after' && a
      );
    });
  function components_CwZ8kStA_$t(t) {
    const n = e.useMemo(() => I(t, { className: 'lk-toast' }), [t]);
    return /* @__PURE__ */ e.createElement('div', { ...n }, t.children);
  }
  const components_CwZ8kStA_Dt = (t) => {
      const n = [];
      for (let a = 0; a < t; a++) n.push([a, t - 1 - a]);
      return n;
    },
    components_CwZ8kStA_fe = (t) => [[Math.floor(t / 2)], [-1]],
    components_CwZ8kStA_Ut = (t, n, a) => {
      const [r, c] = (0, react.useState)(0),
        [s, o] = (0, react.useState)([[]]);
      (0, react.useEffect)(() => {
        if (t === 'thinking') o(components_CwZ8kStA_fe(n));
        else if (t === 'connecting' || t === 'initializing') {
          const i = [...components_CwZ8kStA_Dt(n)];
          o(i);
        } else
          o(
            t === 'listening'
              ? components_CwZ8kStA_fe(n)
              : t === void 0 || t === 'speaking'
                ? [new Array(n).fill(0).map((i, u) => u)]
                : [[]]
          );
        c(0);
      }, [t, n]);
      const l = (0, react.useRef)(null);
      return (
        (0, react.useEffect)(() => {
          let i = performance.now();
          const u = (d) => {
            (d - i >= a && (c((f) => f + 1), (i = d)), (l.current = requestAnimationFrame(u)));
          };
          return (
            (l.current = requestAnimationFrame(u)),
            () => {
              l.current !== null && cancelAnimationFrame(l.current);
            }
          );
        }, [a, n, t, s.length]),
        s[r % s.length]
      );
    },
    components_CwZ8kStA_Gt = /* @__PURE__ */ new Map([
      ['connecting', 2e3],
      ['initializing', 2e3],
      ['listening', 500],
      ['thinking', 150],
    ]),
    components_CwZ8kStA_Qt = (t, n) => {
      if (t === void 0) return 1e3;
      let a = components_CwZ8kStA_Gt.get(t);
      if (a)
        switch (t) {
          case 'connecting':
            a /= n;
            break;
        }
      return a;
    },
    components_CwZ8kStA_Xt = /* @__PURE__ */ react.forwardRef(function (
      { state: n, options: a, barCount: r = 15, trackRef: c, children: s, ...o },
      l
    ) {
      const i = G(o, { className: 'lk-audio-bar-visualizer' });
      let u = Un();
      c && (u = c);
      const d = hooks_4Z76Vz30_on(u, {
          bands: r,
          loPass: 100,
          hiPass: 200,
        }),
        g = (a == null ? void 0 : a.minHeight) ?? 20,
        f = (a == null ? void 0 : a.maxHeight) ?? 100,
        E = components_CwZ8kStA_Ut(n, r, components_CwZ8kStA_Qt(n, r) ?? 100);
      return /* @__PURE__ */ react.createElement(
        'div',
        { ref: l, ...i, 'data-lk-va-state': n },
        d.map((p, m) =>
          s
            ? room_BRK61eNB_H(s, {
                'data-lk-highlighted': E.includes(m),
                'data-lk-bar-index': m,
                className: 'lk-audio-bar',
                style: { height: `${Math.min(f, Math.max(g, p * 100 + 5))}%` },
              })
            : /* @__PURE__ */ react.createElement('span', {
                key: m,
                'data-lk-highlighted': E.includes(m),
                'data-lk-bar-index': m,
                className: `lk-audio-bar ${E.includes(m) && 'lk-highlighted'}`,
                style: {
                  // TODO transform animations would be more performant, however the border-radius gets distorted when using scale transforms. a 9-slice approach (or 3 in this case) could work
                  // transform: `scale(1, ${Math.min(maxHeight, Math.max(minHeight, volume))}`,
                  height: `${Math.min(f, Math.max(g, p * 100 + 5))}%`,
                },
              })
        )
      );
    }),
    ya =
      /* @__PURE__ */ /* unused pure expression or super */ null &&
      e.forwardRef(function (
        { children: n, disableSpeakingIndicator: a, onParticipantClick: r, trackRef: c, ...s },
        o
      ) {
        const l = _(c),
          { elementProps: i } = ve({
            trackRef: l,
            htmlProps: s,
            disableSpeakingIndicator: a,
            onParticipantClick: r,
          });
        return /* @__PURE__ */ e.createElement(
          'div',
          { ref: o, style: { position: 'relative', minHeight: '160px' }, ...i },
          /* @__PURE__ */ e.createElement(
            ae.Provider,
            { value: l },
            n ??
              /* @__PURE__ */ e.createElement(
                e.Fragment,
                null,
                $(l) && /* @__PURE__ */ e.createElement(components_CwZ8kStA_ne, { trackRef: l }),
                /* @__PURE__ */ e.createElement(components_CwZ8kStA_Xt, {
                  barCount: 7,
                  options: { minHeight: 8 },
                }),
                /* @__PURE__ */ e.createElement(
                  'div',
                  { className: 'lk-participant-metadata' },
                  /* @__PURE__ */ e.createElement(
                    'div',
                    { className: 'lk-participant-metadata-item' },
                    /* @__PURE__ */ e.createElement(Se, { trackRef: l }),
                    /* @__PURE__ */ e.createElement(components_CwZ8kStA_K, null)
                  ),
                  /* @__PURE__ */ e.createElement(components_CwZ8kStA_be, {
                    className: 'lk-participant-metadata-item',
                  })
                )
              )
          )
        );
      });
  function ba(t) {
    const [n, a] = e.useState(void 0),
      r = he(t.room);
    return (
      e.useEffect(() => {
        switch (r) {
          case X.Reconnecting:
            a(
              /* @__PURE__ */ e.createElement(
                e.Fragment,
                null,
                /* @__PURE__ */ e.createElement(components_CwZ8kStA_oe, {
                  className: 'lk-spinner',
                }),
                ' Reconnecting'
              )
            );
            break;
          case X.Connecting:
            a(
              /* @__PURE__ */ e.createElement(
                e.Fragment,
                null,
                /* @__PURE__ */ e.createElement(components_CwZ8kStA_oe, {
                  className: 'lk-spinner',
                }),
                ' Connecting'
              )
            );
            break;
          case X.Disconnected:
            a(/* @__PURE__ */ e.createElement(e.Fragment, null, 'Disconnected'));
            break;
          default:
            a(void 0);
            break;
        }
      }, [r]),
      n
        ? /* @__PURE__ */ e.createElement(
            components_CwZ8kStA_$t,
            { className: 'lk-toast-connection-state' },
            n
          )
        : /* @__PURE__ */ e.createElement(e.Fragment, null)
    );
  }
  const Sa =
    /* @__PURE__ */ /* unused pure expression or super */ null &&
    e.forwardRef(function (
      { entry: n, hideName: a = !1, hideTimestamp: r = !1, messageFormatter: c, ...s },
      o
    ) {
      var f, E, p, m;
      const l = e.useMemo(() => (c ? c(n.message) : n.message), [n.message, c]),
        i = !!n.editTimestamp,
        u = new Date(n.timestamp),
        d = typeof navigator < 'u' ? navigator.language : 'en-US',
        g =
          ((f = n.from) == null ? void 0 : f.name) ?? ((E = n.from) == null ? void 0 : E.identity);
      return /* @__PURE__ */ e.createElement(
        'li',
        {
          ref: o,
          className: 'lk-chat-entry',
          title: u.toLocaleTimeString(d, { timeStyle: 'full' }),
          'data-lk-message-origin': (p = n.from) != null && p.isLocal ? 'local' : 'remote',
          ...s,
        },
        (!r || !a || i) &&
          /* @__PURE__ */ e.createElement(
            'span',
            { className: 'lk-meta-data' },
            !a &&
              /* @__PURE__ */ e.createElement('strong', { className: 'lk-participant-name' }, g),
            (!r || i) &&
              /* @__PURE__ */ e.createElement(
                'span',
                { className: 'lk-timestamp' },
                i && 'edited ',
                u.toLocaleTimeString(d, { timeStyle: 'short' })
              )
          ),
        /* @__PURE__ */ e.createElement('span', { className: 'lk-message-body' }, l),
        /* @__PURE__ */ e.createElement(
          'span',
          { className: 'lk-message-attachements' },
          (m = n.attachedFiles) == null
            ? void 0
            : m.map(
                (h) =>
                  h.type.startsWith('image/') &&
                  /* @__PURE__ */ e.createElement('img', {
                    style: { maxWidth: '300px', maxHeight: '300px' },
                    key: h.name,
                    src: URL.createObjectURL(h),
                    alt: h.name,
                  })
              )
        )
      );
    });
  function Ca(t) {
    return ft(t, ht()).map((n, a) => {
      if (typeof n == 'string') return n;
      {
        const r = n.content.toString(),
          c = n.type === 'url' ? (/^http(s?):\/\//.test(r) ? r : `https://${r}`) : `mailto:${r}`;
        return /* @__PURE__ */ e.createElement(
          'a',
          { className: 'lk-chat-link', key: a, href: c, target: '_blank', rel: 'noreferrer' },
          r
        );
      }
    });
  } // ./node_modules/.pnpm/clsx@2.1.1/node_modules/clsx/dist/clsx.mjs

  //# sourceMappingURL=components-CwZ8kStA.mjs.map

  function clsx_r(e) {
    var t,
      f,
      n = '';
    if ('string' == typeof e || 'number' == typeof e) n += e;
    else if ('object' == typeof e)
      if (Array.isArray(e)) {
        var o = e.length;
        for (t = 0; t < o; t++) e[t] && (f = clsx_r(e[t])) && (n && (n += ' '), (n += f));
      } else for (f in e) e[f] && (n && (n += ' '), (n += f));
    return n;
  }
  function clsx() {
    for (var e, t, f = 0, n = '', o = arguments.length; f < o; f++)
      (e = arguments[f]) && (t = clsx_r(e)) && (n && (n += ' '), (n += t));
    return n;
  }
  /* harmony default export */ const dist_clsx = /* unused pure expression or super */ null && clsx; // ./node_modules/.pnpm/tailwind-merge@3.3.1/node_modules/tailwind-merge/dist/bundle-mjs.mjs
  const CLASS_PART_SEPARATOR = '-';
  const createClassGroupUtils = (config) => {
    const classMap = createClassMap(config);
    const { conflictingClassGroups, conflictingClassGroupModifiers } = config;
    const getClassGroupId = (className) => {
      const classParts = className.split(CLASS_PART_SEPARATOR);
      // Classes like `-inset-1` produce an empty string as first classPart. We assume that classes for negative values are used correctly and remove it from classParts.
      if (classParts[0] === '' && classParts.length !== 1) {
        classParts.shift();
      }
      return getGroupRecursive(classParts, classMap) || getGroupIdForArbitraryProperty(className);
    };
    const getConflictingClassGroupIds = (classGroupId, hasPostfixModifier) => {
      const conflicts = conflictingClassGroups[classGroupId] || [];
      if (hasPostfixModifier && conflictingClassGroupModifiers[classGroupId]) {
        return [...conflicts, ...conflictingClassGroupModifiers[classGroupId]];
      }
      return conflicts;
    };
    return {
      getClassGroupId,
      getConflictingClassGroupIds,
    };
  };
  const getGroupRecursive = (classParts, classPartObject) => {
    if (classParts.length === 0) {
      return classPartObject.classGroupId;
    }
    const currentClassPart = classParts[0];
    const nextClassPartObject = classPartObject.nextPart.get(currentClassPart);
    const classGroupFromNextClassPart = nextClassPartObject
      ? getGroupRecursive(classParts.slice(1), nextClassPartObject)
      : undefined;
    if (classGroupFromNextClassPart) {
      return classGroupFromNextClassPart;
    }
    if (classPartObject.validators.length === 0) {
      return undefined;
    }
    const classRest = classParts.join(CLASS_PART_SEPARATOR);
    return classPartObject.validators.find(({ validator }) => validator(classRest))?.classGroupId;
  };
  const arbitraryPropertyRegex = /^\[(.+)\]$/;
  const getGroupIdForArbitraryProperty = (className) => {
    if (arbitraryPropertyRegex.test(className)) {
      const arbitraryPropertyClassName = arbitraryPropertyRegex.exec(className)[1];
      const property = arbitraryPropertyClassName?.substring(
        0,
        arbitraryPropertyClassName.indexOf(':')
      );
      if (property) {
        // I use two dots here because one dot is used as prefix for class groups in plugins
        return 'arbitrary..' + property;
      }
    }
  };
  /**
   * Exported for testing only
   */
  const createClassMap = (config) => {
    const { theme, classGroups } = config;
    const classMap = {
      nextPart: new Map(),
      validators: [],
    };
    for (const classGroupId in classGroups) {
      processClassesRecursively(classGroups[classGroupId], classMap, classGroupId, theme);
    }
    return classMap;
  };
  const processClassesRecursively = (classGroup, classPartObject, classGroupId, theme) => {
    classGroup.forEach((classDefinition) => {
      if (typeof classDefinition === 'string') {
        const classPartObjectToEdit =
          classDefinition === '' ? classPartObject : getPart(classPartObject, classDefinition);
        classPartObjectToEdit.classGroupId = classGroupId;
        return;
      }
      if (typeof classDefinition === 'function') {
        if (isThemeGetter(classDefinition)) {
          processClassesRecursively(classDefinition(theme), classPartObject, classGroupId, theme);
          return;
        }
        classPartObject.validators.push({
          validator: classDefinition,
          classGroupId,
        });
        return;
      }
      Object.entries(classDefinition).forEach(([key, classGroup]) => {
        processClassesRecursively(classGroup, getPart(classPartObject, key), classGroupId, theme);
      });
    });
  };
  const getPart = (classPartObject, path) => {
    let currentClassPartObject = classPartObject;
    path.split(CLASS_PART_SEPARATOR).forEach((pathPart) => {
      if (!currentClassPartObject.nextPart.has(pathPart)) {
        currentClassPartObject.nextPart.set(pathPart, {
          nextPart: new Map(),
          validators: [],
        });
      }
      currentClassPartObject = currentClassPartObject.nextPart.get(pathPart);
    });
    return currentClassPartObject;
  };
  const isThemeGetter = (func) => func.isThemeGetter;

  // LRU cache inspired from hashlru (https://github.com/dominictarr/hashlru/blob/v1.0.4/index.js) but object replaced with Map to improve performance
  const createLruCache = (maxCacheSize) => {
    if (maxCacheSize < 1) {
      return {
        get: () => undefined,
        set: () => {},
      };
    }
    let cacheSize = 0;
    let cache = new Map();
    let previousCache = new Map();
    const update = (key, value) => {
      cache.set(key, value);
      cacheSize++;
      if (cacheSize > maxCacheSize) {
        cacheSize = 0;
        previousCache = cache;
        cache = new Map();
      }
    };
    return {
      get(key) {
        let value = cache.get(key);
        if (value !== undefined) {
          return value;
        }
        if ((value = previousCache.get(key)) !== undefined) {
          update(key, value);
          return value;
        }
      },
      set(key, value) {
        if (cache.has(key)) {
          cache.set(key, value);
        } else {
          update(key, value);
        }
      },
    };
  };
  const IMPORTANT_MODIFIER = '!';
  const MODIFIER_SEPARATOR = ':';
  const MODIFIER_SEPARATOR_LENGTH = MODIFIER_SEPARATOR.length;
  const createParseClassName = (config) => {
    const { prefix, experimentalParseClassName } = config;
    /**
     * Parse class name into parts.
     *
     * Inspired by `splitAtTopLevelOnly` used in Tailwind CSS
     * @see https://github.com/tailwindlabs/tailwindcss/blob/v3.2.2/src/util/splitAtTopLevelOnly.js
     */
    let parseClassName = (className) => {
      const modifiers = [];
      let bracketDepth = 0;
      let parenDepth = 0;
      let modifierStart = 0;
      let postfixModifierPosition;
      for (let index = 0; index < className.length; index++) {
        let currentCharacter = className[index];
        if (bracketDepth === 0 && parenDepth === 0) {
          if (currentCharacter === MODIFIER_SEPARATOR) {
            modifiers.push(className.slice(modifierStart, index));
            modifierStart = index + MODIFIER_SEPARATOR_LENGTH;
            continue;
          }
          if (currentCharacter === '/') {
            postfixModifierPosition = index;
            continue;
          }
        }
        if (currentCharacter === '[') {
          bracketDepth++;
        } else if (currentCharacter === ']') {
          bracketDepth--;
        } else if (currentCharacter === '(') {
          parenDepth++;
        } else if (currentCharacter === ')') {
          parenDepth--;
        }
      }
      const baseClassNameWithImportantModifier =
        modifiers.length === 0 ? className : className.substring(modifierStart);
      const baseClassName = stripImportantModifier(baseClassNameWithImportantModifier);
      const hasImportantModifier = baseClassName !== baseClassNameWithImportantModifier;
      const maybePostfixModifierPosition =
        postfixModifierPosition && postfixModifierPosition > modifierStart
          ? postfixModifierPosition - modifierStart
          : undefined;
      return {
        modifiers,
        hasImportantModifier,
        baseClassName,
        maybePostfixModifierPosition,
      };
    };
    if (prefix) {
      const fullPrefix = prefix + MODIFIER_SEPARATOR;
      const parseClassNameOriginal = parseClassName;
      parseClassName = (className) =>
        className.startsWith(fullPrefix)
          ? parseClassNameOriginal(className.substring(fullPrefix.length))
          : {
              isExternal: true,
              modifiers: [],
              hasImportantModifier: false,
              baseClassName: className,
              maybePostfixModifierPosition: undefined,
            };
    }
    if (experimentalParseClassName) {
      const parseClassNameOriginal = parseClassName;
      parseClassName = (className) =>
        experimentalParseClassName({
          className,
          parseClassName: parseClassNameOriginal,
        });
    }
    return parseClassName;
  };
  const stripImportantModifier = (baseClassName) => {
    if (baseClassName.endsWith(IMPORTANT_MODIFIER)) {
      return baseClassName.substring(0, baseClassName.length - 1);
    }
    /**
     * In Tailwind CSS v3 the important modifier was at the start of the base class name. This is still supported for legacy reasons.
     * @see https://github.com/dcastil/tailwind-merge/issues/513#issuecomment-2614029864
     */
    if (baseClassName.startsWith(IMPORTANT_MODIFIER)) {
      return baseClassName.substring(1);
    }
    return baseClassName;
  };

  /**
   * Sorts modifiers according to following schema:
   * - Predefined modifiers are sorted alphabetically
   * - When an arbitrary variant appears, it must be preserved which modifiers are before and after it
   */
  const createSortModifiers = (config) => {
    const orderSensitiveModifiers = Object.fromEntries(
      config.orderSensitiveModifiers.map((modifier) => [modifier, true])
    );
    const sortModifiers = (modifiers) => {
      if (modifiers.length <= 1) {
        return modifiers;
      }
      const sortedModifiers = [];
      let unsortedModifiers = [];
      modifiers.forEach((modifier) => {
        const isPositionSensitive = modifier[0] === '[' || orderSensitiveModifiers[modifier];
        if (isPositionSensitive) {
          sortedModifiers.push(...unsortedModifiers.sort(), modifier);
          unsortedModifiers = [];
        } else {
          unsortedModifiers.push(modifier);
        }
      });
      sortedModifiers.push(...unsortedModifiers.sort());
      return sortedModifiers;
    };
    return sortModifiers;
  };
  const createConfigUtils = (config) => ({
    cache: createLruCache(config.cacheSize),
    parseClassName: createParseClassName(config),
    sortModifiers: createSortModifiers(config),
    ...createClassGroupUtils(config),
  });
  const SPLIT_CLASSES_REGEX = /\s+/;
  const mergeClassList = (classList, configUtils) => {
    const { parseClassName, getClassGroupId, getConflictingClassGroupIds, sortModifiers } =
      configUtils;
    /**
     * Set of classGroupIds in following format:
     * `{importantModifier}{variantModifiers}{classGroupId}`
     * @example 'float'
     * @example 'hover:focus:bg-color'
     * @example 'md:!pr'
     */
    const classGroupsInConflict = [];
    const classNames = classList.trim().split(SPLIT_CLASSES_REGEX);
    let result = '';
    for (let index = classNames.length - 1; index >= 0; index -= 1) {
      const originalClassName = classNames[index];
      const {
        isExternal,
        modifiers,
        hasImportantModifier,
        baseClassName,
        maybePostfixModifierPosition,
      } = parseClassName(originalClassName);
      if (isExternal) {
        result = originalClassName + (result.length > 0 ? ' ' + result : result);
        continue;
      }
      let hasPostfixModifier = !!maybePostfixModifierPosition;
      let classGroupId = getClassGroupId(
        hasPostfixModifier
          ? baseClassName.substring(0, maybePostfixModifierPosition)
          : baseClassName
      );
      if (!classGroupId) {
        if (!hasPostfixModifier) {
          // Not a Tailwind class
          result = originalClassName + (result.length > 0 ? ' ' + result : result);
          continue;
        }
        classGroupId = getClassGroupId(baseClassName);
        if (!classGroupId) {
          // Not a Tailwind class
          result = originalClassName + (result.length > 0 ? ' ' + result : result);
          continue;
        }
        hasPostfixModifier = false;
      }
      const variantModifier = sortModifiers(modifiers).join(':');
      const modifierId = hasImportantModifier
        ? variantModifier + IMPORTANT_MODIFIER
        : variantModifier;
      const classId = modifierId + classGroupId;
      if (classGroupsInConflict.includes(classId)) {
        // Tailwind class omitted due to conflict
        continue;
      }
      classGroupsInConflict.push(classId);
      const conflictGroups = getConflictingClassGroupIds(classGroupId, hasPostfixModifier);
      for (let i = 0; i < conflictGroups.length; ++i) {
        const group = conflictGroups[i];
        classGroupsInConflict.push(modifierId + group);
      }
      // Tailwind class not in conflict
      result = originalClassName + (result.length > 0 ? ' ' + result : result);
    }
    return result;
  };

  /**
   * The code in this file is copied from https://github.com/lukeed/clsx and modified to suit the needs of tailwind-merge better.
   *
   * Specifically:
   * - Runtime code from https://github.com/lukeed/clsx/blob/v1.2.1/src/index.js
   * - TypeScript types from https://github.com/lukeed/clsx/blob/v1.2.1/clsx.d.ts
   *
   * Original code has MIT license: Copyright (c) Luke Edwards <luke.edwards05@gmail.com> (lukeed.com)
   */
  function twJoin() {
    let index = 0;
    let argument;
    let resolvedValue;
    let string = '';
    while (index < arguments.length) {
      if ((argument = arguments[index++])) {
        if ((resolvedValue = toValue(argument))) {
          string && (string += ' ');
          string += resolvedValue;
        }
      }
    }
    return string;
  }
  const toValue = (mix) => {
    if (typeof mix === 'string') {
      return mix;
    }
    let resolvedValue;
    let string = '';
    for (let k = 0; k < mix.length; k++) {
      if (mix[k]) {
        if ((resolvedValue = toValue(mix[k]))) {
          string && (string += ' ');
          string += resolvedValue;
        }
      }
    }
    return string;
  };
  function createTailwindMerge(createConfigFirst, ...createConfigRest) {
    let configUtils;
    let cacheGet;
    let cacheSet;
    let functionToCall = initTailwindMerge;
    function initTailwindMerge(classList) {
      const config = createConfigRest.reduce(
        (previousConfig, createConfigCurrent) => createConfigCurrent(previousConfig),
        createConfigFirst()
      );
      configUtils = createConfigUtils(config);
      cacheGet = configUtils.cache.get;
      cacheSet = configUtils.cache.set;
      functionToCall = tailwindMerge;
      return tailwindMerge(classList);
    }
    function tailwindMerge(classList) {
      const cachedResult = cacheGet(classList);
      if (cachedResult) {
        return cachedResult;
      }
      const result = mergeClassList(classList, configUtils);
      cacheSet(classList, result);
      return result;
    }
    return function callTailwindMerge() {
      return functionToCall(twJoin.apply(null, arguments));
    };
  }
  const fromTheme = (key) => {
    const themeGetter = (theme) => theme[key] || [];
    themeGetter.isThemeGetter = true;
    return themeGetter;
  };
  const arbitraryValueRegex = /^\[(?:(\w[\w-]*):)?(.+)\]$/i;
  const arbitraryVariableRegex = /^\((?:(\w[\w-]*):)?(.+)\)$/i;
  const fractionRegex = /^\d+\/\d+$/;
  const tshirtUnitRegex = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/;
  const lengthUnitRegex =
    /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/;
  const colorFunctionRegex = /^(rgba?|hsla?|hwb|(ok)?(lab|lch)|color-mix)\(.+\)$/;
  // Shadow always begins with x and y offset separated by underscore optionally prepended by inset
  const shadowRegex = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;
  const imageRegex =
    /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/;
  const isFraction = (value) => fractionRegex.test(value);
  const isNumber = (value) => !!value && !Number.isNaN(Number(value));
  const isInteger = (value) => !!value && Number.isInteger(Number(value));
  const isPercent = (value) => value.endsWith('%') && isNumber(value.slice(0, -1));
  const isTshirtSize = (value) => tshirtUnitRegex.test(value);
  const isAny = () => true;
  const isLengthOnly = (value) =>
    // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
    // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
    // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
    lengthUnitRegex.test(value) && !colorFunctionRegex.test(value);
  const isNever = () => false;
  const isShadow = (value) => shadowRegex.test(value);
  const isImage = (value) => imageRegex.test(value);
  const isAnyNonArbitrary = (value) => !isArbitraryValue(value) && !isArbitraryVariable(value);
  const isArbitrarySize = (value) => getIsArbitraryValue(value, isLabelSize, isNever);
  const isArbitraryValue = (value) => arbitraryValueRegex.test(value);
  const isArbitraryLength = (value) => getIsArbitraryValue(value, isLabelLength, isLengthOnly);
  const isArbitraryNumber = (value) => getIsArbitraryValue(value, isLabelNumber, isNumber);
  const isArbitraryPosition = (value) => getIsArbitraryValue(value, isLabelPosition, isNever);
  const isArbitraryImage = (value) => getIsArbitraryValue(value, isLabelImage, isImage);
  const isArbitraryShadow = (value) => getIsArbitraryValue(value, isLabelShadow, isShadow);
  const isArbitraryVariable = (value) => arbitraryVariableRegex.test(value);
  const isArbitraryVariableLength = (value) => getIsArbitraryVariable(value, isLabelLength);
  const isArbitraryVariableFamilyName = (value) => getIsArbitraryVariable(value, isLabelFamilyName);
  const isArbitraryVariablePosition = (value) => getIsArbitraryVariable(value, isLabelPosition);
  const isArbitraryVariableSize = (value) => getIsArbitraryVariable(value, isLabelSize);
  const isArbitraryVariableImage = (value) => getIsArbitraryVariable(value, isLabelImage);
  const isArbitraryVariableShadow = (value) => getIsArbitraryVariable(value, isLabelShadow, true);
  // Helpers
  const getIsArbitraryValue = (value, testLabel, testValue) => {
    const result = arbitraryValueRegex.exec(value);
    if (result) {
      if (result[1]) {
        return testLabel(result[1]);
      }
      return testValue(result[2]);
    }
    return false;
  };
  const getIsArbitraryVariable = (value, testLabel, shouldMatchNoLabel = false) => {
    const result = arbitraryVariableRegex.exec(value);
    if (result) {
      if (result[1]) {
        return testLabel(result[1]);
      }
      return shouldMatchNoLabel;
    }
    return false;
  };
  // Labels
  const isLabelPosition = (label) => label === 'position' || label === 'percentage';
  const isLabelImage = (label) => label === 'image' || label === 'url';
  const isLabelSize = (label) => label === 'length' || label === 'size' || label === 'bg-size';
  const isLabelLength = (label) => label === 'length';
  const isLabelNumber = (label) => label === 'number';
  const isLabelFamilyName = (label) => label === 'family-name';
  const isLabelShadow = (label) => label === 'shadow';
  const validators = /*#__PURE__*/ Object.defineProperty(
    {
      __proto__: null,
      isAny,
      isAnyNonArbitrary,
      isArbitraryImage,
      isArbitraryLength,
      isArbitraryNumber,
      isArbitraryPosition,
      isArbitraryShadow,
      isArbitrarySize,
      isArbitraryValue,
      isArbitraryVariable,
      isArbitraryVariableFamilyName,
      isArbitraryVariableImage,
      isArbitraryVariableLength,
      isArbitraryVariablePosition,
      isArbitraryVariableShadow,
      isArbitraryVariableSize,
      isFraction,
      isInteger,
      isNumber,
      isPercent,
      isTshirtSize,
    },
    Symbol.toStringTag,
    {
      value: 'Module',
    }
  );
  const getDefaultConfig = () => {
    /**
     * Theme getters for theme variable namespaces
     * @see https://tailwindcss.com/docs/theme#theme-variable-namespaces
     */
    /***/
    const themeColor = fromTheme('color');
    const themeFont = fromTheme('font');
    const themeText = fromTheme('text');
    const themeFontWeight = fromTheme('font-weight');
    const themeTracking = fromTheme('tracking');
    const themeLeading = fromTheme('leading');
    const themeBreakpoint = fromTheme('breakpoint');
    const themeContainer = fromTheme('container');
    const themeSpacing = fromTheme('spacing');
    const themeRadius = fromTheme('radius');
    const themeShadow = fromTheme('shadow');
    const themeInsetShadow = fromTheme('inset-shadow');
    const themeTextShadow = fromTheme('text-shadow');
    const themeDropShadow = fromTheme('drop-shadow');
    const themeBlur = fromTheme('blur');
    const themePerspective = fromTheme('perspective');
    const themeAspect = fromTheme('aspect');
    const themeEase = fromTheme('ease');
    const themeAnimate = fromTheme('animate');
    /**
     * Helpers to avoid repeating the same scales
     *
     * We use functions that create a new array every time they're called instead of static arrays.
     * This ensures that users who modify any scale by mutating the array (e.g. with `array.push(element)`) don't accidentally mutate arrays in other parts of the config.
     */
    /***/
    const scaleBreak = () => [
      'auto',
      'avoid',
      'all',
      'avoid-page',
      'page',
      'left',
      'right',
      'column',
    ];
    const scalePosition = () => [
      'center',
      'top',
      'bottom',
      'left',
      'right',
      'top-left',
      // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
      'left-top',
      'top-right',
      // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
      'right-top',
      'bottom-right',
      // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
      'right-bottom',
      'bottom-left',
      // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
      'left-bottom',
    ];
    const scalePositionWithArbitrary = () => [
      ...scalePosition(),
      isArbitraryVariable,
      isArbitraryValue,
    ];
    const scaleOverflow = () => ['auto', 'hidden', 'clip', 'visible', 'scroll'];
    const scaleOverscroll = () => ['auto', 'contain', 'none'];
    const scaleUnambiguousSpacing = () => [isArbitraryVariable, isArbitraryValue, themeSpacing];
    const scaleInset = () => [isFraction, 'full', 'auto', ...scaleUnambiguousSpacing()];
    const scaleGridTemplateColsRows = () => [
      isInteger,
      'none',
      'subgrid',
      isArbitraryVariable,
      isArbitraryValue,
    ];
    const scaleGridColRowStartAndEnd = () => [
      'auto',
      {
        span: ['full', isInteger, isArbitraryVariable, isArbitraryValue],
      },
      isInteger,
      isArbitraryVariable,
      isArbitraryValue,
    ];
    const scaleGridColRowStartOrEnd = () => [
      isInteger,
      'auto',
      isArbitraryVariable,
      isArbitraryValue,
    ];
    const scaleGridAutoColsRows = () => [
      'auto',
      'min',
      'max',
      'fr',
      isArbitraryVariable,
      isArbitraryValue,
    ];
    const scaleAlignPrimaryAxis = () => [
      'start',
      'end',
      'center',
      'between',
      'around',
      'evenly',
      'stretch',
      'baseline',
      'center-safe',
      'end-safe',
    ];
    const scaleAlignSecondaryAxis = () => [
      'start',
      'end',
      'center',
      'stretch',
      'center-safe',
      'end-safe',
    ];
    const scaleMargin = () => ['auto', ...scaleUnambiguousSpacing()];
    const scaleSizing = () => [
      isFraction,
      'auto',
      'full',
      'dvw',
      'dvh',
      'lvw',
      'lvh',
      'svw',
      'svh',
      'min',
      'max',
      'fit',
      ...scaleUnambiguousSpacing(),
    ];
    const scaleColor = () => [themeColor, isArbitraryVariable, isArbitraryValue];
    const scaleBgPosition = () => [
      ...scalePosition(),
      isArbitraryVariablePosition,
      isArbitraryPosition,
      {
        position: [isArbitraryVariable, isArbitraryValue],
      },
    ];
    const scaleBgRepeat = () => [
      'no-repeat',
      {
        repeat: ['', 'x', 'y', 'space', 'round'],
      },
    ];
    const scaleBgSize = () => [
      'auto',
      'cover',
      'contain',
      isArbitraryVariableSize,
      isArbitrarySize,
      {
        size: [isArbitraryVariable, isArbitraryValue],
      },
    ];
    const scaleGradientStopPosition = () => [
      isPercent,
      isArbitraryVariableLength,
      isArbitraryLength,
    ];
    const scaleRadius = () => [
      // Deprecated since Tailwind CSS v4.0.0
      '',
      'none',
      'full',
      themeRadius,
      isArbitraryVariable,
      isArbitraryValue,
    ];
    const scaleBorderWidth = () => ['', isNumber, isArbitraryVariableLength, isArbitraryLength];
    const scaleLineStyle = () => ['solid', 'dashed', 'dotted', 'double'];
    const scaleBlendMode = () => [
      'normal',
      'multiply',
      'screen',
      'overlay',
      'darken',
      'lighten',
      'color-dodge',
      'color-burn',
      'hard-light',
      'soft-light',
      'difference',
      'exclusion',
      'hue',
      'saturation',
      'color',
      'luminosity',
    ];
    const scaleMaskImagePosition = () => [
      isNumber,
      isPercent,
      isArbitraryVariablePosition,
      isArbitraryPosition,
    ];
    const scaleBlur = () => [
      // Deprecated since Tailwind CSS v4.0.0
      '',
      'none',
      themeBlur,
      isArbitraryVariable,
      isArbitraryValue,
    ];
    const scaleRotate = () => ['none', isNumber, isArbitraryVariable, isArbitraryValue];
    const scaleScale = () => ['none', isNumber, isArbitraryVariable, isArbitraryValue];
    const scaleSkew = () => [isNumber, isArbitraryVariable, isArbitraryValue];
    const scaleTranslate = () => [isFraction, 'full', ...scaleUnambiguousSpacing()];
    return {
      cacheSize: 500,
      theme: {
        animate: ['spin', 'ping', 'pulse', 'bounce'],
        aspect: ['video'],
        blur: [isTshirtSize],
        breakpoint: [isTshirtSize],
        color: [isAny],
        container: [isTshirtSize],
        'drop-shadow': [isTshirtSize],
        ease: ['in', 'out', 'in-out'],
        font: [isAnyNonArbitrary],
        'font-weight': [
          'thin',
          'extralight',
          'light',
          'normal',
          'medium',
          'semibold',
          'bold',
          'extrabold',
          'black',
        ],
        'inset-shadow': [isTshirtSize],
        leading: ['none', 'tight', 'snug', 'normal', 'relaxed', 'loose'],
        perspective: ['dramatic', 'near', 'normal', 'midrange', 'distant', 'none'],
        radius: [isTshirtSize],
        shadow: [isTshirtSize],
        spacing: ['px', isNumber],
        text: [isTshirtSize],
        'text-shadow': [isTshirtSize],
        tracking: ['tighter', 'tight', 'normal', 'wide', 'wider', 'widest'],
      },
      classGroups: {
        // --------------
        // --- Layout ---
        // --------------
        /**
         * Aspect Ratio
         * @see https://tailwindcss.com/docs/aspect-ratio
         */
        aspect: [
          {
            aspect: [
              'auto',
              'square',
              isFraction,
              isArbitraryValue,
              isArbitraryVariable,
              themeAspect,
            ],
          },
        ],
        /**
         * Container
         * @see https://tailwindcss.com/docs/container
         * @deprecated since Tailwind CSS v4.0.0
         */
        container: ['container'],
        /**
         * Columns
         * @see https://tailwindcss.com/docs/columns
         */
        columns: [
          {
            columns: [isNumber, isArbitraryValue, isArbitraryVariable, themeContainer],
          },
        ],
        /**
         * Break After
         * @see https://tailwindcss.com/docs/break-after
         */
        'break-after': [
          {
            'break-after': scaleBreak(),
          },
        ],
        /**
         * Break Before
         * @see https://tailwindcss.com/docs/break-before
         */
        'break-before': [
          {
            'break-before': scaleBreak(),
          },
        ],
        /**
         * Break Inside
         * @see https://tailwindcss.com/docs/break-inside
         */
        'break-inside': [
          {
            'break-inside': ['auto', 'avoid', 'avoid-page', 'avoid-column'],
          },
        ],
        /**
         * Box Decoration Break
         * @see https://tailwindcss.com/docs/box-decoration-break
         */
        'box-decoration': [
          {
            'box-decoration': ['slice', 'clone'],
          },
        ],
        /**
         * Box Sizing
         * @see https://tailwindcss.com/docs/box-sizing
         */
        box: [
          {
            box: ['border', 'content'],
          },
        ],
        /**
         * Display
         * @see https://tailwindcss.com/docs/display
         */
        display: [
          'block',
          'inline-block',
          'inline',
          'flex',
          'inline-flex',
          'table',
          'inline-table',
          'table-caption',
          'table-cell',
          'table-column',
          'table-column-group',
          'table-footer-group',
          'table-header-group',
          'table-row-group',
          'table-row',
          'flow-root',
          'grid',
          'inline-grid',
          'contents',
          'list-item',
          'hidden',
        ],
        /**
         * Screen Reader Only
         * @see https://tailwindcss.com/docs/display#screen-reader-only
         */
        sr: ['sr-only', 'not-sr-only'],
        /**
         * Floats
         * @see https://tailwindcss.com/docs/float
         */
        float: [
          {
            float: ['right', 'left', 'none', 'start', 'end'],
          },
        ],
        /**
         * Clear
         * @see https://tailwindcss.com/docs/clear
         */
        clear: [
          {
            clear: ['left', 'right', 'both', 'none', 'start', 'end'],
          },
        ],
        /**
         * Isolation
         * @see https://tailwindcss.com/docs/isolation
         */
        isolation: ['isolate', 'isolation-auto'],
        /**
         * Object Fit
         * @see https://tailwindcss.com/docs/object-fit
         */
        'object-fit': [
          {
            object: ['contain', 'cover', 'fill', 'none', 'scale-down'],
          },
        ],
        /**
         * Object Position
         * @see https://tailwindcss.com/docs/object-position
         */
        'object-position': [
          {
            object: scalePositionWithArbitrary(),
          },
        ],
        /**
         * Overflow
         * @see https://tailwindcss.com/docs/overflow
         */
        overflow: [
          {
            overflow: scaleOverflow(),
          },
        ],
        /**
         * Overflow X
         * @see https://tailwindcss.com/docs/overflow
         */
        'overflow-x': [
          {
            'overflow-x': scaleOverflow(),
          },
        ],
        /**
         * Overflow Y
         * @see https://tailwindcss.com/docs/overflow
         */
        'overflow-y': [
          {
            'overflow-y': scaleOverflow(),
          },
        ],
        /**
         * Overscroll Behavior
         * @see https://tailwindcss.com/docs/overscroll-behavior
         */
        overscroll: [
          {
            overscroll: scaleOverscroll(),
          },
        ],
        /**
         * Overscroll Behavior X
         * @see https://tailwindcss.com/docs/overscroll-behavior
         */
        'overscroll-x': [
          {
            'overscroll-x': scaleOverscroll(),
          },
        ],
        /**
         * Overscroll Behavior Y
         * @see https://tailwindcss.com/docs/overscroll-behavior
         */
        'overscroll-y': [
          {
            'overscroll-y': scaleOverscroll(),
          },
        ],
        /**
         * Position
         * @see https://tailwindcss.com/docs/position
         */
        position: ['static', 'fixed', 'absolute', 'relative', 'sticky'],
        /**
         * Top / Right / Bottom / Left
         * @see https://tailwindcss.com/docs/top-right-bottom-left
         */
        inset: [
          {
            inset: scaleInset(),
          },
        ],
        /**
         * Right / Left
         * @see https://tailwindcss.com/docs/top-right-bottom-left
         */
        'inset-x': [
          {
            'inset-x': scaleInset(),
          },
        ],
        /**
         * Top / Bottom
         * @see https://tailwindcss.com/docs/top-right-bottom-left
         */
        'inset-y': [
          {
            'inset-y': scaleInset(),
          },
        ],
        /**
         * Start
         * @see https://tailwindcss.com/docs/top-right-bottom-left
         */
        start: [
          {
            start: scaleInset(),
          },
        ],
        /**
         * End
         * @see https://tailwindcss.com/docs/top-right-bottom-left
         */
        end: [
          {
            end: scaleInset(),
          },
        ],
        /**
         * Top
         * @see https://tailwindcss.com/docs/top-right-bottom-left
         */
        top: [
          {
            top: scaleInset(),
          },
        ],
        /**
         * Right
         * @see https://tailwindcss.com/docs/top-right-bottom-left
         */
        right: [
          {
            right: scaleInset(),
          },
        ],
        /**
         * Bottom
         * @see https://tailwindcss.com/docs/top-right-bottom-left
         */
        bottom: [
          {
            bottom: scaleInset(),
          },
        ],
        /**
         * Left
         * @see https://tailwindcss.com/docs/top-right-bottom-left
         */
        left: [
          {
            left: scaleInset(),
          },
        ],
        /**
         * Visibility
         * @see https://tailwindcss.com/docs/visibility
         */
        visibility: ['visible', 'invisible', 'collapse'],
        /**
         * Z-Index
         * @see https://tailwindcss.com/docs/z-index
         */
        z: [
          {
            z: [isInteger, 'auto', isArbitraryVariable, isArbitraryValue],
          },
        ],
        // ------------------------
        // --- Flexbox and Grid ---
        // ------------------------
        /**
         * Flex Basis
         * @see https://tailwindcss.com/docs/flex-basis
         */
        basis: [
          {
            basis: [isFraction, 'full', 'auto', themeContainer, ...scaleUnambiguousSpacing()],
          },
        ],
        /**
         * Flex Direction
         * @see https://tailwindcss.com/docs/flex-direction
         */
        'flex-direction': [
          {
            flex: ['row', 'row-reverse', 'col', 'col-reverse'],
          },
        ],
        /**
         * Flex Wrap
         * @see https://tailwindcss.com/docs/flex-wrap
         */
        'flex-wrap': [
          {
            flex: ['nowrap', 'wrap', 'wrap-reverse'],
          },
        ],
        /**
         * Flex
         * @see https://tailwindcss.com/docs/flex
         */
        flex: [
          {
            flex: [isNumber, isFraction, 'auto', 'initial', 'none', isArbitraryValue],
          },
        ],
        /**
         * Flex Grow
         * @see https://tailwindcss.com/docs/flex-grow
         */
        grow: [
          {
            grow: ['', isNumber, isArbitraryVariable, isArbitraryValue],
          },
        ],
        /**
         * Flex Shrink
         * @see https://tailwindcss.com/docs/flex-shrink
         */
        shrink: [
          {
            shrink: ['', isNumber, isArbitraryVariable, isArbitraryValue],
          },
        ],
        /**
         * Order
         * @see https://tailwindcss.com/docs/order
         */
        order: [
          {
            order: [isInteger, 'first', 'last', 'none', isArbitraryVariable, isArbitraryValue],
          },
        ],
        /**
         * Grid Template Columns
         * @see https://tailwindcss.com/docs/grid-template-columns
         */
        'grid-cols': [
          {
            'grid-cols': scaleGridTemplateColsRows(),
          },
        ],
        /**
         * Grid Column Start / End
         * @see https://tailwindcss.com/docs/grid-column
         */
        'col-start-end': [
          {
            col: scaleGridColRowStartAndEnd(),
          },
        ],
        /**
         * Grid Column Start
         * @see https://tailwindcss.com/docs/grid-column
         */
        'col-start': [
          {
            'col-start': scaleGridColRowStartOrEnd(),
          },
        ],
        /**
         * Grid Column End
         * @see https://tailwindcss.com/docs/grid-column
         */
        'col-end': [
          {
            'col-end': scaleGridColRowStartOrEnd(),
          },
        ],
        /**
         * Grid Template Rows
         * @see https://tailwindcss.com/docs/grid-template-rows
         */
        'grid-rows': [
          {
            'grid-rows': scaleGridTemplateColsRows(),
          },
        ],
        /**
         * Grid Row Start / End
         * @see https://tailwindcss.com/docs/grid-row
         */
        'row-start-end': [
          {
            row: scaleGridColRowStartAndEnd(),
          },
        ],
        /**
         * Grid Row Start
         * @see https://tailwindcss.com/docs/grid-row
         */
        'row-start': [
          {
            'row-start': scaleGridColRowStartOrEnd(),
          },
        ],
        /**
         * Grid Row End
         * @see https://tailwindcss.com/docs/grid-row
         */
        'row-end': [
          {
            'row-end': scaleGridColRowStartOrEnd(),
          },
        ],
        /**
         * Grid Auto Flow
         * @see https://tailwindcss.com/docs/grid-auto-flow
         */
        'grid-flow': [
          {
            'grid-flow': ['row', 'col', 'dense', 'row-dense', 'col-dense'],
          },
        ],
        /**
         * Grid Auto Columns
         * @see https://tailwindcss.com/docs/grid-auto-columns
         */
        'auto-cols': [
          {
            'auto-cols': scaleGridAutoColsRows(),
          },
        ],
        /**
         * Grid Auto Rows
         * @see https://tailwindcss.com/docs/grid-auto-rows
         */
        'auto-rows': [
          {
            'auto-rows': scaleGridAutoColsRows(),
          },
        ],
        /**
         * Gap
         * @see https://tailwindcss.com/docs/gap
         */
        gap: [
          {
            gap: scaleUnambiguousSpacing(),
          },
        ],
        /**
         * Gap X
         * @see https://tailwindcss.com/docs/gap
         */
        'gap-x': [
          {
            'gap-x': scaleUnambiguousSpacing(),
          },
        ],
        /**
         * Gap Y
         * @see https://tailwindcss.com/docs/gap
         */
        'gap-y': [
          {
            'gap-y': scaleUnambiguousSpacing(),
          },
        ],
        /**
         * Justify Content
         * @see https://tailwindcss.com/docs/justify-content
         */
        'justify-content': [
          {
            justify: [...scaleAlignPrimaryAxis(), 'normal'],
          },
        ],
        /**
         * Justify Items
         * @see https://tailwindcss.com/docs/justify-items
         */
        'justify-items': [
          {
            'justify-items': [...scaleAlignSecondaryAxis(), 'normal'],
          },
        ],
        /**
         * Justify Self
         * @see https://tailwindcss.com/docs/justify-self
         */
        'justify-self': [
          {
            'justify-self': ['auto', ...scaleAlignSecondaryAxis()],
          },
        ],
        /**
         * Align Content
         * @see https://tailwindcss.com/docs/align-content
         */
        'align-content': [
          {
            content: ['normal', ...scaleAlignPrimaryAxis()],
          },
        ],
        /**
         * Align Items
         * @see https://tailwindcss.com/docs/align-items
         */
        'align-items': [
          {
            items: [
              ...scaleAlignSecondaryAxis(),
              {
                baseline: ['', 'last'],
              },
            ],
          },
        ],
        /**
         * Align Self
         * @see https://tailwindcss.com/docs/align-self
         */
        'align-self': [
          {
            self: [
              'auto',
              ...scaleAlignSecondaryAxis(),
              {
                baseline: ['', 'last'],
              },
            ],
          },
        ],
        /**
         * Place Content
         * @see https://tailwindcss.com/docs/place-content
         */
        'place-content': [
          {
            'place-content': scaleAlignPrimaryAxis(),
          },
        ],
        /**
         * Place Items
         * @see https://tailwindcss.com/docs/place-items
         */
        'place-items': [
          {
            'place-items': [...scaleAlignSecondaryAxis(), 'baseline'],
          },
        ],
        /**
         * Place Self
         * @see https://tailwindcss.com/docs/place-self
         */
        'place-self': [
          {
            'place-self': ['auto', ...scaleAlignSecondaryAxis()],
          },
        ],
        // Spacing
        /**
         * Padding
         * @see https://tailwindcss.com/docs/padding
         */
        p: [
          {
            p: scaleUnambiguousSpacing(),
          },
        ],
        /**
         * Padding X
         * @see https://tailwindcss.com/docs/padding
         */
        px: [
          {
            px: scaleUnambiguousSpacing(),
          },
        ],
        /**
         * Padding Y
         * @see https://tailwindcss.com/docs/padding
         */
        py: [
          {
            py: scaleUnambiguousSpacing(),
          },
        ],
        /**
         * Padding Start
         * @see https://tailwindcss.com/docs/padding
         */
        ps: [
          {
            ps: scaleUnambiguousSpacing(),
          },
        ],
        /**
         * Padding End
         * @see https://tailwindcss.com/docs/padding
         */
        pe: [
          {
            pe: scaleUnambiguousSpacing(),
          },
        ],
        /**
         * Padding Top
         * @see https://tailwindcss.com/docs/padding
         */
        pt: [
          {
            pt: scaleUnambiguousSpacing(),
          },
        ],
        /**
         * Padding Right
         * @see https://tailwindcss.com/docs/padding
         */
        pr: [
          {
            pr: scaleUnambiguousSpacing(),
          },
        ],
        /**
         * Padding Bottom
         * @see https://tailwindcss.com/docs/padding
         */
        pb: [
          {
            pb: scaleUnambiguousSpacing(),
          },
        ],
        /**
         * Padding Left
         * @see https://tailwindcss.com/docs/padding
         */
        pl: [
          {
            pl: scaleUnambiguousSpacing(),
          },
        ],
        /**
         * Margin
         * @see https://tailwindcss.com/docs/margin
         */
        m: [
          {
            m: scaleMargin(),
          },
        ],
        /**
         * Margin X
         * @see https://tailwindcss.com/docs/margin
         */
        mx: [
          {
            mx: scaleMargin(),
          },
        ],
        /**
         * Margin Y
         * @see https://tailwindcss.com/docs/margin
         */
        my: [
          {
            my: scaleMargin(),
          },
        ],
        /**
         * Margin Start
         * @see https://tailwindcss.com/docs/margin
         */
        ms: [
          {
            ms: scaleMargin(),
          },
        ],
        /**
         * Margin End
         * @see https://tailwindcss.com/docs/margin
         */
        me: [
          {
            me: scaleMargin(),
          },
        ],
        /**
         * Margin Top
         * @see https://tailwindcss.com/docs/margin
         */
        mt: [
          {
            mt: scaleMargin(),
          },
        ],
        /**
         * Margin Right
         * @see https://tailwindcss.com/docs/margin
         */
        mr: [
          {
            mr: scaleMargin(),
          },
        ],
        /**
         * Margin Bottom
         * @see https://tailwindcss.com/docs/margin
         */
        mb: [
          {
            mb: scaleMargin(),
          },
        ],
        /**
         * Margin Left
         * @see https://tailwindcss.com/docs/margin
         */
        ml: [
          {
            ml: scaleMargin(),
          },
        ],
        /**
         * Space Between X
         * @see https://tailwindcss.com/docs/margin#adding-space-between-children
         */
        'space-x': [
          {
            'space-x': scaleUnambiguousSpacing(),
          },
        ],
        /**
         * Space Between X Reverse
         * @see https://tailwindcss.com/docs/margin#adding-space-between-children
         */
        'space-x-reverse': ['space-x-reverse'],
        /**
         * Space Between Y
         * @see https://tailwindcss.com/docs/margin#adding-space-between-children
         */
        'space-y': [
          {
            'space-y': scaleUnambiguousSpacing(),
          },
        ],
        /**
         * Space Between Y Reverse
         * @see https://tailwindcss.com/docs/margin#adding-space-between-children
         */
        'space-y-reverse': ['space-y-reverse'],
        // --------------
        // --- Sizing ---
        // --------------
        /**
         * Size
         * @see https://tailwindcss.com/docs/width#setting-both-width-and-height
         */
        size: [
          {
            size: scaleSizing(),
          },
        ],
        /**
         * Width
         * @see https://tailwindcss.com/docs/width
         */
        w: [
          {
            w: [themeContainer, 'screen', ...scaleSizing()],
          },
        ],
        /**
         * Min-Width
         * @see https://tailwindcss.com/docs/min-width
         */
        'min-w': [
          {
            'min-w': [
              themeContainer,
              'screen' /** Deprecated. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */,
              'none',
              ...scaleSizing(),
            ],
          },
        ],
        /**
         * Max-Width
         * @see https://tailwindcss.com/docs/max-width
         */
        'max-w': [
          {
            'max-w': [
              themeContainer,
              'screen',
              'none' /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */,
              'prose' /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */,
              {
                screen: [themeBreakpoint],
              },
              ...scaleSizing(),
            ],
          },
        ],
        /**
         * Height
         * @see https://tailwindcss.com/docs/height
         */
        h: [
          {
            h: ['screen', 'lh', ...scaleSizing()],
          },
        ],
        /**
         * Min-Height
         * @see https://tailwindcss.com/docs/min-height
         */
        'min-h': [
          {
            'min-h': ['screen', 'lh', 'none', ...scaleSizing()],
          },
        ],
        /**
         * Max-Height
         * @see https://tailwindcss.com/docs/max-height
         */
        'max-h': [
          {
            'max-h': ['screen', 'lh', ...scaleSizing()],
          },
        ],
        // ------------------
        // --- Typography ---
        // ------------------
        /**
         * Font Size
         * @see https://tailwindcss.com/docs/font-size
         */
        'font-size': [
          {
            text: ['base', themeText, isArbitraryVariableLength, isArbitraryLength],
          },
        ],
        /**
         * Font Smoothing
         * @see https://tailwindcss.com/docs/font-smoothing
         */
        'font-smoothing': ['antialiased', 'subpixel-antialiased'],
        /**
         * Font Style
         * @see https://tailwindcss.com/docs/font-style
         */
        'font-style': ['italic', 'not-italic'],
        /**
         * Font Weight
         * @see https://tailwindcss.com/docs/font-weight
         */
        'font-weight': [
          {
            font: [themeFontWeight, isArbitraryVariable, isArbitraryNumber],
          },
        ],
        /**
         * Font Stretch
         * @see https://tailwindcss.com/docs/font-stretch
         */
        'font-stretch': [
          {
            'font-stretch': [
              'ultra-condensed',
              'extra-condensed',
              'condensed',
              'semi-condensed',
              'normal',
              'semi-expanded',
              'expanded',
              'extra-expanded',
              'ultra-expanded',
              isPercent,
              isArbitraryValue,
            ],
          },
        ],
        /**
         * Font Family
         * @see https://tailwindcss.com/docs/font-family
         */
        'font-family': [
          {
            font: [isArbitraryVariableFamilyName, isArbitraryValue, themeFont],
          },
        ],
        /**
         * Font Variant Numeric
         * @see https://tailwindcss.com/docs/font-variant-numeric
         */
        'fvn-normal': ['normal-nums'],
        /**
         * Font Variant Numeric
         * @see https://tailwindcss.com/docs/font-variant-numeric
         */
        'fvn-ordinal': ['ordinal'],
        /**
         * Font Variant Numeric
         * @see https://tailwindcss.com/docs/font-variant-numeric
         */
        'fvn-slashed-zero': ['slashed-zero'],
        /**
         * Font Variant Numeric
         * @see https://tailwindcss.com/docs/font-variant-numeric
         */
        'fvn-figure': ['lining-nums', 'oldstyle-nums'],
        /**
         * Font Variant Numeric
         * @see https://tailwindcss.com/docs/font-variant-numeric
         */
        'fvn-spacing': ['proportional-nums', 'tabular-nums'],
        /**
         * Font Variant Numeric
         * @see https://tailwindcss.com/docs/font-variant-numeric
         */
        'fvn-fraction': ['diagonal-fractions', 'stacked-fractions'],
        /**
         * Letter Spacing
         * @see https://tailwindcss.com/docs/letter-spacing
         */
        tracking: [
          {
            tracking: [themeTracking, isArbitraryVariable, isArbitraryValue],
          },
        ],
        /**
         * Line Clamp
         * @see https://tailwindcss.com/docs/line-clamp
         */
        'line-clamp': [
          {
            'line-clamp': [isNumber, 'none', isArbitraryVariable, isArbitraryNumber],
          },
        ],
        /**
         * Line Height
         * @see https://tailwindcss.com/docs/line-height
         */
        leading: [
          {
            leading: [
              /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
              themeLeading,
              ...scaleUnambiguousSpacing(),
            ],
          },
        ],
        /**
         * List Style Image
         * @see https://tailwindcss.com/docs/list-style-image
         */
        'list-image': [
          {
            'list-image': ['none', isArbitraryVariable, isArbitraryValue],
          },
        ],
        /**
         * List Style Position
         * @see https://tailwindcss.com/docs/list-style-position
         */
        'list-style-position': [
          {
            list: ['inside', 'outside'],
          },
        ],
        /**
         * List Style Type
         * @see https://tailwindcss.com/docs/list-style-type
         */
        'list-style-type': [
          {
            list: ['disc', 'decimal', 'none', isArbitraryVariable, isArbitraryValue],
          },
        ],
        /**
         * Text Alignment
         * @see https://tailwindcss.com/docs/text-align
         */
        'text-alignment': [
          {
            text: ['left', 'center', 'right', 'justify', 'start', 'end'],
          },
        ],
        /**
         * Placeholder Color
         * @deprecated since Tailwind CSS v3.0.0
         * @see https://v3.tailwindcss.com/docs/placeholder-color
         */
        'placeholder-color': [
          {
            placeholder: scaleColor(),
          },
        ],
        /**
         * Text Color
         * @see https://tailwindcss.com/docs/text-color
         */
        'text-color': [
          {
            text: scaleColor(),
          },
        ],
        /**
         * Text Decoration
         * @see https://tailwindcss.com/docs/text-decoration
         */
        'text-decoration': ['underline', 'overline', 'line-through', 'no-underline'],
        /**
         * Text Decoration Style
         * @see https://tailwindcss.com/docs/text-decoration-style
         */
        'text-decoration-style': [
          {
            decoration: [...scaleLineStyle(), 'wavy'],
          },
        ],
        /**
         * Text Decoration Thickness
         * @see https://tailwindcss.com/docs/text-decoration-thickness
         */
        'text-decoration-thickness': [
          {
            decoration: [isNumber, 'from-font', 'auto', isArbitraryVariable, isArbitraryLength],
          },
        ],
        /**
         * Text Decoration Color
         * @see https://tailwindcss.com/docs/text-decoration-color
         */
        'text-decoration-color': [
          {
            decoration: scaleColor(),
          },
        ],
        /**
         * Text Underline Offset
         * @see https://tailwindcss.com/docs/text-underline-offset
         */
        'underline-offset': [
          {
            'underline-offset': [isNumber, 'auto', isArbitraryVariable, isArbitraryValue],
          },
        ],
        /**
         * Text Transform
         * @see https://tailwindcss.com/docs/text-transform
         */
        'text-transform': ['uppercase', 'lowercase', 'capitalize', 'normal-case'],
        /**
         * Text Overflow
         * @see https://tailwindcss.com/docs/text-overflow
         */
        'text-overflow': ['truncate', 'text-ellipsis', 'text-clip'],
        /**
         * Text Wrap
         * @see https://tailwindcss.com/docs/text-wrap
         */
        'text-wrap': [
          {
            text: ['wrap', 'nowrap', 'balance', 'pretty'],
          },
        ],
        /**
         * Text Indent
         * @see https://tailwindcss.com/docs/text-indent
         */
        indent: [
          {
            indent: scaleUnambiguousSpacing(),
          },
        ],
        /**
         * Vertical Alignment
         * @see https://tailwindcss.com/docs/vertical-align
         */
        'vertical-align': [
          {
            align: [
              'baseline',
              'top',
              'middle',
              'bottom',
              'text-top',
              'text-bottom',
              'sub',
              'super',
              isArbitraryVariable,
              isArbitraryValue,
            ],
          },
        ],
        /**
         * Whitespace
         * @see https://tailwindcss.com/docs/whitespace
         */
        whitespace: [
          {
            whitespace: ['normal', 'nowrap', 'pre', 'pre-line', 'pre-wrap', 'break-spaces'],
          },
        ],
        /**
         * Word Break
         * @see https://tailwindcss.com/docs/word-break
         */
        break: [
          {
            break: ['normal', 'words', 'all', 'keep'],
          },
        ],
        /**
         * Overflow Wrap
         * @see https://tailwindcss.com/docs/overflow-wrap
         */
        wrap: [
          {
            wrap: ['break-word', 'anywhere', 'normal'],
          },
        ],
        /**
         * Hyphens
         * @see https://tailwindcss.com/docs/hyphens
         */
        hyphens: [
          {
            hyphens: ['none', 'manual', 'auto'],
          },
        ],
        /**
         * Content
         * @see https://tailwindcss.com/docs/content
         */
        content: [
          {
            content: ['none', isArbitraryVariable, isArbitraryValue],
          },
        ],
        // -------------------
        // --- Backgrounds ---
        // -------------------
        /**
         * Background Attachment
         * @see https://tailwindcss.com/docs/background-attachment
         */
        'bg-attachment': [
          {
            bg: ['fixed', 'local', 'scroll'],
          },
        ],
        /**
         * Background Clip
         * @see https://tailwindcss.com/docs/background-clip
         */
        'bg-clip': [
          {
            'bg-clip': ['border', 'padding', 'content', 'text'],
          },
        ],
        /**
         * Background Origin
         * @see https://tailwindcss.com/docs/background-origin
         */
        'bg-origin': [
          {
            'bg-origin': ['border', 'padding', 'content'],
          },
        ],
        /**
         * Background Position
         * @see https://tailwindcss.com/docs/background-position
         */
        'bg-position': [
          {
            bg: scaleBgPosition(),
          },
        ],
        /**
         * Background Repeat
         * @see https://tailwindcss.com/docs/background-repeat
         */
        'bg-repeat': [
          {
            bg: scaleBgRepeat(),
          },
        ],
        /**
         * Background Size
         * @see https://tailwindcss.com/docs/background-size
         */
        'bg-size': [
          {
            bg: scaleBgSize(),
          },
        ],
        /**
         * Background Image
         * @see https://tailwindcss.com/docs/background-image
         */
        'bg-image': [
          {
            bg: [
              'none',
              {
                linear: [
                  {
                    to: ['t', 'tr', 'r', 'br', 'b', 'bl', 'l', 'tl'],
                  },
                  isInteger,
                  isArbitraryVariable,
                  isArbitraryValue,
                ],
                radial: ['', isArbitraryVariable, isArbitraryValue],
                conic: [isInteger, isArbitraryVariable, isArbitraryValue],
              },
              isArbitraryVariableImage,
              isArbitraryImage,
            ],
          },
        ],
        /**
         * Background Color
         * @see https://tailwindcss.com/docs/background-color
         */
        'bg-color': [
          {
            bg: scaleColor(),
          },
        ],
        /**
         * Gradient Color Stops From Position
         * @see https://tailwindcss.com/docs/gradient-color-stops
         */
        'gradient-from-pos': [
          {
            from: scaleGradientStopPosition(),
          },
        ],
        /**
         * Gradient Color Stops Via Position
         * @see https://tailwindcss.com/docs/gradient-color-stops
         */
        'gradient-via-pos': [
          {
            via: scaleGradientStopPosition(),
          },
        ],
        /**
         * Gradient Color Stops To Position
         * @see https://tailwindcss.com/docs/gradient-color-stops
         */
        'gradient-to-pos': [
          {
            to: scaleGradientStopPosition(),
          },
        ],
        /**
         * Gradient Color Stops From
         * @see https://tailwindcss.com/docs/gradient-color-stops
         */
        'gradient-from': [
          {
            from: scaleColor(),
          },
        ],
        /**
         * Gradient Color Stops Via
         * @see https://tailwindcss.com/docs/gradient-color-stops
         */
        'gradient-via': [
          {
            via: scaleColor(),
          },
        ],
        /**
         * Gradient Color Stops To
         * @see https://tailwindcss.com/docs/gradient-color-stops
         */
        'gradient-to': [
          {
            to: scaleColor(),
          },
        ],
        // ---------------
        // --- Borders ---
        // ---------------
        /**
         * Border Radius
         * @see https://tailwindcss.com/docs/border-radius
         */
        rounded: [
          {
            rounded: scaleRadius(),
          },
        ],
        /**
         * Border Radius Start
         * @see https://tailwindcss.com/docs/border-radius
         */
        'rounded-s': [
          {
            'rounded-s': scaleRadius(),
          },
        ],
        /**
         * Border Radius End
         * @see https://tailwindcss.com/docs/border-radius
         */
        'rounded-e': [
          {
            'rounded-e': scaleRadius(),
          },
        ],
        /**
         * Border Radius Top
         * @see https://tailwindcss.com/docs/border-radius
         */
        'rounded-t': [
          {
            'rounded-t': scaleRadius(),
          },
        ],
        /**
         * Border Radius Right
         * @see https://tailwindcss.com/docs/border-radius
         */
        'rounded-r': [
          {
            'rounded-r': scaleRadius(),
          },
        ],
        /**
         * Border Radius Bottom
         * @see https://tailwindcss.com/docs/border-radius
         */
        'rounded-b': [
          {
            'rounded-b': scaleRadius(),
          },
        ],
        /**
         * Border Radius Left
         * @see https://tailwindcss.com/docs/border-radius
         */
        'rounded-l': [
          {
            'rounded-l': scaleRadius(),
          },
        ],
        /**
         * Border Radius Start Start
         * @see https://tailwindcss.com/docs/border-radius
         */
        'rounded-ss': [
          {
            'rounded-ss': scaleRadius(),
          },
        ],
        /**
         * Border Radius Start End
         * @see https://tailwindcss.com/docs/border-radius
         */
        'rounded-se': [
          {
            'rounded-se': scaleRadius(),
          },
        ],
        /**
         * Border Radius End End
         * @see https://tailwindcss.com/docs/border-radius
         */
        'rounded-ee': [
          {
            'rounded-ee': scaleRadius(),
          },
        ],
        /**
         * Border Radius End Start
         * @see https://tailwindcss.com/docs/border-radius
         */
        'rounded-es': [
          {
            'rounded-es': scaleRadius(),
          },
        ],
        /**
         * Border Radius Top Left
         * @see https://tailwindcss.com/docs/border-radius
         */
        'rounded-tl': [
          {
            'rounded-tl': scaleRadius(),
          },
        ],
        /**
         * Border Radius Top Right
         * @see https://tailwindcss.com/docs/border-radius
         */
        'rounded-tr': [
          {
            'rounded-tr': scaleRadius(),
          },
        ],
        /**
         * Border Radius Bottom Right
         * @see https://tailwindcss.com/docs/border-radius
         */
        'rounded-br': [
          {
            'rounded-br': scaleRadius(),
          },
        ],
        /**
         * Border Radius Bottom Left
         * @see https://tailwindcss.com/docs/border-radius
         */
        'rounded-bl': [
          {
            'rounded-bl': scaleRadius(),
          },
        ],
        /**
         * Border Width
         * @see https://tailwindcss.com/docs/border-width
         */
        'border-w': [
          {
            border: scaleBorderWidth(),
          },
        ],
        /**
         * Border Width X
         * @see https://tailwindcss.com/docs/border-width
         */
        'border-w-x': [
          {
            'border-x': scaleBorderWidth(),
          },
        ],
        /**
         * Border Width Y
         * @see https://tailwindcss.com/docs/border-width
         */
        'border-w-y': [
          {
            'border-y': scaleBorderWidth(),
          },
        ],
        /**
         * Border Width Start
         * @see https://tailwindcss.com/docs/border-width
         */
        'border-w-s': [
          {
            'border-s': scaleBorderWidth(),
          },
        ],
        /**
         * Border Width End
         * @see https://tailwindcss.com/docs/border-width
         */
        'border-w-e': [
          {
            'border-e': scaleBorderWidth(),
          },
        ],
        /**
         * Border Width Top
         * @see https://tailwindcss.com/docs/border-width
         */
        'border-w-t': [
          {
            'border-t': scaleBorderWidth(),
          },
        ],
        /**
         * Border Width Right
         * @see https://tailwindcss.com/docs/border-width
         */
        'border-w-r': [
          {
            'border-r': scaleBorderWidth(),
          },
        ],
        /**
         * Border Width Bottom
         * @see https://tailwindcss.com/docs/border-width
         */
        'border-w-b': [
          {
            'border-b': scaleBorderWidth(),
          },
        ],
        /**
         * Border Width Left
         * @see https://tailwindcss.com/docs/border-width
         */
        'border-w-l': [
          {
            'border-l': scaleBorderWidth(),
          },
        ],
        /**
         * Divide Width X
         * @see https://tailwindcss.com/docs/border-width#between-children
         */
        'divide-x': [
          {
            'divide-x': scaleBorderWidth(),
          },
        ],
        /**
         * Divide Width X Reverse
         * @see https://tailwindcss.com/docs/border-width#between-children
         */
        'divide-x-reverse': ['divide-x-reverse'],
        /**
         * Divide Width Y
         * @see https://tailwindcss.com/docs/border-width#between-children
         */
        'divide-y': [
          {
            'divide-y': scaleBorderWidth(),
          },
        ],
        /**
         * Divide Width Y Reverse
         * @see https://tailwindcss.com/docs/border-width#between-children
         */
        'divide-y-reverse': ['divide-y-reverse'],
        /**
         * Border Style
         * @see https://tailwindcss.com/docs/border-style
         */
        'border-style': [
          {
            border: [...scaleLineStyle(), 'hidden', 'none'],
          },
        ],
        /**
         * Divide Style
         * @see https://tailwindcss.com/docs/border-style#setting-the-divider-style
         */
        'divide-style': [
          {
            divide: [...scaleLineStyle(), 'hidden', 'none'],
          },
        ],
        /**
         * Border Color
         * @see https://tailwindcss.com/docs/border-color
         */
        'border-color': [
          {
            border: scaleColor(),
          },
        ],
        /**
         * Border Color X
         * @see https://tailwindcss.com/docs/border-color
         */
        'border-color-x': [
          {
            'border-x': scaleColor(),
          },
        ],
        /**
         * Border Color Y
         * @see https://tailwindcss.com/docs/border-color
         */
        'border-color-y': [
          {
            'border-y': scaleColor(),
          },
        ],
        /**
         * Border Color S
         * @see https://tailwindcss.com/docs/border-color
         */
        'border-color-s': [
          {
            'border-s': scaleColor(),
          },
        ],
        /**
         * Border Color E
         * @see https://tailwindcss.com/docs/border-color
         */
        'border-color-e': [
          {
            'border-e': scaleColor(),
          },
        ],
        /**
         * Border Color Top
         * @see https://tailwindcss.com/docs/border-color
         */
        'border-color-t': [
          {
            'border-t': scaleColor(),
          },
        ],
        /**
         * Border Color Right
         * @see https://tailwindcss.com/docs/border-color
         */
        'border-color-r': [
          {
            'border-r': scaleColor(),
          },
        ],
        /**
         * Border Color Bottom
         * @see https://tailwindcss.com/docs/border-color
         */
        'border-color-b': [
          {
            'border-b': scaleColor(),
          },
        ],
        /**
         * Border Color Left
         * @see https://tailwindcss.com/docs/border-color
         */
        'border-color-l': [
          {
            'border-l': scaleColor(),
          },
        ],
        /**
         * Divide Color
         * @see https://tailwindcss.com/docs/divide-color
         */
        'divide-color': [
          {
            divide: scaleColor(),
          },
        ],
        /**
         * Outline Style
         * @see https://tailwindcss.com/docs/outline-style
         */
        'outline-style': [
          {
            outline: [...scaleLineStyle(), 'none', 'hidden'],
          },
        ],
        /**
         * Outline Offset
         * @see https://tailwindcss.com/docs/outline-offset
         */
        'outline-offset': [
          {
            'outline-offset': [isNumber, isArbitraryVariable, isArbitraryValue],
          },
        ],
        /**
         * Outline Width
         * @see https://tailwindcss.com/docs/outline-width
         */
        'outline-w': [
          {
            outline: ['', isNumber, isArbitraryVariableLength, isArbitraryLength],
          },
        ],
        /**
         * Outline Color
         * @see https://tailwindcss.com/docs/outline-color
         */
        'outline-color': [
          {
            outline: scaleColor(),
          },
        ],
        // ---------------
        // --- Effects ---
        // ---------------
        /**
         * Box Shadow
         * @see https://tailwindcss.com/docs/box-shadow
         */
        shadow: [
          {
            shadow: [
              // Deprecated since Tailwind CSS v4.0.0
              '',
              'none',
              themeShadow,
              isArbitraryVariableShadow,
              isArbitraryShadow,
            ],
          },
        ],
        /**
         * Box Shadow Color
         * @see https://tailwindcss.com/docs/box-shadow#setting-the-shadow-color
         */
        'shadow-color': [
          {
            shadow: scaleColor(),
          },
        ],
        /**
         * Inset Box Shadow
         * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-shadow
         */
        'inset-shadow': [
          {
            'inset-shadow': [
              'none',
              themeInsetShadow,
              isArbitraryVariableShadow,
              isArbitraryShadow,
            ],
          },
        ],
        /**
         * Inset Box Shadow Color
         * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-shadow-color
         */
        'inset-shadow-color': [
          {
            'inset-shadow': scaleColor(),
          },
        ],
        /**
         * Ring Width
         * @see https://tailwindcss.com/docs/box-shadow#adding-a-ring
         */
        'ring-w': [
          {
            ring: scaleBorderWidth(),
          },
        ],
        /**
         * Ring Width Inset
         * @see https://v3.tailwindcss.com/docs/ring-width#inset-rings
         * @deprecated since Tailwind CSS v4.0.0
         * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
         */
        'ring-w-inset': ['ring-inset'],
        /**
         * Ring Color
         * @see https://tailwindcss.com/docs/box-shadow#setting-the-ring-color
         */
        'ring-color': [
          {
            ring: scaleColor(),
          },
        ],
        /**
         * Ring Offset Width
         * @see https://v3.tailwindcss.com/docs/ring-offset-width
         * @deprecated since Tailwind CSS v4.0.0
         * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
         */
        'ring-offset-w': [
          {
            'ring-offset': [isNumber, isArbitraryLength],
          },
        ],
        /**
         * Ring Offset Color
         * @see https://v3.tailwindcss.com/docs/ring-offset-color
         * @deprecated since Tailwind CSS v4.0.0
         * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
         */
        'ring-offset-color': [
          {
            'ring-offset': scaleColor(),
          },
        ],
        /**
         * Inset Ring Width
         * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-ring
         */
        'inset-ring-w': [
          {
            'inset-ring': scaleBorderWidth(),
          },
        ],
        /**
         * Inset Ring Color
         * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-ring-color
         */
        'inset-ring-color': [
          {
            'inset-ring': scaleColor(),
          },
        ],
        /**
         * Text Shadow
         * @see https://tailwindcss.com/docs/text-shadow
         */
        'text-shadow': [
          {
            'text-shadow': ['none', themeTextShadow, isArbitraryVariableShadow, isArbitraryShadow],
          },
        ],
        /**
         * Text Shadow Color
         * @see https://tailwindcss.com/docs/text-shadow#setting-the-shadow-color
         */
        'text-shadow-color': [
          {
            'text-shadow': scaleColor(),
          },
        ],
        /**
         * Opacity
         * @see https://tailwindcss.com/docs/opacity
         */
        opacity: [
          {
            opacity: [isNumber, isArbitraryVariable, isArbitraryValue],
          },
        ],
        /**
         * Mix Blend Mode
         * @see https://tailwindcss.com/docs/mix-blend-mode
         */
        'mix-blend': [
          {
            'mix-blend': [...scaleBlendMode(), 'plus-darker', 'plus-lighter'],
          },
        ],
        /**
         * Background Blend Mode
         * @see https://tailwindcss.com/docs/background-blend-mode
         */
        'bg-blend': [
          {
            'bg-blend': scaleBlendMode(),
          },
        ],
        /**
         * Mask Clip
         * @see https://tailwindcss.com/docs/mask-clip
         */
        'mask-clip': [
          {
            'mask-clip': ['border', 'padding', 'content', 'fill', 'stroke', 'view'],
          },
          'mask-no-clip',
        ],
        /**
         * Mask Composite
         * @see https://tailwindcss.com/docs/mask-composite
         */
        'mask-composite': [
          {
            mask: ['add', 'subtract', 'intersect', 'exclude'],
          },
        ],
        /**
         * Mask Image
         * @see https://tailwindcss.com/docs/mask-image
         */
        'mask-image-linear-pos': [
          {
            'mask-linear': [isNumber],
          },
        ],
        'mask-image-linear-from-pos': [
          {
            'mask-linear-from': scaleMaskImagePosition(),
          },
        ],
        'mask-image-linear-to-pos': [
          {
            'mask-linear-to': scaleMaskImagePosition(),
          },
        ],
        'mask-image-linear-from-color': [
          {
            'mask-linear-from': scaleColor(),
          },
        ],
        'mask-image-linear-to-color': [
          {
            'mask-linear-to': scaleColor(),
          },
        ],
        'mask-image-t-from-pos': [
          {
            'mask-t-from': scaleMaskImagePosition(),
          },
        ],
        'mask-image-t-to-pos': [
          {
            'mask-t-to': scaleMaskImagePosition(),
          },
        ],
        'mask-image-t-from-color': [
          {
            'mask-t-from': scaleColor(),
          },
        ],
        'mask-image-t-to-color': [
          {
            'mask-t-to': scaleColor(),
          },
        ],
        'mask-image-r-from-pos': [
          {
            'mask-r-from': scaleMaskImagePosition(),
          },
        ],
        'mask-image-r-to-pos': [
          {
            'mask-r-to': scaleMaskImagePosition(),
          },
        ],
        'mask-image-r-from-color': [
          {
            'mask-r-from': scaleColor(),
          },
        ],
        'mask-image-r-to-color': [
          {
            'mask-r-to': scaleColor(),
          },
        ],
        'mask-image-b-from-pos': [
          {
            'mask-b-from': scaleMaskImagePosition(),
          },
        ],
        'mask-image-b-to-pos': [
          {
            'mask-b-to': scaleMaskImagePosition(),
          },
        ],
        'mask-image-b-from-color': [
          {
            'mask-b-from': scaleColor(),
          },
        ],
        'mask-image-b-to-color': [
          {
            'mask-b-to': scaleColor(),
          },
        ],
        'mask-image-l-from-pos': [
          {
            'mask-l-from': scaleMaskImagePosition(),
          },
        ],
        'mask-image-l-to-pos': [
          {
            'mask-l-to': scaleMaskImagePosition(),
          },
        ],
        'mask-image-l-from-color': [
          {
            'mask-l-from': scaleColor(),
          },
        ],
        'mask-image-l-to-color': [
          {
            'mask-l-to': scaleColor(),
          },
        ],
        'mask-image-x-from-pos': [
          {
            'mask-x-from': scaleMaskImagePosition(),
          },
        ],
        'mask-image-x-to-pos': [
          {
            'mask-x-to': scaleMaskImagePosition(),
          },
        ],
        'mask-image-x-from-color': [
          {
            'mask-x-from': scaleColor(),
          },
        ],
        'mask-image-x-to-color': [
          {
            'mask-x-to': scaleColor(),
          },
        ],
        'mask-image-y-from-pos': [
          {
            'mask-y-from': scaleMaskImagePosition(),
          },
        ],
        'mask-image-y-to-pos': [
          {
            'mask-y-to': scaleMaskImagePosition(),
          },
        ],
        'mask-image-y-from-color': [
          {
            'mask-y-from': scaleColor(),
          },
        ],
        'mask-image-y-to-color': [
          {
            'mask-y-to': scaleColor(),
          },
        ],
        'mask-image-radial': [
          {
            'mask-radial': [isArbitraryVariable, isArbitraryValue],
          },
        ],
        'mask-image-radial-from-pos': [
          {
            'mask-radial-from': scaleMaskImagePosition(),
          },
        ],
        'mask-image-radial-to-pos': [
          {
            'mask-radial-to': scaleMaskImagePosition(),
          },
        ],
        'mask-image-radial-from-color': [
          {
            'mask-radial-from': scaleColor(),
          },
        ],
        'mask-image-radial-to-color': [
          {
            'mask-radial-to': scaleColor(),
          },
        ],
        'mask-image-radial-shape': [
          {
            'mask-radial': ['circle', 'ellipse'],
          },
        ],
        'mask-image-radial-size': [
          {
            'mask-radial': [
              {
                closest: ['side', 'corner'],
                farthest: ['side', 'corner'],
              },
            ],
          },
        ],
        'mask-image-radial-pos': [
          {
            'mask-radial-at': scalePosition(),
          },
        ],
        'mask-image-conic-pos': [
          {
            'mask-conic': [isNumber],
          },
        ],
        'mask-image-conic-from-pos': [
          {
            'mask-conic-from': scaleMaskImagePosition(),
          },
        ],
        'mask-image-conic-to-pos': [
          {
            'mask-conic-to': scaleMaskImagePosition(),
          },
        ],
        'mask-image-conic-from-color': [
          {
            'mask-conic-from': scaleColor(),
          },
        ],
        'mask-image-conic-to-color': [
          {
            'mask-conic-to': scaleColor(),
          },
        ],
        /**
         * Mask Mode
         * @see https://tailwindcss.com/docs/mask-mode
         */
        'mask-mode': [
          {
            mask: ['alpha', 'luminance', 'match'],
          },
        ],
        /**
         * Mask Origin
         * @see https://tailwindcss.com/docs/mask-origin
         */
        'mask-origin': [
          {
            'mask-origin': ['border', 'padding', 'content', 'fill', 'stroke', 'view'],
          },
        ],
        /**
         * Mask Position
         * @see https://tailwindcss.com/docs/mask-position
         */
        'mask-position': [
          {
            mask: scaleBgPosition(),
          },
        ],
        /**
         * Mask Repeat
         * @see https://tailwindcss.com/docs/mask-repeat
         */
        'mask-repeat': [
          {
            mask: scaleBgRepeat(),
          },
        ],
        /**
         * Mask Size
         * @see https://tailwindcss.com/docs/mask-size
         */
        'mask-size': [
          {
            mask: scaleBgSize(),
          },
        ],
        /**
         * Mask Type
         * @see https://tailwindcss.com/docs/mask-type
         */
        'mask-type': [
          {
            'mask-type': ['alpha', 'luminance'],
          },
        ],
        /**
         * Mask Image
         * @see https://tailwindcss.com/docs/mask-image
         */
        'mask-image': [
          {
            mask: ['none', isArbitraryVariable, isArbitraryValue],
          },
        ],
        // ---------------
        // --- Filters ---
        // ---------------
        /**
         * Filter
         * @see https://tailwindcss.com/docs/filter
         */
        filter: [
          {
            filter: [
              // Deprecated since Tailwind CSS v3.0.0
              '',
              'none',
              isArbitraryVariable,
              isArbitraryValue,
            ],
          },
        ],
        /**
         * Blur
         * @see https://tailwindcss.com/docs/blur
         */
        blur: [
          {
            blur: scaleBlur(),
          },
        ],
        /**
         * Brightness
         * @see https://tailwindcss.com/docs/brightness
         */
        brightness: [
          {
            brightness: [isNumber, isArbitraryVariable, isArbitraryValue],
          },
        ],
        /**
         * Contrast
         * @see https://tailwindcss.com/docs/contrast
         */
        contrast: [
          {
            contrast: [isNumber, isArbitraryVariable, isArbitraryValue],
          },
        ],
        /**
         * Drop Shadow
         * @see https://tailwindcss.com/docs/drop-shadow
         */
        'drop-shadow': [
          {
            'drop-shadow': [
              // Deprecated since Tailwind CSS v4.0.0
              '',
              'none',
              themeDropShadow,
              isArbitraryVariableShadow,
              isArbitraryShadow,
            ],
          },
        ],
        /**
         * Drop Shadow Color
         * @see https://tailwindcss.com/docs/filter-drop-shadow#setting-the-shadow-color
         */
        'drop-shadow-color': [
          {
            'drop-shadow': scaleColor(),
          },
        ],
        /**
         * Grayscale
         * @see https://tailwindcss.com/docs/grayscale
         */
        grayscale: [
          {
            grayscale: ['', isNumber, isArbitraryVariable, isArbitraryValue],
          },
        ],
        /**
         * Hue Rotate
         * @see https://tailwindcss.com/docs/hue-rotate
         */
        'hue-rotate': [
          {
            'hue-rotate': [isNumber, isArbitraryVariable, isArbitraryValue],
          },
        ],
        /**
         * Invert
         * @see https://tailwindcss.com/docs/invert
         */
        invert: [
          {
            invert: ['', isNumber, isArbitraryVariable, isArbitraryValue],
          },
        ],
        /**
         * Saturate
         * @see https://tailwindcss.com/docs/saturate
         */
        saturate: [
          {
            saturate: [isNumber, isArbitraryVariable, isArbitraryValue],
          },
        ],
        /**
         * Sepia
         * @see https://tailwindcss.com/docs/sepia
         */
        sepia: [
          {
            sepia: ['', isNumber, isArbitraryVariable, isArbitraryValue],
          },
        ],
        /**
         * Backdrop Filter
         * @see https://tailwindcss.com/docs/backdrop-filter
         */
        'backdrop-filter': [
          {
            'backdrop-filter': [
              // Deprecated since Tailwind CSS v3.0.0
              '',
              'none',
              isArbitraryVariable,
              isArbitraryValue,
            ],
          },
        ],
        /**
         * Backdrop Blur
         * @see https://tailwindcss.com/docs/backdrop-blur
         */
        'backdrop-blur': [
          {
            'backdrop-blur': scaleBlur(),
          },
        ],
        /**
         * Backdrop Brightness
         * @see https://tailwindcss.com/docs/backdrop-brightness
         */
        'backdrop-brightness': [
          {
            'backdrop-brightness': [isNumber, isArbitraryVariable, isArbitraryValue],
          },
        ],
        /**
         * Backdrop Contrast
         * @see https://tailwindcss.com/docs/backdrop-contrast
         */
        'backdrop-contrast': [
          {
            'backdrop-contrast': [isNumber, isArbitraryVariable, isArbitraryValue],
          },
        ],
        /**
         * Backdrop Grayscale
         * @see https://tailwindcss.com/docs/backdrop-grayscale
         */
        'backdrop-grayscale': [
          {
            'backdrop-grayscale': ['', isNumber, isArbitraryVariable, isArbitraryValue],
          },
        ],
        /**
         * Backdrop Hue Rotate
         * @see https://tailwindcss.com/docs/backdrop-hue-rotate
         */
        'backdrop-hue-rotate': [
          {
            'backdrop-hue-rotate': [isNumber, isArbitraryVariable, isArbitraryValue],
          },
        ],
        /**
         * Backdrop Invert
         * @see https://tailwindcss.com/docs/backdrop-invert
         */
        'backdrop-invert': [
          {
            'backdrop-invert': ['', isNumber, isArbitraryVariable, isArbitraryValue],
          },
        ],
        /**
         * Backdrop Opacity
         * @see https://tailwindcss.com/docs/backdrop-opacity
         */
        'backdrop-opacity': [
          {
            'backdrop-opacity': [isNumber, isArbitraryVariable, isArbitraryValue],
          },
        ],
        /**
         * Backdrop Saturate
         * @see https://tailwindcss.com/docs/backdrop-saturate
         */
        'backdrop-saturate': [
          {
            'backdrop-saturate': [isNumber, isArbitraryVariable, isArbitraryValue],
          },
        ],
        /**
         * Backdrop Sepia
         * @see https://tailwindcss.com/docs/backdrop-sepia
         */
        'backdrop-sepia': [
          {
            'backdrop-sepia': ['', isNumber, isArbitraryVariable, isArbitraryValue],
          },
        ],
        // --------------
        // --- Tables ---
        // --------------
        /**
         * Border Collapse
         * @see https://tailwindcss.com/docs/border-collapse
         */
        'border-collapse': [
          {
            border: ['collapse', 'separate'],
          },
        ],
        /**
         * Border Spacing
         * @see https://tailwindcss.com/docs/border-spacing
         */
        'border-spacing': [
          {
            'border-spacing': scaleUnambiguousSpacing(),
          },
        ],
        /**
         * Border Spacing X
         * @see https://tailwindcss.com/docs/border-spacing
         */
        'border-spacing-x': [
          {
            'border-spacing-x': scaleUnambiguousSpacing(),
          },
        ],
        /**
         * Border Spacing Y
         * @see https://tailwindcss.com/docs/border-spacing
         */
        'border-spacing-y': [
          {
            'border-spacing-y': scaleUnambiguousSpacing(),
          },
        ],
        /**
         * Table Layout
         * @see https://tailwindcss.com/docs/table-layout
         */
        'table-layout': [
          {
            table: ['auto', 'fixed'],
          },
        ],
        /**
         * Caption Side
         * @see https://tailwindcss.com/docs/caption-side
         */
        caption: [
          {
            caption: ['top', 'bottom'],
          },
        ],
        // ---------------------------------
        // --- Transitions and Animation ---
        // ---------------------------------
        /**
         * Transition Property
         * @see https://tailwindcss.com/docs/transition-property
         */
        transition: [
          {
            transition: [
              '',
              'all',
              'colors',
              'opacity',
              'shadow',
              'transform',
              'none',
              isArbitraryVariable,
              isArbitraryValue,
            ],
          },
        ],
        /**
         * Transition Behavior
         * @see https://tailwindcss.com/docs/transition-behavior
         */
        'transition-behavior': [
          {
            transition: ['normal', 'discrete'],
          },
        ],
        /**
         * Transition Duration
         * @see https://tailwindcss.com/docs/transition-duration
         */
        duration: [
          {
            duration: [isNumber, 'initial', isArbitraryVariable, isArbitraryValue],
          },
        ],
        /**
         * Transition Timing Function
         * @see https://tailwindcss.com/docs/transition-timing-function
         */
        ease: [
          {
            ease: ['linear', 'initial', themeEase, isArbitraryVariable, isArbitraryValue],
          },
        ],
        /**
         * Transition Delay
         * @see https://tailwindcss.com/docs/transition-delay
         */
        delay: [
          {
            delay: [isNumber, isArbitraryVariable, isArbitraryValue],
          },
        ],
        /**
         * Animation
         * @see https://tailwindcss.com/docs/animation
         */
        animate: [
          {
            animate: ['none', themeAnimate, isArbitraryVariable, isArbitraryValue],
          },
        ],
        // ------------------
        // --- Transforms ---
        // ------------------
        /**
         * Backface Visibility
         * @see https://tailwindcss.com/docs/backface-visibility
         */
        backface: [
          {
            backface: ['hidden', 'visible'],
          },
        ],
        /**
         * Perspective
         * @see https://tailwindcss.com/docs/perspective
         */
        perspective: [
          {
            perspective: [themePerspective, isArbitraryVariable, isArbitraryValue],
          },
        ],
        /**
         * Perspective Origin
         * @see https://tailwindcss.com/docs/perspective-origin
         */
        'perspective-origin': [
          {
            'perspective-origin': scalePositionWithArbitrary(),
          },
        ],
        /**
         * Rotate
         * @see https://tailwindcss.com/docs/rotate
         */
        rotate: [
          {
            rotate: scaleRotate(),
          },
        ],
        /**
         * Rotate X
         * @see https://tailwindcss.com/docs/rotate
         */
        'rotate-x': [
          {
            'rotate-x': scaleRotate(),
          },
        ],
        /**
         * Rotate Y
         * @see https://tailwindcss.com/docs/rotate
         */
        'rotate-y': [
          {
            'rotate-y': scaleRotate(),
          },
        ],
        /**
         * Rotate Z
         * @see https://tailwindcss.com/docs/rotate
         */
        'rotate-z': [
          {
            'rotate-z': scaleRotate(),
          },
        ],
        /**
         * Scale
         * @see https://tailwindcss.com/docs/scale
         */
        scale: [
          {
            scale: scaleScale(),
          },
        ],
        /**
         * Scale X
         * @see https://tailwindcss.com/docs/scale
         */
        'scale-x': [
          {
            'scale-x': scaleScale(),
          },
        ],
        /**
         * Scale Y
         * @see https://tailwindcss.com/docs/scale
         */
        'scale-y': [
          {
            'scale-y': scaleScale(),
          },
        ],
        /**
         * Scale Z
         * @see https://tailwindcss.com/docs/scale
         */
        'scale-z': [
          {
            'scale-z': scaleScale(),
          },
        ],
        /**
         * Scale 3D
         * @see https://tailwindcss.com/docs/scale
         */
        'scale-3d': ['scale-3d'],
        /**
         * Skew
         * @see https://tailwindcss.com/docs/skew
         */
        skew: [
          {
            skew: scaleSkew(),
          },
        ],
        /**
         * Skew X
         * @see https://tailwindcss.com/docs/skew
         */
        'skew-x': [
          {
            'skew-x': scaleSkew(),
          },
        ],
        /**
         * Skew Y
         * @see https://tailwindcss.com/docs/skew
         */
        'skew-y': [
          {
            'skew-y': scaleSkew(),
          },
        ],
        /**
         * Transform
         * @see https://tailwindcss.com/docs/transform
         */
        transform: [
          {
            transform: [isArbitraryVariable, isArbitraryValue, '', 'none', 'gpu', 'cpu'],
          },
        ],
        /**
         * Transform Origin
         * @see https://tailwindcss.com/docs/transform-origin
         */
        'transform-origin': [
          {
            origin: scalePositionWithArbitrary(),
          },
        ],
        /**
         * Transform Style
         * @see https://tailwindcss.com/docs/transform-style
         */
        'transform-style': [
          {
            transform: ['3d', 'flat'],
          },
        ],
        /**
         * Translate
         * @see https://tailwindcss.com/docs/translate
         */
        translate: [
          {
            translate: scaleTranslate(),
          },
        ],
        /**
         * Translate X
         * @see https://tailwindcss.com/docs/translate
         */
        'translate-x': [
          {
            'translate-x': scaleTranslate(),
          },
        ],
        /**
         * Translate Y
         * @see https://tailwindcss.com/docs/translate
         */
        'translate-y': [
          {
            'translate-y': scaleTranslate(),
          },
        ],
        /**
         * Translate Z
         * @see https://tailwindcss.com/docs/translate
         */
        'translate-z': [
          {
            'translate-z': scaleTranslate(),
          },
        ],
        /**
         * Translate None
         * @see https://tailwindcss.com/docs/translate
         */
        'translate-none': ['translate-none'],
        // ---------------------
        // --- Interactivity ---
        // ---------------------
        /**
         * Accent Color
         * @see https://tailwindcss.com/docs/accent-color
         */
        accent: [
          {
            accent: scaleColor(),
          },
        ],
        /**
         * Appearance
         * @see https://tailwindcss.com/docs/appearance
         */
        appearance: [
          {
            appearance: ['none', 'auto'],
          },
        ],
        /**
         * Caret Color
         * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
         */
        'caret-color': [
          {
            caret: scaleColor(),
          },
        ],
        /**
         * Color Scheme
         * @see https://tailwindcss.com/docs/color-scheme
         */
        'color-scheme': [
          {
            scheme: ['normal', 'dark', 'light', 'light-dark', 'only-dark', 'only-light'],
          },
        ],
        /**
         * Cursor
         * @see https://tailwindcss.com/docs/cursor
         */
        cursor: [
          {
            cursor: [
              'auto',
              'default',
              'pointer',
              'wait',
              'text',
              'move',
              'help',
              'not-allowed',
              'none',
              'context-menu',
              'progress',
              'cell',
              'crosshair',
              'vertical-text',
              'alias',
              'copy',
              'no-drop',
              'grab',
              'grabbing',
              'all-scroll',
              'col-resize',
              'row-resize',
              'n-resize',
              'e-resize',
              's-resize',
              'w-resize',
              'ne-resize',
              'nw-resize',
              'se-resize',
              'sw-resize',
              'ew-resize',
              'ns-resize',
              'nesw-resize',
              'nwse-resize',
              'zoom-in',
              'zoom-out',
              isArbitraryVariable,
              isArbitraryValue,
            ],
          },
        ],
        /**
         * Field Sizing
         * @see https://tailwindcss.com/docs/field-sizing
         */
        'field-sizing': [
          {
            'field-sizing': ['fixed', 'content'],
          },
        ],
        /**
         * Pointer Events
         * @see https://tailwindcss.com/docs/pointer-events
         */
        'pointer-events': [
          {
            'pointer-events': ['auto', 'none'],
          },
        ],
        /**
         * Resize
         * @see https://tailwindcss.com/docs/resize
         */
        resize: [
          {
            resize: ['none', '', 'y', 'x'],
          },
        ],
        /**
         * Scroll Behavior
         * @see https://tailwindcss.com/docs/scroll-behavior
         */
        'scroll-behavior': [
          {
            scroll: ['auto', 'smooth'],
          },
        ],
        /**
         * Scroll Margin
         * @see https://tailwindcss.com/docs/scroll-margin
         */
        'scroll-m': [
          {
            'scroll-m': scaleUnambiguousSpacing(),
          },
        ],
        /**
         * Scroll Margin X
         * @see https://tailwindcss.com/docs/scroll-margin
         */
        'scroll-mx': [
          {
            'scroll-mx': scaleUnambiguousSpacing(),
          },
        ],
        /**
         * Scroll Margin Y
         * @see https://tailwindcss.com/docs/scroll-margin
         */
        'scroll-my': [
          {
            'scroll-my': scaleUnambiguousSpacing(),
          },
        ],
        /**
         * Scroll Margin Start
         * @see https://tailwindcss.com/docs/scroll-margin
         */
        'scroll-ms': [
          {
            'scroll-ms': scaleUnambiguousSpacing(),
          },
        ],
        /**
         * Scroll Margin End
         * @see https://tailwindcss.com/docs/scroll-margin
         */
        'scroll-me': [
          {
            'scroll-me': scaleUnambiguousSpacing(),
          },
        ],
        /**
         * Scroll Margin Top
         * @see https://tailwindcss.com/docs/scroll-margin
         */
        'scroll-mt': [
          {
            'scroll-mt': scaleUnambiguousSpacing(),
          },
        ],
        /**
         * Scroll Margin Right
         * @see https://tailwindcss.com/docs/scroll-margin
         */
        'scroll-mr': [
          {
            'scroll-mr': scaleUnambiguousSpacing(),
          },
        ],
        /**
         * Scroll Margin Bottom
         * @see https://tailwindcss.com/docs/scroll-margin
         */
        'scroll-mb': [
          {
            'scroll-mb': scaleUnambiguousSpacing(),
          },
        ],
        /**
         * Scroll Margin Left
         * @see https://tailwindcss.com/docs/scroll-margin
         */
        'scroll-ml': [
          {
            'scroll-ml': scaleUnambiguousSpacing(),
          },
        ],
        /**
         * Scroll Padding
         * @see https://tailwindcss.com/docs/scroll-padding
         */
        'scroll-p': [
          {
            'scroll-p': scaleUnambiguousSpacing(),
          },
        ],
        /**
         * Scroll Padding X
         * @see https://tailwindcss.com/docs/scroll-padding
         */
        'scroll-px': [
          {
            'scroll-px': scaleUnambiguousSpacing(),
          },
        ],
        /**
         * Scroll Padding Y
         * @see https://tailwindcss.com/docs/scroll-padding
         */
        'scroll-py': [
          {
            'scroll-py': scaleUnambiguousSpacing(),
          },
        ],
        /**
         * Scroll Padding Start
         * @see https://tailwindcss.com/docs/scroll-padding
         */
        'scroll-ps': [
          {
            'scroll-ps': scaleUnambiguousSpacing(),
          },
        ],
        /**
         * Scroll Padding End
         * @see https://tailwindcss.com/docs/scroll-padding
         */
        'scroll-pe': [
          {
            'scroll-pe': scaleUnambiguousSpacing(),
          },
        ],
        /**
         * Scroll Padding Top
         * @see https://tailwindcss.com/docs/scroll-padding
         */
        'scroll-pt': [
          {
            'scroll-pt': scaleUnambiguousSpacing(),
          },
        ],
        /**
         * Scroll Padding Right
         * @see https://tailwindcss.com/docs/scroll-padding
         */
        'scroll-pr': [
          {
            'scroll-pr': scaleUnambiguousSpacing(),
          },
        ],
        /**
         * Scroll Padding Bottom
         * @see https://tailwindcss.com/docs/scroll-padding
         */
        'scroll-pb': [
          {
            'scroll-pb': scaleUnambiguousSpacing(),
          },
        ],
        /**
         * Scroll Padding Left
         * @see https://tailwindcss.com/docs/scroll-padding
         */
        'scroll-pl': [
          {
            'scroll-pl': scaleUnambiguousSpacing(),
          },
        ],
        /**
         * Scroll Snap Align
         * @see https://tailwindcss.com/docs/scroll-snap-align
         */
        'snap-align': [
          {
            snap: ['start', 'end', 'center', 'align-none'],
          },
        ],
        /**
         * Scroll Snap Stop
         * @see https://tailwindcss.com/docs/scroll-snap-stop
         */
        'snap-stop': [
          {
            snap: ['normal', 'always'],
          },
        ],
        /**
         * Scroll Snap Type
         * @see https://tailwindcss.com/docs/scroll-snap-type
         */
        'snap-type': [
          {
            snap: ['none', 'x', 'y', 'both'],
          },
        ],
        /**
         * Scroll Snap Type Strictness
         * @see https://tailwindcss.com/docs/scroll-snap-type
         */
        'snap-strictness': [
          {
            snap: ['mandatory', 'proximity'],
          },
        ],
        /**
         * Touch Action
         * @see https://tailwindcss.com/docs/touch-action
         */
        touch: [
          {
            touch: ['auto', 'none', 'manipulation'],
          },
        ],
        /**
         * Touch Action X
         * @see https://tailwindcss.com/docs/touch-action
         */
        'touch-x': [
          {
            'touch-pan': ['x', 'left', 'right'],
          },
        ],
        /**
         * Touch Action Y
         * @see https://tailwindcss.com/docs/touch-action
         */
        'touch-y': [
          {
            'touch-pan': ['y', 'up', 'down'],
          },
        ],
        /**
         * Touch Action Pinch Zoom
         * @see https://tailwindcss.com/docs/touch-action
         */
        'touch-pz': ['touch-pinch-zoom'],
        /**
         * User Select
         * @see https://tailwindcss.com/docs/user-select
         */
        select: [
          {
            select: ['none', 'text', 'all', 'auto'],
          },
        ],
        /**
         * Will Change
         * @see https://tailwindcss.com/docs/will-change
         */
        'will-change': [
          {
            'will-change': [
              'auto',
              'scroll',
              'contents',
              'transform',
              isArbitraryVariable,
              isArbitraryValue,
            ],
          },
        ],
        // -----------
        // --- SVG ---
        // -----------
        /**
         * Fill
         * @see https://tailwindcss.com/docs/fill
         */
        fill: [
          {
            fill: ['none', ...scaleColor()],
          },
        ],
        /**
         * Stroke Width
         * @see https://tailwindcss.com/docs/stroke-width
         */
        'stroke-w': [
          {
            stroke: [isNumber, isArbitraryVariableLength, isArbitraryLength, isArbitraryNumber],
          },
        ],
        /**
         * Stroke
         * @see https://tailwindcss.com/docs/stroke
         */
        stroke: [
          {
            stroke: ['none', ...scaleColor()],
          },
        ],
        // ---------------------
        // --- Accessibility ---
        // ---------------------
        /**
         * Forced Color Adjust
         * @see https://tailwindcss.com/docs/forced-color-adjust
         */
        'forced-color-adjust': [
          {
            'forced-color-adjust': ['auto', 'none'],
          },
        ],
      },
      conflictingClassGroups: {
        overflow: ['overflow-x', 'overflow-y'],
        overscroll: ['overscroll-x', 'overscroll-y'],
        inset: ['inset-x', 'inset-y', 'start', 'end', 'top', 'right', 'bottom', 'left'],
        'inset-x': ['right', 'left'],
        'inset-y': ['top', 'bottom'],
        flex: ['basis', 'grow', 'shrink'],
        gap: ['gap-x', 'gap-y'],
        p: ['px', 'py', 'ps', 'pe', 'pt', 'pr', 'pb', 'pl'],
        px: ['pr', 'pl'],
        py: ['pt', 'pb'],
        m: ['mx', 'my', 'ms', 'me', 'mt', 'mr', 'mb', 'ml'],
        mx: ['mr', 'ml'],
        my: ['mt', 'mb'],
        size: ['w', 'h'],
        'font-size': ['leading'],
        'fvn-normal': [
          'fvn-ordinal',
          'fvn-slashed-zero',
          'fvn-figure',
          'fvn-spacing',
          'fvn-fraction',
        ],
        'fvn-ordinal': ['fvn-normal'],
        'fvn-slashed-zero': ['fvn-normal'],
        'fvn-figure': ['fvn-normal'],
        'fvn-spacing': ['fvn-normal'],
        'fvn-fraction': ['fvn-normal'],
        'line-clamp': ['display', 'overflow'],
        rounded: [
          'rounded-s',
          'rounded-e',
          'rounded-t',
          'rounded-r',
          'rounded-b',
          'rounded-l',
          'rounded-ss',
          'rounded-se',
          'rounded-ee',
          'rounded-es',
          'rounded-tl',
          'rounded-tr',
          'rounded-br',
          'rounded-bl',
        ],
        'rounded-s': ['rounded-ss', 'rounded-es'],
        'rounded-e': ['rounded-se', 'rounded-ee'],
        'rounded-t': ['rounded-tl', 'rounded-tr'],
        'rounded-r': ['rounded-tr', 'rounded-br'],
        'rounded-b': ['rounded-br', 'rounded-bl'],
        'rounded-l': ['rounded-tl', 'rounded-bl'],
        'border-spacing': ['border-spacing-x', 'border-spacing-y'],
        'border-w': [
          'border-w-x',
          'border-w-y',
          'border-w-s',
          'border-w-e',
          'border-w-t',
          'border-w-r',
          'border-w-b',
          'border-w-l',
        ],
        'border-w-x': ['border-w-r', 'border-w-l'],
        'border-w-y': ['border-w-t', 'border-w-b'],
        'border-color': [
          'border-color-x',
          'border-color-y',
          'border-color-s',
          'border-color-e',
          'border-color-t',
          'border-color-r',
          'border-color-b',
          'border-color-l',
        ],
        'border-color-x': ['border-color-r', 'border-color-l'],
        'border-color-y': ['border-color-t', 'border-color-b'],
        translate: ['translate-x', 'translate-y', 'translate-none'],
        'translate-none': ['translate', 'translate-x', 'translate-y', 'translate-z'],
        'scroll-m': [
          'scroll-mx',
          'scroll-my',
          'scroll-ms',
          'scroll-me',
          'scroll-mt',
          'scroll-mr',
          'scroll-mb',
          'scroll-ml',
        ],
        'scroll-mx': ['scroll-mr', 'scroll-ml'],
        'scroll-my': ['scroll-mt', 'scroll-mb'],
        'scroll-p': [
          'scroll-px',
          'scroll-py',
          'scroll-ps',
          'scroll-pe',
          'scroll-pt',
          'scroll-pr',
          'scroll-pb',
          'scroll-pl',
        ],
        'scroll-px': ['scroll-pr', 'scroll-pl'],
        'scroll-py': ['scroll-pt', 'scroll-pb'],
        touch: ['touch-x', 'touch-y', 'touch-pz'],
        'touch-x': ['touch'],
        'touch-y': ['touch'],
        'touch-pz': ['touch'],
      },
      conflictingClassGroupModifiers: {
        'font-size': ['leading'],
      },
      orderSensitiveModifiers: [
        '*',
        '**',
        'after',
        'backdrop',
        'before',
        'details-content',
        'file',
        'first-letter',
        'first-line',
        'marker',
        'placeholder',
        'selection',
      ],
    };
  };

  /**
   * @param baseConfig Config where other config will be merged into. This object will be mutated.
   * @param configExtension Partial config to merge into the `baseConfig`.
   */
  const mergeConfigs = (
    baseConfig,
    { cacheSize, prefix, experimentalParseClassName, extend = {}, override = {} }
  ) => {
    overrideProperty(baseConfig, 'cacheSize', cacheSize);
    overrideProperty(baseConfig, 'prefix', prefix);
    overrideProperty(baseConfig, 'experimentalParseClassName', experimentalParseClassName);
    overrideConfigProperties(baseConfig.theme, override.theme);
    overrideConfigProperties(baseConfig.classGroups, override.classGroups);
    overrideConfigProperties(baseConfig.conflictingClassGroups, override.conflictingClassGroups);
    overrideConfigProperties(
      baseConfig.conflictingClassGroupModifiers,
      override.conflictingClassGroupModifiers
    );
    overrideProperty(baseConfig, 'orderSensitiveModifiers', override.orderSensitiveModifiers);
    mergeConfigProperties(baseConfig.theme, extend.theme);
    mergeConfigProperties(baseConfig.classGroups, extend.classGroups);
    mergeConfigProperties(baseConfig.conflictingClassGroups, extend.conflictingClassGroups);
    mergeConfigProperties(
      baseConfig.conflictingClassGroupModifiers,
      extend.conflictingClassGroupModifiers
    );
    mergeArrayProperties(baseConfig, extend, 'orderSensitiveModifiers');
    return baseConfig;
  };
  const overrideProperty = (baseObject, overrideKey, overrideValue) => {
    if (overrideValue !== undefined) {
      baseObject[overrideKey] = overrideValue;
    }
  };
  const overrideConfigProperties = (baseObject, overrideObject) => {
    if (overrideObject) {
      for (const key in overrideObject) {
        overrideProperty(baseObject, key, overrideObject[key]);
      }
    }
  };
  const mergeConfigProperties = (baseObject, mergeObject) => {
    if (mergeObject) {
      for (const key in mergeObject) {
        mergeArrayProperties(baseObject, mergeObject, key);
      }
    }
  };
  const mergeArrayProperties = (baseObject, mergeObject, key) => {
    const mergeValue = mergeObject[key];
    if (mergeValue !== undefined) {
      baseObject[key] = baseObject[key] ? baseObject[key].concat(mergeValue) : mergeValue;
    }
  };
  const extendTailwindMerge = (configExtension, ...createConfig) =>
    typeof configExtension === 'function'
      ? createTailwindMerge(getDefaultConfig, configExtension, ...createConfig)
      : createTailwindMerge(
          () => mergeConfigs(getDefaultConfig(), configExtension),
          ...createConfig
        );
  const twMerge = /*#__PURE__*/ createTailwindMerge(getDefaultConfig); // ./lib/utils.ts

  //# sourceMappingURL=bundle-mjs.mjs.map

  const utils_CONFIG_ENDPOINT = 'MISSING_ENV_VAR'.NEXT_PUBLIC_APP_CONFIG_ENDPOINT;
  const utils_SANDBOX_ID = 'MISSING_ENV_VAR'.SANDBOX_ID;
  const utils_THEME_STORAGE_KEY = 'theme-mode';
  const utils_THEME_MEDIA_QUERY = '(prefers-color-scheme: dark)';
  function utils_cn(...inputs) {
    return twMerge(clsx(inputs));
  }
  // https://react.dev/reference/react/cache#caveats
  // > React will invalidate the cache for all memoized functions for each server request.
  const utils_getAppConfig = (0, react.cache)(async (headers) => {
    var _a;
    if (utils_CONFIG_ENDPOINT) {
      const sandboxId =
        (_a =
          utils_SANDBOX_ID !== null && utils_SANDBOX_ID !== void 0
            ? utils_SANDBOX_ID
            : headers.get('x-sandbox-id')) !== null && _a !== void 0
          ? _a
          : '';
      try {
        if (!sandboxId) {
          throw new Error('Sandbox ID is required');
        }
        const response = await fetch(utils_CONFIG_ENDPOINT, {
          cache: 'no-store',
          headers: { 'X-Sandbox-ID': sandboxId },
        });
        if (response.ok) {
          const remoteConfig = await response.json();
          const config = Object.assign(Object.assign({}, APP_CONFIG_DEFAULTS), { sandboxId });
          for (const [key, entry] of Object.entries(remoteConfig)) {
            if (entry === null) continue;
            // Only include app config entries that are declared in defaults and, if set,
            // share the same primitive type as the default value.
            if (
              (key in APP_CONFIG_DEFAULTS && APP_CONFIG_DEFAULTS[key] === undefined) ||
              (typeof config[key] === entry.type && typeof config[key] === typeof entry.value)
            ) {
              // @ts-expect-error I'm not sure quite how to appease TypeScript, but we've thoroughly checked types above
              config[key] = entry.value;
            }
          }
          return config;
        } else {
          console.error(
            `ERROR: querying config endpoint failed with status ${response.status}: ${response.statusText}`
          );
        }
      } catch (error) {
        console.error('ERROR: getAppConfig() - lib/utils.ts', error);
      }
    }
    return APP_CONFIG_DEFAULTS;
  });
  // check provided accent colors against defaults
  // apply styles if they differ (or in development mode)
  // generate a hover color for the accent color by mixing it with 20% black
  function getStyles(appConfig) {
    const { accent, accentDark } = appConfig;
    return [
      accent
        ? `:root { --primary: ${accent}; --primary-hover: color-mix(in srgb, ${accent} 80%, #000); }`
        : '',
      accentDark
        ? `.dark { --primary: ${accentDark}; --primary-hover: color-mix(in srgb, ${accentDark} 80%, #000); }`
        : '',
    ]
      .filter(Boolean)
      .join('\n');
  }
  function transcriptionToChatMessage(textStream, room) {
    return {
      id: textStream.streamInfo.id,
      timestamp: textStream.streamInfo.timestamp,
      message: textStream.text,
      from:
        textStream.participantInfo.identity === room.localParticipant.identity
          ? room.localParticipant
          : Array.from(room.remoteParticipants.values()).find(
              (p) => p.identity === textStream.participantInfo.identity
            ),
    };
  } // ./components/embed-popup/error-message.tsx

  function ErrorMessage({ error }) {
    return (0, jsx_runtime.jsxs)('div', {
      inert: error === null,
      className: utils_cn(
        'absolute inset-0 z-50 flex h-full w-full flex-col items-center justify-center gap-5 transition-opacity',
        error === null ? 'opacity-0' : 'opacity-100'
      ),
      children: [
        (0, jsx_runtime.jsxs)('div', {
          className: 'pl-3',
          children: [
            (0, jsx_runtime.jsx)('img', {
              src: '/lk-logo.svg',
              alt: 'LiveKit Logo',
              className: 'block size-6 dark:hidden',
            }),
            (0, jsx_runtime.jsx)('img', {
              src: '/lk-logo-dark.svg',
              alt: 'LiveKit Logo',
              className: 'hidden size-6 dark:block',
            }),
          ],
        }),
        (0, jsx_runtime.jsxs)('div', {
          className: 'flex w-full flex-col justify-center gap-4 overflow-auto px-8 text-center',
          children: [
            (0, jsx_runtime.jsx)('span', {
              className: 'leading-tight font-medium text-pretty',
              children: error === null || error === void 0 ? void 0 : error.title,
            }),
            (0, jsx_runtime.jsx)('span', {
              className: 'text-sm text-balance',
              children: error === null || error === void 0 ? void 0 : error.description,
            }),
          ],
        }),
      ],
    });
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/components/AnimatePresence/PopChild.mjs

  ('use client');

  /**
   * Measurement functionality has to be within a separate component
   * to leverage snapshot lifecycle.
   */
  class PopChildMeasure extends react.Component {
    getSnapshotBeforeUpdate(prevProps) {
      const element = this.props.childRef.current;
      if (element && prevProps.isPresent && !this.props.isPresent) {
        const parent = element.offsetParent;
        const parentWidth = isHTMLElement(parent) ? parent.offsetWidth || 0 : 0;
        const size = this.props.sizeRef.current;
        size.height = element.offsetHeight || 0;
        size.width = element.offsetWidth || 0;
        size.top = element.offsetTop;
        size.left = element.offsetLeft;
        size.right = parentWidth - size.width - size.left;
      }
      return null;
    }
    /**
     * Required with getSnapshotBeforeUpdate to stop React complaining.
     */
    componentDidUpdate() {}
    render() {
      return this.props.children;
    }
  }
  function PopChild({ children, isPresent, anchorX }) {
    const id = (0, react.useId)();
    const ref = (0, react.useRef)(null);
    const size = (0, react.useRef)({
      width: 0,
      height: 0,
      top: 0,
      left: 0,
      right: 0,
    });
    const { nonce } = (0, react.useContext)(MotionConfigContext);
    /**
     * We create and inject a style block so we can apply this explicit
     * sizing in a non-destructive manner by just deleting the style block.
     *
     * We can't apply size via render as the measurement happens
     * in getSnapshotBeforeUpdate (post-render), likewise if we apply the
     * styles directly on the DOM node, we might be overwriting
     * styles set via the style prop.
     */
    (0, react.useInsertionEffect)(() => {
      const { width, height, top, left, right } = size.current;
      if (isPresent || !ref.current || !width || !height) return;
      const x = anchorX === 'left' ? `left: ${left}` : `right: ${right}`;
      ref.current.dataset.motionPopId = id;
      const style = document.createElement('style');
      if (nonce) style.nonce = nonce;
      document.head.appendChild(style);
      if (style.sheet) {
        style.sheet.insertRule(`
          [data-motion-pop-id="${id}"] {
            position: absolute !important;
            width: ${width}px !important;
            height: ${height}px !important;
            ${x}px !important;
            top: ${top}px !important;
          }
        `);
      }
      return () => {
        if (document.head.contains(style)) {
          document.head.removeChild(style);
        }
      };
    }, [isPresent]);
    return (0, jsx_runtime.jsx)(PopChildMeasure, {
      isPresent: isPresent,
      childRef: ref,
      sizeRef: size,
      children: react.cloneElement(children, { ref }),
    });
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/components/AnimatePresence/PresenceChild.mjs

  ('use client');

  const PresenceChild = ({
    children,
    initial,
    isPresent,
    onExitComplete,
    custom,
    presenceAffectsLayout,
    mode,
    anchorX,
  }) => {
    const presenceChildren = useConstant(newChildrenMap);
    const id = (0, react.useId)();
    let isReusedContext = true;
    let context = (0, react.useMemo)(() => {
      isReusedContext = false;
      return {
        id,
        initial,
        isPresent,
        custom,
        onExitComplete: (childId) => {
          presenceChildren.set(childId, true);
          for (const isComplete of presenceChildren.values()) {
            if (!isComplete) return; // can stop searching when any is incomplete
          }
          onExitComplete && onExitComplete();
        },
        register: (childId) => {
          presenceChildren.set(childId, false);
          return () => presenceChildren.delete(childId);
        },
      };
    }, [isPresent, presenceChildren, onExitComplete]);
    /**
     * If the presence of a child affects the layout of the components around it,
     * we want to make a new context value to ensure they get re-rendered
     * so they can detect that layout change.
     */
    if (presenceAffectsLayout && isReusedContext) {
      context = { ...context };
    }
    (0, react.useMemo)(() => {
      presenceChildren.forEach((_, key) => presenceChildren.set(key, false));
    }, [isPresent]);
    /**
     * If there's no `motion` components to fire exit animations, we want to remove this
     * component immediately.
     */
    react.useEffect(() => {
      !isPresent && !presenceChildren.size && onExitComplete && onExitComplete();
    }, [isPresent]);
    if (mode === 'popLayout') {
      children = (0, jsx_runtime.jsx)(PopChild, {
        isPresent: isPresent,
        anchorX: anchorX,
        children: children,
      });
    }
    return (0, jsx_runtime.jsx)(PresenceContext_PresenceContext.Provider, {
      value: context,
      children: children,
    });
  };
  function newChildrenMap() {
    return new Map();
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/components/AnimatePresence/utils.mjs

  const getChildKey = (child) => child.key || '';
  function onlyElements(children) {
    const filtered = [];
    // We use forEach here instead of map as map mutates the component key by preprending `.$`
    react.Children.forEach(children, (child) => {
      if ((0, react.isValidElement)(child)) filtered.push(child);
    });
    return filtered;
  } // ./node_modules/.pnpm/motion@12.16.0_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/motion/dist/es/framer-motion/dist/es/components/AnimatePresence/index.mjs

  ('use client');

  /**
   * `AnimatePresence` enables the animation of components that have been removed from the tree.
   *
   * When adding/removing more than a single child, every child **must** be given a unique `key` prop.
   *
   * Any `motion` components that have an `exit` property defined will animate out when removed from
   * the tree.
   *
   * ```jsx
   * import { motion, AnimatePresence } from 'framer-motion'
   *
   * export const Items = ({ items }) => (
   *   <AnimatePresence>
   *     {items.map(item => (
   *       <motion.div
   *         key={item.id}
   *         initial={{ opacity: 0 }}
   *         animate={{ opacity: 1 }}
   *         exit={{ opacity: 0 }}
   *       />
   *     ))}
   *   </AnimatePresence>
   * )
   * ```
   *
   * You can sequence exit animations throughout a tree using variants.
   *
   * If a child contains multiple `motion` components with `exit` props, it will only unmount the child
   * once all `motion` components have finished animating out. Likewise, any components using
   * `usePresence` all need to call `safeToRemove`.
   *
   * @public
   */
  const AnimatePresence = ({
    children,
    custom,
    initial = true,
    onExitComplete,
    presenceAffectsLayout = true,
    mode = 'sync',
    propagate = false,
    anchorX = 'left',
  }) => {
    const [isParentPresent, safeToRemove] = usePresence(propagate);
    /**
     * Filter any children that aren't ReactElements. We can only track components
     * between renders with a props.key.
     */
    const presentChildren = (0, react.useMemo)(() => onlyElements(children), [children]);
    /**
     * Track the keys of the currently rendered children. This is used to
     * determine which children are exiting.
     */
    const presentKeys = propagate && !isParentPresent ? [] : presentChildren.map(getChildKey);
    /**
     * If `initial={false}` we only want to pass this to components in the first render.
     */
    const isInitialRender = (0, react.useRef)(true);
    /**
     * A ref containing the currently present children. When all exit animations
     * are complete, we use this to re-render the component with the latest children
     * *committed* rather than the latest children *rendered*.
     */
    const pendingPresentChildren = (0, react.useRef)(presentChildren);
    /**
     * Track which exiting children have finished animating out.
     */
    const exitComplete = useConstant(() => new Map());
    /**
     * Save children to render as React state. To ensure this component is concurrent-safe,
     * we check for exiting children via an effect.
     */
    const [diffedChildren, setDiffedChildren] = (0, react.useState)(presentChildren);
    const [renderedChildren, setRenderedChildren] = (0, react.useState)(presentChildren);
    useIsomorphicLayoutEffect(() => {
      isInitialRender.current = false;
      pendingPresentChildren.current = presentChildren;
      /**
       * Update complete status of exiting children.
       */
      for (let i = 0; i < renderedChildren.length; i++) {
        const key = getChildKey(renderedChildren[i]);
        if (!presentKeys.includes(key)) {
          if (exitComplete.get(key) !== true) {
            exitComplete.set(key, false);
          }
        } else {
          exitComplete.delete(key);
        }
      }
    }, [renderedChildren, presentKeys.length, presentKeys.join('-')]);
    const exitingChildren = [];
    if (presentChildren !== diffedChildren) {
      let nextChildren = [...presentChildren];
      /**
       * Loop through all the currently rendered components and decide which
       * are exiting.
       */
      for (let i = 0; i < renderedChildren.length; i++) {
        const child = renderedChildren[i];
        const key = getChildKey(child);
        if (!presentKeys.includes(key)) {
          nextChildren.splice(i, 0, child);
          exitingChildren.push(child);
        }
      }
      /**
       * If we're in "wait" mode, and we have exiting children, we want to
       * only render these until they've all exited.
       */
      if (mode === 'wait' && exitingChildren.length) {
        nextChildren = exitingChildren;
      }
      setRenderedChildren(onlyElements(nextChildren));
      setDiffedChildren(presentChildren);
      /**
       * Early return to ensure once we've set state with the latest diffed
       * children, we can immediately re-render.
       */
      return null;
    }
    if (false) {
      // removed by dead control flow
    }
    /**
     * If we've been provided a forceRender function by the LayoutGroupContext,
     * we can use it to force a re-render amongst all surrounding components once
     * all components have finished animating out.
     */
    const { forceRender } = (0, react.useContext)(LayoutGroupContext);
    return (0, jsx_runtime.jsx)(jsx_runtime.Fragment, {
      children: renderedChildren.map((child) => {
        const key = getChildKey(child);
        const isPresent =
          propagate && !isParentPresent
            ? false
            : presentChildren === renderedChildren || presentKeys.includes(key);
        const onExit = () => {
          if (exitComplete.has(key)) {
            exitComplete.set(key, true);
          } else {
            return;
          }
          let isEveryExitComplete = true;
          exitComplete.forEach((isExitComplete) => {
            if (!isExitComplete) isEveryExitComplete = false;
          });
          if (isEveryExitComplete) {
            forceRender?.();
            setRenderedChildren(pendingPresentChildren.current);
            propagate && safeToRemove?.();
            onExitComplete && onExitComplete();
          }
        };
        return (0, jsx_runtime.jsx)(
          PresenceChild,
          {
            isPresent: isPresent,
            initial: !isInitialRender.current || initial ? undefined : false,
            custom: custom,
            presenceAffectsLayout: presenceAffectsLayout,
            mode: mode,
            onExitComplete: isPresent ? undefined : onExit,
            anchorX: anchorX,
            children: child,
          },
          key
        );
      }),
    });
  }; // ./node_modules/.pnpm/@phosphor-icons+react@2.1.10_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/@phosphor-icons/react/dist/lib/SSRBase.es.js

  const SSRBase_es_w = react.forwardRef((l, s) => {
    const {
      alt: r,
      color: a = 'currentColor',
      size: t = '1em',
      weight: o = 'regular',
      mirrored: i = !1,
      children: n,
      weights: c,
      ...m
    } = l;
    return /* @__PURE__ */ react.createElement(
      'svg',
      {
        ref: s,
        xmlns: 'http://www.w3.org/2000/svg',
        width: t,
        height: t,
        fill: a,
        viewBox: '0 0 256 256',
        transform: i ? 'scale(-1, 1)' : void 0,
        ...m,
      },
      !!r && /* @__PURE__ */ react.createElement('title', null, r),
      n,
      c.get(o)
    );
  });
  SSRBase_es_w.displayName = 'SSRBase'; // ./node_modules/.pnpm/@phosphor-icons+react@2.1.10_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/@phosphor-icons/react/dist/defs/ChatText.es.js

  const ChatText_es_e = /* @__PURE__ */ new Map([
    [
      'bold',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M216,44H40A20,20,0,0,0,20,64V224A19.82,19.82,0,0,0,31.56,242.1a20.14,20.14,0,0,0,8.49,1.9,19.91,19.91,0,0,0,12.82-4.72l.12-.11L84.47,212H216a20,20,0,0,0,20-20V64A20,20,0,0,0,216,44Zm-4,144H80a11.93,11.93,0,0,0-7.84,2.92L44,215.23V68H212ZM84,108A12,12,0,0,1,96,96h64a12,12,0,1,1,0,24H96A12,12,0,0,1,84,108Zm0,40a12,12,0,0,1,12-12h64a12,12,0,0,1,0,24H96A12,12,0,0,1,84,148Z',
        })
      ),
    ],
    [
      'duotone',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M224,64V192a8,8,0,0,1-8,8H80L45.15,230.11A8,8,0,0,1,32,224V64a8,8,0,0,1,8-8H216A8,8,0,0,1,224,64Z',
          opacity: '0.2',
        }),
        /* @__PURE__ */ react.createElement('path', {
          d: 'M216,48H40A16,16,0,0,0,24,64V224a15.85,15.85,0,0,0,9.24,14.5A16.13,16.13,0,0,0,40,240a15.89,15.89,0,0,0,10.25-3.78l.09-.07L83,208H216a16,16,0,0,0,16-16V64A16,16,0,0,0,216,48ZM40,224h0ZM216,192H80a8,8,0,0,0-5.23,1.95L40,224V64H216ZM88,112a8,8,0,0,1,8-8h64a8,8,0,0,1,0,16H96A8,8,0,0,1,88,112Zm0,32a8,8,0,0,1,8-8h64a8,8,0,1,1,0,16H96A8,8,0,0,1,88,144Z',
        })
      ),
    ],
    [
      'fill',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M216,48H40A16,16,0,0,0,24,64V224a15.84,15.84,0,0,0,9.25,14.5A16.05,16.05,0,0,0,40,240a15.89,15.89,0,0,0,10.25-3.78l.09-.07L83,208H216a16,16,0,0,0,16-16V64A16,16,0,0,0,216,48ZM160,152H96a8,8,0,0,1,0-16h64a8,8,0,0,1,0,16Zm0-32H96a8,8,0,0,1,0-16h64a8,8,0,0,1,0,16Z',
        })
      ),
    ],
    [
      'light',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M216,50H40A14,14,0,0,0,26,64V224a13.88,13.88,0,0,0,8.09,12.69A14.11,14.11,0,0,0,40,238a13.87,13.87,0,0,0,9-3.31l.06-.05L82.23,206H216a14,14,0,0,0,14-14V64A14,14,0,0,0,216,50Zm2,142a2,2,0,0,1-2,2H80a6,6,0,0,0-3.92,1.46L41.26,225.53A2,2,0,0,1,38,224V64a2,2,0,0,1,2-2H216a2,2,0,0,1,2,2Zm-52-80a6,6,0,0,1-6,6H96a6,6,0,0,1,0-12h64A6,6,0,0,1,166,112Zm0,32a6,6,0,0,1-6,6H96a6,6,0,0,1,0-12h64A6,6,0,0,1,166,144Z',
        })
      ),
    ],
    [
      'regular',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M216,48H40A16,16,0,0,0,24,64V224a15.85,15.85,0,0,0,9.24,14.5A16.13,16.13,0,0,0,40,240a15.89,15.89,0,0,0,10.25-3.78l.09-.07L83,208H216a16,16,0,0,0,16-16V64A16,16,0,0,0,216,48ZM40,224h0ZM216,192H80a8,8,0,0,0-5.23,1.95L40,224V64H216ZM88,112a8,8,0,0,1,8-8h64a8,8,0,0,1,0,16H96A8,8,0,0,1,88,112Zm0,32a8,8,0,0,1,8-8h64a8,8,0,1,1,0,16H96A8,8,0,0,1,88,144Z',
        })
      ),
    ],
    [
      'thin',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M216,52H40A12,12,0,0,0,28,64V224a11.89,11.89,0,0,0,6.93,10.88A12.17,12.17,0,0,0,40,236a11.89,11.89,0,0,0,7.69-2.83l0,0L81.49,204H216a12,12,0,0,0,12-12V64A12,12,0,0,0,216,52Zm4,140a4,4,0,0,1-4,4H80a4,4,0,0,0-2.62,1L42.56,227.06A4,4,0,0,1,36,224V64a4,4,0,0,1,4-4H216a4,4,0,0,1,4,4Zm-56-80a4,4,0,0,1-4,4H96a4,4,0,0,1,0-8h64A4,4,0,0,1,164,112Zm0,32a4,4,0,0,1-4,4H96a4,4,0,0,1,0-8h64A4,4,0,0,1,164,144Z',
        })
      ),
    ],
  ]); // ./node_modules/.pnpm/@phosphor-icons+react@2.1.10_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/@phosphor-icons/react/dist/ssr/ChatText.es.js

  const ssr_ChatText_es_e = react.forwardRef((o, a) =>
    /* @__PURE__ */ react.createElement(SSRBase_es_w, { ref: a, ...o, weights: ChatText_es_e })
  );
  ssr_ChatText_es_e.displayName = 'ChatTextIcon';
  const f = /* unused pure expression or super */ null && ssr_ChatText_es_e; // ./node_modules/.pnpm/@phosphor-icons+react@2.1.10_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/@phosphor-icons/react/dist/lib/context.es.js

  const context_es_o = (0, react.createContext)({
    color: 'currentColor',
    size: '1em',
    weight: 'regular',
    mirrored: !1,
  }); // ./node_modules/.pnpm/@phosphor-icons+react@2.1.10_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/@phosphor-icons/react/dist/lib/IconBase.es.js

  const p = react.forwardRef((s, a) => {
    const { alt: n, color: r, size: t, weight: o, mirrored: c, children: i, weights: m, ...x } = s,
      {
        color: d = 'currentColor',
        size: l,
        weight: f = 'regular',
        mirrored: g = !1,
        ...w
      } = react.useContext(context_es_o);
    return /* @__PURE__ */ react.createElement(
      'svg',
      {
        ref: a,
        xmlns: 'http://www.w3.org/2000/svg',
        width: t != null ? t : l,
        height: t != null ? t : l,
        fill: r != null ? r : d,
        viewBox: '0 0 256 256',
        transform: c || g ? 'scale(-1, 1)' : void 0,
        ...w,
        ...x,
      },
      !!n && /* @__PURE__ */ react.createElement('title', null, n),
      i,
      m.get(o != null ? o : f)
    );
  });
  p.displayName = 'IconBase'; // ./node_modules/.pnpm/@phosphor-icons+react@2.1.10_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/@phosphor-icons/react/dist/defs/PaperPlaneRight.es.js

  const a = /* @__PURE__ */ new Map([
    [
      'bold',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M233.86,110.48,65.8,14.58A20,20,0,0,0,37.15,38.64L67.33,128,37.15,217.36A20,20,0,0,0,56,244a20.1,20.1,0,0,0,9.81-2.58l.09-.06,168-96.07a20,20,0,0,0,0-34.81ZM63.19,215.26,88.61,140H144a12,12,0,0,0,0-24H88.61L63.18,40.72l152.76,87.17Z',
        })
      ),
    ],
    [
      'duotone',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M227.91,134.86,59.93,231a8,8,0,0,1-11.44-9.67L80,128,48.49,34.72a8,8,0,0,1,11.44-9.67l168,95.85A8,8,0,0,1,227.91,134.86Z',
          opacity: '0.2',
        }),
        /* @__PURE__ */ react.createElement('path', {
          d: 'M231.87,114l-168-95.89A16,16,0,0,0,40.92,37.34L71.55,128,40.92,218.67A16,16,0,0,0,56,240a16.15,16.15,0,0,0,7.93-2.1l167.92-96.05a16,16,0,0,0,.05-27.89ZM56,224a.56.56,0,0,0,0-.12L85.74,136H144a8,8,0,0,0,0-16H85.74L56.06,32.16A.46.46,0,0,0,56,32l168,95.83Z',
        })
      ),
    ],
    [
      'fill',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M240,127.89a16,16,0,0,1-8.18,14L63.9,237.9A16.15,16.15,0,0,1,56,240a16,16,0,0,1-15-21.33l27-79.95A4,4,0,0,1,71.72,136H144a8,8,0,0,0,8-8.53,8.19,8.19,0,0,0-8.26-7.47h-72a4,4,0,0,1-3.79-2.72l-27-79.94A16,16,0,0,1,63.84,18.07l168,95.89A16,16,0,0,1,240,127.89Z',
        })
      ),
    ],
    [
      'light',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M230.88,115.69l-168-95.88a14,14,0,0,0-20,16.87L73.66,128,42.81,219.33A14,14,0,0,0,56,238a14.15,14.15,0,0,0,6.93-1.83L230.84,140.1a14,14,0,0,0,0-24.41Zm-5.95,14L57,225.73a2,2,0,0,1-2.86-2.42.42.42,0,0,0,0-.1L84.3,134H144a6,6,0,0,0,0-12H84.3L54.17,32.8a.3.3,0,0,0,0-.1,1.87,1.87,0,0,1,.6-2.2A1.85,1.85,0,0,1,57,30.25l168,95.89a1.93,1.93,0,0,1,1,1.74A2,2,0,0,1,224.93,129.66Z',
        })
      ),
    ],
    [
      'regular',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M231.87,114l-168-95.89A16,16,0,0,0,40.92,37.34L71.55,128,40.92,218.67A16,16,0,0,0,56,240a16.15,16.15,0,0,0,7.93-2.1l167.92-96.05a16,16,0,0,0,.05-27.89ZM56,224a.56.56,0,0,0,0-.12L85.74,136H144a8,8,0,0,0,0-16H85.74L56.06,32.16A.46.46,0,0,0,56,32l168,95.83Z',
        })
      ),
    ],
    [
      'thin',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M229.89,117.43l-168-95.88A12,12,0,0,0,44.7,36l31.08,92L44.71,220A12,12,0,0,0,56,236a12.13,12.13,0,0,0,5.93-1.57l167.94-96.08a12,12,0,0,0,0-20.92Zm-4,14L58,227.47a4,4,0,0,1-5.72-4.83l0-.07L82.87,132H144a4,4,0,0,0,0-8H82.87L52.26,33.37A3.89,3.89,0,0,1,53.44,29,4.13,4.13,0,0,1,56,28a3.88,3.88,0,0,1,1.93.54l168,95.87a4,4,0,0,1,0,7Z',
        })
      ),
    ],
  ]); // ./node_modules/.pnpm/@phosphor-icons+react@2.1.10_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/@phosphor-icons/react/dist/csr/PaperPlaneRight.es.js

  const PaperPlaneRight_es_a = react.forwardRef((o, r) =>
    /* @__PURE__ */ react.createElement(p, { ref: r, ...o, weights: a })
  );
  PaperPlaneRight_es_a.displayName = 'PaperPlaneRightIcon';
  const PaperPlaneRight_es_p = /* unused pure expression or super */ null && PaperPlaneRight_es_a; // ./node_modules/.pnpm/class-variance-authority@0.7.1/node_modules/class-variance-authority/dist/index.mjs

  /**
   * Copyright 2022 Joe Bell. All rights reserved.
   *
   * This file is licensed to you under the Apache License, Version 2.0
   * (the "License"); you may not use this file except in compliance with the
   * License. You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR REPRESENTATIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */
  const falsyToString = (value) =>
    typeof value === 'boolean' ? `${value}` : value === 0 ? '0' : value;
  const cx = clsx;
  const cva = (base, config) => (props) => {
    var _config_compoundVariants;
    if ((config === null || config === void 0 ? void 0 : config.variants) == null)
      return cx(
        base,
        props === null || props === void 0 ? void 0 : props.class,
        props === null || props === void 0 ? void 0 : props.className
      );
    const { variants, defaultVariants } = config;
    const getVariantClassNames = Object.keys(variants).map((variant) => {
      const variantProp = props === null || props === void 0 ? void 0 : props[variant];
      const defaultVariantProp =
        defaultVariants === null || defaultVariants === void 0 ? void 0 : defaultVariants[variant];
      if (variantProp === null) return null;
      const variantKey = falsyToString(variantProp) || falsyToString(defaultVariantProp);
      return variants[variant][variantKey];
    });
    const propsWithoutUndefined =
      props &&
      Object.entries(props).reduce((acc, param) => {
        let [key, value] = param;
        if (value === undefined) {
          return acc;
        }
        acc[key] = value;
        return acc;
      }, {});
    const getCompoundVariantClassNames =
      config === null || config === void 0
        ? void 0
        : (_config_compoundVariants = config.compoundVariants) === null ||
            _config_compoundVariants === void 0
          ? void 0
          : _config_compoundVariants.reduce((acc, param) => {
              let { class: cvClass, className: cvClassName, ...compoundVariantOptions } = param;
              return Object.entries(compoundVariantOptions).every((param) => {
                let [key, value] = param;
                return Array.isArray(value)
                  ? value.includes(
                      {
                        ...defaultVariants,
                        ...propsWithoutUndefined,
                      }[key]
                    )
                  : {
                      ...defaultVariants,
                      ...propsWithoutUndefined,
                    }[key] === value;
              })
                ? [...acc, cvClass, cvClassName]
                : acc;
            }, []);
    return cx(
      base,
      getVariantClassNames,
      getCompoundVariantClassNames,
      props === null || props === void 0 ? void 0 : props.class,
      props === null || props === void 0 ? void 0 : props.className
    );
  }; // ./node_modules/.pnpm/@radix-ui+react-compose-refs@1.1.2_@types+react@19.1.12_react@19.1.1/node_modules/@radix-ui/react-compose-refs/dist/index.mjs

  // packages/react/compose-refs/src/compose-refs.tsx

  function setRef(ref, value) {
    if (typeof ref === 'function') {
      return ref(value);
    } else if (ref !== null && ref !== void 0) {
      ref.current = value;
    }
  }
  function composeRefs(...refs) {
    return (node) => {
      let hasCleanup = false;
      const cleanups = refs.map((ref) => {
        const cleanup = setRef(ref, node);
        if (!hasCleanup && typeof cleanup == 'function') {
          hasCleanup = true;
        }
        return cleanup;
      });
      if (hasCleanup) {
        return () => {
          for (let i = 0; i < cleanups.length; i++) {
            const cleanup = cleanups[i];
            if (typeof cleanup == 'function') {
              cleanup();
            } else {
              setRef(refs[i], null);
            }
          }
        };
      }
    };
  }
  function useComposedRefs(...refs) {
    return react.useCallback(composeRefs(...refs), refs);
  } // ./node_modules/.pnpm/@radix-ui+react-slot@1.2.3_@types+react@19.1.12_react@19.1.1/node_modules/@radix-ui/react-slot/dist/index.mjs

  //# sourceMappingURL=index.mjs.map

  // src/slot.tsx

  // @__NO_SIDE_EFFECTS__
  function createSlot(ownerName) {
    const SlotClone = /* @__PURE__ */ createSlotClone(ownerName);
    const Slot2 = react.forwardRef((props, forwardedRef) => {
      const { children, ...slotProps } = props;
      const childrenArray = react.Children.toArray(children);
      const slottable = childrenArray.find(isSlottable);
      if (slottable) {
        const newElement = slottable.props.children;
        const newChildren = childrenArray.map((child) => {
          if (child === slottable) {
            if (react.Children.count(newElement) > 1) return react.Children.only(null);
            return react.isValidElement(newElement) ? newElement.props.children : null;
          } else {
            return child;
          }
        });
        return /* @__PURE__ */ (0, jsx_runtime.jsx)(SlotClone, {
          ...slotProps,
          ref: forwardedRef,
          children: react.isValidElement(newElement)
            ? react.cloneElement(newElement, void 0, newChildren)
            : null,
        });
      }
      return /* @__PURE__ */ (0, jsx_runtime.jsx)(SlotClone, {
        ...slotProps,
        ref: forwardedRef,
        children,
      });
    });
    Slot2.displayName = `${ownerName}.Slot`;
    return Slot2;
  }
  var Slot = /* @__PURE__ */ createSlot('Slot');
  // @__NO_SIDE_EFFECTS__
  function createSlotClone(ownerName) {
    const SlotClone = react.forwardRef((props, forwardedRef) => {
      const { children, ...slotProps } = props;
      if (react.isValidElement(children)) {
        const childrenRef = getElementRef(children);
        const props2 = mergeProps(slotProps, children.props);
        if (children.type !== react.Fragment) {
          props2.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;
        }
        return react.cloneElement(children, props2);
      }
      return react.Children.count(children) > 1 ? react.Children.only(null) : null;
    });
    SlotClone.displayName = `${ownerName}.SlotClone`;
    return SlotClone;
  }
  var SLOTTABLE_IDENTIFIER = Symbol('radix.slottable');
  // @__NO_SIDE_EFFECTS__
  function createSlottable(ownerName) {
    const Slottable2 = ({ children }) => {
      return /* @__PURE__ */ jsx(Fragment2, { children });
    };
    Slottable2.displayName = `${ownerName}.Slottable`;
    Slottable2.__radixId = SLOTTABLE_IDENTIFIER;
    return Slottable2;
  }
  var Slottable =
    /* @__PURE__ */ /* unused pure expression or super */ null && createSlottable('Slottable');
  function isSlottable(child) {
    return (
      react.isValidElement(child) &&
      typeof child.type === 'function' &&
      '__radixId' in child.type &&
      child.type.__radixId === SLOTTABLE_IDENTIFIER
    );
  }
  function mergeProps(slotProps, childProps) {
    const overrideProps = { ...childProps };
    for (const propName in childProps) {
      const slotPropValue = slotProps[propName];
      const childPropValue = childProps[propName];
      const isHandler = /^on[A-Z]/.test(propName);
      if (isHandler) {
        if (slotPropValue && childPropValue) {
          overrideProps[propName] = (...args) => {
            const result = childPropValue(...args);
            slotPropValue(...args);
            return result;
          };
        } else if (slotPropValue) {
          overrideProps[propName] = slotPropValue;
        }
      } else if (propName === 'style') {
        overrideProps[propName] = { ...slotPropValue, ...childPropValue };
      } else if (propName === 'className') {
        overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(' ');
      }
    }
    return { ...slotProps, ...overrideProps };
  }
  function getElementRef(element) {
    let getter = Object.getOwnPropertyDescriptor(element.props, 'ref')?.get;
    let mayWarn = getter && 'isReactWarning' in getter && getter.isReactWarning;
    if (mayWarn) {
      return element.ref;
    }
    getter = Object.getOwnPropertyDescriptor(element, 'ref')?.get;
    mayWarn = getter && 'isReactWarning' in getter && getter.isReactWarning;
    if (mayWarn) {
      return element.props.ref;
    }
    return element.props.ref || element.ref;
  } // ./components/livekit/button.tsx

  //# sourceMappingURL=index.mjs.map

  var button_rest =
    (undefined && undefined.__rest) ||
    function (s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === 'function')
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };

  const buttonVariants = cva(
    [
      'text-xs font-bold tracking-wider uppercase whitespace-nowrap',
      'inline-flex items-center justify-center gap-2 shrink-0 rounded-full cursor-pointer outline-none transition-colors duration-300',
      'focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]',
      'disabled:pointer-events-none disabled:opacity-50',
      'aria-invalid:ring-destructive/20 aria-invalid:border-destructive dark:aria-invalid:ring-destructive/40 ',
      "[&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 [&_svg]:shrink-0",
    ],
    {
      variants: {
        variant: {
          default: 'bg-muted text-foreground hover:bg-muted focus:bg-muted hover:bg-foreground/10',
          destructive: [
            'bg-destructive/10 text-destructive',
            'hover:bg-destructive/20 focus:bg-destructive/20 focus-visible:ring-destructive/20',
            'dark:focus-visible:ring-destructive/40',
          ],
          outline: [
            'border border-input bg-background',
            'hover:bg-accent hover:text-accent-foreground',
            'dark:bg-input/30 dark:border-input dark:hover:bg-input/50',
          ],
          primary: 'bg-primary text-primary-foreground hover:bg-primary/70 focus:bg-primary/70',
          secondary: 'bg-foreground/15 text-secondary-foreground hover:bg-foreground/20',
          ghost: 'hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50',
          link: 'text-primary underline-offset-4 hover:underline',
        },
        size: {
          default: 'h-9 px-4 py-2 has-[>svg]:px-3',
          sm: 'h-8 gap-1.5 px-3 has-[>svg]:px-2.5',
          lg: 'h-10 px-6 has-[>svg]:px-4',
          icon: 'size-9',
        },
      },
      defaultVariants: {
        variant: 'default',
        size: 'default',
      },
    }
  );
  function Button(_a) {
    var { className, variant, size, asChild = false } = _a,
      props = button_rest(_a, ['className', 'variant', 'size', 'asChild']);
    const Comp = asChild ? Slot : 'button';
    return (0, jsx_runtime.jsx)(
      Comp,
      Object.assign(
        {
          'data-slot': 'button',
          className: utils_cn(buttonVariants({ variant, size, className })),
        },
        props
      )
    );
  } // ./components/livekit/chat/chat-input.tsx

  var chat_input_rest =
    (undefined && undefined.__rest) ||
    function (s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === 'function')
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };

  function ChatInput(_a) {
    var { onSend, className, disabled } = _a,
      props = chat_input_rest(_a, ['onSend', 'className', 'disabled']);
    const inputRef = (0, react.useRef)(null);
    const [message, setMessage] = (0, react.useState)('');
    const handleSubmit = (e) => {
      var _a;
      e.preventDefault();
      (_a = props.onSubmit) === null || _a === void 0 ? void 0 : _a.call(props, e);
      onSend === null || onSend === void 0 ? void 0 : onSend(message);
      setMessage('');
    };
    const isDisabled = disabled || message.trim().length === 0;
    (0, react.useEffect)(() => {
      var _a;
      if (disabled) {
        return;
      }
      // when not disabled refocus on input
      (_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.focus();
    }, [disabled]);
    return (0, jsx_runtime.jsxs)(
      'form',
      Object.assign({}, props, {
        onSubmit: handleSubmit,
        className: utils_cn('flex items-center gap-2 rounded-md pl-1 text-sm', className),
        children: [
          (0, jsx_runtime.jsx)('input', {
            autoFocus: true,
            ref: inputRef,
            type: 'text',
            value: message,
            disabled: disabled,
            placeholder: 'Type something...',
            onChange: (e) => setMessage(e.target.value),
            className:
              'h-9 shrink-1 grow-1 pl-2 focus:outline-none disabled:cursor-not-allowed disabled:opacity-50',
          }),
          (0, jsx_runtime.jsx)(Button, {
            size: 'icon',
            type: 'submit',
            variant: isDisabled ? 'secondary' : 'primary',
            disabled: isDisabled,
            children: (0, jsx_runtime.jsx)(PaperPlaneRight_es_a, { weight: 'bold' }),
          }),
        ],
      })
    );
  } // ./node_modules/.pnpm/@phosphor-icons+react@2.1.10_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/@phosphor-icons/react/dist/defs/CaretDown.es.js

  const CaretDown_es_t = /* @__PURE__ */ new Map([
    [
      'bold',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M216.49,104.49l-80,80a12,12,0,0,1-17,0l-80-80a12,12,0,0,1,17-17L128,159l71.51-71.52a12,12,0,0,1,17,17Z',
        })
      ),
    ],
    [
      'duotone',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', { d: 'M208,96l-80,80L48,96Z', opacity: '0.2' }),
        /* @__PURE__ */ react.createElement('path', {
          d: 'M215.39,92.94A8,8,0,0,0,208,88H48a8,8,0,0,0-5.66,13.66l80,80a8,8,0,0,0,11.32,0l80-80A8,8,0,0,0,215.39,92.94ZM128,164.69,67.31,104H188.69Z',
        })
      ),
    ],
    [
      'fill',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M213.66,101.66l-80,80a8,8,0,0,1-11.32,0l-80-80A8,8,0,0,1,48,88H208a8,8,0,0,1,5.66,13.66Z',
        })
      ),
    ],
    [
      'light',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M212.24,100.24l-80,80a6,6,0,0,1-8.48,0l-80-80a6,6,0,0,1,8.48-8.48L128,167.51l75.76-75.75a6,6,0,0,1,8.48,8.48Z',
        })
      ),
    ],
    [
      'regular',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M213.66,101.66l-80,80a8,8,0,0,1-11.32,0l-80-80A8,8,0,0,1,53.66,90.34L128,164.69l74.34-74.35a8,8,0,0,1,11.32,11.32Z',
        })
      ),
    ],
    [
      'thin',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M210.83,98.83l-80,80a4,4,0,0,1-5.66,0l-80-80a4,4,0,0,1,5.66-5.66L128,170.34l77.17-77.17a4,4,0,1,1,5.66,5.66Z',
        })
      ),
    ],
  ]); // ./node_modules/.pnpm/@phosphor-icons+react@2.1.10_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/@phosphor-icons/react/dist/ssr/CaretDown.es.js

  const CaretDown_es_e = react.forwardRef((r, t) =>
    /* @__PURE__ */ react.createElement(SSRBase_es_w, { ref: t, ...r, weights: CaretDown_es_t })
  );
  CaretDown_es_e.displayName = 'CaretDownIcon';
  const CaretDown_es_c = /* unused pure expression or super */ null && CaretDown_es_e; // ./node_modules/.pnpm/@phosphor-icons+react@2.1.10_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/@phosphor-icons/react/dist/defs/Check.es.js

  const Check_es_a = /* @__PURE__ */ new Map([
    [
      'bold',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M232.49,80.49l-128,128a12,12,0,0,1-17,0l-56-56a12,12,0,1,1,17-17L96,183,215.51,63.51a12,12,0,0,1,17,17Z',
        })
      ),
    ],
    [
      'duotone',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M232,56V200a16,16,0,0,1-16,16H40a16,16,0,0,1-16-16V56A16,16,0,0,1,40,40H216A16,16,0,0,1,232,56Z',
          opacity: '0.2',
        }),
        /* @__PURE__ */ react.createElement('path', {
          d: 'M205.66,85.66l-96,96a8,8,0,0,1-11.32,0l-40-40a8,8,0,0,1,11.32-11.32L104,164.69l90.34-90.35a8,8,0,0,1,11.32,11.32Z',
        })
      ),
    ],
    [
      'fill',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M216,40H40A16,16,0,0,0,24,56V200a16,16,0,0,0,16,16H216a16,16,0,0,0,16-16V56A16,16,0,0,0,216,40ZM205.66,85.66l-96,96a8,8,0,0,1-11.32,0l-40-40a8,8,0,0,1,11.32-11.32L104,164.69l90.34-90.35a8,8,0,0,1,11.32,11.32Z',
        })
      ),
    ],
    [
      'light',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M228.24,76.24l-128,128a6,6,0,0,1-8.48,0l-56-56a6,6,0,0,1,8.48-8.48L96,191.51,219.76,67.76a6,6,0,0,1,8.48,8.48Z',
        })
      ),
    ],
    [
      'regular',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M229.66,77.66l-128,128a8,8,0,0,1-11.32,0l-56-56a8,8,0,0,1,11.32-11.32L96,188.69,218.34,66.34a8,8,0,0,1,11.32,11.32Z',
        })
      ),
    ],
    [
      'thin',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M226.83,74.83l-128,128a4,4,0,0,1-5.66,0l-56-56a4,4,0,0,1,5.66-5.66L96,194.34,221.17,69.17a4,4,0,1,1,5.66,5.66Z',
        })
      ),
    ],
  ]); // ./node_modules/.pnpm/@phosphor-icons+react@2.1.10_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/@phosphor-icons/react/dist/ssr/Check.es.js

  const Check_es_o = react.forwardRef((r, t) =>
    /* @__PURE__ */ react.createElement(SSRBase_es_w, { ref: t, ...r, weights: Check_es_a })
  );
  Check_es_o.displayName = 'CheckIcon';
  const Check_es_f = /* unused pure expression or super */ null && Check_es_o; // ./node_modules/.pnpm/@phosphor-icons+react@2.1.10_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/@phosphor-icons/react/dist/defs/CaretUp.es.js

  const CaretUp_es_a = /* @__PURE__ */ new Map([
    [
      'bold',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M216.49,168.49a12,12,0,0,1-17,0L128,97,56.49,168.49a12,12,0,0,1-17-17l80-80a12,12,0,0,1,17,0l80,80A12,12,0,0,1,216.49,168.49Z',
        })
      ),
    ],
    [
      'duotone',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', { d: 'M208,160H48l80-80Z', opacity: '0.2' }),
        /* @__PURE__ */ react.createElement('path', {
          d: 'M213.66,154.34l-80-80a8,8,0,0,0-11.32,0l-80,80A8,8,0,0,0,48,168H208a8,8,0,0,0,5.66-13.66ZM67.31,152,128,91.31,188.69,152Z',
        })
      ),
    ],
    [
      'fill',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M215.39,163.06A8,8,0,0,1,208,168H48a8,8,0,0,1-5.66-13.66l80-80a8,8,0,0,1,11.32,0l80,80A8,8,0,0,1,215.39,163.06Z',
        })
      ),
    ],
    [
      'light',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M212.24,164.24a6,6,0,0,1-8.48,0L128,88.49,52.24,164.24a6,6,0,0,1-8.48-8.48l80-80a6,6,0,0,1,8.48,0l80,80A6,6,0,0,1,212.24,164.24Z',
        })
      ),
    ],
    [
      'regular',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M213.66,165.66a8,8,0,0,1-11.32,0L128,91.31,53.66,165.66a8,8,0,0,1-11.32-11.32l80-80a8,8,0,0,1,11.32,0l80,80A8,8,0,0,1,213.66,165.66Z',
        })
      ),
    ],
    [
      'thin',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M210.83,162.83a4,4,0,0,1-5.66,0L128,85.66,50.83,162.83a4,4,0,0,1-5.66-5.66l80-80a4,4,0,0,1,5.66,0l80,80A4,4,0,0,1,210.83,162.83Z',
        })
      ),
    ],
  ]); // ./node_modules/.pnpm/@phosphor-icons+react@2.1.10_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/@phosphor-icons/react/dist/ssr/CaretUp.es.js

  const CaretUp_es_r = react.forwardRef((t, o) =>
    /* @__PURE__ */ react.createElement(SSRBase_es_w, { ref: o, ...t, weights: CaretUp_es_a })
  );
  CaretUp_es_r.displayName = 'CaretUpIcon';
  const CaretUp_es_c = /* unused pure expression or super */ null && CaretUp_es_r;

  // EXTERNAL MODULE: ./node_modules/.pnpm/react-dom@19.1.1_react@19.1.1/node_modules/react-dom/index.js
  var react_dom = __webpack_require__(937); // ./node_modules/.pnpm/@radix-ui+number@1.1.1/node_modules/@radix-ui/number/dist/index.mjs
  // packages/core/number/src/number.ts
  function dist_clamp(value, [min, max]) {
    return Math.min(max, Math.max(min, value));
  } // ./node_modules/.pnpm/@radix-ui+primitive@1.1.3/node_modules/@radix-ui/primitive/dist/index.mjs

  //# sourceMappingURL=index.mjs.map

  // src/primitive.tsx
  var canUseDOM = !!(
    typeof window !== 'undefined' &&
    window.document &&
    window.document.createElement
  );
  function composeEventHandlers(
    originalEventHandler,
    ourEventHandler,
    { checkForDefaultPrevented = true } = {}
  ) {
    return function handleEvent(event) {
      originalEventHandler?.(event);
      if (checkForDefaultPrevented === false || !event.defaultPrevented) {
        return ourEventHandler?.(event);
      }
    };
  }
  function getOwnerWindow(element) {
    if (!canUseDOM) {
      throw new Error('Cannot access window outside of the DOM');
    }
    return element?.ownerDocument?.defaultView ?? window;
  }
  function getOwnerDocument(element) {
    if (!canUseDOM) {
      throw new Error('Cannot access document outside of the DOM');
    }
    return element?.ownerDocument ?? document;
  }
  function getActiveElement(node, activeDescendant = false) {
    const { activeElement } = getOwnerDocument(node);
    if (!activeElement?.nodeName) {
      return null;
    }
    if (isFrame(activeElement) && activeElement.contentDocument) {
      return getActiveElement(activeElement.contentDocument.body, activeDescendant);
    }
    if (activeDescendant) {
      const id = activeElement.getAttribute('aria-activedescendant');
      if (id) {
        const element = getOwnerDocument(activeElement).getElementById(id);
        if (element) {
          return element;
        }
      }
    }
    return activeElement;
  }
  function isFrame(element) {
    return element.tagName === 'IFRAME';
  } // ./node_modules/.pnpm/@radix-ui+react-context@1.1.2_@types+react@19.1.12_react@19.1.1/node_modules/@radix-ui/react-context/dist/index.mjs

  //# sourceMappingURL=index.mjs.map

  // packages/react/context/src/create-context.tsx

  function createContext2(rootComponentName, defaultContext) {
    const Context = React.createContext(defaultContext);
    const Provider = (props) => {
      const { children, ...context } = props;
      const value = React.useMemo(() => context, Object.values(context));
      return /* @__PURE__ */ jsx(Context.Provider, { value, children });
    };
    Provider.displayName = rootComponentName + 'Provider';
    function useContext2(consumerName) {
      const context = React.useContext(Context);
      if (context) return context;
      if (defaultContext !== void 0) return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    return [Provider, useContext2];
  }
  function createContextScope(scopeName, createContextScopeDeps = []) {
    let defaultContexts = [];
    function createContext3(rootComponentName, defaultContext) {
      const BaseContext = react.createContext(defaultContext);
      const index = defaultContexts.length;
      defaultContexts = [...defaultContexts, defaultContext];
      const Provider = (props) => {
        const { scope, children, ...context } = props;
        const Context = scope?.[scopeName]?.[index] || BaseContext;
        const value = react.useMemo(() => context, Object.values(context));
        return /* @__PURE__ */ (0, jsx_runtime.jsx)(Context.Provider, { value, children });
      };
      Provider.displayName = rootComponentName + 'Provider';
      function useContext2(consumerName, scope) {
        const Context = scope?.[scopeName]?.[index] || BaseContext;
        const context = react.useContext(Context);
        if (context) return context;
        if (defaultContext !== void 0) return defaultContext;
        throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
      }
      return [Provider, useContext2];
    }
    const createScope = () => {
      const scopeContexts = defaultContexts.map((defaultContext) => {
        return react.createContext(defaultContext);
      });
      return function useScope(scope) {
        const contexts = scope?.[scopeName] || scopeContexts;
        return react.useMemo(
          () => ({ [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts } }),
          [scope, contexts]
        );
      };
    };
    createScope.scopeName = scopeName;
    return [createContext3, composeContextScopes(createScope, ...createContextScopeDeps)];
  }
  function composeContextScopes(...scopes) {
    const baseScope = scopes[0];
    if (scopes.length === 1) return baseScope;
    const createScope = () => {
      const scopeHooks = scopes.map((createScope2) => ({
        useScope: createScope2(),
        scopeName: createScope2.scopeName,
      }));
      return function useComposedScopes(overrideScopes) {
        const nextScopes = scopeHooks.reduce((nextScopes2, { useScope, scopeName }) => {
          const scopeProps = useScope(overrideScopes);
          const currentScope = scopeProps[`__scope${scopeName}`];
          return { ...nextScopes2, ...currentScope };
        }, {});
        return react.useMemo(
          () => ({ [`__scope${baseScope.scopeName}`]: nextScopes }),
          [nextScopes]
        );
      };
    };
    createScope.scopeName = baseScope.scopeName;
    return createScope;
  } // ./node_modules/.pnpm/@radix-ui+react-collection@1.1.7_@types+react-dom@19.1.9_@types+react@19.1.12__@types+react@1_ttlvhkp5jmchy6ap7ybcvyxiue/node_modules/@radix-ui/react-collection/dist/index.mjs

  //# sourceMappingURL=index.mjs.map

  ('use client');

  // src/collection-legacy.tsx

  function createCollection(name) {
    const PROVIDER_NAME = name + 'CollectionProvider';
    const [createCollectionContext, createCollectionScope] = createContextScope(PROVIDER_NAME);
    const [CollectionProviderImpl, useCollectionContext] = createCollectionContext(PROVIDER_NAME, {
      collectionRef: { current: null },
      itemMap: /* @__PURE__ */ new Map(),
    });
    const CollectionProvider = (props) => {
      const { scope, children } = props;
      const ref = react.useRef(null);
      const itemMap = react.useRef(/* @__PURE__ */ new Map()).current;
      return /* @__PURE__ */ (0, jsx_runtime.jsx)(CollectionProviderImpl, {
        scope,
        itemMap,
        collectionRef: ref,
        children,
      });
    };
    CollectionProvider.displayName = PROVIDER_NAME;
    const COLLECTION_SLOT_NAME = name + 'CollectionSlot';
    const CollectionSlotImpl = createSlot(COLLECTION_SLOT_NAME);
    const CollectionSlot = react.forwardRef((props, forwardedRef) => {
      const { scope, children } = props;
      const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);
      const composedRefs = useComposedRefs(forwardedRef, context.collectionRef);
      return /* @__PURE__ */ (0, jsx_runtime.jsx)(CollectionSlotImpl, {
        ref: composedRefs,
        children,
      });
    });
    CollectionSlot.displayName = COLLECTION_SLOT_NAME;
    const ITEM_SLOT_NAME = name + 'CollectionItemSlot';
    const ITEM_DATA_ATTR = 'data-radix-collection-item';
    const CollectionItemSlotImpl = createSlot(ITEM_SLOT_NAME);
    const CollectionItemSlot = react.forwardRef((props, forwardedRef) => {
      const { scope, children, ...itemData } = props;
      const ref = react.useRef(null);
      const composedRefs = useComposedRefs(forwardedRef, ref);
      const context = useCollectionContext(ITEM_SLOT_NAME, scope);
      react.useEffect(() => {
        context.itemMap.set(ref, { ref, ...itemData });
        return () => void context.itemMap.delete(ref);
      });
      return /* @__PURE__ */ (0, jsx_runtime.jsx)(CollectionItemSlotImpl, {
        ...{ [ITEM_DATA_ATTR]: '' },
        ref: composedRefs,
        children,
      });
    });
    CollectionItemSlot.displayName = ITEM_SLOT_NAME;
    function useCollection(scope) {
      const context = useCollectionContext(name + 'CollectionConsumer', scope);
      const getItems = react.useCallback(() => {
        const collectionNode = context.collectionRef.current;
        if (!collectionNode) return [];
        const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));
        const items = Array.from(context.itemMap.values());
        const orderedItems = items.sort(
          (a, b) => orderedNodes.indexOf(a.ref.current) - orderedNodes.indexOf(b.ref.current)
        );
        return orderedItems;
      }, [context.collectionRef, context.itemMap]);
      return getItems;
    }
    return [
      { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },
      useCollection,
      createCollectionScope,
    ];
  }

  // src/collection.tsx

  // src/ordered-dictionary.ts
  var __instanciated = /* @__PURE__ */ new WeakMap();
  var OrderedDict = class _OrderedDict extends Map {
    #keys;
    constructor(entries) {
      super(entries);
      this.#keys = [...super.keys()];
      __instanciated.set(this, true);
    }
    set(key, value) {
      if (__instanciated.get(this)) {
        if (this.has(key)) {
          this.#keys[this.#keys.indexOf(key)] = key;
        } else {
          this.#keys.push(key);
        }
      }
      super.set(key, value);
      return this;
    }
    insert(index, key, value) {
      const has = this.has(key);
      const length = this.#keys.length;
      const relativeIndex = toSafeInteger(index);
      let actualIndex = relativeIndex >= 0 ? relativeIndex : length + relativeIndex;
      const safeIndex = actualIndex < 0 || actualIndex >= length ? -1 : actualIndex;
      if (safeIndex === this.size || (has && safeIndex === this.size - 1) || safeIndex === -1) {
        this.set(key, value);
        return this;
      }
      const size = this.size + (has ? 0 : 1);
      if (relativeIndex < 0) {
        actualIndex++;
      }
      const keys = [...this.#keys];
      let nextValue;
      let shouldSkip = false;
      for (let i = actualIndex; i < size; i++) {
        if (actualIndex === i) {
          let nextKey = keys[i];
          if (keys[i] === key) {
            nextKey = keys[i + 1];
          }
          if (has) {
            this.delete(key);
          }
          nextValue = this.get(nextKey);
          this.set(key, value);
        } else {
          if (!shouldSkip && keys[i - 1] === key) {
            shouldSkip = true;
          }
          const currentKey = keys[shouldSkip ? i : i - 1];
          const currentValue = nextValue;
          nextValue = this.get(currentKey);
          this.delete(currentKey);
          this.set(currentKey, currentValue);
        }
      }
      return this;
    }
    with(index, key, value) {
      const copy = new _OrderedDict(this);
      copy.insert(index, key, value);
      return copy;
    }
    before(key) {
      const index = this.#keys.indexOf(key) - 1;
      if (index < 0) {
        return void 0;
      }
      return this.entryAt(index);
    }
    /**
     * Sets a new key-value pair at the position before the given key.
     */
    setBefore(key, newKey, value) {
      const index = this.#keys.indexOf(key);
      if (index === -1) {
        return this;
      }
      return this.insert(index, newKey, value);
    }
    after(key) {
      let index = this.#keys.indexOf(key);
      index = index === -1 || index === this.size - 1 ? -1 : index + 1;
      if (index === -1) {
        return void 0;
      }
      return this.entryAt(index);
    }
    /**
     * Sets a new key-value pair at the position after the given key.
     */
    setAfter(key, newKey, value) {
      const index = this.#keys.indexOf(key);
      if (index === -1) {
        return this;
      }
      return this.insert(index + 1, newKey, value);
    }
    first() {
      return this.entryAt(0);
    }
    last() {
      return this.entryAt(-1);
    }
    clear() {
      this.#keys = [];
      return super.clear();
    }
    delete(key) {
      const deleted = super.delete(key);
      if (deleted) {
        this.#keys.splice(this.#keys.indexOf(key), 1);
      }
      return deleted;
    }
    deleteAt(index) {
      const key = this.keyAt(index);
      if (key !== void 0) {
        return this.delete(key);
      }
      return false;
    }
    at(index) {
      const key = dist_at(this.#keys, index);
      if (key !== void 0) {
        return this.get(key);
      }
    }
    entryAt(index) {
      const key = dist_at(this.#keys, index);
      if (key !== void 0) {
        return [key, this.get(key)];
      }
    }
    indexOf(key) {
      return this.#keys.indexOf(key);
    }
    keyAt(index) {
      return dist_at(this.#keys, index);
    }
    from(key, offset) {
      const index = this.indexOf(key);
      if (index === -1) {
        return void 0;
      }
      let dest = index + offset;
      if (dest < 0) dest = 0;
      if (dest >= this.size) dest = this.size - 1;
      return this.at(dest);
    }
    keyFrom(key, offset) {
      const index = this.indexOf(key);
      if (index === -1) {
        return void 0;
      }
      let dest = index + offset;
      if (dest < 0) dest = 0;
      if (dest >= this.size) dest = this.size - 1;
      return this.keyAt(dest);
    }
    find(predicate, thisArg) {
      let index = 0;
      for (const entry of this) {
        if (Reflect.apply(predicate, thisArg, [entry, index, this])) {
          return entry;
        }
        index++;
      }
      return void 0;
    }
    findIndex(predicate, thisArg) {
      let index = 0;
      for (const entry of this) {
        if (Reflect.apply(predicate, thisArg, [entry, index, this])) {
          return index;
        }
        index++;
      }
      return -1;
    }
    filter(predicate, thisArg) {
      const entries = [];
      let index = 0;
      for (const entry of this) {
        if (Reflect.apply(predicate, thisArg, [entry, index, this])) {
          entries.push(entry);
        }
        index++;
      }
      return new _OrderedDict(entries);
    }
    map(callbackfn, thisArg) {
      const entries = [];
      let index = 0;
      for (const entry of this) {
        entries.push([entry[0], Reflect.apply(callbackfn, thisArg, [entry, index, this])]);
        index++;
      }
      return new _OrderedDict(entries);
    }
    reduce(...args) {
      const [callbackfn, initialValue] = args;
      let index = 0;
      let accumulator = initialValue ?? this.at(0);
      for (const entry of this) {
        if (index === 0 && args.length === 1) {
          accumulator = entry;
        } else {
          accumulator = Reflect.apply(callbackfn, this, [accumulator, entry, index, this]);
        }
        index++;
      }
      return accumulator;
    }
    reduceRight(...args) {
      const [callbackfn, initialValue] = args;
      let accumulator = initialValue ?? this.at(-1);
      for (let index = this.size - 1; index >= 0; index--) {
        const entry = this.at(index);
        if (index === this.size - 1 && args.length === 1) {
          accumulator = entry;
        } else {
          accumulator = Reflect.apply(callbackfn, this, [accumulator, entry, index, this]);
        }
      }
      return accumulator;
    }
    toSorted(compareFn) {
      const entries = [...this.entries()].sort(compareFn);
      return new _OrderedDict(entries);
    }
    toReversed() {
      const reversed = new _OrderedDict();
      for (let index = this.size - 1; index >= 0; index--) {
        const key = this.keyAt(index);
        const element = this.get(key);
        reversed.set(key, element);
      }
      return reversed;
    }
    toSpliced(...args) {
      const entries = [...this.entries()];
      entries.splice(...args);
      return new _OrderedDict(entries);
    }
    slice(start, end) {
      const result = new _OrderedDict();
      let stop = this.size - 1;
      if (start === void 0) {
        return result;
      }
      if (start < 0) {
        start = start + this.size;
      }
      if (end !== void 0 && end > 0) {
        stop = end - 1;
      }
      for (let index = start; index <= stop; index++) {
        const key = this.keyAt(index);
        const element = this.get(key);
        result.set(key, element);
      }
      return result;
    }
    every(predicate, thisArg) {
      let index = 0;
      for (const entry of this) {
        if (!Reflect.apply(predicate, thisArg, [entry, index, this])) {
          return false;
        }
        index++;
      }
      return true;
    }
    some(predicate, thisArg) {
      let index = 0;
      for (const entry of this) {
        if (Reflect.apply(predicate, thisArg, [entry, index, this])) {
          return true;
        }
        index++;
      }
      return false;
    }
  };
  function dist_at(array, index) {
    if ('at' in Array.prototype) {
      return Array.prototype.at.call(array, index);
    }
    const actualIndex = toSafeIndex(array, index);
    return actualIndex === -1 ? void 0 : array[actualIndex];
  }
  function toSafeIndex(array, index) {
    const length = array.length;
    const relativeIndex = toSafeInteger(index);
    const actualIndex = relativeIndex >= 0 ? relativeIndex : length + relativeIndex;
    return actualIndex < 0 || actualIndex >= length ? -1 : actualIndex;
  }
  function toSafeInteger(number) {
    return number !== number || number === 0 ? 0 : Math.trunc(number);
  }

  // src/collection.tsx

  function createCollection2(name) {
    const PROVIDER_NAME = name + 'CollectionProvider';
    const [createCollectionContext, createCollectionScope] = createContextScope2(PROVIDER_NAME);
    const [CollectionContextProvider, useCollectionContext] = createCollectionContext(
      PROVIDER_NAME,
      {
        collectionElement: null,
        collectionRef: { current: null },
        collectionRefObject: { current: null },
        itemMap: new OrderedDict(),
        setItemMap: () => void 0,
      }
    );
    const CollectionProvider = ({ state, ...props }) => {
      return state
        ? /* @__PURE__ */ jsx2(CollectionProviderImpl, { ...props, state })
        : /* @__PURE__ */ jsx2(CollectionInit, { ...props });
    };
    CollectionProvider.displayName = PROVIDER_NAME;
    const CollectionInit = (props) => {
      const state = useInitCollection();
      return /* @__PURE__ */ jsx2(CollectionProviderImpl, { ...props, state });
    };
    CollectionInit.displayName = PROVIDER_NAME + 'Init';
    const CollectionProviderImpl = (props) => {
      const { scope, children, state } = props;
      const ref = React2.useRef(null);
      const [collectionElement, setCollectionElement] = React2.useState(null);
      const composeRefs = useComposedRefs2(ref, setCollectionElement);
      const [itemMap, setItemMap] = state;
      React2.useEffect(() => {
        if (!collectionElement) return;
        const observer = getChildListObserver(() => {});
        observer.observe(collectionElement, {
          childList: true,
          subtree: true,
        });
        return () => {
          observer.disconnect();
        };
      }, [collectionElement]);
      return /* @__PURE__ */ jsx2(CollectionContextProvider, {
        scope,
        itemMap,
        setItemMap,
        collectionRef: composeRefs,
        collectionRefObject: ref,
        collectionElement,
        children,
      });
    };
    CollectionProviderImpl.displayName = PROVIDER_NAME + 'Impl';
    const COLLECTION_SLOT_NAME = name + 'CollectionSlot';
    const CollectionSlotImpl = createSlot2(COLLECTION_SLOT_NAME);
    const CollectionSlot = React2.forwardRef((props, forwardedRef) => {
      const { scope, children } = props;
      const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);
      const composedRefs = useComposedRefs2(forwardedRef, context.collectionRef);
      return /* @__PURE__ */ jsx2(CollectionSlotImpl, { ref: composedRefs, children });
    });
    CollectionSlot.displayName = COLLECTION_SLOT_NAME;
    const ITEM_SLOT_NAME = name + 'CollectionItemSlot';
    const ITEM_DATA_ATTR = 'data-radix-collection-item';
    const CollectionItemSlotImpl = createSlot2(ITEM_SLOT_NAME);
    const CollectionItemSlot = React2.forwardRef((props, forwardedRef) => {
      const { scope, children, ...itemData } = props;
      const ref = React2.useRef(null);
      const [element, setElement] = React2.useState(null);
      const composedRefs = useComposedRefs2(forwardedRef, ref, setElement);
      const context = useCollectionContext(ITEM_SLOT_NAME, scope);
      const { setItemMap } = context;
      const itemDataRef = React2.useRef(itemData);
      if (!shallowEqual(itemDataRef.current, itemData)) {
        itemDataRef.current = itemData;
      }
      const memoizedItemData = itemDataRef.current;
      React2.useEffect(() => {
        const itemData2 = memoizedItemData;
        setItemMap((map) => {
          if (!element) {
            return map;
          }
          if (!map.has(element)) {
            map.set(element, { ...itemData2, element });
            return map.toSorted(sortByDocumentPosition);
          }
          return map.set(element, { ...itemData2, element }).toSorted(sortByDocumentPosition);
        });
        return () => {
          setItemMap((map) => {
            if (!element || !map.has(element)) {
              return map;
            }
            map.delete(element);
            return new OrderedDict(map);
          });
        };
      }, [element, memoizedItemData, setItemMap]);
      return /* @__PURE__ */ jsx2(CollectionItemSlotImpl, {
        ...{ [ITEM_DATA_ATTR]: '' },
        ref: composedRefs,
        children,
      });
    });
    CollectionItemSlot.displayName = ITEM_SLOT_NAME;
    function useInitCollection() {
      return React2.useState(new OrderedDict());
    }
    function useCollection(scope) {
      const { itemMap } = useCollectionContext(name + 'CollectionConsumer', scope);
      return itemMap;
    }
    const functions = {
      createCollectionScope,
      useCollection,
      useInitCollection,
    };
    return [
      { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },
      functions,
    ];
  }
  function shallowEqual(a, b) {
    if (a === b) return true;
    if (typeof a !== 'object' || typeof b !== 'object') return false;
    if (a == null || b == null) return false;
    const keysA = Object.keys(a);
    const keysB = Object.keys(b);
    if (keysA.length !== keysB.length) return false;
    for (const key of keysA) {
      if (!Object.prototype.hasOwnProperty.call(b, key)) return false;
      if (a[key] !== b[key]) return false;
    }
    return true;
  }
  function isElementPreceding(a, b) {
    return !!(b.compareDocumentPosition(a) & Node.DOCUMENT_POSITION_PRECEDING);
  }
  function sortByDocumentPosition(a, b) {
    return !a[1].element || !b[1].element
      ? 0
      : isElementPreceding(a[1].element, b[1].element)
        ? -1
        : 1;
  }
  function getChildListObserver(callback) {
    const observer = new MutationObserver((mutationsList) => {
      for (const mutation of mutationsList) {
        if (mutation.type === 'childList') {
          callback();
          return;
        }
      }
    });
    return observer;
  } // ./node_modules/.pnpm/@radix-ui+react-direction@1.1.1_@types+react@19.1.12_react@19.1.1/node_modules/@radix-ui/react-direction/dist/index.mjs

  //# sourceMappingURL=index.mjs.map

  // packages/react/direction/src/direction.tsx

  var DirectionContext = react.createContext(void 0);
  var DirectionProvider = (props) => {
    const { dir, children } = props;
    return /* @__PURE__ */ jsx(DirectionContext.Provider, { value: dir, children });
  };
  function useDirection(localDir) {
    const globalDir = react.useContext(DirectionContext);
    return localDir || globalDir || 'ltr';
  }
  var Provider = /* unused pure expression or super */ null && DirectionProvider; // ./node_modules/.pnpm/@radix-ui+react-primitive@2.1.3_@types+react-dom@19.1.9_@types+react@19.1.12__@types+react@19_lmzbvsrp6azyiv2x7lhofvqlty/node_modules/@radix-ui/react-primitive/dist/index.mjs

  //# sourceMappingURL=index.mjs.map

  // src/primitive.tsx

  var NODES = [
    'a',
    'button',
    'div',
    'form',
    'h2',
    'h3',
    'img',
    'input',
    'label',
    'li',
    'nav',
    'ol',
    'p',
    'select',
    'span',
    'svg',
    'ul',
  ];
  var Primitive = NODES.reduce((primitive, node) => {
    const Slot = createSlot(`Primitive.${node}`);
    const Node = react.forwardRef((props, forwardedRef) => {
      const { asChild, ...primitiveProps } = props;
      const Comp = asChild ? Slot : node;
      if (typeof window !== 'undefined') {
        window[Symbol.for('radix-ui')] = true;
      }
      return /* @__PURE__ */ (0, jsx_runtime.jsx)(Comp, { ...primitiveProps, ref: forwardedRef });
    });
    Node.displayName = `Primitive.${node}`;
    return { ...primitive, [node]: Node };
  }, {});
  function dispatchDiscreteCustomEvent(target, event) {
    if (target) react_dom.flushSync(() => target.dispatchEvent(event));
  }
  var Root = /* unused pure expression or super */ null && Primitive; // ./node_modules/.pnpm/@radix-ui+react-use-callback-ref@1.1.1_@types+react@19.1.12_react@19.1.1/node_modules/@radix-ui/react-use-callback-ref/dist/index.mjs

  //# sourceMappingURL=index.mjs.map

  // packages/react/use-callback-ref/src/use-callback-ref.tsx

  function useCallbackRef(callback) {
    const callbackRef = react.useRef(callback);
    react.useEffect(() => {
      callbackRef.current = callback;
    });
    return react.useMemo(
      () =>
        (...args) =>
          callbackRef.current?.(...args),
      []
    );
  } // ./node_modules/.pnpm/@radix-ui+react-use-escape-keydown@1.1.1_@types+react@19.1.12_react@19.1.1/node_modules/@radix-ui/react-use-escape-keydown/dist/index.mjs

  //# sourceMappingURL=index.mjs.map

  // packages/react/use-escape-keydown/src/use-escape-keydown.tsx

  function useEscapeKeydown(onEscapeKeyDownProp, ownerDocument = globalThis?.document) {
    const onEscapeKeyDown = useCallbackRef(onEscapeKeyDownProp);
    react.useEffect(() => {
      const handleKeyDown = (event) => {
        if (event.key === 'Escape') {
          onEscapeKeyDown(event);
        }
      };
      ownerDocument.addEventListener('keydown', handleKeyDown, { capture: true });
      return () => ownerDocument.removeEventListener('keydown', handleKeyDown, { capture: true });
    }, [onEscapeKeyDown, ownerDocument]);
  } // ./node_modules/.pnpm/@radix-ui+react-dismissable-layer@1.1.11_@types+react-dom@19.1.9_@types+react@19.1.12__@types_of6ds77xiw334td7izmtysi7om/node_modules/@radix-ui/react-dismissable-layer/dist/index.mjs

  //# sourceMappingURL=index.mjs.map

  ('use client');

  // src/dismissable-layer.tsx

  var DISMISSABLE_LAYER_NAME = 'DismissableLayer';
  var CONTEXT_UPDATE = 'dismissableLayer.update';
  var POINTER_DOWN_OUTSIDE = 'dismissableLayer.pointerDownOutside';
  var FOCUS_OUTSIDE = 'dismissableLayer.focusOutside';
  var originalBodyPointerEvents;
  var DismissableLayerContext = react.createContext({
    layers: /* @__PURE__ */ new Set(),
    layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
    branches: /* @__PURE__ */ new Set(),
  });
  var DismissableLayer = react.forwardRef((props, forwardedRef) => {
    const {
      disableOutsidePointerEvents = false,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      onDismiss,
      ...layerProps
    } = props;
    const context = react.useContext(DismissableLayerContext);
    const [node, setNode] = react.useState(null);
    const ownerDocument = node?.ownerDocument ?? globalThis?.document;
    const [, force] = react.useState({});
    const composedRefs = useComposedRefs(forwardedRef, (node2) => setNode(node2));
    const layers = Array.from(context.layers);
    const [highestLayerWithOutsidePointerEventsDisabled] = [
      ...context.layersWithOutsidePointerEventsDisabled,
    ].slice(-1);
    const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(
      highestLayerWithOutsidePointerEventsDisabled
    );
    const index = node ? layers.indexOf(node) : -1;
    const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;
    const isPointerEventsEnabled = index >= highestLayerWithOutsidePointerEventsDisabledIndex;
    const pointerDownOutside = usePointerDownOutside((event) => {
      const target = event.target;
      const isPointerDownOnBranch = [...context.branches].some((branch) => branch.contains(target));
      if (!isPointerEventsEnabled || isPointerDownOnBranch) return;
      onPointerDownOutside?.(event);
      onInteractOutside?.(event);
      if (!event.defaultPrevented) onDismiss?.();
    }, ownerDocument);
    const focusOutside = useFocusOutside((event) => {
      const target = event.target;
      const isFocusInBranch = [...context.branches].some((branch) => branch.contains(target));
      if (isFocusInBranch) return;
      onFocusOutside?.(event);
      onInteractOutside?.(event);
      if (!event.defaultPrevented) onDismiss?.();
    }, ownerDocument);
    useEscapeKeydown((event) => {
      const isHighestLayer = index === context.layers.size - 1;
      if (!isHighestLayer) return;
      onEscapeKeyDown?.(event);
      if (!event.defaultPrevented && onDismiss) {
        event.preventDefault();
        onDismiss();
      }
    }, ownerDocument);
    react.useEffect(() => {
      if (!node) return;
      if (disableOutsidePointerEvents) {
        if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
          originalBodyPointerEvents = ownerDocument.body.style.pointerEvents;
          ownerDocument.body.style.pointerEvents = 'none';
        }
        context.layersWithOutsidePointerEventsDisabled.add(node);
      }
      context.layers.add(node);
      dispatchUpdate();
      return () => {
        if (
          disableOutsidePointerEvents &&
          context.layersWithOutsidePointerEventsDisabled.size === 1
        ) {
          ownerDocument.body.style.pointerEvents = originalBodyPointerEvents;
        }
      };
    }, [node, ownerDocument, disableOutsidePointerEvents, context]);
    react.useEffect(() => {
      return () => {
        if (!node) return;
        context.layers.delete(node);
        context.layersWithOutsidePointerEventsDisabled.delete(node);
        dispatchUpdate();
      };
    }, [node, context]);
    react.useEffect(() => {
      const handleUpdate = () => force({});
      document.addEventListener(CONTEXT_UPDATE, handleUpdate);
      return () => document.removeEventListener(CONTEXT_UPDATE, handleUpdate);
    }, []);
    return /* @__PURE__ */ (0, jsx_runtime.jsx)(Primitive.div, {
      ...layerProps,
      ref: composedRefs,
      style: {
        pointerEvents: isBodyPointerEventsDisabled
          ? isPointerEventsEnabled
            ? 'auto'
            : 'none'
          : void 0,
        ...props.style,
      },
      onFocusCapture: composeEventHandlers(props.onFocusCapture, focusOutside.onFocusCapture),
      onBlurCapture: composeEventHandlers(props.onBlurCapture, focusOutside.onBlurCapture),
      onPointerDownCapture: composeEventHandlers(
        props.onPointerDownCapture,
        pointerDownOutside.onPointerDownCapture
      ),
    });
  });
  DismissableLayer.displayName = DISMISSABLE_LAYER_NAME;
  var BRANCH_NAME = 'DismissableLayerBranch';
  var DismissableLayerBranch = react.forwardRef((props, forwardedRef) => {
    const context = react.useContext(DismissableLayerContext);
    const ref = react.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    react.useEffect(() => {
      const node = ref.current;
      if (node) {
        context.branches.add(node);
        return () => {
          context.branches.delete(node);
        };
      }
    }, [context.branches]);
    return /* @__PURE__ */ (0, jsx_runtime.jsx)(Primitive.div, { ...props, ref: composedRefs });
  });
  DismissableLayerBranch.displayName = BRANCH_NAME;
  function usePointerDownOutside(onPointerDownOutside, ownerDocument = globalThis?.document) {
    const handlePointerDownOutside = useCallbackRef(onPointerDownOutside);
    const isPointerInsideReactTreeRef = react.useRef(false);
    const handleClickRef = react.useRef(() => {});
    react.useEffect(() => {
      const handlePointerDown = (event) => {
        if (event.target && !isPointerInsideReactTreeRef.current) {
          let handleAndDispatchPointerDownOutsideEvent2 = function () {
            handleAndDispatchCustomEvent(
              POINTER_DOWN_OUTSIDE,
              handlePointerDownOutside,
              eventDetail,
              { discrete: true }
            );
          };
          var handleAndDispatchPointerDownOutsideEvent = handleAndDispatchPointerDownOutsideEvent2;
          const eventDetail = { originalEvent: event };
          if (event.pointerType === 'touch') {
            ownerDocument.removeEventListener('click', handleClickRef.current);
            handleClickRef.current = handleAndDispatchPointerDownOutsideEvent2;
            ownerDocument.addEventListener('click', handleClickRef.current, { once: true });
          } else {
            handleAndDispatchPointerDownOutsideEvent2();
          }
        } else {
          ownerDocument.removeEventListener('click', handleClickRef.current);
        }
        isPointerInsideReactTreeRef.current = false;
      };
      const timerId = window.setTimeout(() => {
        ownerDocument.addEventListener('pointerdown', handlePointerDown);
      }, 0);
      return () => {
        window.clearTimeout(timerId);
        ownerDocument.removeEventListener('pointerdown', handlePointerDown);
        ownerDocument.removeEventListener('click', handleClickRef.current);
      };
    }, [ownerDocument, handlePointerDownOutside]);
    return {
      // ensures we check React component tree (not just DOM tree)
      onPointerDownCapture: () => (isPointerInsideReactTreeRef.current = true),
    };
  }
  function useFocusOutside(onFocusOutside, ownerDocument = globalThis?.document) {
    const handleFocusOutside = useCallbackRef(onFocusOutside);
    const isFocusInsideReactTreeRef = react.useRef(false);
    react.useEffect(() => {
      const handleFocus = (event) => {
        if (event.target && !isFocusInsideReactTreeRef.current) {
          const eventDetail = { originalEvent: event };
          handleAndDispatchCustomEvent(FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {
            discrete: false,
          });
        }
      };
      ownerDocument.addEventListener('focusin', handleFocus);
      return () => ownerDocument.removeEventListener('focusin', handleFocus);
    }, [ownerDocument, handleFocusOutside]);
    return {
      onFocusCapture: () => (isFocusInsideReactTreeRef.current = true),
      onBlurCapture: () => (isFocusInsideReactTreeRef.current = false),
    };
  }
  function dispatchUpdate() {
    const event = new CustomEvent(CONTEXT_UPDATE);
    document.dispatchEvent(event);
  }
  function handleAndDispatchCustomEvent(name, handler, detail, { discrete }) {
    const target = detail.originalEvent.target;
    const event = new CustomEvent(name, { bubbles: false, cancelable: true, detail });
    if (handler) target.addEventListener(name, handler, { once: true });
    if (discrete) {
      dispatchDiscreteCustomEvent(target, event);
    } else {
      target.dispatchEvent(event);
    }
  }
  var dist_Root = /* unused pure expression or super */ null && DismissableLayer;
  var Branch = /* unused pure expression or super */ null && DismissableLayerBranch; // ./node_modules/.pnpm/@radix-ui+react-focus-guards@1.1.3_@types+react@19.1.12_react@19.1.1/node_modules/@radix-ui/react-focus-guards/dist/index.mjs

  //# sourceMappingURL=index.mjs.map

  ('use client');

  // src/focus-guards.tsx

  var count = 0;
  function FocusGuards(props) {
    useFocusGuards();
    return props.children;
  }
  function useFocusGuards() {
    react.useEffect(() => {
      const edgeGuards = document.querySelectorAll('[data-radix-focus-guard]');
      document.body.insertAdjacentElement('afterbegin', edgeGuards[0] ?? createFocusGuard());
      document.body.insertAdjacentElement('beforeend', edgeGuards[1] ?? createFocusGuard());
      count++;
      return () => {
        if (count === 1) {
          document.querySelectorAll('[data-radix-focus-guard]').forEach((node) => node.remove());
        }
        count--;
      };
    }, []);
  }
  function createFocusGuard() {
    const element = document.createElement('span');
    element.setAttribute('data-radix-focus-guard', '');
    element.tabIndex = 0;
    element.style.outline = 'none';
    element.style.opacity = '0';
    element.style.position = 'fixed';
    element.style.pointerEvents = 'none';
    return element;
  } // ./node_modules/.pnpm/@radix-ui+react-focus-scope@1.1.7_@types+react-dom@19.1.9_@types+react@19.1.12__@types+react@_53re6awiyhio6bc3nqekwpz7tq/node_modules/@radix-ui/react-focus-scope/dist/index.mjs

  //# sourceMappingURL=index.mjs.map

  ('use client');

  // src/focus-scope.tsx

  var AUTOFOCUS_ON_MOUNT = 'focusScope.autoFocusOnMount';
  var AUTOFOCUS_ON_UNMOUNT = 'focusScope.autoFocusOnUnmount';
  var EVENT_OPTIONS = { bubbles: false, cancelable: true };
  var FOCUS_SCOPE_NAME = 'FocusScope';
  var FocusScope = react.forwardRef((props, forwardedRef) => {
    const {
      loop = false,
      trapped = false,
      onMountAutoFocus: onMountAutoFocusProp,
      onUnmountAutoFocus: onUnmountAutoFocusProp,
      ...scopeProps
    } = props;
    const [container, setContainer] = react.useState(null);
    const onMountAutoFocus = useCallbackRef(onMountAutoFocusProp);
    const onUnmountAutoFocus = useCallbackRef(onUnmountAutoFocusProp);
    const lastFocusedElementRef = react.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setContainer(node));
    const focusScope = react.useRef({
      paused: false,
      pause() {
        this.paused = true;
      },
      resume() {
        this.paused = false;
      },
    }).current;
    react.useEffect(() => {
      if (trapped) {
        let handleFocusIn2 = function (event) {
            if (focusScope.paused || !container) return;
            const target = event.target;
            if (container.contains(target)) {
              lastFocusedElementRef.current = target;
            } else {
              dist_focus(lastFocusedElementRef.current, { select: true });
            }
          },
          handleFocusOut2 = function (event) {
            if (focusScope.paused || !container) return;
            const relatedTarget = event.relatedTarget;
            if (relatedTarget === null) return;
            if (!container.contains(relatedTarget)) {
              dist_focus(lastFocusedElementRef.current, { select: true });
            }
          },
          handleMutations2 = function (mutations) {
            const focusedElement = document.activeElement;
            if (focusedElement !== document.body) return;
            for (const mutation of mutations) {
              if (mutation.removedNodes.length > 0) dist_focus(container);
            }
          };
        var handleFocusIn = handleFocusIn2,
          handleFocusOut = handleFocusOut2,
          handleMutations = handleMutations2;
        document.addEventListener('focusin', handleFocusIn2);
        document.addEventListener('focusout', handleFocusOut2);
        const mutationObserver = new MutationObserver(handleMutations2);
        if (container) mutationObserver.observe(container, { childList: true, subtree: true });
        return () => {
          document.removeEventListener('focusin', handleFocusIn2);
          document.removeEventListener('focusout', handleFocusOut2);
          mutationObserver.disconnect();
        };
      }
    }, [trapped, container, focusScope.paused]);
    react.useEffect(() => {
      if (container) {
        focusScopesStack.add(focusScope);
        const previouslyFocusedElement = document.activeElement;
        const hasFocusedCandidate = container.contains(previouslyFocusedElement);
        if (!hasFocusedCandidate) {
          const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);
          container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
          container.dispatchEvent(mountEvent);
          if (!mountEvent.defaultPrevented) {
            focusFirst(removeLinks(getTabbableCandidates(container)), { select: true });
            if (document.activeElement === previouslyFocusedElement) {
              dist_focus(container);
            }
          }
        }
        return () => {
          container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
          setTimeout(() => {
            const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS);
            container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
            container.dispatchEvent(unmountEvent);
            if (!unmountEvent.defaultPrevented) {
              dist_focus(previouslyFocusedElement ?? document.body, { select: true });
            }
            container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
            focusScopesStack.remove(focusScope);
          }, 0);
        };
      }
    }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);
    const handleKeyDown = react.useCallback(
      (event) => {
        if (!loop && !trapped) return;
        if (focusScope.paused) return;
        const isTabKey = event.key === 'Tab' && !event.altKey && !event.ctrlKey && !event.metaKey;
        const focusedElement = document.activeElement;
        if (isTabKey && focusedElement) {
          const container2 = event.currentTarget;
          const [first, last] = getTabbableEdges(container2);
          const hasTabbableElementsInside = first && last;
          if (!hasTabbableElementsInside) {
            if (focusedElement === container2) event.preventDefault();
          } else {
            if (!event.shiftKey && focusedElement === last) {
              event.preventDefault();
              if (loop) dist_focus(first, { select: true });
            } else if (event.shiftKey && focusedElement === first) {
              event.preventDefault();
              if (loop) dist_focus(last, { select: true });
            }
          }
        }
      },
      [loop, trapped, focusScope.paused]
    );
    return /* @__PURE__ */ (0, jsx_runtime.jsx)(Primitive.div, {
      tabIndex: -1,
      ...scopeProps,
      ref: composedRefs,
      onKeyDown: handleKeyDown,
    });
  });
  FocusScope.displayName = FOCUS_SCOPE_NAME;
  function focusFirst(candidates, { select = false } = {}) {
    const previouslyFocusedElement = document.activeElement;
    for (const candidate of candidates) {
      dist_focus(candidate, { select });
      if (document.activeElement !== previouslyFocusedElement) return;
    }
  }
  function getTabbableEdges(container) {
    const candidates = getTabbableCandidates(container);
    const first = findVisible(candidates, container);
    const last = findVisible(candidates.reverse(), container);
    return [first, last];
  }
  function getTabbableCandidates(container) {
    const nodes = [];
    const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
      acceptNode: (node) => {
        const isHiddenInput = node.tagName === 'INPUT' && node.type === 'hidden';
        if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;
        return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
      },
    });
    while (walker.nextNode()) nodes.push(walker.currentNode);
    return nodes;
  }
  function findVisible(elements, container) {
    for (const element of elements) {
      if (!isHidden(element, { upTo: container })) return element;
    }
  }
  function isHidden(node, { upTo }) {
    if (getComputedStyle(node).visibility === 'hidden') return true;
    while (node) {
      if (upTo !== void 0 && node === upTo) return false;
      if (getComputedStyle(node).display === 'none') return true;
      node = node.parentElement;
    }
    return false;
  }
  function isSelectableInput(element) {
    return element instanceof HTMLInputElement && 'select' in element;
  }
  function dist_focus(element, { select = false } = {}) {
    if (element && element.focus) {
      const previouslyFocusedElement = document.activeElement;
      element.focus({ preventScroll: true });
      if (element !== previouslyFocusedElement && isSelectableInput(element) && select)
        element.select();
    }
  }
  var focusScopesStack = createFocusScopesStack();
  function createFocusScopesStack() {
    let stack = [];
    return {
      add(focusScope) {
        const activeFocusScope = stack[0];
        if (focusScope !== activeFocusScope) {
          activeFocusScope?.pause();
        }
        stack = arrayRemove(stack, focusScope);
        stack.unshift(focusScope);
      },
      remove(focusScope) {
        stack = arrayRemove(stack, focusScope);
        stack[0]?.resume();
      },
    };
  }
  function arrayRemove(array, item) {
    const updatedArray = [...array];
    const index = updatedArray.indexOf(item);
    if (index !== -1) {
      updatedArray.splice(index, 1);
    }
    return updatedArray;
  }
  function removeLinks(items) {
    return items.filter((item) => item.tagName !== 'A');
  }
  var react_focus_scope_dist_Root = /* unused pure expression or super */ null && FocusScope; // ./node_modules/.pnpm/@radix-ui+react-use-layout-effect@1.1.1_@types+react@19.1.12_react@19.1.1/node_modules/@radix-ui/react-use-layout-effect/dist/index.mjs

  //# sourceMappingURL=index.mjs.map

  // packages/react/use-layout-effect/src/use-layout-effect.tsx

  var useLayoutEffect2 = globalThis?.document ? react.useLayoutEffect : () => {}; // ./node_modules/.pnpm/@radix-ui+react-id@1.1.1_@types+react@19.1.12_react@19.1.1/node_modules/@radix-ui/react-id/dist/index.mjs

  //# sourceMappingURL=index.mjs.map

  // packages/react/id/src/id.tsx

  var useReactId = react_namespaceObject[' useId '.trim().toString()] || (() => void 0);
  var dist_count = 0;
  function useId(deterministicId) {
    const [id, setId] = react.useState(useReactId());
    useLayoutEffect2(() => {
      if (!deterministicId) setId((reactId) => reactId ?? String(dist_count++));
    }, [deterministicId]);
    return deterministicId || (id ? `radix-${id}` : '');
  } // ./node_modules/.pnpm/@floating-ui+utils@0.2.10/node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs

  //# sourceMappingURL=index.mjs.map

  /**
   * Custom positioning reference element.
   * @see https://floating-ui.com/docs/virtual-elements
   */

  const sides = ['top', 'right', 'bottom', 'left'];
  const alignments = /* unused pure expression or super */ null && ['start', 'end'];
  const floating_ui_utils_placements =
    /*#__PURE__*/ /* unused pure expression or super */ null &&
    sides.reduce(
      (acc, side) => acc.concat(side, side + '-' + alignments[0], side + '-' + alignments[1]),
      []
    );
  const floating_ui_utils_min = Math.min;
  const floating_ui_utils_max = Math.max;
  const round = Math.round;
  const floor = Math.floor;
  const createCoords = (v) => ({
    x: v,
    y: v,
  });
  const oppositeSideMap = {
    left: 'right',
    right: 'left',
    bottom: 'top',
    top: 'bottom',
  };
  const oppositeAlignmentMap = {
    start: 'end',
    end: 'start',
  };
  function floating_ui_utils_clamp(start, value, end) {
    return floating_ui_utils_max(start, floating_ui_utils_min(value, end));
  }
  function floating_ui_utils_evaluate(value, param) {
    return typeof value === 'function' ? value(param) : value;
  }
  function floating_ui_utils_getSide(placement) {
    return placement.split('-')[0];
  }
  function floating_ui_utils_getAlignment(placement) {
    return placement.split('-')[1];
  }
  function getOppositeAxis(axis) {
    return axis === 'x' ? 'y' : 'x';
  }
  function getAxisLength(axis) {
    return axis === 'y' ? 'height' : 'width';
  }
  const yAxisSides = /*#__PURE__*/ new Set(['top', 'bottom']);
  function floating_ui_utils_getSideAxis(placement) {
    return yAxisSides.has(floating_ui_utils_getSide(placement)) ? 'y' : 'x';
  }
  function getAlignmentAxis(placement) {
    return getOppositeAxis(floating_ui_utils_getSideAxis(placement));
  }
  function floating_ui_utils_getAlignmentSides(placement, rects, rtl) {
    if (rtl === void 0) {
      rtl = false;
    }
    const alignment = floating_ui_utils_getAlignment(placement);
    const alignmentAxis = getAlignmentAxis(placement);
    const length = getAxisLength(alignmentAxis);
    let mainAlignmentSide =
      alignmentAxis === 'x'
        ? alignment === (rtl ? 'end' : 'start')
          ? 'right'
          : 'left'
        : alignment === 'start'
          ? 'bottom'
          : 'top';
    if (rects.reference[length] > rects.floating[length]) {
      mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
    }
    return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
  }
  function getExpandedPlacements(placement) {
    const oppositePlacement = getOppositePlacement(placement);
    return [
      floating_ui_utils_getOppositeAlignmentPlacement(placement),
      oppositePlacement,
      floating_ui_utils_getOppositeAlignmentPlacement(oppositePlacement),
    ];
  }
  function floating_ui_utils_getOppositeAlignmentPlacement(placement) {
    return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
  }
  const lrPlacement = ['left', 'right'];
  const rlPlacement = ['right', 'left'];
  const tbPlacement = ['top', 'bottom'];
  const btPlacement = ['bottom', 'top'];
  function getSideList(side, isStart, rtl) {
    switch (side) {
      case 'top':
      case 'bottom':
        if (rtl) return isStart ? rlPlacement : lrPlacement;
        return isStart ? lrPlacement : rlPlacement;
      case 'left':
      case 'right':
        return isStart ? tbPlacement : btPlacement;
      default:
        return [];
    }
  }
  function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
    const alignment = floating_ui_utils_getAlignment(placement);
    let list = getSideList(floating_ui_utils_getSide(placement), direction === 'start', rtl);
    if (alignment) {
      list = list.map((side) => side + '-' + alignment);
      if (flipAlignment) {
        list = list.concat(list.map(floating_ui_utils_getOppositeAlignmentPlacement));
      }
    }
    return list;
  }
  function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
  }
  function expandPaddingObject(padding) {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      ...padding,
    };
  }
  function floating_ui_utils_getPaddingObject(padding) {
    return typeof padding !== 'number'
      ? expandPaddingObject(padding)
      : {
          top: padding,
          right: padding,
          bottom: padding,
          left: padding,
        };
  }
  function floating_ui_utils_rectToClientRect(rect) {
    const { x, y, width, height } = rect;
    return {
      width,
      height,
      top: y,
      left: x,
      right: x + width,
      bottom: y + height,
      x,
      y,
    };
  } // ./node_modules/.pnpm/@floating-ui+core@1.7.3/node_modules/@floating-ui/core/dist/floating-ui.core.mjs

  function computeCoordsFromPlacement(_ref, placement, rtl) {
    let { reference, floating } = _ref;
    const sideAxis = floating_ui_utils_getSideAxis(placement);
    const alignmentAxis = getAlignmentAxis(placement);
    const alignLength = getAxisLength(alignmentAxis);
    const side = floating_ui_utils_getSide(placement);
    const isVertical = sideAxis === 'y';
    const commonX = reference.x + reference.width / 2 - floating.width / 2;
    const commonY = reference.y + reference.height / 2 - floating.height / 2;
    const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
    let coords;
    switch (side) {
      case 'top':
        coords = {
          x: commonX,
          y: reference.y - floating.height,
        };
        break;
      case 'bottom':
        coords = {
          x: commonX,
          y: reference.y + reference.height,
        };
        break;
      case 'right':
        coords = {
          x: reference.x + reference.width,
          y: commonY,
        };
        break;
      case 'left':
        coords = {
          x: reference.x - floating.width,
          y: commonY,
        };
        break;
      default:
        coords = {
          x: reference.x,
          y: reference.y,
        };
    }
    switch (floating_ui_utils_getAlignment(placement)) {
      case 'start':
        coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
        break;
      case 'end':
        coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
        break;
    }
    return coords;
  }

  /**
   * Computes the `x` and `y` coordinates that will place the floating element
   * next to a given reference element.
   *
   * This export does not have any `platform` interface logic. You will need to
   * write one for the platform you are using Floating UI with.
   */
  const computePosition = async (reference, floating, config) => {
    const { placement = 'bottom', strategy = 'absolute', middleware = [], platform } = config;
    const validMiddleware = middleware.filter(Boolean);
    const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));
    let rects = await platform.getElementRects({
      reference,
      floating,
      strategy,
    });
    let { x, y } = computeCoordsFromPlacement(rects, placement, rtl);
    let statefulPlacement = placement;
    let middlewareData = {};
    let resetCount = 0;
    for (let i = 0; i < validMiddleware.length; i++) {
      const { name, fn } = validMiddleware[i];
      const {
        x: nextX,
        y: nextY,
        data,
        reset,
      } = await fn({
        x,
        y,
        initialPlacement: placement,
        placement: statefulPlacement,
        strategy,
        middlewareData,
        rects,
        platform,
        elements: {
          reference,
          floating,
        },
      });
      x = nextX != null ? nextX : x;
      y = nextY != null ? nextY : y;
      middlewareData = {
        ...middlewareData,
        [name]: {
          ...middlewareData[name],
          ...data,
        },
      };
      if (reset && resetCount <= 50) {
        resetCount++;
        if (typeof reset === 'object') {
          if (reset.placement) {
            statefulPlacement = reset.placement;
          }
          if (reset.rects) {
            rects =
              reset.rects === true
                ? await platform.getElementRects({
                    reference,
                    floating,
                    strategy,
                  })
                : reset.rects;
          }
          ({ x, y } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
        }
        i = -1;
      }
    }
    return {
      x,
      y,
      placement: statefulPlacement,
      strategy,
      middlewareData,
    };
  };

  /**
   * Resolves with an object of overflow side offsets that determine how much the
   * element is overflowing a given clipping boundary on each side.
   * - positive = overflowing the boundary by that number of pixels
   * - negative = how many pixels left before it will overflow
   * - 0 = lies flush with the boundary
   * @see https://floating-ui.com/docs/detectOverflow
   */
  async function detectOverflow(state, options) {
    var _await$platform$isEle;
    if (options === void 0) {
      options = {};
    }
    const { x, y, platform, rects, elements, strategy } = state;
    const {
      boundary = 'clippingAncestors',
      rootBoundary = 'viewport',
      elementContext = 'floating',
      altBoundary = false,
      padding = 0,
    } = floating_ui_utils_evaluate(options, state);
    const paddingObject = floating_ui_utils_getPaddingObject(padding);
    const altContext = elementContext === 'floating' ? 'reference' : 'floating';
    const element = elements[altBoundary ? altContext : elementContext];
    const clippingClientRect = floating_ui_utils_rectToClientRect(
      await platform.getClippingRect({
        element: (
          (_await$platform$isEle = await (platform.isElement == null
            ? void 0
            : platform.isElement(element))) != null
            ? _await$platform$isEle
            : true
        )
          ? element
          : element.contextElement ||
            (await (platform.getDocumentElement == null
              ? void 0
              : platform.getDocumentElement(elements.floating))),
        boundary,
        rootBoundary,
        strategy,
      })
    );
    const rect =
      elementContext === 'floating'
        ? {
            x,
            y,
            width: rects.floating.width,
            height: rects.floating.height,
          }
        : rects.reference;
    const offsetParent = await (platform.getOffsetParent == null
      ? void 0
      : platform.getOffsetParent(elements.floating));
    const offsetScale = (await (platform.isElement == null
      ? void 0
      : platform.isElement(offsetParent)))
      ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {
          x: 1,
          y: 1,
        }
      : {
          x: 1,
          y: 1,
        };
    const elementClientRect = floating_ui_utils_rectToClientRect(
      platform.convertOffsetParentRelativeRectToViewportRelativeRect
        ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({
            elements,
            rect,
            offsetParent,
            strategy,
          })
        : rect
    );
    return {
      top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
      bottom:
        (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) /
        offsetScale.y,
      left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
      right:
        (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x,
    };
  }

  /**
   * Provides data to position an inner element of the floating element so that it
   * appears centered to the reference element.
   * @see https://floating-ui.com/docs/arrow
   */
  const arrow = (options) => ({
    name: 'arrow',
    options,
    async fn(state) {
      const { x, y, placement, rects, platform, elements, middlewareData } = state;
      // Since `element` is required, we don't Partial<> the type.
      const { element, padding = 0 } = floating_ui_utils_evaluate(options, state) || {};
      if (element == null) {
        return {};
      }
      const paddingObject = floating_ui_utils_getPaddingObject(padding);
      const coords = {
        x,
        y,
      };
      const axis = getAlignmentAxis(placement);
      const length = getAxisLength(axis);
      const arrowDimensions = await platform.getDimensions(element);
      const isYAxis = axis === 'y';
      const minProp = isYAxis ? 'top' : 'left';
      const maxProp = isYAxis ? 'bottom' : 'right';
      const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';
      const endDiff =
        rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
      const startDiff = coords[axis] - rects.reference[axis];
      const arrowOffsetParent = await (platform.getOffsetParent == null
        ? void 0
        : platform.getOffsetParent(element));
      let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;

      // DOM platform can return `window` as the `offsetParent`.
      if (
        !clientSize ||
        !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))
      ) {
        clientSize = elements.floating[clientProp] || rects.floating[length];
      }
      const centerToReference = endDiff / 2 - startDiff / 2;

      // If the padding is large enough that it causes the arrow to no longer be
      // centered, modify the padding so that it is centered.
      const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
      const minPadding = floating_ui_utils_min(paddingObject[minProp], largestPossiblePadding);
      const maxPadding = floating_ui_utils_min(paddingObject[maxProp], largestPossiblePadding);

      // Make sure the arrow doesn't overflow the floating element if the center
      // point is outside the floating element's bounds.
      const min$1 = minPadding;
      const max = clientSize - arrowDimensions[length] - maxPadding;
      const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
      const offset = floating_ui_utils_clamp(min$1, center, max);

      // If the reference is small enough that the arrow's padding causes it to
      // to point to nothing for an aligned placement, adjust the offset of the
      // floating element itself. To ensure `shift()` continues to take action,
      // a single reset is performed when this is true.
      const shouldAddOffset =
        !middlewareData.arrow &&
        floating_ui_utils_getAlignment(placement) != null &&
        center !== offset &&
        rects.reference[length] / 2 -
          (center < min$1 ? minPadding : maxPadding) -
          arrowDimensions[length] / 2 <
          0;
      const alignmentOffset = shouldAddOffset
        ? center < min$1
          ? center - min$1
          : center - max
        : 0;
      return {
        [axis]: coords[axis] + alignmentOffset,
        data: {
          [axis]: offset,
          centerOffset: center - offset - alignmentOffset,
          ...(shouldAddOffset && {
            alignmentOffset,
          }),
        },
        reset: shouldAddOffset,
      };
    },
  });

  function getPlacementList(alignment, autoAlignment, allowedPlacements) {
    const allowedPlacementsSortedByAlignment = alignment
      ? [
          ...allowedPlacements.filter((placement) => getAlignment(placement) === alignment),
          ...allowedPlacements.filter((placement) => getAlignment(placement) !== alignment),
        ]
      : allowedPlacements.filter((placement) => getSide(placement) === placement);
    return allowedPlacementsSortedByAlignment.filter((placement) => {
      if (alignment) {
        return (
          getAlignment(placement) === alignment ||
          (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false)
        );
      }
      return true;
    });
  }
  /**
   * Optimizes the visibility of the floating element by choosing the placement
   * that has the most space available automatically, without needing to specify a
   * preferred placement. Alternative to `flip`.
   * @see https://floating-ui.com/docs/autoPlacement
   */
  const autoPlacement = function (options) {
    if (options === void 0) {
      options = {};
    }
    return {
      name: 'autoPlacement',
      options,
      async fn(state) {
        var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;
        const { rects, middlewareData, placement, platform, elements } = state;
        const {
          crossAxis = false,
          alignment,
          allowedPlacements = placements,
          autoAlignment = true,
          ...detectOverflowOptions
        } = evaluate(options, state);
        const placements$1 =
          alignment !== undefined || allowedPlacements === placements
            ? getPlacementList(alignment || null, autoAlignment, allowedPlacements)
            : allowedPlacements;
        const overflow = await detectOverflow(state, detectOverflowOptions);
        const currentIndex =
          ((_middlewareData$autoP = middlewareData.autoPlacement) == null
            ? void 0
            : _middlewareData$autoP.index) || 0;
        const currentPlacement = placements$1[currentIndex];
        if (currentPlacement == null) {
          return {};
        }
        const alignmentSides = getAlignmentSides(
          currentPlacement,
          rects,
          await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))
        );

        // Make `computeCoords` start from the right place.
        if (placement !== currentPlacement) {
          return {
            reset: {
              placement: placements$1[0],
            },
          };
        }
        const currentOverflows = [
          overflow[getSide(currentPlacement)],
          overflow[alignmentSides[0]],
          overflow[alignmentSides[1]],
        ];
        const allOverflows = [
          ...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null
            ? void 0
            : _middlewareData$autoP2.overflows) || []),
          {
            placement: currentPlacement,
            overflows: currentOverflows,
          },
        ];
        const nextPlacement = placements$1[currentIndex + 1];

        // There are more placements to check.
        if (nextPlacement) {
          return {
            data: {
              index: currentIndex + 1,
              overflows: allOverflows,
            },
            reset: {
              placement: nextPlacement,
            },
          };
        }
        const placementsSortedByMostSpace = allOverflows
          .map((d) => {
            const alignment = getAlignment(d.placement);
            return [
              d.placement,
              alignment && crossAxis
                ? // Check along the mainAxis and main crossAxis side.
                  d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0)
                : // Check only the mainAxis.
                  d.overflows[0],
              d.overflows,
            ];
          })
          .sort((a, b) => a[1] - b[1]);
        const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter((d) =>
          d[2]
            .slice(
              0,
              // Aligned placements should not check their opposite crossAxis
              // side.
              getAlignment(d[0]) ? 2 : 3
            )
            .every((v) => v <= 0)
        );
        const resetPlacement =
          ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null
            ? void 0
            : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];
        if (resetPlacement !== placement) {
          return {
            data: {
              index: currentIndex + 1,
              overflows: allOverflows,
            },
            reset: {
              placement: resetPlacement,
            },
          };
        }
        return {};
      },
    };
  };

  /**
   * Optimizes the visibility of the floating element by flipping the `placement`
   * in order to keep it in view when the preferred placement(s) will overflow the
   * clipping boundary. Alternative to `autoPlacement`.
   * @see https://floating-ui.com/docs/flip
   */
  const flip = function (options) {
    if (options === void 0) {
      options = {};
    }
    return {
      name: 'flip',
      options,
      async fn(state) {
        var _middlewareData$arrow, _middlewareData$flip;
        const { placement, middlewareData, rects, initialPlacement, platform, elements } = state;
        const {
          mainAxis: checkMainAxis = true,
          crossAxis: checkCrossAxis = true,
          fallbackPlacements: specifiedFallbackPlacements,
          fallbackStrategy = 'bestFit',
          fallbackAxisSideDirection = 'none',
          flipAlignment = true,
          ...detectOverflowOptions
        } = floating_ui_utils_evaluate(options, state);

        // If a reset by the arrow was caused due to an alignment offset being
        // added, we should skip any logic now since `flip()` has already done its
        // work.
        // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643
        if (
          (_middlewareData$arrow = middlewareData.arrow) != null &&
          _middlewareData$arrow.alignmentOffset
        ) {
          return {};
        }
        const side = floating_ui_utils_getSide(placement);
        const initialSideAxis = floating_ui_utils_getSideAxis(initialPlacement);
        const isBasePlacement = floating_ui_utils_getSide(initialPlacement) === initialPlacement;
        const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));
        const fallbackPlacements =
          specifiedFallbackPlacements ||
          (isBasePlacement || !flipAlignment
            ? [getOppositePlacement(initialPlacement)]
            : getExpandedPlacements(initialPlacement));
        const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== 'none';
        if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
          fallbackPlacements.push(
            ...getOppositeAxisPlacements(
              initialPlacement,
              flipAlignment,
              fallbackAxisSideDirection,
              rtl
            )
          );
        }
        const placements = [initialPlacement, ...fallbackPlacements];
        const overflow = await detectOverflow(state, detectOverflowOptions);
        const overflows = [];
        let overflowsData =
          ((_middlewareData$flip = middlewareData.flip) == null
            ? void 0
            : _middlewareData$flip.overflows) || [];
        if (checkMainAxis) {
          overflows.push(overflow[side]);
        }
        if (checkCrossAxis) {
          const sides = floating_ui_utils_getAlignmentSides(placement, rects, rtl);
          overflows.push(overflow[sides[0]], overflow[sides[1]]);
        }
        overflowsData = [
          ...overflowsData,
          {
            placement,
            overflows,
          },
        ];

        // One or more sides is overflowing.
        if (!overflows.every((side) => side <= 0)) {
          var _middlewareData$flip2, _overflowsData$filter;
          const nextIndex =
            (((_middlewareData$flip2 = middlewareData.flip) == null
              ? void 0
              : _middlewareData$flip2.index) || 0) + 1;
          const nextPlacement = placements[nextIndex];
          if (nextPlacement) {
            const ignoreCrossAxisOverflow =
              checkCrossAxis === 'alignment'
                ? initialSideAxis !== floating_ui_utils_getSideAxis(nextPlacement)
                : false;
            if (
              !ignoreCrossAxisOverflow ||
              // We leave the current main axis only if every placement on that axis
              // overflows the main axis.
              overflowsData.every((d) =>
                floating_ui_utils_getSideAxis(d.placement) === initialSideAxis
                  ? d.overflows[0] > 0
                  : true
              )
            ) {
              // Try next placement and re-run the lifecycle.
              return {
                data: {
                  index: nextIndex,
                  overflows: overflowsData,
                },
                reset: {
                  placement: nextPlacement,
                },
              };
            }
          }

          // First, find the candidates that fit on the mainAxis side of overflow,
          // then find the placement that fits the best on the main crossAxis side.
          let resetPlacement =
            (_overflowsData$filter = overflowsData
              .filter((d) => d.overflows[0] <= 0)
              .sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null
              ? void 0
              : _overflowsData$filter.placement;

          // Otherwise fallback.
          if (!resetPlacement) {
            switch (fallbackStrategy) {
              case 'bestFit': {
                var _overflowsData$filter2;
                const placement =
                  (_overflowsData$filter2 = overflowsData
                    .filter((d) => {
                      if (hasFallbackAxisSideDirection) {
                        const currentSideAxis = floating_ui_utils_getSideAxis(d.placement);
                        return (
                          currentSideAxis === initialSideAxis ||
                          // Create a bias to the `y` side axis due to horizontal
                          // reading directions favoring greater width.
                          currentSideAxis === 'y'
                        );
                      }
                      return true;
                    })
                    .map((d) => [
                      d.placement,
                      d.overflows
                        .filter((overflow) => overflow > 0)
                        .reduce((acc, overflow) => acc + overflow, 0),
                    ])
                    .sort((a, b) => a[1] - b[1])[0]) == null
                    ? void 0
                    : _overflowsData$filter2[0];
                if (placement) {
                  resetPlacement = placement;
                }
                break;
              }
              case 'initialPlacement':
                resetPlacement = initialPlacement;
                break;
            }
          }
          if (placement !== resetPlacement) {
            return {
              reset: {
                placement: resetPlacement,
              },
            };
          }
        }
        return {};
      },
    };
  };

  function getSideOffsets(overflow, rect) {
    return {
      top: overflow.top - rect.height,
      right: overflow.right - rect.width,
      bottom: overflow.bottom - rect.height,
      left: overflow.left - rect.width,
    };
  }
  function isAnySideFullyClipped(overflow) {
    return sides.some((side) => overflow[side] >= 0);
  }
  /**
   * Provides data to hide the floating element in applicable situations, such as
   * when it is not in the same clipping context as the reference element.
   * @see https://floating-ui.com/docs/hide
   */
  const hide = function (options) {
    if (options === void 0) {
      options = {};
    }
    return {
      name: 'hide',
      options,
      async fn(state) {
        const { rects } = state;
        const { strategy = 'referenceHidden', ...detectOverflowOptions } =
          floating_ui_utils_evaluate(options, state);
        switch (strategy) {
          case 'referenceHidden': {
            const overflow = await detectOverflow(state, {
              ...detectOverflowOptions,
              elementContext: 'reference',
            });
            const offsets = getSideOffsets(overflow, rects.reference);
            return {
              data: {
                referenceHiddenOffsets: offsets,
                referenceHidden: isAnySideFullyClipped(offsets),
              },
            };
          }
          case 'escaped': {
            const overflow = await detectOverflow(state, {
              ...detectOverflowOptions,
              altBoundary: true,
            });
            const offsets = getSideOffsets(overflow, rects.floating);
            return {
              data: {
                escapedOffsets: offsets,
                escaped: isAnySideFullyClipped(offsets),
              },
            };
          }
          default: {
            return {};
          }
        }
      },
    };
  };

  function getBoundingRect(rects) {
    const minX = min(...rects.map((rect) => rect.left));
    const minY = min(...rects.map((rect) => rect.top));
    const maxX = max(...rects.map((rect) => rect.right));
    const maxY = max(...rects.map((rect) => rect.bottom));
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY,
    };
  }
  function getRectsByLine(rects) {
    const sortedRects = rects.slice().sort((a, b) => a.y - b.y);
    const groups = [];
    let prevRect = null;
    for (let i = 0; i < sortedRects.length; i++) {
      const rect = sortedRects[i];
      if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {
        groups.push([rect]);
      } else {
        groups[groups.length - 1].push(rect);
      }
      prevRect = rect;
    }
    return groups.map((rect) => rectToClientRect(getBoundingRect(rect)));
  }
  /**
   * Provides improved positioning for inline reference elements that can span
   * over multiple lines, such as hyperlinks or range selections.
   * @see https://floating-ui.com/docs/inline
   */
  const inline = function (options) {
    if (options === void 0) {
      options = {};
    }
    return {
      name: 'inline',
      options,
      async fn(state) {
        const { placement, elements, rects, platform, strategy } = state;
        // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a
        // ClientRect's bounds, despite the event listener being triggered. A
        // padding of 2 seems to handle this issue.
        const { padding = 2, x, y } = evaluate(options, state);
        const nativeClientRects = Array.from(
          (await (platform.getClientRects == null
            ? void 0
            : platform.getClientRects(elements.reference))) || []
        );
        const clientRects = getRectsByLine(nativeClientRects);
        const fallback = rectToClientRect(getBoundingRect(nativeClientRects));
        const paddingObject = getPaddingObject(padding);
        function getBoundingClientRect() {
          // There are two rects and they are disjoined.
          if (
            clientRects.length === 2 &&
            clientRects[0].left > clientRects[1].right &&
            x != null &&
            y != null
          ) {
            // Find the first rect in which the point is fully inside.
            return (
              clientRects.find(
                (rect) =>
                  x > rect.left - paddingObject.left &&
                  x < rect.right + paddingObject.right &&
                  y > rect.top - paddingObject.top &&
                  y < rect.bottom + paddingObject.bottom
              ) || fallback
            );
          }

          // There are 2 or more connected rects.
          if (clientRects.length >= 2) {
            if (getSideAxis(placement) === 'y') {
              const firstRect = clientRects[0];
              const lastRect = clientRects[clientRects.length - 1];
              const isTop = getSide(placement) === 'top';
              const top = firstRect.top;
              const bottom = lastRect.bottom;
              const left = isTop ? firstRect.left : lastRect.left;
              const right = isTop ? firstRect.right : lastRect.right;
              const width = right - left;
              const height = bottom - top;
              return {
                top,
                bottom,
                left,
                right,
                width,
                height,
                x: left,
                y: top,
              };
            }
            const isLeftSide = getSide(placement) === 'left';
            const maxRight = max(...clientRects.map((rect) => rect.right));
            const minLeft = min(...clientRects.map((rect) => rect.left));
            const measureRects = clientRects.filter((rect) =>
              isLeftSide ? rect.left === minLeft : rect.right === maxRight
            );
            const top = measureRects[0].top;
            const bottom = measureRects[measureRects.length - 1].bottom;
            const left = minLeft;
            const right = maxRight;
            const width = right - left;
            const height = bottom - top;
            return {
              top,
              bottom,
              left,
              right,
              width,
              height,
              x: left,
              y: top,
            };
          }
          return fallback;
        }
        const resetRects = await platform.getElementRects({
          reference: {
            getBoundingClientRect,
          },
          floating: elements.floating,
          strategy,
        });
        if (
          rects.reference.x !== resetRects.reference.x ||
          rects.reference.y !== resetRects.reference.y ||
          rects.reference.width !== resetRects.reference.width ||
          rects.reference.height !== resetRects.reference.height
        ) {
          return {
            reset: {
              rects: resetRects,
            },
          };
        }
        return {};
      },
    };
  };

  const originSides = /*#__PURE__*/ new Set(['left', 'top']);

  // For type backwards-compatibility, the `OffsetOptions` type was also
  // Derivable.

  async function convertValueToCoords(state, options) {
    const { placement, platform, elements } = state;
    const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));
    const side = floating_ui_utils_getSide(placement);
    const alignment = floating_ui_utils_getAlignment(placement);
    const isVertical = floating_ui_utils_getSideAxis(placement) === 'y';
    const mainAxisMulti = originSides.has(side) ? -1 : 1;
    const crossAxisMulti = rtl && isVertical ? -1 : 1;
    const rawValue = floating_ui_utils_evaluate(options, state);

    // eslint-disable-next-line prefer-const
    let { mainAxis, crossAxis, alignmentAxis } =
      typeof rawValue === 'number'
        ? {
            mainAxis: rawValue,
            crossAxis: 0,
            alignmentAxis: null,
          }
        : {
            mainAxis: rawValue.mainAxis || 0,
            crossAxis: rawValue.crossAxis || 0,
            alignmentAxis: rawValue.alignmentAxis,
          };
    if (alignment && typeof alignmentAxis === 'number') {
      crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;
    }
    return isVertical
      ? {
          x: crossAxis * crossAxisMulti,
          y: mainAxis * mainAxisMulti,
        }
      : {
          x: mainAxis * mainAxisMulti,
          y: crossAxis * crossAxisMulti,
        };
  }

  /**
   * Modifies the placement by translating the floating element along the
   * specified axes.
   * A number (shorthand for `mainAxis` or distance), or an axes configuration
   * object may be passed.
   * @see https://floating-ui.com/docs/offset
   */
  const offset = function (options) {
    if (options === void 0) {
      options = 0;
    }
    return {
      name: 'offset',
      options,
      async fn(state) {
        var _middlewareData$offse, _middlewareData$arrow;
        const { x, y, placement, middlewareData } = state;
        const diffCoords = await convertValueToCoords(state, options);

        // If the placement is the same and the arrow caused an alignment offset
        // then we don't need to change the positioning coordinates.
        if (
          placement ===
            ((_middlewareData$offse = middlewareData.offset) == null
              ? void 0
              : _middlewareData$offse.placement) &&
          (_middlewareData$arrow = middlewareData.arrow) != null &&
          _middlewareData$arrow.alignmentOffset
        ) {
          return {};
        }
        return {
          x: x + diffCoords.x,
          y: y + diffCoords.y,
          data: {
            ...diffCoords,
            placement,
          },
        };
      },
    };
  };

  /**
   * Optimizes the visibility of the floating element by shifting it in order to
   * keep it in view when it will overflow the clipping boundary.
   * @see https://floating-ui.com/docs/shift
   */
  const shift = function (options) {
    if (options === void 0) {
      options = {};
    }
    return {
      name: 'shift',
      options,
      async fn(state) {
        const { x, y, placement } = state;
        const {
          mainAxis: checkMainAxis = true,
          crossAxis: checkCrossAxis = false,
          limiter = {
            fn: (_ref) => {
              let { x, y } = _ref;
              return {
                x,
                y,
              };
            },
          },
          ...detectOverflowOptions
        } = floating_ui_utils_evaluate(options, state);
        const coords = {
          x,
          y,
        };
        const overflow = await detectOverflow(state, detectOverflowOptions);
        const crossAxis = floating_ui_utils_getSideAxis(floating_ui_utils_getSide(placement));
        const mainAxis = getOppositeAxis(crossAxis);
        let mainAxisCoord = coords[mainAxis];
        let crossAxisCoord = coords[crossAxis];
        if (checkMainAxis) {
          const minSide = mainAxis === 'y' ? 'top' : 'left';
          const maxSide = mainAxis === 'y' ? 'bottom' : 'right';
          const min = mainAxisCoord + overflow[minSide];
          const max = mainAxisCoord - overflow[maxSide];
          mainAxisCoord = floating_ui_utils_clamp(min, mainAxisCoord, max);
        }
        if (checkCrossAxis) {
          const minSide = crossAxis === 'y' ? 'top' : 'left';
          const maxSide = crossAxis === 'y' ? 'bottom' : 'right';
          const min = crossAxisCoord + overflow[minSide];
          const max = crossAxisCoord - overflow[maxSide];
          crossAxisCoord = floating_ui_utils_clamp(min, crossAxisCoord, max);
        }
        const limitedCoords = limiter.fn({
          ...state,
          [mainAxis]: mainAxisCoord,
          [crossAxis]: crossAxisCoord,
        });
        return {
          ...limitedCoords,
          data: {
            x: limitedCoords.x - x,
            y: limitedCoords.y - y,
            enabled: {
              [mainAxis]: checkMainAxis,
              [crossAxis]: checkCrossAxis,
            },
          },
        };
      },
    };
  };
  /**
   * Built-in `limiter` that will stop `shift()` at a certain point.
   */
  const limitShift = function (options) {
    if (options === void 0) {
      options = {};
    }
    return {
      options,
      fn(state) {
        const { x, y, placement, rects, middlewareData } = state;
        const {
          offset = 0,
          mainAxis: checkMainAxis = true,
          crossAxis: checkCrossAxis = true,
        } = floating_ui_utils_evaluate(options, state);
        const coords = {
          x,
          y,
        };
        const crossAxis = floating_ui_utils_getSideAxis(placement);
        const mainAxis = getOppositeAxis(crossAxis);
        let mainAxisCoord = coords[mainAxis];
        let crossAxisCoord = coords[crossAxis];
        const rawOffset = floating_ui_utils_evaluate(offset, state);
        const computedOffset =
          typeof rawOffset === 'number'
            ? {
                mainAxis: rawOffset,
                crossAxis: 0,
              }
            : {
                mainAxis: 0,
                crossAxis: 0,
                ...rawOffset,
              };
        if (checkMainAxis) {
          const len = mainAxis === 'y' ? 'height' : 'width';
          const limitMin =
            rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
          const limitMax =
            rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
          if (mainAxisCoord < limitMin) {
            mainAxisCoord = limitMin;
          } else if (mainAxisCoord > limitMax) {
            mainAxisCoord = limitMax;
          }
        }
        if (checkCrossAxis) {
          var _middlewareData$offse, _middlewareData$offse2;
          const len = mainAxis === 'y' ? 'width' : 'height';
          const isOriginSide = originSides.has(floating_ui_utils_getSide(placement));
          const limitMin =
            rects.reference[crossAxis] -
            rects.floating[len] +
            (isOriginSide
              ? ((_middlewareData$offse = middlewareData.offset) == null
                  ? void 0
                  : _middlewareData$offse[crossAxis]) || 0
              : 0) +
            (isOriginSide ? 0 : computedOffset.crossAxis);
          const limitMax =
            rects.reference[crossAxis] +
            rects.reference[len] +
            (isOriginSide
              ? 0
              : ((_middlewareData$offse2 = middlewareData.offset) == null
                  ? void 0
                  : _middlewareData$offse2[crossAxis]) || 0) -
            (isOriginSide ? computedOffset.crossAxis : 0);
          if (crossAxisCoord < limitMin) {
            crossAxisCoord = limitMin;
          } else if (crossAxisCoord > limitMax) {
            crossAxisCoord = limitMax;
          }
        }
        return {
          [mainAxis]: mainAxisCoord,
          [crossAxis]: crossAxisCoord,
        };
      },
    };
  };

  /**
   * Provides data that allows you to change the size of the floating element 
   * for instance, prevent it from overflowing the clipping boundary or match the
   * width of the reference element.
   * @see https://floating-ui.com/docs/size
   */
  const size = function (options) {
    if (options === void 0) {
      options = {};
    }
    return {
      name: 'size',
      options,
      async fn(state) {
        var _state$middlewareData, _state$middlewareData2;
        const { placement, rects, platform, elements } = state;
        const { apply = () => {}, ...detectOverflowOptions } = floating_ui_utils_evaluate(
          options,
          state
        );
        const overflow = await detectOverflow(state, detectOverflowOptions);
        const side = floating_ui_utils_getSide(placement);
        const alignment = floating_ui_utils_getAlignment(placement);
        const isYAxis = floating_ui_utils_getSideAxis(placement) === 'y';
        const { width, height } = rects.floating;
        let heightSide;
        let widthSide;
        if (side === 'top' || side === 'bottom') {
          heightSide = side;
          widthSide =
            alignment ===
            ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)))
              ? 'start'
              : 'end')
              ? 'left'
              : 'right';
        } else {
          widthSide = side;
          heightSide = alignment === 'end' ? 'top' : 'bottom';
        }
        const maximumClippingHeight = height - overflow.top - overflow.bottom;
        const maximumClippingWidth = width - overflow.left - overflow.right;
        const overflowAvailableHeight = floating_ui_utils_min(
          height - overflow[heightSide],
          maximumClippingHeight
        );
        const overflowAvailableWidth = floating_ui_utils_min(
          width - overflow[widthSide],
          maximumClippingWidth
        );
        const noShift = !state.middlewareData.shift;
        let availableHeight = overflowAvailableHeight;
        let availableWidth = overflowAvailableWidth;
        if (
          (_state$middlewareData = state.middlewareData.shift) != null &&
          _state$middlewareData.enabled.x
        ) {
          availableWidth = maximumClippingWidth;
        }
        if (
          (_state$middlewareData2 = state.middlewareData.shift) != null &&
          _state$middlewareData2.enabled.y
        ) {
          availableHeight = maximumClippingHeight;
        }
        if (noShift && !alignment) {
          const xMin = floating_ui_utils_max(overflow.left, 0);
          const xMax = floating_ui_utils_max(overflow.right, 0);
          const yMin = floating_ui_utils_max(overflow.top, 0);
          const yMax = floating_ui_utils_max(overflow.bottom, 0);
          if (isYAxis) {
            availableWidth =
              width -
              2 *
                (xMin !== 0 || xMax !== 0
                  ? xMin + xMax
                  : floating_ui_utils_max(overflow.left, overflow.right));
          } else {
            availableHeight =
              height -
              2 *
                (yMin !== 0 || yMax !== 0
                  ? yMin + yMax
                  : floating_ui_utils_max(overflow.top, overflow.bottom));
          }
        }
        await apply({
          ...state,
          availableWidth,
          availableHeight,
        });
        const nextDimensions = await platform.getDimensions(elements.floating);
        if (width !== nextDimensions.width || height !== nextDimensions.height) {
          return {
            reset: {
              rects: true,
            },
          };
        }
        return {};
      },
    };
  }; // ./node_modules/.pnpm/@floating-ui+utils@0.2.10/node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs

  function hasWindow() {
    return typeof window !== 'undefined';
  }
  function getNodeName(node) {
    if (isNode(node)) {
      return (node.nodeName || '').toLowerCase();
    }
    // Mocked nodes in testing environments may not be instances of Node. By
    // returning `#document` an infinite loop won't occur.
    // https://github.com/floating-ui/floating-ui/issues/2317
    return '#document';
  }
  function getWindow(node) {
    var _node$ownerDocument;
    return (
      (node == null || (_node$ownerDocument = node.ownerDocument) == null
        ? void 0
        : _node$ownerDocument.defaultView) || window
    );
  }
  function getDocumentElement(node) {
    var _ref;
    return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null
      ? void 0
      : _ref.documentElement;
  }
  function isNode(value) {
    if (!hasWindow()) {
      return false;
    }
    return value instanceof Node || value instanceof getWindow(value).Node;
  }
  function isElement(value) {
    if (!hasWindow()) {
      return false;
    }
    return value instanceof Element || value instanceof getWindow(value).Element;
  }
  function floating_ui_utils_dom_isHTMLElement(value) {
    if (!hasWindow()) {
      return false;
    }
    return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
  }
  function isShadowRoot(value) {
    if (!hasWindow() || typeof ShadowRoot === 'undefined') {
      return false;
    }
    return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
  }
  const invalidOverflowDisplayValues = /*#__PURE__*/ new Set(['inline', 'contents']);
  function isOverflowElement(element) {
    const { overflow, overflowX, overflowY, display } =
      floating_ui_utils_dom_getComputedStyle(element);
    return (
      /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) &&
      !invalidOverflowDisplayValues.has(display)
    );
  }
  const tableElements = /*#__PURE__*/ new Set(['table', 'td', 'th']);
  function isTableElement(element) {
    return tableElements.has(getNodeName(element));
  }
  const topLayerSelectors = [':popover-open', ':modal'];
  function isTopLayer(element) {
    return topLayerSelectors.some((selector) => {
      try {
        return element.matches(selector);
      } catch (_e) {
        return false;
      }
    });
  }
  const transformProperties = ['transform', 'translate', 'scale', 'rotate', 'perspective'];
  const willChangeValues = ['transform', 'translate', 'scale', 'rotate', 'perspective', 'filter'];
  const containValues = ['paint', 'layout', 'strict', 'content'];
  function isContainingBlock(elementOrCss) {
    const webkit = isWebKit();
    const css = isElement(elementOrCss)
      ? floating_ui_utils_dom_getComputedStyle(elementOrCss)
      : elementOrCss;

    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
    // https://drafts.csswg.org/css-transforms-2/#individual-transforms
    return (
      transformProperties.some((value) => (css[value] ? css[value] !== 'none' : false)) ||
      (css.containerType ? css.containerType !== 'normal' : false) ||
      (!webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false)) ||
      (!webkit && (css.filter ? css.filter !== 'none' : false)) ||
      willChangeValues.some((value) => (css.willChange || '').includes(value)) ||
      containValues.some((value) => (css.contain || '').includes(value))
    );
  }
  function getContainingBlock(element) {
    let currentNode = getParentNode(element);
    while (
      floating_ui_utils_dom_isHTMLElement(currentNode) &&
      !isLastTraversableNode(currentNode)
    ) {
      if (isContainingBlock(currentNode)) {
        return currentNode;
      } else if (isTopLayer(currentNode)) {
        return null;
      }
      currentNode = getParentNode(currentNode);
    }
    return null;
  }
  function isWebKit() {
    if (typeof CSS === 'undefined' || !CSS.supports) return false;
    return CSS.supports('-webkit-backdrop-filter', 'none');
  }
  const lastTraversableNodeNames = /*#__PURE__*/ new Set(['html', 'body', '#document']);
  function isLastTraversableNode(node) {
    return lastTraversableNodeNames.has(getNodeName(node));
  }
  function floating_ui_utils_dom_getComputedStyle(element) {
    return getWindow(element).getComputedStyle(element);
  }
  function getNodeScroll(element) {
    if (isElement(element)) {
      return {
        scrollLeft: element.scrollLeft,
        scrollTop: element.scrollTop,
      };
    }
    return {
      scrollLeft: element.scrollX,
      scrollTop: element.scrollY,
    };
  }
  function getParentNode(node) {
    if (getNodeName(node) === 'html') {
      return node;
    }
    const result =
      // Step into the shadow DOM of the parent of a slotted node.
      node.assignedSlot ||
      // DOM Element detected.
      node.parentNode ||
      // ShadowRoot detected.
      (isShadowRoot(node) && node.host) ||
      // Fallback.
      getDocumentElement(node);
    return isShadowRoot(result) ? result.host : result;
  }
  function getNearestOverflowAncestor(node) {
    const parentNode = getParentNode(node);
    if (isLastTraversableNode(parentNode)) {
      return node.ownerDocument ? node.ownerDocument.body : node.body;
    }
    if (floating_ui_utils_dom_isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
      return parentNode;
    }
    return getNearestOverflowAncestor(parentNode);
  }
  function getOverflowAncestors(node, list, traverseIframes) {
    var _node$ownerDocument2;
    if (list === void 0) {
      list = [];
    }
    if (traverseIframes === void 0) {
      traverseIframes = true;
    }
    const scrollableAncestor = getNearestOverflowAncestor(node);
    const isBody =
      scrollableAncestor ===
      ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
    const win = getWindow(scrollableAncestor);
    if (isBody) {
      const frameElement = getFrameElement(win);
      return list.concat(
        win,
        win.visualViewport || [],
        isOverflowElement(scrollableAncestor) ? scrollableAncestor : [],
        frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []
      );
    }
    return list.concat(
      scrollableAncestor,
      getOverflowAncestors(scrollableAncestor, [], traverseIframes)
    );
  }
  function getFrameElement(win) {
    return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
  } // ./node_modules/.pnpm/@floating-ui+dom@1.7.3/node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs

  function getCssDimensions(element) {
    const css = floating_ui_utils_dom_getComputedStyle(element);
    // In testing environments, the `width` and `height` properties are empty
    // strings for SVG elements, returning NaN. Fallback to `0` in this case.
    let width = parseFloat(css.width) || 0;
    let height = parseFloat(css.height) || 0;
    const hasOffset = floating_ui_utils_dom_isHTMLElement(element);
    const offsetWidth = hasOffset ? element.offsetWidth : width;
    const offsetHeight = hasOffset ? element.offsetHeight : height;
    const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
    if (shouldFallback) {
      width = offsetWidth;
      height = offsetHeight;
    }
    return {
      width,
      height,
      $: shouldFallback,
    };
  }

  function unwrapElement(element) {
    return !isElement(element) ? element.contextElement : element;
  }

  function getScale(element) {
    const domElement = unwrapElement(element);
    if (!floating_ui_utils_dom_isHTMLElement(domElement)) {
      return createCoords(1);
    }
    const rect = domElement.getBoundingClientRect();
    const { width, height, $ } = getCssDimensions(domElement);
    let x = ($ ? round(rect.width) : rect.width) / width;
    let y = ($ ? round(rect.height) : rect.height) / height;

    // 0, NaN, or Infinity should always fallback to 1.

    if (!x || !Number.isFinite(x)) {
      x = 1;
    }
    if (!y || !Number.isFinite(y)) {
      y = 1;
    }
    return {
      x,
      y,
    };
  }

  const noOffsets = /*#__PURE__*/ createCoords(0);
  function getVisualOffsets(element) {
    const win = getWindow(element);
    if (!isWebKit() || !win.visualViewport) {
      return noOffsets;
    }
    return {
      x: win.visualViewport.offsetLeft,
      y: win.visualViewport.offsetTop,
    };
  }
  function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
    if (isFixed === void 0) {
      isFixed = false;
    }
    if (!floatingOffsetParent || (isFixed && floatingOffsetParent !== getWindow(element))) {
      return false;
    }
    return isFixed;
  }

  function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
    if (includeScale === void 0) {
      includeScale = false;
    }
    if (isFixedStrategy === void 0) {
      isFixedStrategy = false;
    }
    const clientRect = element.getBoundingClientRect();
    const domElement = unwrapElement(element);
    let scale = createCoords(1);
    if (includeScale) {
      if (offsetParent) {
        if (isElement(offsetParent)) {
          scale = getScale(offsetParent);
        }
      } else {
        scale = getScale(element);
      }
    }
    const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent)
      ? getVisualOffsets(domElement)
      : createCoords(0);
    let x = (clientRect.left + visualOffsets.x) / scale.x;
    let y = (clientRect.top + visualOffsets.y) / scale.y;
    let width = clientRect.width / scale.x;
    let height = clientRect.height / scale.y;
    if (domElement) {
      const win = getWindow(domElement);
      const offsetWin =
        offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
      let currentWin = win;
      let currentIFrame = getFrameElement(currentWin);
      while (currentIFrame && offsetParent && offsetWin !== currentWin) {
        const iframeScale = getScale(currentIFrame);
        const iframeRect = currentIFrame.getBoundingClientRect();
        const css = floating_ui_utils_dom_getComputedStyle(currentIFrame);
        const left =
          iframeRect.left +
          (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
        const top =
          iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
        x *= iframeScale.x;
        y *= iframeScale.y;
        width *= iframeScale.x;
        height *= iframeScale.y;
        x += left;
        y += top;
        currentWin = getWindow(currentIFrame);
        currentIFrame = getFrameElement(currentWin);
      }
    }
    return floating_ui_utils_rectToClientRect({
      width,
      height,
      x,
      y,
    });
  }

  // If <html> has a CSS width greater than the viewport, then this will be
  // incorrect for RTL.
  function getWindowScrollBarX(element, rect) {
    const leftScroll = getNodeScroll(element).scrollLeft;
    if (!rect) {
      return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
    }
    return rect.left + leftScroll;
  }

  function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
    if (ignoreScrollbarX === void 0) {
      ignoreScrollbarX = false;
    }
    const htmlRect = documentElement.getBoundingClientRect();
    const x =
      htmlRect.left +
      scroll.scrollLeft -
      (ignoreScrollbarX
        ? 0
        : // RTL <body> scrollbar.
          getWindowScrollBarX(documentElement, htmlRect));
    const y = htmlRect.top + scroll.scrollTop;
    return {
      x,
      y,
    };
  }

  function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
    let { elements, rect, offsetParent, strategy } = _ref;
    const isFixed = strategy === 'fixed';
    const documentElement = getDocumentElement(offsetParent);
    const topLayer = elements ? isTopLayer(elements.floating) : false;
    if (offsetParent === documentElement || (topLayer && isFixed)) {
      return rect;
    }
    let scroll = {
      scrollLeft: 0,
      scrollTop: 0,
    };
    let scale = createCoords(1);
    const offsets = createCoords(0);
    const isOffsetParentAnElement = floating_ui_utils_dom_isHTMLElement(offsetParent);
    if (isOffsetParentAnElement || (!isOffsetParentAnElement && !isFixed)) {
      if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }
      if (floating_ui_utils_dom_isHTMLElement(offsetParent)) {
        const offsetRect = getBoundingClientRect(offsetParent);
        scale = getScale(offsetParent);
        offsets.x = offsetRect.x + offsetParent.clientLeft;
        offsets.y = offsetRect.y + offsetParent.clientTop;
      }
    }
    const htmlOffset =
      documentElement && !isOffsetParentAnElement && !isFixed
        ? getHTMLOffset(documentElement, scroll, true)
        : createCoords(0);
    return {
      width: rect.width * scale.x,
      height: rect.height * scale.y,
      x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
      y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y,
    };
  }

  function getClientRects(element) {
    return Array.from(element.getClientRects());
  }

  // Gets the entire size of the scrollable document area, even extending outside
  // of the `<html>` and `<body>` rect bounds if horizontally scrollable.
  function getDocumentRect(element) {
    const html = getDocumentElement(element);
    const scroll = getNodeScroll(element);
    const body = element.ownerDocument.body;
    const width = floating_ui_utils_max(
      html.scrollWidth,
      html.clientWidth,
      body.scrollWidth,
      body.clientWidth
    );
    const height = floating_ui_utils_max(
      html.scrollHeight,
      html.clientHeight,
      body.scrollHeight,
      body.clientHeight
    );
    let x = -scroll.scrollLeft + getWindowScrollBarX(element);
    const y = -scroll.scrollTop;
    if (floating_ui_utils_dom_getComputedStyle(body).direction === 'rtl') {
      x += floating_ui_utils_max(html.clientWidth, body.clientWidth) - width;
    }
    return {
      width,
      height,
      x,
      y,
    };
  }

  function getViewportRect(element, strategy) {
    const win = getWindow(element);
    const html = getDocumentElement(element);
    const visualViewport = win.visualViewport;
    let width = html.clientWidth;
    let height = html.clientHeight;
    let x = 0;
    let y = 0;
    if (visualViewport) {
      width = visualViewport.width;
      height = visualViewport.height;
      const visualViewportBased = isWebKit();
      if (!visualViewportBased || (visualViewportBased && strategy === 'fixed')) {
        x = visualViewport.offsetLeft;
        y = visualViewport.offsetTop;
      }
    }
    return {
      width,
      height,
      x,
      y,
    };
  }

  const absoluteOrFixed = /*#__PURE__*/ new Set(['absolute', 'fixed']);
  // Returns the inner client rect, subtracting scrollbars if present.
  function getInnerBoundingClientRect(element, strategy) {
    const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');
    const top = clientRect.top + element.clientTop;
    const left = clientRect.left + element.clientLeft;
    const scale = floating_ui_utils_dom_isHTMLElement(element)
      ? getScale(element)
      : createCoords(1);
    const width = element.clientWidth * scale.x;
    const height = element.clientHeight * scale.y;
    const x = left * scale.x;
    const y = top * scale.y;
    return {
      width,
      height,
      x,
      y,
    };
  }
  function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
    let rect;
    if (clippingAncestor === 'viewport') {
      rect = getViewportRect(element, strategy);
    } else if (clippingAncestor === 'document') {
      rect = getDocumentRect(getDocumentElement(element));
    } else if (isElement(clippingAncestor)) {
      rect = getInnerBoundingClientRect(clippingAncestor, strategy);
    } else {
      const visualOffsets = getVisualOffsets(element);
      rect = {
        x: clippingAncestor.x - visualOffsets.x,
        y: clippingAncestor.y - visualOffsets.y,
        width: clippingAncestor.width,
        height: clippingAncestor.height,
      };
    }
    return floating_ui_utils_rectToClientRect(rect);
  }
  function hasFixedPositionAncestor(element, stopNode) {
    const parentNode = getParentNode(element);
    if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
      return false;
    }
    return (
      floating_ui_utils_dom_getComputedStyle(parentNode).position === 'fixed' ||
      hasFixedPositionAncestor(parentNode, stopNode)
    );
  }

  // A "clipping ancestor" is an `overflow` element with the characteristic of
  // clipping (or hiding) child elements. This returns all clipping ancestors
  // of the given element up the tree.
  function getClippingElementAncestors(element, cache) {
    const cachedResult = cache.get(element);
    if (cachedResult) {
      return cachedResult;
    }
    let result = getOverflowAncestors(element, [], false).filter(
      (el) => isElement(el) && getNodeName(el) !== 'body'
    );
    let currentContainingBlockComputedStyle = null;
    const elementIsFixed = floating_ui_utils_dom_getComputedStyle(element).position === 'fixed';
    let currentNode = elementIsFixed ? getParentNode(element) : element;

    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
    while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
      const computedStyle = floating_ui_utils_dom_getComputedStyle(currentNode);
      const currentNodeIsContaining = isContainingBlock(currentNode);
      if (!currentNodeIsContaining && computedStyle.position === 'fixed') {
        currentContainingBlockComputedStyle = null;
      }
      const shouldDropCurrentNode = elementIsFixed
        ? !currentNodeIsContaining && !currentContainingBlockComputedStyle
        : (!currentNodeIsContaining &&
            computedStyle.position === 'static' &&
            !!currentContainingBlockComputedStyle &&
            absoluteOrFixed.has(currentContainingBlockComputedStyle.position)) ||
          (isOverflowElement(currentNode) &&
            !currentNodeIsContaining &&
            hasFixedPositionAncestor(element, currentNode));
      if (shouldDropCurrentNode) {
        // Drop non-containing blocks.
        result = result.filter((ancestor) => ancestor !== currentNode);
      } else {
        // Record last containing block for next iteration.
        currentContainingBlockComputedStyle = computedStyle;
      }
      currentNode = getParentNode(currentNode);
    }
    cache.set(element, result);
    return result;
  }

  // Gets the maximum area that the element is visible in due to any number of
  // clipping ancestors.
  function getClippingRect(_ref) {
    let { element, boundary, rootBoundary, strategy } = _ref;
    const elementClippingAncestors =
      boundary === 'clippingAncestors'
        ? isTopLayer(element)
          ? []
          : getClippingElementAncestors(element, this._c)
        : [].concat(boundary);
    const clippingAncestors = [...elementClippingAncestors, rootBoundary];
    const firstClippingAncestor = clippingAncestors[0];
    const clippingRect = clippingAncestors.reduce(
      (accRect, clippingAncestor) => {
        const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
        accRect.top = floating_ui_utils_max(rect.top, accRect.top);
        accRect.right = floating_ui_utils_min(rect.right, accRect.right);
        accRect.bottom = floating_ui_utils_min(rect.bottom, accRect.bottom);
        accRect.left = floating_ui_utils_max(rect.left, accRect.left);
        return accRect;
      },
      getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy)
    );
    return {
      width: clippingRect.right - clippingRect.left,
      height: clippingRect.bottom - clippingRect.top,
      x: clippingRect.left,
      y: clippingRect.top,
    };
  }

  function getDimensions(element) {
    const { width, height } = getCssDimensions(element);
    return {
      width,
      height,
    };
  }

  function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
    const isOffsetParentAnElement = floating_ui_utils_dom_isHTMLElement(offsetParent);
    const documentElement = getDocumentElement(offsetParent);
    const isFixed = strategy === 'fixed';
    const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
    let scroll = {
      scrollLeft: 0,
      scrollTop: 0,
    };
    const offsets = createCoords(0);

    // If the <body> scrollbar appears on the left (e.g. RTL systems). Use
    // Firefox with layout.scrollbar.side = 3 in about:config to test this.
    function setLeftRTLScrollbarOffset() {
      offsets.x = getWindowScrollBarX(documentElement);
    }
    if (isOffsetParentAnElement || (!isOffsetParentAnElement && !isFixed)) {
      if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }
      if (isOffsetParentAnElement) {
        const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
        offsets.x = offsetRect.x + offsetParent.clientLeft;
        offsets.y = offsetRect.y + offsetParent.clientTop;
      } else if (documentElement) {
        setLeftRTLScrollbarOffset();
      }
    }
    if (isFixed && !isOffsetParentAnElement && documentElement) {
      setLeftRTLScrollbarOffset();
    }
    const htmlOffset =
      documentElement && !isOffsetParentAnElement && !isFixed
        ? getHTMLOffset(documentElement, scroll)
        : createCoords(0);
    const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
    const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
    return {
      x,
      y,
      width: rect.width,
      height: rect.height,
    };
  }

  function isStaticPositioned(element) {
    return floating_ui_utils_dom_getComputedStyle(element).position === 'static';
  }

  function getTrueOffsetParent(element, polyfill) {
    if (
      !floating_ui_utils_dom_isHTMLElement(element) ||
      floating_ui_utils_dom_getComputedStyle(element).position === 'fixed'
    ) {
      return null;
    }
    if (polyfill) {
      return polyfill(element);
    }
    let rawOffsetParent = element.offsetParent;

    // Firefox returns the <html> element as the offsetParent if it's non-static,
    // while Chrome and Safari return the <body> element. The <body> element must
    // be used to perform the correct calculations even if the <html> element is
    // non-static.
    if (getDocumentElement(element) === rawOffsetParent) {
      rawOffsetParent = rawOffsetParent.ownerDocument.body;
    }
    return rawOffsetParent;
  }

  // Gets the closest ancestor positioned element. Handles some edge cases,
  // such as table ancestors and cross browser bugs.
  function getOffsetParent(element, polyfill) {
    const win = getWindow(element);
    if (isTopLayer(element)) {
      return win;
    }
    if (!floating_ui_utils_dom_isHTMLElement(element)) {
      let svgOffsetParent = getParentNode(element);
      while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
        if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
          return svgOffsetParent;
        }
        svgOffsetParent = getParentNode(svgOffsetParent);
      }
      return win;
    }
    let offsetParent = getTrueOffsetParent(element, polyfill);
    while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
      offsetParent = getTrueOffsetParent(offsetParent, polyfill);
    }
    if (
      offsetParent &&
      isLastTraversableNode(offsetParent) &&
      isStaticPositioned(offsetParent) &&
      !isContainingBlock(offsetParent)
    ) {
      return win;
    }
    return offsetParent || getContainingBlock(element) || win;
  }

  const getElementRects = async function (data) {
    const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
    const getDimensionsFn = this.getDimensions;
    const floatingDimensions = await getDimensionsFn(data.floating);
    return {
      reference: getRectRelativeToOffsetParent(
        data.reference,
        await getOffsetParentFn(data.floating),
        data.strategy
      ),
      floating: {
        x: 0,
        y: 0,
        width: floatingDimensions.width,
        height: floatingDimensions.height,
      },
    };
  };

  function isRTL(element) {
    return floating_ui_utils_dom_getComputedStyle(element).direction === 'rtl';
  }

  const platform = {
    convertOffsetParentRelativeRectToViewportRelativeRect,
    getDocumentElement: getDocumentElement,
    getClippingRect,
    getOffsetParent,
    getElementRects,
    getClientRects,
    getDimensions,
    getScale,
    isElement: isElement,
    isRTL,
  };

  function rectsAreEqual(a, b) {
    return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
  }

  // https://samthor.au/2021/observing-dom/
  function observeMove(element, onMove) {
    let io = null;
    let timeoutId;
    const root = getDocumentElement(element);
    function cleanup() {
      var _io;
      clearTimeout(timeoutId);
      (_io = io) == null || _io.disconnect();
      io = null;
    }
    function refresh(skip, threshold) {
      if (skip === void 0) {
        skip = false;
      }
      if (threshold === void 0) {
        threshold = 1;
      }
      cleanup();
      const elementRectForRootMargin = element.getBoundingClientRect();
      const { left, top, width, height } = elementRectForRootMargin;
      if (!skip) {
        onMove();
      }
      if (!width || !height) {
        return;
      }
      const insetTop = floor(top);
      const insetRight = floor(root.clientWidth - (left + width));
      const insetBottom = floor(root.clientHeight - (top + height));
      const insetLeft = floor(left);
      const rootMargin =
        -insetTop + 'px ' + -insetRight + 'px ' + -insetBottom + 'px ' + -insetLeft + 'px';
      const options = {
        rootMargin,
        threshold: floating_ui_utils_max(0, floating_ui_utils_min(1, threshold)) || 1,
      };
      let isFirstUpdate = true;
      function handleObserve(entries) {
        const ratio = entries[0].intersectionRatio;
        if (ratio !== threshold) {
          if (!isFirstUpdate) {
            return refresh();
          }
          if (!ratio) {
            // If the reference is clipped, the ratio is 0. Throttle the refresh
            // to prevent an infinite loop of updates.
            timeoutId = setTimeout(() => {
              refresh(false, 1e-7);
            }, 1000);
          } else {
            refresh(false, ratio);
          }
        }
        if (
          ratio === 1 &&
          !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())
        ) {
          // It's possible that even though the ratio is reported as 1, the
          // element is not actually fully within the IntersectionObserver's root
          // area anymore. This can happen under performance constraints. This may
          // be a bug in the browser's IntersectionObserver implementation. To
          // work around this, we compare the element's bounding rect now with
          // what it was at the time we created the IntersectionObserver. If they
          // are not equal then the element moved, so we refresh.
          refresh();
        }
        isFirstUpdate = false;
      }

      // Older browsers don't support a `document` as the root and will throw an
      // error.
      try {
        io = new IntersectionObserver(handleObserve, {
          ...options,
          // Handle <iframe>s
          root: root.ownerDocument,
        });
      } catch (_e) {
        io = new IntersectionObserver(handleObserve, options);
      }
      io.observe(element);
    }
    refresh(true);
    return cleanup;
  }

  /**
   * Automatically updates the position of the floating element when necessary.
   * Should only be called when the floating element is mounted on the DOM or
   * visible on the screen.
   * @returns cleanup function that should be invoked when the floating element is
   * removed from the DOM or hidden from the screen.
   * @see https://floating-ui.com/docs/autoUpdate
   */
  function autoUpdate(reference, floating, update, options) {
    if (options === void 0) {
      options = {};
    }
    const {
      ancestorScroll = true,
      ancestorResize = true,
      elementResize = typeof ResizeObserver === 'function',
      layoutShift = typeof IntersectionObserver === 'function',
      animationFrame = false,
    } = options;
    const referenceEl = unwrapElement(reference);
    const ancestors =
      ancestorScroll || ancestorResize
        ? [
            ...(referenceEl ? getOverflowAncestors(referenceEl) : []),
            ...getOverflowAncestors(floating),
          ]
        : [];
    ancestors.forEach((ancestor) => {
      ancestorScroll &&
        ancestor.addEventListener('scroll', update, {
          passive: true,
        });
      ancestorResize && ancestor.addEventListener('resize', update);
    });
    const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
    let reobserveFrame = -1;
    let resizeObserver = null;
    if (elementResize) {
      resizeObserver = new ResizeObserver((_ref) => {
        let [firstEntry] = _ref;
        if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
          // Prevent update loops when using the `size` middleware.
          // https://github.com/floating-ui/floating-ui/issues/1740
          resizeObserver.unobserve(floating);
          cancelAnimationFrame(reobserveFrame);
          reobserveFrame = requestAnimationFrame(() => {
            var _resizeObserver;
            (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
          });
        }
        update();
      });
      if (referenceEl && !animationFrame) {
        resizeObserver.observe(referenceEl);
      }
      resizeObserver.observe(floating);
    }
    let frameId;
    let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
    if (animationFrame) {
      frameLoop();
    }
    function frameLoop() {
      const nextRefRect = getBoundingClientRect(reference);
      if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
        update();
      }
      prevRefRect = nextRefRect;
      frameId = requestAnimationFrame(frameLoop);
    }
    update();
    return () => {
      var _resizeObserver2;
      ancestors.forEach((ancestor) => {
        ancestorScroll && ancestor.removeEventListener('scroll', update);
        ancestorResize && ancestor.removeEventListener('resize', update);
      });
      cleanupIo == null || cleanupIo();
      (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
      resizeObserver = null;
      if (animationFrame) {
        cancelAnimationFrame(frameId);
      }
    };
  }

  /**
   * Resolves with an object of overflow side offsets that determine how much the
   * element is overflowing a given clipping boundary on each side.
   * - positive = overflowing the boundary by that number of pixels
   * - negative = how many pixels left before it will overflow
   * - 0 = lies flush with the boundary
   * @see https://floating-ui.com/docs/detectOverflow
   */
  const floating_ui_dom_detectOverflow =
    /* unused pure expression or super */ null && detectOverflow$1;

  /**
   * Modifies the placement by translating the floating element along the
   * specified axes.
   * A number (shorthand for `mainAxis` or distance), or an axes configuration
   * object may be passed.
   * @see https://floating-ui.com/docs/offset
   */
  const floating_ui_dom_offset = offset;

  /**
   * Optimizes the visibility of the floating element by choosing the placement
   * that has the most space available automatically, without needing to specify a
   * preferred placement. Alternative to `flip`.
   * @see https://floating-ui.com/docs/autoPlacement
   */
  const floating_ui_dom_autoPlacement =
    /* unused pure expression or super */ null && autoPlacement$1;

  /**
   * Optimizes the visibility of the floating element by shifting it in order to
   * keep it in view when it will overflow the clipping boundary.
   * @see https://floating-ui.com/docs/shift
   */
  const floating_ui_dom_shift = shift;

  /**
   * Optimizes the visibility of the floating element by flipping the `placement`
   * in order to keep it in view when the preferred placement(s) will overflow the
   * clipping boundary. Alternative to `autoPlacement`.
   * @see https://floating-ui.com/docs/flip
   */
  const floating_ui_dom_flip = flip;

  /**
   * Provides data that allows you to change the size of the floating element 
   * for instance, prevent it from overflowing the clipping boundary or match the
   * width of the reference element.
   * @see https://floating-ui.com/docs/size
   */
  const floating_ui_dom_size = size;

  /**
   * Provides data to hide the floating element in applicable situations, such as
   * when it is not in the same clipping context as the reference element.
   * @see https://floating-ui.com/docs/hide
   */
  const floating_ui_dom_hide = hide;

  /**
   * Provides data to position an inner element of the floating element so that it
   * appears centered to the reference element.
   * @see https://floating-ui.com/docs/arrow
   */
  const floating_ui_dom_arrow = arrow;

  /**
   * Provides improved positioning for inline reference elements that can span
   * over multiple lines, such as hyperlinks or range selections.
   * @see https://floating-ui.com/docs/inline
   */
  const floating_ui_dom_inline = /* unused pure expression or super */ null && inline$1;

  /**
   * Built-in `limiter` that will stop `shift()` at a certain point.
   */
  const floating_ui_dom_limitShift = limitShift;

  /**
   * Computes the `x` and `y` coordinates that will place the floating element
   * next to a given reference element.
   */
  const floating_ui_dom_computePosition = (reference, floating, options) => {
    // This caches the expensive `getClippingElementAncestors` function so that
    // multiple lifecycle resets re-use the same result. It only lives for a
    // single call. If other functions become expensive, we can add them as well.
    const cache = new Map();
    const mergedOptions = {
      platform,
      ...options,
    };
    const platformWithCache = {
      ...mergedOptions.platform,
      _c: cache,
    };
    return computePosition(reference, floating, {
      ...mergedOptions,
      platform: platformWithCache,
    });
  }; // ./node_modules/.pnpm/@floating-ui+react-dom@2.1.5_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs

  var isClient = typeof document !== 'undefined';

  var floating_ui_react_dom_noop = function noop() {};
  var index = isClient ? react.useLayoutEffect : floating_ui_react_dom_noop;

  // Fork of `fast-deep-equal` that only does the comparisons we need and compares
  // functions
  function deepEqual(a, b) {
    if (a === b) {
      return true;
    }
    if (typeof a !== typeof b) {
      return false;
    }
    if (typeof a === 'function' && a.toString() === b.toString()) {
      return true;
    }
    let length;
    let i;
    let keys;
    if (a && b && typeof a === 'object') {
      if (Array.isArray(a)) {
        length = a.length;
        if (length !== b.length) return false;
        for (i = length; i-- !== 0; ) {
          if (!deepEqual(a[i], b[i])) {
            return false;
          }
        }
        return true;
      }
      keys = Object.keys(a);
      length = keys.length;
      if (length !== Object.keys(b).length) {
        return false;
      }
      for (i = length; i-- !== 0; ) {
        if (!{}.hasOwnProperty.call(b, keys[i])) {
          return false;
        }
      }
      for (i = length; i-- !== 0; ) {
        const key = keys[i];
        if (key === '_owner' && a.$$typeof) {
          continue;
        }
        if (!deepEqual(a[key], b[key])) {
          return false;
        }
      }
      return true;
    }
    return a !== a && b !== b;
  }

  function getDPR(element) {
    if (typeof window === 'undefined') {
      return 1;
    }
    const win = element.ownerDocument.defaultView || window;
    return win.devicePixelRatio || 1;
  }

  function roundByDPR(element, value) {
    const dpr = getDPR(element);
    return Math.round(value * dpr) / dpr;
  }

  function useLatestRef(value) {
    const ref = react.useRef(value);
    index(() => {
      ref.current = value;
    });
    return ref;
  }

  /**
   * Provides data to position a floating element.
   * @see https://floating-ui.com/docs/useFloating
   */
  function useFloating(options) {
    if (options === void 0) {
      options = {};
    }
    const {
      placement = 'bottom',
      strategy = 'absolute',
      middleware = [],
      platform,
      elements: { reference: externalReference, floating: externalFloating } = {},
      transform = true,
      whileElementsMounted,
      open,
    } = options;
    const [data, setData] = react.useState({
      x: 0,
      y: 0,
      strategy,
      placement,
      middlewareData: {},
      isPositioned: false,
    });
    const [latestMiddleware, setLatestMiddleware] = react.useState(middleware);
    if (!deepEqual(latestMiddleware, middleware)) {
      setLatestMiddleware(middleware);
    }
    const [_reference, _setReference] = react.useState(null);
    const [_floating, _setFloating] = react.useState(null);
    const setReference = react.useCallback((node) => {
      if (node !== referenceRef.current) {
        referenceRef.current = node;
        _setReference(node);
      }
    }, []);
    const setFloating = react.useCallback((node) => {
      if (node !== floatingRef.current) {
        floatingRef.current = node;
        _setFloating(node);
      }
    }, []);
    const referenceEl = externalReference || _reference;
    const floatingEl = externalFloating || _floating;
    const referenceRef = react.useRef(null);
    const floatingRef = react.useRef(null);
    const dataRef = react.useRef(data);
    const hasWhileElementsMounted = whileElementsMounted != null;
    const whileElementsMountedRef = useLatestRef(whileElementsMounted);
    const platformRef = useLatestRef(platform);
    const openRef = useLatestRef(open);
    const update = react.useCallback(() => {
      if (!referenceRef.current || !floatingRef.current) {
        return;
      }
      const config = {
        placement,
        strategy,
        middleware: latestMiddleware,
      };
      if (platformRef.current) {
        config.platform = platformRef.current;
      }
      floating_ui_dom_computePosition(referenceRef.current, floatingRef.current, config).then(
        (data) => {
          const fullData = {
            ...data,
            // The floating element's position may be recomputed while it's closed
            // but still mounted (such as when transitioning out). To ensure
            // `isPositioned` will be `false` initially on the next open, avoid
            // setting it to `true` when `open === false` (must be specified).
            isPositioned: openRef.current !== false,
          };
          if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
            dataRef.current = fullData;
            react_dom.flushSync(() => {
              setData(fullData);
            });
          }
        }
      );
    }, [latestMiddleware, placement, strategy, platformRef, openRef]);
    index(() => {
      if (open === false && dataRef.current.isPositioned) {
        dataRef.current.isPositioned = false;
        setData((data) => ({
          ...data,
          isPositioned: false,
        }));
      }
    }, [open]);
    const isMountedRef = react.useRef(false);
    index(() => {
      isMountedRef.current = true;
      return () => {
        isMountedRef.current = false;
      };
    }, []);
    index(() => {
      if (referenceEl) referenceRef.current = referenceEl;
      if (floatingEl) floatingRef.current = floatingEl;
      if (referenceEl && floatingEl) {
        if (whileElementsMountedRef.current) {
          return whileElementsMountedRef.current(referenceEl, floatingEl, update);
        }
        update();
      }
    }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
    const refs = react.useMemo(
      () => ({
        reference: referenceRef,
        floating: floatingRef,
        setReference,
        setFloating,
      }),
      [setReference, setFloating]
    );
    const elements = react.useMemo(
      () => ({
        reference: referenceEl,
        floating: floatingEl,
      }),
      [referenceEl, floatingEl]
    );
    const floatingStyles = react.useMemo(() => {
      const initialStyles = {
        position: strategy,
        left: 0,
        top: 0,
      };
      if (!elements.floating) {
        return initialStyles;
      }
      const x = roundByDPR(elements.floating, data.x);
      const y = roundByDPR(elements.floating, data.y);
      if (transform) {
        return {
          ...initialStyles,
          transform: 'translate(' + x + 'px, ' + y + 'px)',
          ...(getDPR(elements.floating) >= 1.5 && {
            willChange: 'transform',
          }),
        };
      }
      return {
        position: strategy,
        left: x,
        top: y,
      };
    }, [strategy, transform, elements.floating, data.x, data.y]);
    return react.useMemo(
      () => ({
        ...data,
        update,
        refs,
        elements,
        floatingStyles,
      }),
      [data, update, refs, elements, floatingStyles]
    );
  }

  /**
   * Provides data to position an inner element of the floating element so that it
   * appears centered to the reference element.
   * This wraps the core `arrow` middleware to allow React refs as the element.
   * @see https://floating-ui.com/docs/arrow
   */
  const arrow$1 = (options) => {
    function isRef(value) {
      return {}.hasOwnProperty.call(value, 'current');
    }
    return {
      name: 'arrow',
      options,
      fn(state) {
        const { element, padding } = typeof options === 'function' ? options(state) : options;
        if (element && isRef(element)) {
          if (element.current != null) {
            return floating_ui_dom_arrow({
              element: element.current,
              padding,
            }).fn(state);
          }
          return {};
        }
        if (element) {
          return floating_ui_dom_arrow({
            element,
            padding,
          }).fn(state);
        }
        return {};
      },
    };
  };

  /**
   * Modifies the placement by translating the floating element along the
   * specified axes.
   * A number (shorthand for `mainAxis` or distance), or an axes configuration
   * object may be passed.
   * @see https://floating-ui.com/docs/offset
   */
  const floating_ui_react_dom_offset = (options, deps) => ({
    ...floating_ui_dom_offset(options),
    options: [options, deps],
  });

  /**
   * Optimizes the visibility of the floating element by shifting it in order to
   * keep it in view when it will overflow the clipping boundary.
   * @see https://floating-ui.com/docs/shift
   */
  const floating_ui_react_dom_shift = (options, deps) => ({
    ...floating_ui_dom_shift(options),
    options: [options, deps],
  });

  /**
   * Built-in `limiter` that will stop `shift()` at a certain point.
   */
  const floating_ui_react_dom_limitShift = (options, deps) => ({
    ...floating_ui_dom_limitShift(options),
    options: [options, deps],
  });

  /**
   * Optimizes the visibility of the floating element by flipping the `placement`
   * in order to keep it in view when the preferred placement(s) will overflow the
   * clipping boundary. Alternative to `autoPlacement`.
   * @see https://floating-ui.com/docs/flip
   */
  const floating_ui_react_dom_flip = (options, deps) => ({
    ...floating_ui_dom_flip(options),
    options: [options, deps],
  });

  /**
   * Provides data that allows you to change the size of the floating element 
   * for instance, prevent it from overflowing the clipping boundary or match the
   * width of the reference element.
   * @see https://floating-ui.com/docs/size
   */
  const floating_ui_react_dom_size = (options, deps) => ({
    ...floating_ui_dom_size(options),
    options: [options, deps],
  });

  /**
   * Optimizes the visibility of the floating element by choosing the placement
   * that has the most space available automatically, without needing to specify a
   * preferred placement. Alternative to `flip`.
   * @see https://floating-ui.com/docs/autoPlacement
   */
  const floating_ui_react_dom_autoPlacement = (options, deps) => ({
    ...autoPlacement$1(options),
    options: [options, deps],
  });

  /**
   * Provides data to hide the floating element in applicable situations, such as
   * when it is not in the same clipping context as the reference element.
   * @see https://floating-ui.com/docs/hide
   */
  const floating_ui_react_dom_hide = (options, deps) => ({
    ...floating_ui_dom_hide(options),
    options: [options, deps],
  });

  /**
   * Provides improved positioning for inline reference elements that can span
   * over multiple lines, such as hyperlinks or range selections.
   * @see https://floating-ui.com/docs/inline
   */
  const floating_ui_react_dom_inline = (options, deps) => ({
    ...inline$1(options),
    options: [options, deps],
  });

  /**
   * Provides data to position an inner element of the floating element so that it
   * appears centered to the reference element.
   * This wraps the core `arrow` middleware to allow React refs as the element.
   * @see https://floating-ui.com/docs/arrow
   */
  const floating_ui_react_dom_arrow = (options, deps) => ({
    ...arrow$1(options),
    options: [options, deps],
  }); // ./node_modules/.pnpm/@radix-ui+react-arrow@1.1.7_@types+react-dom@19.1.9_@types+react@19.1.12__@types+react@19.1.1_yroqwa3qrgclu4tfirktd5n5tu/node_modules/@radix-ui/react-arrow/dist/index.mjs

  // src/arrow.tsx

  var NAME = 'Arrow';
  var Arrow = react.forwardRef((props, forwardedRef) => {
    const { children, width = 10, height = 5, ...arrowProps } = props;
    return /* @__PURE__ */ (0, jsx_runtime.jsx)(Primitive.svg, {
      ...arrowProps,
      ref: forwardedRef,
      width,
      height,
      viewBox: '0 0 30 10',
      preserveAspectRatio: 'none',
      children: props.asChild
        ? children
        : /* @__PURE__ */ (0, jsx_runtime.jsx)('polygon', { points: '0,0 30,0 15,10' }),
    });
  });
  Arrow.displayName = NAME;
  var react_arrow_dist_Root = Arrow; // ./node_modules/.pnpm/@radix-ui+react-use-size@1.1.1_@types+react@19.1.12_react@19.1.1/node_modules/@radix-ui/react-use-size/dist/index.mjs

  //# sourceMappingURL=index.mjs.map

  // packages/react/use-size/src/use-size.tsx

  function useSize(element) {
    const [size, setSize] = react.useState(void 0);
    useLayoutEffect2(() => {
      if (element) {
        setSize({ width: element.offsetWidth, height: element.offsetHeight });
        const resizeObserver = new ResizeObserver((entries) => {
          if (!Array.isArray(entries)) {
            return;
          }
          if (!entries.length) {
            return;
          }
          const entry = entries[0];
          let width;
          let height;
          if ('borderBoxSize' in entry) {
            const borderSizeEntry = entry['borderBoxSize'];
            const borderSize = Array.isArray(borderSizeEntry)
              ? borderSizeEntry[0]
              : borderSizeEntry;
            width = borderSize['inlineSize'];
            height = borderSize['blockSize'];
          } else {
            width = element.offsetWidth;
            height = element.offsetHeight;
          }
          setSize({ width, height });
        });
        resizeObserver.observe(element, { box: 'border-box' });
        return () => resizeObserver.unobserve(element);
      } else {
        setSize(void 0);
      }
    }, [element]);
    return size;
  } // ./node_modules/.pnpm/@radix-ui+react-popper@1.2.8_@types+react-dom@19.1.9_@types+react@19.1.12__@types+react@19.1._dcwpv6adi64skpuy7ijzcnyhze/node_modules/@radix-ui/react-popper/dist/index.mjs

  //# sourceMappingURL=index.mjs.map

  ('use client');

  // src/popper.tsx

  var SIDE_OPTIONS = /* unused pure expression or super */ null && [
    'top',
    'right',
    'bottom',
    'left',
  ];
  var ALIGN_OPTIONS = /* unused pure expression or super */ null && ['start', 'center', 'end'];
  var POPPER_NAME = 'Popper';
  var [createPopperContext, createPopperScope] = createContextScope(POPPER_NAME);
  var [PopperProvider, usePopperContext] = createPopperContext(POPPER_NAME);
  var Popper = (props) => {
    const { __scopePopper, children } = props;
    const [anchor, setAnchor] = react.useState(null);
    return /* @__PURE__ */ (0, jsx_runtime.jsx)(PopperProvider, {
      scope: __scopePopper,
      anchor,
      onAnchorChange: setAnchor,
      children,
    });
  };
  Popper.displayName = POPPER_NAME;
  var ANCHOR_NAME = 'PopperAnchor';
  var PopperAnchor = react.forwardRef((props, forwardedRef) => {
    const { __scopePopper, virtualRef, ...anchorProps } = props;
    const context = usePopperContext(ANCHOR_NAME, __scopePopper);
    const ref = react.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const anchorRef = react.useRef(null);
    react.useEffect(() => {
      const previousAnchor = anchorRef.current;
      anchorRef.current = virtualRef?.current || ref.current;
      if (previousAnchor !== anchorRef.current) {
        context.onAnchorChange(anchorRef.current);
      }
    });
    return virtualRef
      ? null
      : /* @__PURE__ */ (0, jsx_runtime.jsx)(Primitive.div, { ...anchorProps, ref: composedRefs });
  });
  PopperAnchor.displayName = ANCHOR_NAME;
  var CONTENT_NAME = 'PopperContent';
  var [PopperContentProvider, useContentContext] = createPopperContext(CONTENT_NAME);
  var PopperContent = react.forwardRef((props, forwardedRef) => {
    const {
      __scopePopper,
      side = 'bottom',
      sideOffset = 0,
      align = 'center',
      alignOffset = 0,
      arrowPadding = 0,
      avoidCollisions = true,
      collisionBoundary = [],
      collisionPadding: collisionPaddingProp = 0,
      sticky = 'partial',
      hideWhenDetached = false,
      updatePositionStrategy = 'optimized',
      onPlaced,
      ...contentProps
    } = props;
    const context = usePopperContext(CONTENT_NAME, __scopePopper);
    const [content, setContent] = react.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));
    const [arrow, setArrow] = react.useState(null);
    const arrowSize = useSize(arrow);
    const arrowWidth = arrowSize?.width ?? 0;
    const arrowHeight = arrowSize?.height ?? 0;
    const desiredPlacement = side + (align !== 'center' ? '-' + align : '');
    const collisionPadding =
      typeof collisionPaddingProp === 'number'
        ? collisionPaddingProp
        : { top: 0, right: 0, bottom: 0, left: 0, ...collisionPaddingProp };
    const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [collisionBoundary];
    const hasExplicitBoundaries = boundary.length > 0;
    const detectOverflowOptions = {
      padding: collisionPadding,
      boundary: boundary.filter(dist_isNotNull),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: hasExplicitBoundaries,
    };
    const { refs, floatingStyles, placement, isPositioned, middlewareData } = useFloating({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: 'fixed',
      placement: desiredPlacement,
      whileElementsMounted: (...args) => {
        const cleanup = autoUpdate(...args, {
          animationFrame: updatePositionStrategy === 'always',
        });
        return cleanup;
      },
      elements: {
        reference: context.anchor,
      },
      middleware: [
        floating_ui_react_dom_offset({
          mainAxis: sideOffset + arrowHeight,
          alignmentAxis: alignOffset,
        }),
        avoidCollisions &&
          floating_ui_react_dom_shift({
            mainAxis: true,
            crossAxis: false,
            limiter: sticky === 'partial' ? floating_ui_react_dom_limitShift() : void 0,
            ...detectOverflowOptions,
          }),
        avoidCollisions && floating_ui_react_dom_flip({ ...detectOverflowOptions }),
        floating_ui_react_dom_size({
          ...detectOverflowOptions,
          apply: ({ elements, rects, availableWidth, availableHeight }) => {
            const { width: anchorWidth, height: anchorHeight } = rects.reference;
            const contentStyle = elements.floating.style;
            contentStyle.setProperty('--radix-popper-available-width', `${availableWidth}px`);
            contentStyle.setProperty('--radix-popper-available-height', `${availableHeight}px`);
            contentStyle.setProperty('--radix-popper-anchor-width', `${anchorWidth}px`);
            contentStyle.setProperty('--radix-popper-anchor-height', `${anchorHeight}px`);
          },
        }),
        arrow && floating_ui_react_dom_arrow({ element: arrow, padding: arrowPadding }),
        transformOrigin({ arrowWidth, arrowHeight }),
        hideWhenDetached &&
          floating_ui_react_dom_hide({ strategy: 'referenceHidden', ...detectOverflowOptions }),
      ],
    });
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const handlePlaced = useCallbackRef(onPlaced);
    useLayoutEffect2(() => {
      if (isPositioned) {
        handlePlaced?.();
      }
    }, [isPositioned, handlePlaced]);
    const arrowX = middlewareData.arrow?.x;
    const arrowY = middlewareData.arrow?.y;
    const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;
    const [contentZIndex, setContentZIndex] = react.useState();
    useLayoutEffect2(() => {
      if (content) setContentZIndex(window.getComputedStyle(content).zIndex);
    }, [content]);
    return /* @__PURE__ */ (0, jsx_runtime.jsx)('div', {
      ref: refs.setFloating,
      'data-radix-popper-content-wrapper': '',
      style: {
        ...floatingStyles,
        transform: isPositioned ? floatingStyles.transform : 'translate(0, -200%)',
        // keep off the page when measuring
        minWidth: 'max-content',
        zIndex: contentZIndex,
        ['--radix-popper-transform-origin']: [
          middlewareData.transformOrigin?.x,
          middlewareData.transformOrigin?.y,
        ].join(' '),
        // hide the content if using the hide middleware and should be hidden
        // set visibility to hidden and disable pointer events so the UI behaves
        // as if the PopperContent isn't there at all
        ...(middlewareData.hide?.referenceHidden && {
          visibility: 'hidden',
          pointerEvents: 'none',
        }),
      },
      dir: props.dir,
      children: /* @__PURE__ */ (0, jsx_runtime.jsx)(PopperContentProvider, {
        scope: __scopePopper,
        placedSide,
        onArrowChange: setArrow,
        arrowX,
        arrowY,
        shouldHideArrow: cannotCenterArrow,
        children: /* @__PURE__ */ (0, jsx_runtime.jsx)(Primitive.div, {
          'data-side': placedSide,
          'data-align': placedAlign,
          ...contentProps,
          ref: composedRefs,
          style: {
            ...contentProps.style,
            // if the PopperContent hasn't been placed yet (not all measurements done)
            // we prevent animations so that users's animation don't kick in too early referring wrong sides
            animation: !isPositioned ? 'none' : void 0,
          },
        }),
      }),
    });
  });
  PopperContent.displayName = CONTENT_NAME;
  var ARROW_NAME = 'PopperArrow';
  var OPPOSITE_SIDE = {
    top: 'bottom',
    right: 'left',
    bottom: 'top',
    left: 'right',
  };
  var PopperArrow = react.forwardRef(function PopperArrow2(props, forwardedRef) {
    const { __scopePopper, ...arrowProps } = props;
    const contentContext = useContentContext(ARROW_NAME, __scopePopper);
    const baseSide = OPPOSITE_SIDE[contentContext.placedSide];
    return (
      // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
      // doesn't report size as we'd expect on SVG elements.
      // it reports their bounding box which is effectively the largest path inside the SVG.
      /* @__PURE__ */ (0, jsx_runtime.jsx)('span', {
        ref: contentContext.onArrowChange,
        style: {
          position: 'absolute',
          left: contentContext.arrowX,
          top: contentContext.arrowY,
          [baseSide]: 0,
          transformOrigin: {
            top: '',
            right: '0 0',
            bottom: 'center 0',
            left: '100% 0',
          }[contentContext.placedSide],
          transform: {
            top: 'translateY(100%)',
            right: 'translateY(50%) rotate(90deg) translateX(-50%)',
            bottom: `rotate(180deg)`,
            left: 'translateY(50%) rotate(-90deg) translateX(50%)',
          }[contentContext.placedSide],
          visibility: contentContext.shouldHideArrow ? 'hidden' : void 0,
        },
        children: /* @__PURE__ */ (0, jsx_runtime.jsx)(react_arrow_dist_Root, {
          ...arrowProps,
          ref: forwardedRef,
          style: {
            ...arrowProps.style,
            // ensures the element can be measured correctly (mostly for if SVG)
            display: 'block',
          },
        }),
      })
    );
  });
  PopperArrow.displayName = ARROW_NAME;
  function dist_isNotNull(value) {
    return value !== null;
  }
  var transformOrigin = (options) => ({
    name: 'transformOrigin',
    options,
    fn(data) {
      const { placement, rects, middlewareData } = data;
      const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;
      const isArrowHidden = cannotCenterArrow;
      const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;
      const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;
      const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
      const noArrowAlign = { start: '0%', center: '50%', end: '100%' }[placedAlign];
      const arrowXCenter = (middlewareData.arrow?.x ?? 0) + arrowWidth / 2;
      const arrowYCenter = (middlewareData.arrow?.y ?? 0) + arrowHeight / 2;
      let x = '';
      let y = '';
      if (placedSide === 'bottom') {
        x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
        y = `${-arrowHeight}px`;
      } else if (placedSide === 'top') {
        x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
        y = `${rects.floating.height + arrowHeight}px`;
      } else if (placedSide === 'right') {
        x = `${-arrowHeight}px`;
        y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
      } else if (placedSide === 'left') {
        x = `${rects.floating.width + arrowHeight}px`;
        y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
      }
      return { data: { x, y } };
    },
  });
  function getSideAndAlignFromPlacement(placement) {
    const [side, align = 'center'] = placement.split('-');
    return [side, align];
  }
  var Root2 = Popper;
  var Anchor = PopperAnchor;
  var Content = PopperContent;
  var dist_Arrow = PopperArrow; // ./node_modules/.pnpm/@radix-ui+react-portal@1.1.9_@types+react-dom@19.1.9_@types+react@19.1.12__@types+react@19.1._fzuvnzh2mzo35zvsvdmob45e4q/node_modules/@radix-ui/react-portal/dist/index.mjs

  //# sourceMappingURL=index.mjs.map

  ('use client');

  // src/portal.tsx

  var PORTAL_NAME = 'Portal';
  var Portal = react.forwardRef((props, forwardedRef) => {
    const { container: containerProp, ...portalProps } = props;
    const [mounted, setMounted] = react.useState(false);
    useLayoutEffect2(() => setMounted(true), []);
    const container = containerProp || (mounted && globalThis?.document?.body);
    return container
      ? react_dom.createPortal(
          /* @__PURE__ */ (0, jsx_runtime.jsx)(Primitive.div, {
            ...portalProps,
            ref: forwardedRef,
          }),
          container
        )
      : null;
  });
  Portal.displayName = PORTAL_NAME;
  var react_portal_dist_Root = /* unused pure expression or super */ null && Portal; // ./node_modules/.pnpm/@radix-ui+react-use-controllable-state@1.2.2_@types+react@19.1.12_react@19.1.1/node_modules/@radix-ui/react-use-controllable-state/dist/index.mjs

  //# sourceMappingURL=index.mjs.map

  // src/use-controllable-state.tsx

  var useInsertionEffect =
    react_namespaceObject[' useInsertionEffect '.trim().toString()] || useLayoutEffect2;
  function useControllableState({ prop, defaultProp, onChange = () => {}, caller }) {
    const [uncontrolledProp, setUncontrolledProp, onChangeRef] = useUncontrolledState({
      defaultProp,
      onChange,
    });
    const isControlled = prop !== void 0;
    const value = isControlled ? prop : uncontrolledProp;
    if (true) {
      const isControlledRef = react.useRef(prop !== void 0);
      react.useEffect(() => {
        const wasControlled = isControlledRef.current;
        if (wasControlled !== isControlled) {
          const from = wasControlled ? 'controlled' : 'uncontrolled';
          const to = isControlled ? 'controlled' : 'uncontrolled';
          console.warn(
            `${caller} is changing from ${from} to ${to}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`
          );
        }
        isControlledRef.current = isControlled;
      }, [isControlled, caller]);
    }
    const setValue = react.useCallback(
      (nextValue) => {
        if (isControlled) {
          const value2 = isFunction(nextValue) ? nextValue(prop) : nextValue;
          if (value2 !== prop) {
            onChangeRef.current?.(value2);
          }
        } else {
          setUncontrolledProp(nextValue);
        }
      },
      [isControlled, prop, setUncontrolledProp, onChangeRef]
    );
    return [value, setValue];
  }
  function useUncontrolledState({ defaultProp, onChange }) {
    const [value, setValue] = react.useState(defaultProp);
    const prevValueRef = react.useRef(value);
    const onChangeRef = react.useRef(onChange);
    useInsertionEffect(() => {
      onChangeRef.current = onChange;
    }, [onChange]);
    react.useEffect(() => {
      if (prevValueRef.current !== value) {
        onChangeRef.current?.(value);
        prevValueRef.current = value;
      }
    }, [value, prevValueRef]);
    return [value, setValue, onChangeRef];
  }
  function isFunction(value) {
    return typeof value === 'function';
  }

  // src/use-controllable-state-reducer.tsx

  var SYNC_STATE = Symbol('RADIX:SYNC_STATE');
  function useControllableStateReducer(reducer, userArgs, initialArg, init) {
    const { prop: controlledState, defaultProp, onChange: onChangeProp, caller } = userArgs;
    const isControlled = controlledState !== void 0;
    const onChange = useEffectEvent(onChangeProp);
    if (true) {
      const isControlledRef = React2.useRef(controlledState !== void 0);
      React2.useEffect(() => {
        const wasControlled = isControlledRef.current;
        if (wasControlled !== isControlled) {
          const from = wasControlled ? 'controlled' : 'uncontrolled';
          const to = isControlled ? 'controlled' : 'uncontrolled';
          console.warn(
            `${caller} is changing from ${from} to ${to}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`
          );
        }
        isControlledRef.current = isControlled;
      }, [isControlled, caller]);
    }
    const args = [{ ...initialArg, state: defaultProp }];
    if (init) {
      args.push(init);
    }
    const [internalState, dispatch] = React2.useReducer(
      (state2, action) => {
        if (action.type === SYNC_STATE) {
          return { ...state2, state: action.state };
        }
        const next = reducer(state2, action);
        if (isControlled && !Object.is(next.state, state2.state)) {
          onChange(next.state);
        }
        return next;
      },
      ...args
    );
    const uncontrolledState = internalState.state;
    const prevValueRef = React2.useRef(uncontrolledState);
    React2.useEffect(() => {
      if (prevValueRef.current !== uncontrolledState) {
        prevValueRef.current = uncontrolledState;
        if (!isControlled) {
          onChange(uncontrolledState);
        }
      }
    }, [onChange, uncontrolledState, prevValueRef, isControlled]);
    const state = React2.useMemo(() => {
      const isControlled2 = controlledState !== void 0;
      if (isControlled2) {
        return { ...internalState, state: controlledState };
      }
      return internalState;
    }, [internalState, controlledState]);
    React2.useEffect(() => {
      if (isControlled && !Object.is(controlledState, internalState.state)) {
        dispatch({ type: SYNC_STATE, state: controlledState });
      }
    }, [controlledState, internalState.state, isControlled]);
    return [state, dispatch];
  } // ./node_modules/.pnpm/@radix-ui+react-use-previous@1.1.1_@types+react@19.1.12_react@19.1.1/node_modules/@radix-ui/react-use-previous/dist/index.mjs

  //# sourceMappingURL=index.mjs.map

  // packages/react/use-previous/src/use-previous.tsx

  function usePrevious(value) {
    const ref = react.useRef({ value, previous: value });
    return react.useMemo(() => {
      if (ref.current.value !== value) {
        ref.current.previous = ref.current.value;
        ref.current.value = value;
      }
      return ref.current.previous;
    }, [value]);
  } // ./node_modules/.pnpm/@radix-ui+react-visually-hidden@1.2.3_@types+react-dom@19.1.9_@types+react@19.1.12__@types+re_glzfabgyyawwcn33epmcxzkaxi/node_modules/@radix-ui/react-visually-hidden/dist/index.mjs

  //# sourceMappingURL=index.mjs.map

  // src/visually-hidden.tsx

  var VISUALLY_HIDDEN_STYLES = Object.freeze({
    // See: https://github.com/twbs/bootstrap/blob/main/scss/mixins/_visually-hidden.scss
    position: 'absolute',
    border: 0,
    width: 1,
    height: 1,
    padding: 0,
    margin: -1,
    overflow: 'hidden',
    clip: 'rect(0, 0, 0, 0)',
    whiteSpace: 'nowrap',
    wordWrap: 'normal',
  });
  var dist_NAME = 'VisuallyHidden';
  var VisuallyHidden = react.forwardRef((props, forwardedRef) => {
    return /* @__PURE__ */ (0, jsx_runtime.jsx)(Primitive.span, {
      ...props,
      ref: forwardedRef,
      style: { ...VISUALLY_HIDDEN_STYLES, ...props.style },
    });
  });
  VisuallyHidden.displayName = dist_NAME;
  var react_visually_hidden_dist_Root =
    /* unused pure expression or super */ null && VisuallyHidden; // ./node_modules/.pnpm/aria-hidden@1.2.6/node_modules/aria-hidden/dist/es2015/index.js

  //# sourceMappingURL=index.mjs.map

  var getDefaultParent = function (originalTarget) {
    if (typeof document === 'undefined') {
      return null;
    }
    var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
    return sampleTarget.ownerDocument.body;
  };
  var counterMap = new WeakMap();
  var uncontrolledNodes = new WeakMap();
  var markerMap = {};
  var lockCount = 0;
  var unwrapHost = function (node) {
    return node && (node.host || unwrapHost(node.parentNode));
  };
  var correctTargets = function (parent, targets) {
    return targets
      .map(function (target) {
        if (parent.contains(target)) {
          return target;
        }
        var correctedTarget = unwrapHost(target);
        if (correctedTarget && parent.contains(correctedTarget)) {
          return correctedTarget;
        }
        console.error('aria-hidden', target, 'in not contained inside', parent, '. Doing nothing');
        return null;
      })
      .filter(function (x) {
        return Boolean(x);
      });
  };
  /**
   * Marks everything except given node(or nodes) as aria-hidden
   * @param {Element | Element[]} originalTarget - elements to keep on the page
   * @param [parentNode] - top element, defaults to document.body
   * @param {String} [markerName] - a special attribute to mark every node
   * @param {String} [controlAttribute] - html Attribute to control
   * @return {Undo} undo command
   */
  var applyAttributeToOthers = function (originalTarget, parentNode, markerName, controlAttribute) {
    var targets = correctTargets(
      parentNode,
      Array.isArray(originalTarget) ? originalTarget : [originalTarget]
    );
    if (!markerMap[markerName]) {
      markerMap[markerName] = new WeakMap();
    }
    var markerCounter = markerMap[markerName];
    var hiddenNodes = [];
    var elementsToKeep = new Set();
    var elementsToStop = new Set(targets);
    var keep = function (el) {
      if (!el || elementsToKeep.has(el)) {
        return;
      }
      elementsToKeep.add(el);
      keep(el.parentNode);
    };
    targets.forEach(keep);
    var deep = function (parent) {
      if (!parent || elementsToStop.has(parent)) {
        return;
      }
      Array.prototype.forEach.call(parent.children, function (node) {
        if (elementsToKeep.has(node)) {
          deep(node);
        } else {
          try {
            var attr = node.getAttribute(controlAttribute);
            var alreadyHidden = attr !== null && attr !== 'false';
            var counterValue = (counterMap.get(node) || 0) + 1;
            var markerValue = (markerCounter.get(node) || 0) + 1;
            counterMap.set(node, counterValue);
            markerCounter.set(node, markerValue);
            hiddenNodes.push(node);
            if (counterValue === 1 && alreadyHidden) {
              uncontrolledNodes.set(node, true);
            }
            if (markerValue === 1) {
              node.setAttribute(markerName, 'true');
            }
            if (!alreadyHidden) {
              node.setAttribute(controlAttribute, 'true');
            }
          } catch (e) {
            console.error('aria-hidden: cannot operate on ', node, e);
          }
        }
      });
    };
    deep(parentNode);
    elementsToKeep.clear();
    lockCount++;
    return function () {
      hiddenNodes.forEach(function (node) {
        var counterValue = counterMap.get(node) - 1;
        var markerValue = markerCounter.get(node) - 1;
        counterMap.set(node, counterValue);
        markerCounter.set(node, markerValue);
        if (!counterValue) {
          if (!uncontrolledNodes.has(node)) {
            node.removeAttribute(controlAttribute);
          }
          uncontrolledNodes.delete(node);
        }
        if (!markerValue) {
          node.removeAttribute(markerName);
        }
      });
      lockCount--;
      if (!lockCount) {
        // clear
        counterMap = new WeakMap();
        counterMap = new WeakMap();
        uncontrolledNodes = new WeakMap();
        markerMap = {};
      }
    };
  };
  /**
   * Marks everything except given node(or nodes) as aria-hidden
   * @param {Element | Element[]} originalTarget - elements to keep on the page
   * @param [parentNode] - top element, defaults to document.body
   * @param {String} [markerName] - a special attribute to mark every node
   * @return {Undo} undo command
   */
  var hideOthers = function (originalTarget, parentNode, markerName) {
    if (markerName === void 0) {
      markerName = 'data-aria-hidden';
    }
    var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
    var activeParentNode = parentNode || getDefaultParent(originalTarget);
    if (!activeParentNode) {
      return function () {
        return null;
      };
    }
    // we should not hide aria-live elements - https://github.com/theKashey/aria-hidden/issues/10
    // and script elements, as they have no impact on accessibility.
    targets.push.apply(
      targets,
      Array.from(activeParentNode.querySelectorAll('[aria-live], script'))
    );
    return applyAttributeToOthers(targets, activeParentNode, markerName, 'aria-hidden');
  };
  /**
   * Marks everything except given node(or nodes) as inert
   * @param {Element | Element[]} originalTarget - elements to keep on the page
   * @param [parentNode] - top element, defaults to document.body
   * @param {String} [markerName] - a special attribute to mark every node
   * @return {Undo} undo command
   */
  var inertOthers = function (originalTarget, parentNode, markerName) {
    if (markerName === void 0) {
      markerName = 'data-inert-ed';
    }
    var activeParentNode = parentNode || getDefaultParent(originalTarget);
    if (!activeParentNode) {
      return function () {
        return null;
      };
    }
    return applyAttributeToOthers(originalTarget, activeParentNode, markerName, 'inert');
  };
  /**
   * @returns if current browser supports inert
   */
  var supportsInert = function () {
    return typeof HTMLElement !== 'undefined' && HTMLElement.prototype.hasOwnProperty('inert');
  };
  /**
   * Automatic function to "suppress" DOM elements - _hide_ or _inert_ in the best possible way
   * @param {Element | Element[]} originalTarget - elements to keep on the page
   * @param [parentNode] - top element, defaults to document.body
   * @param {String} [markerName] - a special attribute to mark every node
   * @return {Undo} undo command
   */
  var suppressOthers = function (originalTarget, parentNode, markerName) {
    if (markerName === void 0) {
      markerName = 'data-suppressed';
    }
    return (supportsInert() ? inertOthers : hideOthers)(originalTarget, parentNode, markerName);
  }; // ./node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs

  /******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
  /* global Reflect, Promise, SuppressedError, Symbol, Iterator */

  var extendStatics = function (d, b) {
    extendStatics =
      Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array &&
        function (d, b) {
          d.__proto__ = b;
        }) ||
      function (d, b) {
        for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      };
    return extendStatics(d, b);
  };

  function __extends(d, b) {
    if (typeof b !== 'function' && b !== null)
      throw new TypeError('Class extends value ' + String(b) + ' is not a constructor or null');
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : ((__.prototype = b.prototype), new __());
  }

  var __assign = function () {
    __assign =
      Object.assign ||
      function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
      };
    return __assign.apply(this, arguments);
  };

  function tslib_es6_rest(s, e) {
    var t = {};
    for (var p in s)
      if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === 'function')
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
          t[p[i]] = s[p[i]];
      }
    return t;
  }

  function __decorate(decorators, target, key, desc) {
    var c = arguments.length,
      r =
        c < 3
          ? target
          : desc === null
            ? (desc = Object.getOwnPropertyDescriptor(target, key))
            : desc,
      d;
    if (typeof Reflect === 'object' && typeof Reflect.decorate === 'function')
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if ((d = decorators[i]))
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return (c > 3 && r && Object.defineProperty(target, key, r), r);
  }

  function __param(paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  }

  function __esDecorate(
    ctor,
    descriptorIn,
    decorators,
    contextIn,
    initializers,
    extraInitializers
  ) {
    function accept(f) {
      if (f !== void 0 && typeof f !== 'function') throw new TypeError('Function expected');
      return f;
    }
    var kind = contextIn.kind,
      key = kind === 'getter' ? 'get' : kind === 'setter' ? 'set' : 'value';
    var target = !descriptorIn && ctor ? (contextIn['static'] ? ctor : ctor.prototype) : null;
    var descriptor =
      descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _,
      done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
      var context = {};
      for (var p in contextIn) context[p] = p === 'access' ? {} : contextIn[p];
      for (var p in contextIn.access) context.access[p] = contextIn.access[p];
      context.addInitializer = function (f) {
        if (done) throw new TypeError('Cannot add initializers after decoration has completed');
        extraInitializers.push(accept(f || null));
      };
      var result = (0, decorators[i])(
        kind === 'accessor' ? { get: descriptor.get, set: descriptor.set } : descriptor[key],
        context
      );
      if (kind === 'accessor') {
        if (result === void 0) continue;
        if (result === null || typeof result !== 'object') throw new TypeError('Object expected');
        if ((_ = accept(result.get))) descriptor.get = _;
        if ((_ = accept(result.set))) descriptor.set = _;
        if ((_ = accept(result.init))) initializers.unshift(_);
      } else if ((_ = accept(result))) {
        if (kind === 'field') initializers.unshift(_);
        else descriptor[key] = _;
      }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
  }

  function __runInitializers(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
  }

  function __propKey(x) {
    return typeof x === 'symbol' ? x : ''.concat(x);
  }

  function __setFunctionName(f, name, prefix) {
    if (typeof name === 'symbol') name = name.description ? '['.concat(name.description, ']') : '';
    return Object.defineProperty(f, 'name', {
      configurable: true,
      value: prefix ? ''.concat(prefix, ' ', name) : name,
    });
  }

  function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === 'object' && typeof Reflect.metadata === 'function')
      return Reflect.metadata(metadataKey, metadataValue);
  }

  function tslib_es6_awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P
        ? value
        : new P(function (resolve) {
            resolve(value);
          });
    }
    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator['throw'](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }

  function __generator(thisArg, body) {
    var _ = {
        label: 0,
        sent: function () {
          if (t[0] & 1) throw t[1];
          return t[1];
        },
        trys: [],
        ops: [],
      },
      f,
      y,
      t,
      g = Object.create((typeof Iterator === 'function' ? Iterator : Object).prototype);
    return (
      (g.next = verb(0)),
      (g['throw'] = verb(1)),
      (g['return'] = verb(2)),
      typeof Symbol === 'function' &&
        (g[Symbol.iterator] = function () {
          return this;
        }),
      g
    );
    function verb(n) {
      return function (v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f) throw new TypeError('Generator is already executing.');
      while ((g && ((g = 0), op[0] && (_ = 0)), _))
        try {
          if (
            ((f = 1),
            y &&
              (t =
                op[0] & 2
                  ? y['return']
                  : op[0]
                    ? y['throw'] || ((t = y['return']) && t.call(y), 0)
                    : y.next) &&
              !(t = t.call(y, op[1])).done)
          )
            return t;
          if (((y = 0), t)) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (
                !((t = _.trys), (t = t.length > 0 && t[t.length - 1])) &&
                (op[0] === 6 || op[0] === 2)
              ) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      if (op[0] & 5) throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  }

  var __createBinding = Object.create
    ? function (o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ('get' in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = {
            enumerable: true,
            get: function () {
              return m[k];
            },
          };
        }
        Object.defineProperty(o, k2, desc);
      }
    : function (o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
      };

  function __exportStar(m, o) {
    for (var p in m)
      if (p !== 'default' && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
  }

  function tslib_es6_values(o) {
    var s = typeof Symbol === 'function' && Symbol.iterator,
      m = s && o[s],
      i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === 'number')
      return {
        next: function () {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
        },
      };
    throw new TypeError(s ? 'Object is not iterable.' : 'Symbol.iterator is not defined.');
  }

  function __read(o, n) {
    var m = typeof Symbol === 'function' && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o),
      r,
      ar = [],
      e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    } catch (error) {
      e = { error: error };
    } finally {
      try {
        if (r && !r.done && (m = i['return'])) m.call(i);
      } finally {
        if (e) throw e.error;
      }
    }
    return ar;
  }

  /** @deprecated */
  function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
  }

  /** @deprecated */
  function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];
    return r;
  }

  function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2)
      for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
    return to.concat(ar || Array.prototype.slice.call(from));
  }

  function __await(v) {
    return this instanceof __await ? ((this.v = v), this) : new __await(v);
  }

  function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError('Symbol.asyncIterator is not defined.');
    var g = generator.apply(thisArg, _arguments || []),
      i,
      q = [];
    return (
      (i = Object.create((typeof AsyncIterator === 'function' ? AsyncIterator : Object).prototype)),
      verb('next'),
      verb('throw'),
      verb('return', awaitReturn),
      (i[Symbol.asyncIterator] = function () {
        return this;
      }),
      i
    );
    function awaitReturn(f) {
      return function (v) {
        return Promise.resolve(v).then(f, reject);
      };
    }
    function verb(n, f) {
      if (g[n]) {
        i[n] = function (v) {
          return new Promise(function (a, b) {
            q.push([n, v, a, b]) > 1 || resume(n, v);
          });
        };
        if (f) i[n] = f(i[n]);
      }
    }
    function resume(n, v) {
      try {
        step(g[n](v));
      } catch (e) {
        settle(q[0][3], e);
      }
    }
    function step(r) {
      r.value instanceof __await
        ? Promise.resolve(r.value.v).then(fulfill, reject)
        : settle(q[0][2], r);
    }
    function fulfill(value) {
      resume('next', value);
    }
    function reject(value) {
      resume('throw', value);
    }
    function settle(f, v) {
      if ((f(v), q.shift(), q.length)) resume(q[0][0], q[0][1]);
    }
  }

  function __asyncDelegator(o) {
    var i, p;
    return (
      (i = {}),
      verb('next'),
      verb('throw', function (e) {
        throw e;
      }),
      verb('return'),
      (i[Symbol.iterator] = function () {
        return this;
      }),
      i
    );
    function verb(n, f) {
      i[n] = o[n]
        ? function (v) {
            return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
          }
        : f;
    }
  }

  function tslib_es6_asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError('Symbol.asyncIterator is not defined.');
    var m = o[Symbol.asyncIterator],
      i;
    return m
      ? m.call(o)
      : ((o = typeof tslib_es6_values === 'function' ? tslib_es6_values(o) : o[Symbol.iterator]()),
        (i = {}),
        verb('next'),
        verb('throw'),
        verb('return'),
        (i[Symbol.asyncIterator] = function () {
          return this;
        }),
        i);
    function verb(n) {
      i[n] =
        o[n] &&
        function (v) {
          return new Promise(function (resolve, reject) {
            ((v = o[n](v)), settle(resolve, reject, v.done, v.value));
          });
        };
    }
    function settle(resolve, reject, d, v) {
      Promise.resolve(v).then(function (v) {
        resolve({ value: v, done: d });
      }, reject);
    }
  }

  function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) {
      Object.defineProperty(cooked, 'raw', { value: raw });
    } else {
      cooked.raw = raw;
    }
    return cooked;
  }

  var __setModuleDefault = Object.create
    ? function (o, v) {
        Object.defineProperty(o, 'default', { enumerable: true, value: v });
      }
    : function (o, v) {
        o['default'] = v;
      };

  var ownKeys = function (o) {
    ownKeys =
      Object.getOwnPropertyNames ||
      function (o) {
        var ar = [];
        for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
        return ar;
      };
    return ownKeys(o);
  };

  function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null)
      for (var k = ownKeys(mod), i = 0; i < k.length; i++)
        if (k[i] !== 'default') __createBinding(result, mod, k[i]);
    __setModuleDefault(result, mod);
    return result;
  }

  function __importDefault(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  }

  function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === 'a' && !f) throw new TypeError('Private accessor was defined without a getter');
    if (typeof state === 'function' ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError(
        'Cannot read private member from an object whose class did not declare it'
      );
    return kind === 'm' ? f : kind === 'a' ? f.call(receiver) : f ? f.value : state.get(receiver);
  }

  function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === 'm') throw new TypeError('Private method is not writable');
    if (kind === 'a' && !f) throw new TypeError('Private accessor was defined without a setter');
    if (typeof state === 'function' ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError(
        'Cannot write private member to an object whose class did not declare it'
      );
    return (
      kind === 'a' ? f.call(receiver, value) : f ? (f.value = value) : state.set(receiver, value),
      value
    );
  }

  function __classPrivateFieldIn(state, receiver) {
    if (receiver === null || (typeof receiver !== 'object' && typeof receiver !== 'function'))
      throw new TypeError("Cannot use 'in' operator on non-object");
    return typeof state === 'function' ? receiver === state : state.has(receiver);
  }

  function __addDisposableResource(env, value, async) {
    if (value !== null && value !== void 0) {
      if (typeof value !== 'object' && typeof value !== 'function')
        throw new TypeError('Object expected.');
      var dispose, inner;
      if (async) {
        if (!Symbol.asyncDispose) throw new TypeError('Symbol.asyncDispose is not defined.');
        dispose = value[Symbol.asyncDispose];
      }
      if (dispose === void 0) {
        if (!Symbol.dispose) throw new TypeError('Symbol.dispose is not defined.');
        dispose = value[Symbol.dispose];
        if (async) inner = dispose;
      }
      if (typeof dispose !== 'function') throw new TypeError('Object not disposable.');
      if (inner)
        dispose = function () {
          try {
            inner.call(this);
          } catch (e) {
            return Promise.reject(e);
          }
        };
      env.stack.push({ value: value, dispose: dispose, async: async });
    } else if (async) {
      env.stack.push({ async: true });
    }
    return value;
  }

  var _SuppressedError =
    typeof SuppressedError === 'function'
      ? SuppressedError
      : function (error, suppressed, message) {
          var e = new Error(message);
          return ((e.name = 'SuppressedError'), (e.error = error), (e.suppressed = suppressed), e);
        };

  function __disposeResources(env) {
    function fail(e) {
      env.error = env.hasError
        ? new _SuppressedError(e, env.error, 'An error was suppressed during disposal.')
        : e;
      env.hasError = true;
    }
    var r,
      s = 0;
    function next() {
      while ((r = env.stack.pop())) {
        try {
          if (!r.async && s === 1)
            return ((s = 0), env.stack.push(r), Promise.resolve().then(next));
          if (r.dispose) {
            var result = r.dispose.call(r.value);
            if (r.async)
              return (
                (s |= 2),
                Promise.resolve(result).then(next, function (e) {
                  fail(e);
                  return next();
                })
              );
          } else s |= 1;
        } catch (e) {
          fail(e);
        }
      }
      if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
      if (env.hasError) throw env.error;
    }
    return next();
  }

  function __rewriteRelativeImportExtension(path, preserveJsx) {
    if (typeof path === 'string' && /^\.\.?\//.test(path)) {
      return path.replace(
        /\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i,
        function (m, tsx, d, ext, cm) {
          return tsx
            ? preserveJsx
              ? '.jsx'
              : '.js'
            : d && (!ext || !cm)
              ? m
              : d + ext + '.' + cm.toLowerCase() + 'js';
        }
      );
    }
    return path;
  }

  /* harmony default export */ const tslib_es6 = {
    __extends,
    __assign,
    __rest: tslib_es6_rest,
    __decorate,
    __param,
    __esDecorate,
    __runInitializers,
    __propKey,
    __setFunctionName,
    __metadata,
    __awaiter: tslib_es6_awaiter,
    __generator,
    __createBinding,
    __exportStar,
    __values: tslib_es6_values,
    __read,
    __spread,
    __spreadArrays,
    __spreadArray,
    __await,
    __asyncGenerator,
    __asyncDelegator,
    __asyncValues: tslib_es6_asyncValues,
    __makeTemplateObject,
    __importStar,
    __importDefault,
    __classPrivateFieldGet,
    __classPrivateFieldSet,
    __classPrivateFieldIn,
    __addDisposableResource,
    __disposeResources,
    __rewriteRelativeImportExtension,
  }; // ./node_modules/.pnpm/react-remove-scroll-bar@2.3.8_@types+react@19.1.12_react@19.1.1/node_modules/react-remove-scroll-bar/dist/es2015/constants.js

  var zeroRightClassName = 'right-scroll-bar-position';
  var fullWidthClassName = 'width-before-scroll-bar';
  var noScrollbarsClassName = 'with-scroll-bars-hidden';
  /**
   * Name of a CSS variable containing the amount of "hidden" scrollbar
   * ! might be undefined ! use will fallback!
   */
  var removedBarSizeVariable = '--removed-body-scroll-bar-size'; // ./node_modules/.pnpm/use-callback-ref@1.3.3_@types+react@19.1.12_react@19.1.1/node_modules/use-callback-ref/dist/es2015/assignRef.js

  /**
   * Assigns a value for a given ref, no matter of the ref format
   * @param {RefObject} ref - a callback function or ref object
   * @param value - a new value
   *
   * @see https://github.com/theKashey/use-callback-ref#assignref
   * @example
   * const refObject = useRef();
   * const refFn = (ref) => {....}
   *
   * assignRef(refObject, "refValue");
   * assignRef(refFn, "refValue");
   */
  function assignRef(ref, value) {
    if (typeof ref === 'function') {
      ref(value);
    } else if (ref) {
      ref.current = value;
    }
    return ref;
  } // ./node_modules/.pnpm/use-callback-ref@1.3.3_@types+react@19.1.12_react@19.1.1/node_modules/use-callback-ref/dist/es2015/useRef.js

  /**
   * creates a MutableRef with ref change callback
   * @param initialValue - initial ref value
   * @param {Function} callback - a callback to run when value changes
   *
   * @example
   * const ref = useCallbackRef(0, (newValue, oldValue) => console.log(oldValue, '->', newValue);
   * ref.current = 1;
   * // prints 0 -> 1
   *
   * @see https://reactjs.org/docs/hooks-reference.html#useref
   * @see https://github.com/theKashey/use-callback-ref#usecallbackref---to-replace-reactuseref
   * @returns {MutableRefObject}
   */
  function useRef_useCallbackRef(initialValue, callback) {
    var ref = (0, react.useState)(function () {
      return {
        // value
        value: initialValue,
        // last callback
        callback: callback,
        // "memoized" public interface
        facade: {
          get current() {
            return ref.value;
          },
          set current(value) {
            var last = ref.value;
            if (last !== value) {
              ref.value = value;
              ref.callback(value, last);
            }
          },
        },
      };
    })[0];
    // update callback
    ref.callback = callback;
    return ref.facade;
  } // ./node_modules/.pnpm/use-callback-ref@1.3.3_@types+react@19.1.12_react@19.1.1/node_modules/use-callback-ref/dist/es2015/useMergeRef.js

  var useMergeRef_useIsomorphicLayoutEffect =
    typeof window !== 'undefined' ? react.useLayoutEffect : react.useEffect;
  var currentValues = new WeakMap();
  /**
   * Merges two or more refs together providing a single interface to set their value
   * @param {RefObject|Ref} refs
   * @returns {MutableRefObject} - a new ref, which translates all changes to {refs}
   *
   * @see {@link mergeRefs} a version without buit-in memoization
   * @see https://github.com/theKashey/use-callback-ref#usemergerefs
   * @example
   * const Component = React.forwardRef((props, ref) => {
   *   const ownRef = useRef();
   *   const domRef = useMergeRefs([ref, ownRef]); //  merge together
   *   return <div ref={domRef}>...</div>
   * }
   */
  function useMergeRefs(refs, defaultValue) {
    var callbackRef = useRef_useCallbackRef(defaultValue || null, function (newValue) {
      return refs.forEach(function (ref) {
        return assignRef(ref, newValue);
      });
    });
    // handle refs changes - added or removed
    useMergeRef_useIsomorphicLayoutEffect(
      function () {
        var oldValue = currentValues.get(callbackRef);
        if (oldValue) {
          var prevRefs_1 = new Set(oldValue);
          var nextRefs_1 = new Set(refs);
          var current_1 = callbackRef.current;
          prevRefs_1.forEach(function (ref) {
            if (!nextRefs_1.has(ref)) {
              assignRef(ref, null);
            }
          });
          nextRefs_1.forEach(function (ref) {
            if (!prevRefs_1.has(ref)) {
              assignRef(ref, current_1);
            }
          });
        }
        currentValues.set(callbackRef, refs);
      },
      [refs]
    );
    return callbackRef;
  } // ./node_modules/.pnpm/use-sidecar@1.1.3_@types+react@19.1.12_react@19.1.1/node_modules/use-sidecar/dist/es2015/medium.js

  function ItoI(a) {
    return a;
  }
  function innerCreateMedium(defaults, middleware) {
    if (middleware === void 0) {
      middleware = ItoI;
    }
    var buffer = [];
    var assigned = false;
    var medium = {
      read: function () {
        if (assigned) {
          throw new Error(
            'Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.'
          );
        }
        if (buffer.length) {
          return buffer[buffer.length - 1];
        }
        return defaults;
      },
      useMedium: function (data) {
        var item = middleware(data, assigned);
        buffer.push(item);
        return function () {
          buffer = buffer.filter(function (x) {
            return x !== item;
          });
        };
      },
      assignSyncMedium: function (cb) {
        assigned = true;
        while (buffer.length) {
          var cbs = buffer;
          buffer = [];
          cbs.forEach(cb);
        }
        buffer = {
          push: function (x) {
            return cb(x);
          },
          filter: function () {
            return buffer;
          },
        };
      },
      assignMedium: function (cb) {
        assigned = true;
        var pendingQueue = [];
        if (buffer.length) {
          var cbs = buffer;
          buffer = [];
          cbs.forEach(cb);
          pendingQueue = buffer;
        }
        var executeQueue = function () {
          var cbs = pendingQueue;
          pendingQueue = [];
          cbs.forEach(cb);
        };
        var cycle = function () {
          return Promise.resolve().then(executeQueue);
        };
        cycle();
        buffer = {
          push: function (x) {
            pendingQueue.push(x);
            cycle();
          },
          filter: function (filter) {
            pendingQueue = pendingQueue.filter(filter);
            return buffer;
          },
        };
      },
    };
    return medium;
  }
  function createMedium(defaults, middleware) {
    if (middleware === void 0) {
      middleware = ItoI;
    }
    return innerCreateMedium(defaults, middleware);
  }
  // eslint-disable-next-line @typescript-eslint/ban-types
  function createSidecarMedium(options) {
    if (options === void 0) {
      options = {};
    }
    var medium = innerCreateMedium(null);
    medium.options = __assign({ async: true, ssr: false }, options);
    return medium;
  } // ./node_modules/.pnpm/react-remove-scroll@2.7.1_@types+react@19.1.12_react@19.1.1/node_modules/react-remove-scroll/dist/es2015/medium.js

  var effectCar = createSidecarMedium(); // ./node_modules/.pnpm/react-remove-scroll@2.7.1_@types+react@19.1.12_react@19.1.1/node_modules/react-remove-scroll/dist/es2015/UI.js

  var nothing = function () {
    return;
  };
  /**
   * Removes scrollbar from the page and contain the scroll within the Lock
   */
  var RemoveScroll = react.forwardRef(function (props, parentRef) {
    var ref = react.useRef(null);
    var _a = react.useState({
        onScrollCapture: nothing,
        onWheelCapture: nothing,
        onTouchMoveCapture: nothing,
      }),
      callbacks = _a[0],
      setCallbacks = _a[1];
    var forwardProps = props.forwardProps,
      children = props.children,
      className = props.className,
      removeScrollBar = props.removeScrollBar,
      enabled = props.enabled,
      shards = props.shards,
      sideCar = props.sideCar,
      noRelative = props.noRelative,
      noIsolation = props.noIsolation,
      inert = props.inert,
      allowPinchZoom = props.allowPinchZoom,
      _b = props.as,
      Container = _b === void 0 ? 'div' : _b,
      gapMode = props.gapMode,
      rest = tslib_es6_rest(props, [
        'forwardProps',
        'children',
        'className',
        'removeScrollBar',
        'enabled',
        'shards',
        'sideCar',
        'noRelative',
        'noIsolation',
        'inert',
        'allowPinchZoom',
        'as',
        'gapMode',
      ]);
    var SideCar = sideCar;
    var containerRef = useMergeRefs([ref, parentRef]);
    var containerProps = __assign(__assign({}, rest), callbacks);
    return react.createElement(
      react.Fragment,
      null,
      enabled &&
        react.createElement(SideCar, {
          sideCar: effectCar,
          removeScrollBar: removeScrollBar,
          shards: shards,
          noRelative: noRelative,
          noIsolation: noIsolation,
          inert: inert,
          setCallbacks: setCallbacks,
          allowPinchZoom: !!allowPinchZoom,
          lockRef: ref,
          gapMode: gapMode,
        }),
      forwardProps
        ? react.cloneElement(
            react.Children.only(children),
            __assign(__assign({}, containerProps), { ref: containerRef })
          )
        : react.createElement(
            Container,
            __assign({}, containerProps, { className: className, ref: containerRef }),
            children
          )
    );
  });
  RemoveScroll.defaultProps = {
    enabled: true,
    removeScrollBar: true,
    inert: false,
  };
  RemoveScroll.classNames = {
    fullWidth: fullWidthClassName,
    zeroRight: zeroRightClassName,
  }; // ./node_modules/.pnpm/use-sidecar@1.1.3_@types+react@19.1.12_react@19.1.1/node_modules/use-sidecar/dist/es2015/exports.js

  var SideCar = function (_a) {
    var sideCar = _a.sideCar,
      rest = tslib_es6_rest(_a, ['sideCar']);
    if (!sideCar) {
      throw new Error('Sidecar: please provide `sideCar` property to import the right car');
    }
    var Target = sideCar.read();
    if (!Target) {
      throw new Error('Sidecar medium not found');
    }
    return react.createElement(Target, __assign({}, rest));
  };
  SideCar.isSideCarExport = true;
  function exportSidecar(medium, exported) {
    medium.useMedium(exported);
    return SideCar;
  } // ./node_modules/.pnpm/get-nonce@1.0.1/node_modules/get-nonce/dist/es2015/index.js

  var currentNonce;
  var setNonce = function (nonce) {
    currentNonce = nonce;
  };
  var getNonce = function () {
    if (currentNonce) {
      return currentNonce;
    }
    if (true) {
      return __webpack_require__.nc;
    }
    // removed by dead control flow
  }; // ./node_modules/.pnpm/react-style-singleton@2.2.3_@types+react@19.1.12_react@19.1.1/node_modules/react-style-singleton/dist/es2015/singleton.js

  function makeStyleTag() {
    if (!document) return null;
    var tag = document.createElement('style');
    tag.type = 'text/css';
    var nonce = getNonce();
    if (nonce) {
      tag.setAttribute('nonce', nonce);
    }
    return tag;
  }
  function injectStyles(tag, css) {
    // @ts-ignore
    if (tag.styleSheet) {
      // @ts-ignore
      tag.styleSheet.cssText = css;
    } else {
      tag.appendChild(document.createTextNode(css));
    }
  }
  function insertStyleTag(tag) {
    var head = document.head || document.getElementsByTagName('head')[0];
    head.appendChild(tag);
  }
  var stylesheetSingleton = function () {
    var counter = 0;
    var stylesheet = null;
    return {
      add: function (style) {
        if (counter == 0) {
          if ((stylesheet = makeStyleTag())) {
            injectStyles(stylesheet, style);
            insertStyleTag(stylesheet);
          }
        }
        counter++;
      },
      remove: function () {
        counter--;
        if (!counter && stylesheet) {
          stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
          stylesheet = null;
        }
      },
    };
  }; // ./node_modules/.pnpm/react-style-singleton@2.2.3_@types+react@19.1.12_react@19.1.1/node_modules/react-style-singleton/dist/es2015/hook.js

  /**
   * creates a hook to control style singleton
   * @see {@link styleSingleton} for a safer component version
   * @example
   * ```tsx
   * const useStyle = styleHookSingleton();
   * ///
   * useStyle('body { overflow: hidden}');
   */
  var styleHookSingleton = function () {
    var sheet = stylesheetSingleton();
    return function (styles, isDynamic) {
      react.useEffect(
        function () {
          sheet.add(styles);
          return function () {
            sheet.remove();
          };
        },
        [styles && isDynamic]
      );
    };
  }; // ./node_modules/.pnpm/react-style-singleton@2.2.3_@types+react@19.1.12_react@19.1.1/node_modules/react-style-singleton/dist/es2015/component.js

  /**
   * create a Component to add styles on demand
   * - styles are added when first instance is mounted
   * - styles are removed when the last instance is unmounted
   * - changing styles in runtime does nothing unless dynamic is set. But with multiple components that can lead to the undefined behavior
   */
  var styleSingleton = function () {
    var useStyle = styleHookSingleton();
    var Sheet = function (_a) {
      var styles = _a.styles,
        dynamic = _a.dynamic;
      useStyle(styles, dynamic);
      return null;
    };
    return Sheet;
  }; // ./node_modules/.pnpm/react-style-singleton@2.2.3_@types+react@19.1.12_react@19.1.1/node_modules/react-style-singleton/dist/es2015/index.js
  // ./node_modules/.pnpm/react-remove-scroll-bar@2.3.8_@types+react@19.1.12_react@19.1.1/node_modules/react-remove-scroll-bar/dist/es2015/utils.js

  var zeroGap = {
    left: 0,
    top: 0,
    right: 0,
    gap: 0,
  };
  var parse = function (x) {
    return parseInt(x || '', 10) || 0;
  };
  var getOffset = function (gapMode) {
    var cs = window.getComputedStyle(document.body);
    var left = cs[gapMode === 'padding' ? 'paddingLeft' : 'marginLeft'];
    var top = cs[gapMode === 'padding' ? 'paddingTop' : 'marginTop'];
    var right = cs[gapMode === 'padding' ? 'paddingRight' : 'marginRight'];
    return [parse(left), parse(top), parse(right)];
  };
  var getGapWidth = function (gapMode) {
    if (gapMode === void 0) {
      gapMode = 'margin';
    }
    if (typeof window === 'undefined') {
      return zeroGap;
    }
    var offsets = getOffset(gapMode);
    var documentWidth = document.documentElement.clientWidth;
    var windowWidth = window.innerWidth;
    return {
      left: offsets[0],
      top: offsets[1],
      right: offsets[2],
      gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0]),
    };
  }; // ./node_modules/.pnpm/react-remove-scroll-bar@2.3.8_@types+react@19.1.12_react@19.1.1/node_modules/react-remove-scroll-bar/dist/es2015/component.js

  var Style = styleSingleton();
  var lockAttribute = 'data-scroll-locked';
  // important tip - once we measure scrollBar width and remove them
  // we could not repeat this operation
  // thus we are using style-singleton - only the first "yet correct" style will be applied.
  var component_getStyles = function (_a, allowRelative, gapMode, important) {
    var left = _a.left,
      top = _a.top,
      right = _a.right,
      gap = _a.gap;
    if (gapMode === void 0) {
      gapMode = 'margin';
    }
    return '\n  .'
      .concat(noScrollbarsClassName, ' {\n   overflow: hidden ')
      .concat(important, ';\n   padding-right: ')
      .concat(gap, 'px ')
      .concat(important, ';\n  }\n  body[')
      .concat(lockAttribute, '] {\n    overflow: hidden ')
      .concat(important, ';\n    overscroll-behavior: contain;\n    ')
      .concat(
        [
          allowRelative && 'position: relative '.concat(important, ';'),
          gapMode === 'margin' &&
            '\n    padding-left: '
              .concat(left, 'px;\n    padding-top: ')
              .concat(top, 'px;\n    padding-right: ')
              .concat(right, 'px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ')
              .concat(gap, 'px ')
              .concat(important, ';\n    '),
          gapMode === 'padding' && 'padding-right: '.concat(gap, 'px ').concat(important, ';'),
        ]
          .filter(Boolean)
          .join(''),
        '\n  }\n  \n  .'
      )
      .concat(zeroRightClassName, ' {\n    right: ')
      .concat(gap, 'px ')
      .concat(important, ';\n  }\n  \n  .')
      .concat(fullWidthClassName, ' {\n    margin-right: ')
      .concat(gap, 'px ')
      .concat(important, ';\n  }\n  \n  .')
      .concat(zeroRightClassName, ' .')
      .concat(zeroRightClassName, ' {\n    right: 0 ')
      .concat(important, ';\n  }\n  \n  .')
      .concat(fullWidthClassName, ' .')
      .concat(fullWidthClassName, ' {\n    margin-right: 0 ')
      .concat(important, ';\n  }\n  \n  body[')
      .concat(lockAttribute, '] {\n    ')
      .concat(removedBarSizeVariable, ': ')
      .concat(gap, 'px;\n  }\n');
  };
  var getCurrentUseCounter = function () {
    var counter = parseInt(document.body.getAttribute(lockAttribute) || '0', 10);
    return isFinite(counter) ? counter : 0;
  };
  var useLockAttribute = function () {
    react.useEffect(function () {
      document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString());
      return function () {
        var newCounter = getCurrentUseCounter() - 1;
        if (newCounter <= 0) {
          document.body.removeAttribute(lockAttribute);
        } else {
          document.body.setAttribute(lockAttribute, newCounter.toString());
        }
      };
    }, []);
  };
  /**
   * Removes page scrollbar and blocks page scroll when mounted
   */
  var RemoveScrollBar = function (_a) {
    var noRelative = _a.noRelative,
      noImportant = _a.noImportant,
      _b = _a.gapMode,
      gapMode = _b === void 0 ? 'margin' : _b;
    useLockAttribute();
    /*
     gap will be measured on every component mount
     however it will be used only by the "first" invocation
     due to singleton nature of <Style
     */
    var gap = react.useMemo(
      function () {
        return getGapWidth(gapMode);
      },
      [gapMode]
    );
    return react.createElement(Style, {
      styles: component_getStyles(gap, !noRelative, gapMode, !noImportant ? '!important' : ''),
    });
  }; // ./node_modules/.pnpm/react-remove-scroll-bar@2.3.8_@types+react@19.1.12_react@19.1.1/node_modules/react-remove-scroll-bar/dist/es2015/index.js
  // ./node_modules/.pnpm/react-remove-scroll@2.7.1_@types+react@19.1.12_react@19.1.1/node_modules/react-remove-scroll/dist/es2015/aggresiveCapture.js

  var passiveSupported = false;
  if (typeof window !== 'undefined') {
    try {
      var options = Object.defineProperty({}, 'passive', {
        get: function () {
          passiveSupported = true;
          return true;
        },
      });
      // @ts-ignore
      window.addEventListener('test', options, options);
      // @ts-ignore
      window.removeEventListener('test', options, options);
    } catch (err) {
      passiveSupported = false;
    }
  }
  var nonPassive = passiveSupported ? { passive: false } : false; // ./node_modules/.pnpm/react-remove-scroll@2.7.1_@types+react@19.1.12_react@19.1.1/node_modules/react-remove-scroll/dist/es2015/handleScroll.js

  var alwaysContainsScroll = function (node) {
    // textarea will always _contain_ scroll inside self. It only can be hidden
    return node.tagName === 'TEXTAREA';
  };
  var elementCanBeScrolled = function (node, overflow) {
    if (!(node instanceof Element)) {
      return false;
    }
    var styles = window.getComputedStyle(node);
    return (
      // not-not-scrollable
      styles[overflow] !== 'hidden' &&
      // contains scroll inside self
      !(
        styles.overflowY === styles.overflowX &&
        !alwaysContainsScroll(node) &&
        styles[overflow] === 'visible'
      )
    );
  };
  var elementCouldBeVScrolled = function (node) {
    return elementCanBeScrolled(node, 'overflowY');
  };
  var elementCouldBeHScrolled = function (node) {
    return elementCanBeScrolled(node, 'overflowX');
  };
  var locationCouldBeScrolled = function (axis, node) {
    var ownerDocument = node.ownerDocument;
    var current = node;
    do {
      // Skip over shadow root
      if (typeof ShadowRoot !== 'undefined' && current instanceof ShadowRoot) {
        current = current.host;
      }
      var isScrollable = elementCouldBeScrolled(axis, current);
      if (isScrollable) {
        var _a = getScrollVariables(axis, current),
          scrollHeight = _a[1],
          clientHeight = _a[2];
        if (scrollHeight > clientHeight) {
          return true;
        }
      }
      current = current.parentNode;
    } while (current && current !== ownerDocument.body);
    return false;
  };
  var getVScrollVariables = function (_a) {
    var scrollTop = _a.scrollTop,
      scrollHeight = _a.scrollHeight,
      clientHeight = _a.clientHeight;
    return [scrollTop, scrollHeight, clientHeight];
  };
  var getHScrollVariables = function (_a) {
    var scrollLeft = _a.scrollLeft,
      scrollWidth = _a.scrollWidth,
      clientWidth = _a.clientWidth;
    return [scrollLeft, scrollWidth, clientWidth];
  };
  var elementCouldBeScrolled = function (axis, node) {
    return axis === 'v' ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);
  };
  var getScrollVariables = function (axis, node) {
    return axis === 'v' ? getVScrollVariables(node) : getHScrollVariables(node);
  };
  var getDirectionFactor = function (axis, direction) {
    /**
     * If the element's direction is rtl (right-to-left), then scrollLeft is 0 when the scrollbar is at its rightmost position,
     * and then increasingly negative as you scroll towards the end of the content.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollLeft
     */
    return axis === 'h' && direction === 'rtl' ? -1 : 1;
  };
  var handleScroll = function (axis, endTarget, event, sourceDelta, noOverscroll) {
    var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
    var delta = directionFactor * sourceDelta;
    // find scrollable target
    var target = event.target;
    var targetInLock = endTarget.contains(target);
    var shouldCancelScroll = false;
    var isDeltaPositive = delta > 0;
    var availableScroll = 0;
    var availableScrollTop = 0;
    do {
      if (!target) {
        break;
      }
      var _a = getScrollVariables(axis, target),
        position = _a[0],
        scroll_1 = _a[1],
        capacity = _a[2];
      var elementScroll = scroll_1 - capacity - directionFactor * position;
      if (position || elementScroll) {
        if (elementCouldBeScrolled(axis, target)) {
          availableScroll += elementScroll;
          availableScrollTop += position;
        }
      }
      var parent_1 = target.parentNode;
      // we will "bubble" from ShadowDom in case we are, or just to the parent in normal case
      // this is the same logic used in focus-lock
      target =
        parent_1 && parent_1.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? parent_1.host : parent_1;
    } while (
      // portaled content
      (!targetInLock && target !== document.body) ||
      // self content
      (targetInLock && (endTarget.contains(target) || endTarget === target))
    );
    // handle epsilon around 0 (non standard zoom levels)
    if (
      isDeltaPositive &&
      ((noOverscroll && Math.abs(availableScroll) < 1) ||
        (!noOverscroll && delta > availableScroll))
    ) {
      shouldCancelScroll = true;
    } else if (
      !isDeltaPositive &&
      ((noOverscroll && Math.abs(availableScrollTop) < 1) ||
        (!noOverscroll && -delta > availableScrollTop))
    ) {
      shouldCancelScroll = true;
    }
    return shouldCancelScroll;
  }; // ./node_modules/.pnpm/react-remove-scroll@2.7.1_@types+react@19.1.12_react@19.1.1/node_modules/react-remove-scroll/dist/es2015/SideEffect.js

  var getTouchXY = function (event) {
    return 'changedTouches' in event
      ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY]
      : [0, 0];
  };
  var getDeltaXY = function (event) {
    return [event.deltaX, event.deltaY];
  };
  var extractRef = function (ref) {
    return ref && 'current' in ref ? ref.current : ref;
  };
  var deltaCompare = function (x, y) {
    return x[0] === y[0] && x[1] === y[1];
  };
  var generateStyle = function (id) {
    return '\n  .block-interactivity-'
      .concat(id, ' {pointer-events: none;}\n  .allow-interactivity-')
      .concat(id, ' {pointer-events: all;}\n');
  };
  var idCounter = 0;
  var lockStack = [];
  function RemoveScrollSideCar(props) {
    var shouldPreventQueue = react.useRef([]);
    var touchStartRef = react.useRef([0, 0]);
    var activeAxis = react.useRef();
    var id = react.useState(idCounter++)[0];
    var Style = react.useState(styleSingleton)[0];
    var lastProps = react.useRef(props);
    react.useEffect(
      function () {
        lastProps.current = props;
      },
      [props]
    );
    react.useEffect(
      function () {
        if (props.inert) {
          document.body.classList.add('block-interactivity-'.concat(id));
          var allow_1 = __spreadArray(
            [props.lockRef.current],
            (props.shards || []).map(extractRef),
            true
          ).filter(Boolean);
          allow_1.forEach(function (el) {
            return el.classList.add('allow-interactivity-'.concat(id));
          });
          return function () {
            document.body.classList.remove('block-interactivity-'.concat(id));
            allow_1.forEach(function (el) {
              return el.classList.remove('allow-interactivity-'.concat(id));
            });
          };
        }
        return;
      },
      [props.inert, props.lockRef.current, props.shards]
    );
    var shouldCancelEvent = react.useCallback(function (event, parent) {
      if (
        ('touches' in event && event.touches.length === 2) ||
        (event.type === 'wheel' && event.ctrlKey)
      ) {
        return !lastProps.current.allowPinchZoom;
      }
      var touch = getTouchXY(event);
      var touchStart = touchStartRef.current;
      var deltaX = 'deltaX' in event ? event.deltaX : touchStart[0] - touch[0];
      var deltaY = 'deltaY' in event ? event.deltaY : touchStart[1] - touch[1];
      var currentAxis;
      var target = event.target;
      var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? 'h' : 'v';
      // allow horizontal touch move on Range inputs. They will not cause any scroll
      if ('touches' in event && moveDirection === 'h' && target.type === 'range') {
        return false;
      }
      var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
      if (!canBeScrolledInMainDirection) {
        return true;
      }
      if (canBeScrolledInMainDirection) {
        currentAxis = moveDirection;
      } else {
        currentAxis = moveDirection === 'v' ? 'h' : 'v';
        canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
        // other axis might be not scrollable
      }
      if (!canBeScrolledInMainDirection) {
        return false;
      }
      if (!activeAxis.current && 'changedTouches' in event && (deltaX || deltaY)) {
        activeAxis.current = currentAxis;
      }
      if (!currentAxis) {
        return true;
      }
      var cancelingAxis = activeAxis.current || currentAxis;
      return handleScroll(
        cancelingAxis,
        parent,
        event,
        cancelingAxis === 'h' ? deltaX : deltaY,
        true
      );
    }, []);
    var shouldPrevent = react.useCallback(function (_event) {
      var event = _event;
      if (!lockStack.length || lockStack[lockStack.length - 1] !== Style) {
        // not the last active
        return;
      }
      var delta = 'deltaY' in event ? getDeltaXY(event) : getTouchXY(event);
      var sourceEvent = shouldPreventQueue.current.filter(function (e) {
        return (
          e.name === event.type &&
          (e.target === event.target || event.target === e.shadowParent) &&
          deltaCompare(e.delta, delta)
        );
      })[0];
      // self event, and should be canceled
      if (sourceEvent && sourceEvent.should) {
        if (event.cancelable) {
          event.preventDefault();
        }
        return;
      }
      // outside or shard event
      if (!sourceEvent) {
        var shardNodes = (lastProps.current.shards || [])
          .map(extractRef)
          .filter(Boolean)
          .filter(function (node) {
            return node.contains(event.target);
          });
        var shouldStop =
          shardNodes.length > 0
            ? shouldCancelEvent(event, shardNodes[0])
            : !lastProps.current.noIsolation;
        if (shouldStop) {
          if (event.cancelable) {
            event.preventDefault();
          }
        }
      }
    }, []);
    var shouldCancel = react.useCallback(function (name, delta, target, should) {
      var event = {
        name: name,
        delta: delta,
        target: target,
        should: should,
        shadowParent: getOutermostShadowParent(target),
      };
      shouldPreventQueue.current.push(event);
      setTimeout(function () {
        shouldPreventQueue.current = shouldPreventQueue.current.filter(function (e) {
          return e !== event;
        });
      }, 1);
    }, []);
    var scrollTouchStart = react.useCallback(function (event) {
      touchStartRef.current = getTouchXY(event);
      activeAxis.current = undefined;
    }, []);
    var scrollWheel = react.useCallback(function (event) {
      shouldCancel(
        event.type,
        getDeltaXY(event),
        event.target,
        shouldCancelEvent(event, props.lockRef.current)
      );
    }, []);
    var scrollTouchMove = react.useCallback(function (event) {
      shouldCancel(
        event.type,
        getTouchXY(event),
        event.target,
        shouldCancelEvent(event, props.lockRef.current)
      );
    }, []);
    react.useEffect(function () {
      lockStack.push(Style);
      props.setCallbacks({
        onScrollCapture: scrollWheel,
        onWheelCapture: scrollWheel,
        onTouchMoveCapture: scrollTouchMove,
      });
      document.addEventListener('wheel', shouldPrevent, nonPassive);
      document.addEventListener('touchmove', shouldPrevent, nonPassive);
      document.addEventListener('touchstart', scrollTouchStart, nonPassive);
      return function () {
        lockStack = lockStack.filter(function (inst) {
          return inst !== Style;
        });
        document.removeEventListener('wheel', shouldPrevent, nonPassive);
        document.removeEventListener('touchmove', shouldPrevent, nonPassive);
        document.removeEventListener('touchstart', scrollTouchStart, nonPassive);
      };
    }, []);
    var removeScrollBar = props.removeScrollBar,
      inert = props.inert;
    return react.createElement(
      react.Fragment,
      null,
      inert ? react.createElement(Style, { styles: generateStyle(id) }) : null,
      removeScrollBar
        ? react.createElement(RemoveScrollBar, {
            noRelative: props.noRelative,
            gapMode: props.gapMode,
          })
        : null
    );
  }
  function getOutermostShadowParent(node) {
    var shadowParent = null;
    while (node !== null) {
      if (node instanceof ShadowRoot) {
        shadowParent = node.host;
        node = node.host;
      }
      node = node.parentNode;
    }
    return shadowParent;
  } // ./node_modules/.pnpm/react-remove-scroll@2.7.1_@types+react@19.1.12_react@19.1.1/node_modules/react-remove-scroll/dist/es2015/sidecar.js

  /* harmony default export */ const sidecar = exportSidecar(effectCar, RemoveScrollSideCar); // ./node_modules/.pnpm/react-remove-scroll@2.7.1_@types+react@19.1.12_react@19.1.1/node_modules/react-remove-scroll/dist/es2015/Combination.js

  var ReactRemoveScroll = react.forwardRef(function (props, ref) {
    return react.createElement(RemoveScroll, __assign({}, props, { ref: ref, sideCar: sidecar }));
  });
  ReactRemoveScroll.classNames = RemoveScroll.classNames;
  /* harmony default export */ const Combination = ReactRemoveScroll; // ./node_modules/.pnpm/@radix-ui+react-select@2.2.6_@types+react-dom@19.1.9_@types+react@19.1.12__@types+react@19.1._w5265cnngflinvsnzlwz2dyhyy/node_modules/@radix-ui/react-select/dist/index.mjs

  ('use client');

  // src/select.tsx

  var OPEN_KEYS = [' ', 'Enter', 'ArrowUp', 'ArrowDown'];
  var SELECTION_KEYS = [' ', 'Enter'];
  var SELECT_NAME = 'Select';
  var [Collection, useCollection, createCollectionScope] = createCollection(SELECT_NAME);
  var [createSelectContext, createSelectScope] = createContextScope(SELECT_NAME, [
    createCollectionScope,
    createPopperScope,
  ]);
  var usePopperScope = createPopperScope();
  var [SelectProvider, useSelectContext] = createSelectContext(SELECT_NAME);
  var [SelectNativeOptionsProvider, useSelectNativeOptionsContext] =
    createSelectContext(SELECT_NAME);
  var Select = (props) => {
    const {
      __scopeSelect,
      children,
      open: openProp,
      defaultOpen,
      onOpenChange,
      value: valueProp,
      defaultValue,
      onValueChange,
      dir,
      name,
      autoComplete,
      disabled,
      required,
      form,
    } = props;
    const popperScope = usePopperScope(__scopeSelect);
    const [trigger, setTrigger] = react.useState(null);
    const [valueNode, setValueNode] = react.useState(null);
    const [valueNodeHasChildren, setValueNodeHasChildren] = react.useState(false);
    const direction = useDirection(dir);
    const [open, setOpen] = useControllableState({
      prop: openProp,
      defaultProp: defaultOpen ?? false,
      onChange: onOpenChange,
      caller: SELECT_NAME,
    });
    const [value, setValue] = useControllableState({
      prop: valueProp,
      defaultProp: defaultValue,
      onChange: onValueChange,
      caller: SELECT_NAME,
    });
    const triggerPointerDownPosRef = react.useRef(null);
    const isFormControl = trigger ? form || !!trigger.closest('form') : true;
    const [nativeOptionsSet, setNativeOptionsSet] = react.useState(/* @__PURE__ */ new Set());
    const nativeSelectKey = Array.from(nativeOptionsSet)
      .map((option) => option.props.value)
      .join(';');
    return /* @__PURE__ */ (0, jsx_runtime.jsx)(Root2, {
      ...popperScope,
      children: /* @__PURE__ */ (0, jsx_runtime.jsxs)(SelectProvider, {
        required,
        scope: __scopeSelect,
        trigger,
        onTriggerChange: setTrigger,
        valueNode,
        onValueNodeChange: setValueNode,
        valueNodeHasChildren,
        onValueNodeHasChildrenChange: setValueNodeHasChildren,
        contentId: useId(),
        value,
        onValueChange: setValue,
        open,
        onOpenChange: setOpen,
        dir: direction,
        triggerPointerDownPosRef,
        disabled,
        children: [
          /* @__PURE__ */ (0, jsx_runtime.jsx)(Collection.Provider, {
            scope: __scopeSelect,
            children: /* @__PURE__ */ (0, jsx_runtime.jsx)(SelectNativeOptionsProvider, {
              scope: props.__scopeSelect,
              onNativeOptionAdd: react.useCallback((option) => {
                setNativeOptionsSet((prev) => new Set(prev).add(option));
              }, []),
              onNativeOptionRemove: react.useCallback((option) => {
                setNativeOptionsSet((prev) => {
                  const optionsSet = new Set(prev);
                  optionsSet.delete(option);
                  return optionsSet;
                });
              }, []),
              children,
            }),
          }),
          isFormControl
            ? /* @__PURE__ */ (0, jsx_runtime.jsxs)(
                SelectBubbleInput,
                {
                  'aria-hidden': true,
                  required,
                  tabIndex: -1,
                  name,
                  autoComplete,
                  value,
                  onChange: (event) => setValue(event.target.value),
                  disabled,
                  form,
                  children: [
                    value === void 0
                      ? /* @__PURE__ */ (0, jsx_runtime.jsx)('option', { value: '' })
                      : null,
                    Array.from(nativeOptionsSet),
                  ],
                },
                nativeSelectKey
              )
            : null,
        ],
      }),
    });
  };
  Select.displayName = SELECT_NAME;
  var TRIGGER_NAME = 'SelectTrigger';
  var SelectTrigger = react.forwardRef((props, forwardedRef) => {
    const { __scopeSelect, disabled = false, ...triggerProps } = props;
    const popperScope = usePopperScope(__scopeSelect);
    const context = useSelectContext(TRIGGER_NAME, __scopeSelect);
    const isDisabled = context.disabled || disabled;
    const composedRefs = useComposedRefs(forwardedRef, context.onTriggerChange);
    const getItems = useCollection(__scopeSelect);
    const pointerTypeRef = react.useRef('touch');
    const [searchRef, handleTypeaheadSearch, resetTypeahead] = useTypeaheadSearch((search) => {
      const enabledItems = getItems().filter((item) => !item.disabled);
      const currentItem = enabledItems.find((item) => item.value === context.value);
      const nextItem = findNextItem(enabledItems, search, currentItem);
      if (nextItem !== void 0) {
        context.onValueChange(nextItem.value);
      }
    });
    const handleOpen = (pointerEvent) => {
      if (!isDisabled) {
        context.onOpenChange(true);
        resetTypeahead();
      }
      if (pointerEvent) {
        context.triggerPointerDownPosRef.current = {
          x: Math.round(pointerEvent.pageX),
          y: Math.round(pointerEvent.pageY),
        };
      }
    };
    return /* @__PURE__ */ (0, jsx_runtime.jsx)(Anchor, {
      asChild: true,
      ...popperScope,
      children: /* @__PURE__ */ (0, jsx_runtime.jsx)(Primitive.button, {
        type: 'button',
        role: 'combobox',
        'aria-controls': context.contentId,
        'aria-expanded': context.open,
        'aria-required': context.required,
        'aria-autocomplete': 'none',
        dir: context.dir,
        'data-state': context.open ? 'open' : 'closed',
        disabled: isDisabled,
        'data-disabled': isDisabled ? '' : void 0,
        'data-placeholder': shouldShowPlaceholder(context.value) ? '' : void 0,
        ...triggerProps,
        ref: composedRefs,
        onClick: composeEventHandlers(triggerProps.onClick, (event) => {
          event.currentTarget.focus();
          if (pointerTypeRef.current !== 'mouse') {
            handleOpen(event);
          }
        }),
        onPointerDown: composeEventHandlers(triggerProps.onPointerDown, (event) => {
          pointerTypeRef.current = event.pointerType;
          const target = event.target;
          if (target.hasPointerCapture(event.pointerId)) {
            target.releasePointerCapture(event.pointerId);
          }
          if (event.button === 0 && event.ctrlKey === false && event.pointerType === 'mouse') {
            handleOpen(event);
            event.preventDefault();
          }
        }),
        onKeyDown: composeEventHandlers(triggerProps.onKeyDown, (event) => {
          const isTypingAhead = searchRef.current !== '';
          const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
          if (!isModifierKey && event.key.length === 1) handleTypeaheadSearch(event.key);
          if (isTypingAhead && event.key === ' ') return;
          if (OPEN_KEYS.includes(event.key)) {
            handleOpen();
            event.preventDefault();
          }
        }),
      }),
    });
  });
  SelectTrigger.displayName = TRIGGER_NAME;
  var VALUE_NAME = 'SelectValue';
  var SelectValue = react.forwardRef((props, forwardedRef) => {
    const { __scopeSelect, className, style, children, placeholder = '', ...valueProps } = props;
    const context = useSelectContext(VALUE_NAME, __scopeSelect);
    const { onValueNodeHasChildrenChange } = context;
    const hasChildren = children !== void 0;
    const composedRefs = useComposedRefs(forwardedRef, context.onValueNodeChange);
    useLayoutEffect2(() => {
      onValueNodeHasChildrenChange(hasChildren);
    }, [onValueNodeHasChildrenChange, hasChildren]);
    return /* @__PURE__ */ (0, jsx_runtime.jsx)(Primitive.span, {
      ...valueProps,
      ref: composedRefs,
      style: { pointerEvents: 'none' },
      children: shouldShowPlaceholder(context.value)
        ? /* @__PURE__ */ (0, jsx_runtime.jsx)(jsx_runtime.Fragment, { children: placeholder })
        : children,
    });
  });
  SelectValue.displayName = VALUE_NAME;
  var ICON_NAME = 'SelectIcon';
  var SelectIcon = react.forwardRef((props, forwardedRef) => {
    const { __scopeSelect, children, ...iconProps } = props;
    return /* @__PURE__ */ (0, jsx_runtime.jsx)(Primitive.span, {
      'aria-hidden': true,
      ...iconProps,
      ref: forwardedRef,
      children: children || '\u25BC',
    });
  });
  SelectIcon.displayName = ICON_NAME;
  var dist_PORTAL_NAME = 'SelectPortal';
  var SelectPortal = (props) => {
    return /* @__PURE__ */ (0, jsx_runtime.jsx)(Portal, { asChild: true, ...props });
  };
  SelectPortal.displayName = dist_PORTAL_NAME;
  var dist_CONTENT_NAME = 'SelectContent';
  var SelectContent = react.forwardRef((props, forwardedRef) => {
    const context = useSelectContext(dist_CONTENT_NAME, props.__scopeSelect);
    const [fragment, setFragment] = react.useState();
    useLayoutEffect2(() => {
      setFragment(new DocumentFragment());
    }, []);
    if (!context.open) {
      const frag = fragment;
      return frag
        ? react_dom.createPortal(
            /* @__PURE__ */ (0, jsx_runtime.jsx)(SelectContentProvider, {
              scope: props.__scopeSelect,
              children: /* @__PURE__ */ (0, jsx_runtime.jsx)(Collection.Slot, {
                scope: props.__scopeSelect,
                children: /* @__PURE__ */ (0, jsx_runtime.jsx)('div', { children: props.children }),
              }),
            }),
            frag
          )
        : null;
    }
    return /* @__PURE__ */ (0, jsx_runtime.jsx)(SelectContentImpl, { ...props, ref: forwardedRef });
  });
  SelectContent.displayName = dist_CONTENT_NAME;
  var CONTENT_MARGIN = 10;
  var [SelectContentProvider, useSelectContentContext] = createSelectContext(dist_CONTENT_NAME);
  var CONTENT_IMPL_NAME = 'SelectContentImpl';
  var dist_Slot = createSlot('SelectContent.RemoveScroll');
  var SelectContentImpl = react.forwardRef((props, forwardedRef) => {
    const {
      __scopeSelect,
      position = 'item-aligned',
      onCloseAutoFocus,
      onEscapeKeyDown,
      onPointerDownOutside,
      //
      // PopperContent props
      side,
      sideOffset,
      align,
      alignOffset,
      arrowPadding,
      collisionBoundary,
      collisionPadding,
      sticky,
      hideWhenDetached,
      avoidCollisions,
      //
      ...contentProps
    } = props;
    const context = useSelectContext(dist_CONTENT_NAME, __scopeSelect);
    const [content, setContent] = react.useState(null);
    const [viewport, setViewport] = react.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));
    const [selectedItem, setSelectedItem] = react.useState(null);
    const [selectedItemText, setSelectedItemText] = react.useState(null);
    const getItems = useCollection(__scopeSelect);
    const [isPositioned, setIsPositioned] = react.useState(false);
    const firstValidItemFoundRef = react.useRef(false);
    react.useEffect(() => {
      if (content) return hideOthers(content);
    }, [content]);
    useFocusGuards();
    const focusFirst = react.useCallback(
      (candidates) => {
        const [firstItem, ...restItems] = getItems().map((item) => item.ref.current);
        const [lastItem] = restItems.slice(-1);
        const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
        for (const candidate of candidates) {
          if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;
          candidate?.scrollIntoView({ block: 'nearest' });
          if (candidate === firstItem && viewport) viewport.scrollTop = 0;
          if (candidate === lastItem && viewport) viewport.scrollTop = viewport.scrollHeight;
          candidate?.focus();
          if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;
        }
      },
      [getItems, viewport]
    );
    const focusSelectedItem = react.useCallback(
      () => focusFirst([selectedItem, content]),
      [focusFirst, selectedItem, content]
    );
    react.useEffect(() => {
      if (isPositioned) {
        focusSelectedItem();
      }
    }, [isPositioned, focusSelectedItem]);
    const { onOpenChange, triggerPointerDownPosRef } = context;
    react.useEffect(() => {
      if (content) {
        let pointerMoveDelta = { x: 0, y: 0 };
        const handlePointerMove = (event) => {
          pointerMoveDelta = {
            x: Math.abs(Math.round(event.pageX) - (triggerPointerDownPosRef.current?.x ?? 0)),
            y: Math.abs(Math.round(event.pageY) - (triggerPointerDownPosRef.current?.y ?? 0)),
          };
        };
        const handlePointerUp = (event) => {
          if (pointerMoveDelta.x <= 10 && pointerMoveDelta.y <= 10) {
            event.preventDefault();
          } else {
            if (!content.contains(event.target)) {
              onOpenChange(false);
            }
          }
          document.removeEventListener('pointermove', handlePointerMove);
          triggerPointerDownPosRef.current = null;
        };
        if (triggerPointerDownPosRef.current !== null) {
          document.addEventListener('pointermove', handlePointerMove);
          document.addEventListener('pointerup', handlePointerUp, { capture: true, once: true });
        }
        return () => {
          document.removeEventListener('pointermove', handlePointerMove);
          document.removeEventListener('pointerup', handlePointerUp, { capture: true });
        };
      }
    }, [content, onOpenChange, triggerPointerDownPosRef]);
    react.useEffect(() => {
      const close = () => onOpenChange(false);
      window.addEventListener('blur', close);
      window.addEventListener('resize', close);
      return () => {
        window.removeEventListener('blur', close);
        window.removeEventListener('resize', close);
      };
    }, [onOpenChange]);
    const [searchRef, handleTypeaheadSearch] = useTypeaheadSearch((search) => {
      const enabledItems = getItems().filter((item) => !item.disabled);
      const currentItem = enabledItems.find((item) => item.ref.current === document.activeElement);
      const nextItem = findNextItem(enabledItems, search, currentItem);
      if (nextItem) {
        setTimeout(() => nextItem.ref.current.focus());
      }
    });
    const itemRefCallback = react.useCallback(
      (node, value, disabled) => {
        const isFirstValidItem = !firstValidItemFoundRef.current && !disabled;
        const isSelectedItem = context.value !== void 0 && context.value === value;
        if (isSelectedItem || isFirstValidItem) {
          setSelectedItem(node);
          if (isFirstValidItem) firstValidItemFoundRef.current = true;
        }
      },
      [context.value]
    );
    const handleItemLeave = react.useCallback(() => content?.focus(), [content]);
    const itemTextRefCallback = react.useCallback(
      (node, value, disabled) => {
        const isFirstValidItem = !firstValidItemFoundRef.current && !disabled;
        const isSelectedItem = context.value !== void 0 && context.value === value;
        if (isSelectedItem || isFirstValidItem) {
          setSelectedItemText(node);
        }
      },
      [context.value]
    );
    const SelectPosition = position === 'popper' ? SelectPopperPosition : SelectItemAlignedPosition;
    const popperContentProps =
      SelectPosition === SelectPopperPosition
        ? {
            side,
            sideOffset,
            align,
            alignOffset,
            arrowPadding,
            collisionBoundary,
            collisionPadding,
            sticky,
            hideWhenDetached,
            avoidCollisions,
          }
        : {};
    return /* @__PURE__ */ (0, jsx_runtime.jsx)(SelectContentProvider, {
      scope: __scopeSelect,
      content,
      viewport,
      onViewportChange: setViewport,
      itemRefCallback,
      selectedItem,
      onItemLeave: handleItemLeave,
      itemTextRefCallback,
      focusSelectedItem,
      selectedItemText,
      position,
      isPositioned,
      searchRef,
      children: /* @__PURE__ */ (0, jsx_runtime.jsx)(Combination, {
        as: dist_Slot,
        allowPinchZoom: true,
        children: /* @__PURE__ */ (0, jsx_runtime.jsx)(FocusScope, {
          asChild: true,
          trapped: context.open,
          onMountAutoFocus: (event) => {
            event.preventDefault();
          },
          onUnmountAutoFocus: composeEventHandlers(onCloseAutoFocus, (event) => {
            context.trigger?.focus({ preventScroll: true });
            event.preventDefault();
          }),
          children: /* @__PURE__ */ (0, jsx_runtime.jsx)(DismissableLayer, {
            asChild: true,
            disableOutsidePointerEvents: true,
            onEscapeKeyDown,
            onPointerDownOutside,
            onFocusOutside: (event) => event.preventDefault(),
            onDismiss: () => context.onOpenChange(false),
            children: /* @__PURE__ */ (0, jsx_runtime.jsx)(SelectPosition, {
              role: 'listbox',
              id: context.contentId,
              'data-state': context.open ? 'open' : 'closed',
              dir: context.dir,
              onContextMenu: (event) => event.preventDefault(),
              ...contentProps,
              ...popperContentProps,
              onPlaced: () => setIsPositioned(true),
              ref: composedRefs,
              style: {
                // flex layout so we can place the scroll buttons properly
                display: 'flex',
                flexDirection: 'column',
                // reset the outline by default as the content MAY get focused
                outline: 'none',
                ...contentProps.style,
              },
              onKeyDown: composeEventHandlers(contentProps.onKeyDown, (event) => {
                const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
                if (event.key === 'Tab') event.preventDefault();
                if (!isModifierKey && event.key.length === 1) handleTypeaheadSearch(event.key);
                if (['ArrowUp', 'ArrowDown', 'Home', 'End'].includes(event.key)) {
                  const items = getItems().filter((item) => !item.disabled);
                  let candidateNodes = items.map((item) => item.ref.current);
                  if (['ArrowUp', 'End'].includes(event.key)) {
                    candidateNodes = candidateNodes.slice().reverse();
                  }
                  if (['ArrowUp', 'ArrowDown'].includes(event.key)) {
                    const currentElement = event.target;
                    const currentIndex = candidateNodes.indexOf(currentElement);
                    candidateNodes = candidateNodes.slice(currentIndex + 1);
                  }
                  setTimeout(() => focusFirst(candidateNodes));
                  event.preventDefault();
                }
              }),
            }),
          }),
        }),
      }),
    });
  });
  SelectContentImpl.displayName = CONTENT_IMPL_NAME;
  var ITEM_ALIGNED_POSITION_NAME = 'SelectItemAlignedPosition';
  var SelectItemAlignedPosition = react.forwardRef((props, forwardedRef) => {
    const { __scopeSelect, onPlaced, ...popperProps } = props;
    const context = useSelectContext(dist_CONTENT_NAME, __scopeSelect);
    const contentContext = useSelectContentContext(dist_CONTENT_NAME, __scopeSelect);
    const [contentWrapper, setContentWrapper] = react.useState(null);
    const [content, setContent] = react.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));
    const getItems = useCollection(__scopeSelect);
    const shouldExpandOnScrollRef = react.useRef(false);
    const shouldRepositionRef = react.useRef(true);
    const { viewport, selectedItem, selectedItemText, focusSelectedItem } = contentContext;
    const position = react.useCallback(() => {
      if (
        context.trigger &&
        context.valueNode &&
        contentWrapper &&
        content &&
        viewport &&
        selectedItem &&
        selectedItemText
      ) {
        const triggerRect = context.trigger.getBoundingClientRect();
        const contentRect = content.getBoundingClientRect();
        const valueNodeRect = context.valueNode.getBoundingClientRect();
        const itemTextRect = selectedItemText.getBoundingClientRect();
        if (context.dir !== 'rtl') {
          const itemTextOffset = itemTextRect.left - contentRect.left;
          const left = valueNodeRect.left - itemTextOffset;
          const leftDelta = triggerRect.left - left;
          const minContentWidth = triggerRect.width + leftDelta;
          const contentWidth = Math.max(minContentWidth, contentRect.width);
          const rightEdge = window.innerWidth - CONTENT_MARGIN;
          const clampedLeft = dist_clamp(left, [
            CONTENT_MARGIN,
            // Prevents the content from going off the starting edge of the
            // viewport. It may still go off the ending edge, but this can be
            // controlled by the user since they may want to manage overflow in a
            // specific way.
            // https://github.com/radix-ui/primitives/issues/2049
            Math.max(CONTENT_MARGIN, rightEdge - contentWidth),
          ]);
          contentWrapper.style.minWidth = minContentWidth + 'px';
          contentWrapper.style.left = clampedLeft + 'px';
        } else {
          const itemTextOffset = contentRect.right - itemTextRect.right;
          const right = window.innerWidth - valueNodeRect.right - itemTextOffset;
          const rightDelta = window.innerWidth - triggerRect.right - right;
          const minContentWidth = triggerRect.width + rightDelta;
          const contentWidth = Math.max(minContentWidth, contentRect.width);
          const leftEdge = window.innerWidth - CONTENT_MARGIN;
          const clampedRight = dist_clamp(right, [
            CONTENT_MARGIN,
            Math.max(CONTENT_MARGIN, leftEdge - contentWidth),
          ]);
          contentWrapper.style.minWidth = minContentWidth + 'px';
          contentWrapper.style.right = clampedRight + 'px';
        }
        const items = getItems();
        const availableHeight = window.innerHeight - CONTENT_MARGIN * 2;
        const itemsHeight = viewport.scrollHeight;
        const contentStyles = window.getComputedStyle(content);
        const contentBorderTopWidth = parseInt(contentStyles.borderTopWidth, 10);
        const contentPaddingTop = parseInt(contentStyles.paddingTop, 10);
        const contentBorderBottomWidth = parseInt(contentStyles.borderBottomWidth, 10);
        const contentPaddingBottom = parseInt(contentStyles.paddingBottom, 10);
        const fullContentHeight =
          contentBorderTopWidth +
          contentPaddingTop +
          itemsHeight +
          contentPaddingBottom +
          contentBorderBottomWidth;
        const minContentHeight = Math.min(selectedItem.offsetHeight * 5, fullContentHeight);
        const viewportStyles = window.getComputedStyle(viewport);
        const viewportPaddingTop = parseInt(viewportStyles.paddingTop, 10);
        const viewportPaddingBottom = parseInt(viewportStyles.paddingBottom, 10);
        const topEdgeToTriggerMiddle = triggerRect.top + triggerRect.height / 2 - CONTENT_MARGIN;
        const triggerMiddleToBottomEdge = availableHeight - topEdgeToTriggerMiddle;
        const selectedItemHalfHeight = selectedItem.offsetHeight / 2;
        const itemOffsetMiddle = selectedItem.offsetTop + selectedItemHalfHeight;
        const contentTopToItemMiddle = contentBorderTopWidth + contentPaddingTop + itemOffsetMiddle;
        const itemMiddleToContentBottom = fullContentHeight - contentTopToItemMiddle;
        const willAlignWithoutTopOverflow = contentTopToItemMiddle <= topEdgeToTriggerMiddle;
        if (willAlignWithoutTopOverflow) {
          const isLastItem =
            items.length > 0 && selectedItem === items[items.length - 1].ref.current;
          contentWrapper.style.bottom = '0px';
          const viewportOffsetBottom =
            content.clientHeight - viewport.offsetTop - viewport.offsetHeight;
          const clampedTriggerMiddleToBottomEdge = Math.max(
            triggerMiddleToBottomEdge,
            selectedItemHalfHeight + // viewport might have padding bottom, include it to avoid a scrollable viewport
              (isLastItem ? viewportPaddingBottom : 0) +
              viewportOffsetBottom +
              contentBorderBottomWidth
          );
          const height = contentTopToItemMiddle + clampedTriggerMiddleToBottomEdge;
          contentWrapper.style.height = height + 'px';
        } else {
          const isFirstItem = items.length > 0 && selectedItem === items[0].ref.current;
          contentWrapper.style.top = '0px';
          const clampedTopEdgeToTriggerMiddle = Math.max(
            topEdgeToTriggerMiddle,
            contentBorderTopWidth +
              viewport.offsetTop + // viewport might have padding top, include it to avoid a scrollable viewport
              (isFirstItem ? viewportPaddingTop : 0) +
              selectedItemHalfHeight
          );
          const height = clampedTopEdgeToTriggerMiddle + itemMiddleToContentBottom;
          contentWrapper.style.height = height + 'px';
          viewport.scrollTop = contentTopToItemMiddle - topEdgeToTriggerMiddle + viewport.offsetTop;
        }
        contentWrapper.style.margin = `${CONTENT_MARGIN}px 0`;
        contentWrapper.style.minHeight = minContentHeight + 'px';
        contentWrapper.style.maxHeight = availableHeight + 'px';
        onPlaced?.();
        requestAnimationFrame(() => (shouldExpandOnScrollRef.current = true));
      }
    }, [
      getItems,
      context.trigger,
      context.valueNode,
      contentWrapper,
      content,
      viewport,
      selectedItem,
      selectedItemText,
      context.dir,
      onPlaced,
    ]);
    useLayoutEffect2(() => position(), [position]);
    const [contentZIndex, setContentZIndex] = react.useState();
    useLayoutEffect2(() => {
      if (content) setContentZIndex(window.getComputedStyle(content).zIndex);
    }, [content]);
    const handleScrollButtonChange = react.useCallback(
      (node) => {
        if (node && shouldRepositionRef.current === true) {
          position();
          focusSelectedItem?.();
          shouldRepositionRef.current = false;
        }
      },
      [position, focusSelectedItem]
    );
    return /* @__PURE__ */ (0, jsx_runtime.jsx)(SelectViewportProvider, {
      scope: __scopeSelect,
      contentWrapper,
      shouldExpandOnScrollRef,
      onScrollButtonChange: handleScrollButtonChange,
      children: /* @__PURE__ */ (0, jsx_runtime.jsx)('div', {
        ref: setContentWrapper,
        style: {
          display: 'flex',
          flexDirection: 'column',
          position: 'fixed',
          zIndex: contentZIndex,
        },
        children: /* @__PURE__ */ (0, jsx_runtime.jsx)(Primitive.div, {
          ...popperProps,
          ref: composedRefs,
          style: {
            // When we get the height of the content, it includes borders. If we were to set
            // the height without having `boxSizing: 'border-box'` it would be too big.
            boxSizing: 'border-box',
            // We need to ensure the content doesn't get taller than the wrapper
            maxHeight: '100%',
            ...popperProps.style,
          },
        }),
      }),
    });
  });
  SelectItemAlignedPosition.displayName = ITEM_ALIGNED_POSITION_NAME;
  var POPPER_POSITION_NAME = 'SelectPopperPosition';
  var SelectPopperPosition = react.forwardRef((props, forwardedRef) => {
    const {
      __scopeSelect,
      align = 'start',
      collisionPadding = CONTENT_MARGIN,
      ...popperProps
    } = props;
    const popperScope = usePopperScope(__scopeSelect);
    return /* @__PURE__ */ (0, jsx_runtime.jsx)(Content, {
      ...popperScope,
      ...popperProps,
      ref: forwardedRef,
      align,
      collisionPadding,
      style: {
        // Ensure border-box for floating-ui calculations
        boxSizing: 'border-box',
        ...popperProps.style,
        // re-namespace exposed content custom properties
        ...{
          '--radix-select-content-transform-origin': 'var(--radix-popper-transform-origin)',
          '--radix-select-content-available-width': 'var(--radix-popper-available-width)',
          '--radix-select-content-available-height': 'var(--radix-popper-available-height)',
          '--radix-select-trigger-width': 'var(--radix-popper-anchor-width)',
          '--radix-select-trigger-height': 'var(--radix-popper-anchor-height)',
        },
      },
    });
  });
  SelectPopperPosition.displayName = POPPER_POSITION_NAME;
  var [SelectViewportProvider, useSelectViewportContext] = createSelectContext(
    dist_CONTENT_NAME,
    {}
  );
  var VIEWPORT_NAME = 'SelectViewport';
  var SelectViewport = react.forwardRef((props, forwardedRef) => {
    const { __scopeSelect, nonce, ...viewportProps } = props;
    const contentContext = useSelectContentContext(VIEWPORT_NAME, __scopeSelect);
    const viewportContext = useSelectViewportContext(VIEWPORT_NAME, __scopeSelect);
    const composedRefs = useComposedRefs(forwardedRef, contentContext.onViewportChange);
    const prevScrollTopRef = react.useRef(0);
    return /* @__PURE__ */ (0, jsx_runtime.jsxs)(jsx_runtime.Fragment, {
      children: [
        /* @__PURE__ */ (0, jsx_runtime.jsx)('style', {
          dangerouslySetInnerHTML: {
            __html: `[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}`,
          },
          nonce,
        }),
        /* @__PURE__ */ (0, jsx_runtime.jsx)(Collection.Slot, {
          scope: __scopeSelect,
          children: /* @__PURE__ */ (0, jsx_runtime.jsx)(Primitive.div, {
            'data-radix-select-viewport': '',
            role: 'presentation',
            ...viewportProps,
            ref: composedRefs,
            style: {
              // we use position: 'relative' here on the `viewport` so that when we call
              // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
              // (independent of the scrollUpButton).
              position: 'relative',
              flex: 1,
              // Viewport should only be scrollable in the vertical direction.
              // This won't work in vertical writing modes, so we'll need to
              // revisit this if/when that is supported
              // https://developer.chrome.com/blog/vertical-form-controls
              overflow: 'hidden auto',
              ...viewportProps.style,
            },
            onScroll: composeEventHandlers(viewportProps.onScroll, (event) => {
              const viewport = event.currentTarget;
              const { contentWrapper, shouldExpandOnScrollRef } = viewportContext;
              if (shouldExpandOnScrollRef?.current && contentWrapper) {
                const scrolledBy = Math.abs(prevScrollTopRef.current - viewport.scrollTop);
                if (scrolledBy > 0) {
                  const availableHeight = window.innerHeight - CONTENT_MARGIN * 2;
                  const cssMinHeight = parseFloat(contentWrapper.style.minHeight);
                  const cssHeight = parseFloat(contentWrapper.style.height);
                  const prevHeight = Math.max(cssMinHeight, cssHeight);
                  if (prevHeight < availableHeight) {
                    const nextHeight = prevHeight + scrolledBy;
                    const clampedNextHeight = Math.min(availableHeight, nextHeight);
                    const heightDiff = nextHeight - clampedNextHeight;
                    contentWrapper.style.height = clampedNextHeight + 'px';
                    if (contentWrapper.style.bottom === '0px') {
                      viewport.scrollTop = heightDiff > 0 ? heightDiff : 0;
                      contentWrapper.style.justifyContent = 'flex-end';
                    }
                  }
                }
              }
              prevScrollTopRef.current = viewport.scrollTop;
            }),
          }),
        }),
      ],
    });
  });
  SelectViewport.displayName = VIEWPORT_NAME;
  var GROUP_NAME = 'SelectGroup';
  var [SelectGroupContextProvider, useSelectGroupContext] = createSelectContext(GROUP_NAME);
  var SelectGroup = react.forwardRef((props, forwardedRef) => {
    const { __scopeSelect, ...groupProps } = props;
    const groupId = useId();
    return /* @__PURE__ */ (0, jsx_runtime.jsx)(SelectGroupContextProvider, {
      scope: __scopeSelect,
      id: groupId,
      children: /* @__PURE__ */ (0, jsx_runtime.jsx)(Primitive.div, {
        role: 'group',
        'aria-labelledby': groupId,
        ...groupProps,
        ref: forwardedRef,
      }),
    });
  });
  SelectGroup.displayName = GROUP_NAME;
  var LABEL_NAME = 'SelectLabel';
  var SelectLabel = react.forwardRef((props, forwardedRef) => {
    const { __scopeSelect, ...labelProps } = props;
    const groupContext = useSelectGroupContext(LABEL_NAME, __scopeSelect);
    return /* @__PURE__ */ (0, jsx_runtime.jsx)(Primitive.div, {
      id: groupContext.id,
      ...labelProps,
      ref: forwardedRef,
    });
  });
  SelectLabel.displayName = LABEL_NAME;
  var ITEM_NAME = 'SelectItem';
  var [SelectItemContextProvider, useSelectItemContext] = createSelectContext(ITEM_NAME);
  var SelectItem = react.forwardRef((props, forwardedRef) => {
    const {
      __scopeSelect,
      value,
      disabled = false,
      textValue: textValueProp,
      ...itemProps
    } = props;
    const context = useSelectContext(ITEM_NAME, __scopeSelect);
    const contentContext = useSelectContentContext(ITEM_NAME, __scopeSelect);
    const isSelected = context.value === value;
    const [textValue, setTextValue] = react.useState(textValueProp ?? '');
    const [isFocused, setIsFocused] = react.useState(false);
    const composedRefs = useComposedRefs(forwardedRef, (node) =>
      contentContext.itemRefCallback?.(node, value, disabled)
    );
    const textId = useId();
    const pointerTypeRef = react.useRef('touch');
    const handleSelect = () => {
      if (!disabled) {
        context.onValueChange(value);
        context.onOpenChange(false);
      }
    };
    if (value === '') {
      throw new Error(
        'A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder.'
      );
    }
    return /* @__PURE__ */ (0, jsx_runtime.jsx)(SelectItemContextProvider, {
      scope: __scopeSelect,
      value,
      disabled,
      textId,
      isSelected,
      onItemTextChange: react.useCallback((node) => {
        setTextValue((prevTextValue) => prevTextValue || (node?.textContent ?? '').trim());
      }, []),
      children: /* @__PURE__ */ (0, jsx_runtime.jsx)(Collection.ItemSlot, {
        scope: __scopeSelect,
        value,
        disabled,
        textValue,
        children: /* @__PURE__ */ (0, jsx_runtime.jsx)(Primitive.div, {
          role: 'option',
          'aria-labelledby': textId,
          'data-highlighted': isFocused ? '' : void 0,
          'aria-selected': isSelected && isFocused,
          'data-state': isSelected ? 'checked' : 'unchecked',
          'aria-disabled': disabled || void 0,
          'data-disabled': disabled ? '' : void 0,
          tabIndex: disabled ? void 0 : -1,
          ...itemProps,
          ref: composedRefs,
          onFocus: composeEventHandlers(itemProps.onFocus, () => setIsFocused(true)),
          onBlur: composeEventHandlers(itemProps.onBlur, () => setIsFocused(false)),
          onClick: composeEventHandlers(itemProps.onClick, () => {
            if (pointerTypeRef.current !== 'mouse') handleSelect();
          }),
          onPointerUp: composeEventHandlers(itemProps.onPointerUp, () => {
            if (pointerTypeRef.current === 'mouse') handleSelect();
          }),
          onPointerDown: composeEventHandlers(itemProps.onPointerDown, (event) => {
            pointerTypeRef.current = event.pointerType;
          }),
          onPointerMove: composeEventHandlers(itemProps.onPointerMove, (event) => {
            pointerTypeRef.current = event.pointerType;
            if (disabled) {
              contentContext.onItemLeave?.();
            } else if (pointerTypeRef.current === 'mouse') {
              event.currentTarget.focus({ preventScroll: true });
            }
          }),
          onPointerLeave: composeEventHandlers(itemProps.onPointerLeave, (event) => {
            if (event.currentTarget === document.activeElement) {
              contentContext.onItemLeave?.();
            }
          }),
          onKeyDown: composeEventHandlers(itemProps.onKeyDown, (event) => {
            const isTypingAhead = contentContext.searchRef?.current !== '';
            if (isTypingAhead && event.key === ' ') return;
            if (SELECTION_KEYS.includes(event.key)) handleSelect();
            if (event.key === ' ') event.preventDefault();
          }),
        }),
      }),
    });
  });
  SelectItem.displayName = ITEM_NAME;
  var ITEM_TEXT_NAME = 'SelectItemText';
  var SelectItemText = react.forwardRef((props, forwardedRef) => {
    const { __scopeSelect, className, style, ...itemTextProps } = props;
    const context = useSelectContext(ITEM_TEXT_NAME, __scopeSelect);
    const contentContext = useSelectContentContext(ITEM_TEXT_NAME, __scopeSelect);
    const itemContext = useSelectItemContext(ITEM_TEXT_NAME, __scopeSelect);
    const nativeOptionsContext = useSelectNativeOptionsContext(ITEM_TEXT_NAME, __scopeSelect);
    const [itemTextNode, setItemTextNode] = react.useState(null);
    const composedRefs = useComposedRefs(
      forwardedRef,
      (node) => setItemTextNode(node),
      itemContext.onItemTextChange,
      (node) => contentContext.itemTextRefCallback?.(node, itemContext.value, itemContext.disabled)
    );
    const textContent = itemTextNode?.textContent;
    const nativeOption = react.useMemo(
      () =>
        /* @__PURE__ */ (0, jsx_runtime.jsx)(
          'option',
          { value: itemContext.value, disabled: itemContext.disabled, children: textContent },
          itemContext.value
        ),
      [itemContext.disabled, itemContext.value, textContent]
    );
    const { onNativeOptionAdd, onNativeOptionRemove } = nativeOptionsContext;
    useLayoutEffect2(() => {
      onNativeOptionAdd(nativeOption);
      return () => onNativeOptionRemove(nativeOption);
    }, [onNativeOptionAdd, onNativeOptionRemove, nativeOption]);
    return /* @__PURE__ */ (0, jsx_runtime.jsxs)(jsx_runtime.Fragment, {
      children: [
        /* @__PURE__ */ (0, jsx_runtime.jsx)(Primitive.span, {
          id: itemContext.textId,
          ...itemTextProps,
          ref: composedRefs,
        }),
        itemContext.isSelected && context.valueNode && !context.valueNodeHasChildren
          ? react_dom.createPortal(itemTextProps.children, context.valueNode)
          : null,
      ],
    });
  });
  SelectItemText.displayName = ITEM_TEXT_NAME;
  var ITEM_INDICATOR_NAME = 'SelectItemIndicator';
  var SelectItemIndicator = react.forwardRef((props, forwardedRef) => {
    const { __scopeSelect, ...itemIndicatorProps } = props;
    const itemContext = useSelectItemContext(ITEM_INDICATOR_NAME, __scopeSelect);
    return itemContext.isSelected
      ? /* @__PURE__ */ (0, jsx_runtime.jsx)(Primitive.span, {
          'aria-hidden': true,
          ...itemIndicatorProps,
          ref: forwardedRef,
        })
      : null;
  });
  SelectItemIndicator.displayName = ITEM_INDICATOR_NAME;
  var SCROLL_UP_BUTTON_NAME = 'SelectScrollUpButton';
  var SelectScrollUpButton = react.forwardRef((props, forwardedRef) => {
    const contentContext = useSelectContentContext(SCROLL_UP_BUTTON_NAME, props.__scopeSelect);
    const viewportContext = useSelectViewportContext(SCROLL_UP_BUTTON_NAME, props.__scopeSelect);
    const [canScrollUp, setCanScrollUp] = react.useState(false);
    const composedRefs = useComposedRefs(forwardedRef, viewportContext.onScrollButtonChange);
    useLayoutEffect2(() => {
      if (contentContext.viewport && contentContext.isPositioned) {
        let handleScroll2 = function () {
          const canScrollUp2 = viewport.scrollTop > 0;
          setCanScrollUp(canScrollUp2);
        };
        var handleScroll = handleScroll2;
        const viewport = contentContext.viewport;
        handleScroll2();
        viewport.addEventListener('scroll', handleScroll2);
        return () => viewport.removeEventListener('scroll', handleScroll2);
      }
    }, [contentContext.viewport, contentContext.isPositioned]);
    return canScrollUp
      ? /* @__PURE__ */ (0, jsx_runtime.jsx)(SelectScrollButtonImpl, {
          ...props,
          ref: composedRefs,
          onAutoScroll: () => {
            const { viewport, selectedItem } = contentContext;
            if (viewport && selectedItem) {
              viewport.scrollTop = viewport.scrollTop - selectedItem.offsetHeight;
            }
          },
        })
      : null;
  });
  SelectScrollUpButton.displayName = SCROLL_UP_BUTTON_NAME;
  var SCROLL_DOWN_BUTTON_NAME = 'SelectScrollDownButton';
  var SelectScrollDownButton = react.forwardRef((props, forwardedRef) => {
    const contentContext = useSelectContentContext(SCROLL_DOWN_BUTTON_NAME, props.__scopeSelect);
    const viewportContext = useSelectViewportContext(SCROLL_DOWN_BUTTON_NAME, props.__scopeSelect);
    const [canScrollDown, setCanScrollDown] = react.useState(false);
    const composedRefs = useComposedRefs(forwardedRef, viewportContext.onScrollButtonChange);
    useLayoutEffect2(() => {
      if (contentContext.viewport && contentContext.isPositioned) {
        let handleScroll2 = function () {
          const maxScroll = viewport.scrollHeight - viewport.clientHeight;
          const canScrollDown2 = Math.ceil(viewport.scrollTop) < maxScroll;
          setCanScrollDown(canScrollDown2);
        };
        var handleScroll = handleScroll2;
        const viewport = contentContext.viewport;
        handleScroll2();
        viewport.addEventListener('scroll', handleScroll2);
        return () => viewport.removeEventListener('scroll', handleScroll2);
      }
    }, [contentContext.viewport, contentContext.isPositioned]);
    return canScrollDown
      ? /* @__PURE__ */ (0, jsx_runtime.jsx)(SelectScrollButtonImpl, {
          ...props,
          ref: composedRefs,
          onAutoScroll: () => {
            const { viewport, selectedItem } = contentContext;
            if (viewport && selectedItem) {
              viewport.scrollTop = viewport.scrollTop + selectedItem.offsetHeight;
            }
          },
        })
      : null;
  });
  SelectScrollDownButton.displayName = SCROLL_DOWN_BUTTON_NAME;
  var SelectScrollButtonImpl = react.forwardRef((props, forwardedRef) => {
    const { __scopeSelect, onAutoScroll, ...scrollIndicatorProps } = props;
    const contentContext = useSelectContentContext('SelectScrollButton', __scopeSelect);
    const autoScrollTimerRef = react.useRef(null);
    const getItems = useCollection(__scopeSelect);
    const clearAutoScrollTimer = react.useCallback(() => {
      if (autoScrollTimerRef.current !== null) {
        window.clearInterval(autoScrollTimerRef.current);
        autoScrollTimerRef.current = null;
      }
    }, []);
    react.useEffect(() => {
      return () => clearAutoScrollTimer();
    }, [clearAutoScrollTimer]);
    useLayoutEffect2(() => {
      const activeItem = getItems().find((item) => item.ref.current === document.activeElement);
      activeItem?.ref.current?.scrollIntoView({ block: 'nearest' });
    }, [getItems]);
    return /* @__PURE__ */ (0, jsx_runtime.jsx)(Primitive.div, {
      'aria-hidden': true,
      ...scrollIndicatorProps,
      ref: forwardedRef,
      style: { flexShrink: 0, ...scrollIndicatorProps.style },
      onPointerDown: composeEventHandlers(scrollIndicatorProps.onPointerDown, () => {
        if (autoScrollTimerRef.current === null) {
          autoScrollTimerRef.current = window.setInterval(onAutoScroll, 50);
        }
      }),
      onPointerMove: composeEventHandlers(scrollIndicatorProps.onPointerMove, () => {
        contentContext.onItemLeave?.();
        if (autoScrollTimerRef.current === null) {
          autoScrollTimerRef.current = window.setInterval(onAutoScroll, 50);
        }
      }),
      onPointerLeave: composeEventHandlers(scrollIndicatorProps.onPointerLeave, () => {
        clearAutoScrollTimer();
      }),
    });
  });
  var SEPARATOR_NAME = 'SelectSeparator';
  var SelectSeparator = react.forwardRef((props, forwardedRef) => {
    const { __scopeSelect, ...separatorProps } = props;
    return /* @__PURE__ */ (0, jsx_runtime.jsx)(Primitive.div, {
      'aria-hidden': true,
      ...separatorProps,
      ref: forwardedRef,
    });
  });
  SelectSeparator.displayName = SEPARATOR_NAME;
  var dist_ARROW_NAME = 'SelectArrow';
  var SelectArrow = react.forwardRef((props, forwardedRef) => {
    const { __scopeSelect, ...arrowProps } = props;
    const popperScope = usePopperScope(__scopeSelect);
    const context = useSelectContext(dist_ARROW_NAME, __scopeSelect);
    const contentContext = useSelectContentContext(dist_ARROW_NAME, __scopeSelect);
    return context.open && contentContext.position === 'popper'
      ? /* @__PURE__ */ (0, jsx_runtime.jsx)(dist_Arrow, {
          ...popperScope,
          ...arrowProps,
          ref: forwardedRef,
        })
      : null;
  });
  SelectArrow.displayName = dist_ARROW_NAME;
  var BUBBLE_INPUT_NAME = 'SelectBubbleInput';
  var SelectBubbleInput = react.forwardRef(({ __scopeSelect, value, ...props }, forwardedRef) => {
    const ref = react.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const prevValue = usePrevious(value);
    react.useEffect(() => {
      const select = ref.current;
      if (!select) return;
      const selectProto = window.HTMLSelectElement.prototype;
      const descriptor = Object.getOwnPropertyDescriptor(selectProto, 'value');
      const setValue = descriptor.set;
      if (prevValue !== value && setValue) {
        const event = new Event('change', { bubbles: true });
        setValue.call(select, value);
        select.dispatchEvent(event);
      }
    }, [prevValue, value]);
    return /* @__PURE__ */ (0, jsx_runtime.jsx)(Primitive.select, {
      ...props,
      style: { ...VISUALLY_HIDDEN_STYLES, ...props.style },
      ref: composedRefs,
      defaultValue: value,
    });
  });
  SelectBubbleInput.displayName = BUBBLE_INPUT_NAME;
  function shouldShowPlaceholder(value) {
    return value === '' || value === void 0;
  }
  function useTypeaheadSearch(onSearchChange) {
    const handleSearchChange = useCallbackRef(onSearchChange);
    const searchRef = react.useRef('');
    const timerRef = react.useRef(0);
    const handleTypeaheadSearch = react.useCallback(
      (key) => {
        const search = searchRef.current + key;
        handleSearchChange(search);
        (function updateSearch(value) {
          searchRef.current = value;
          window.clearTimeout(timerRef.current);
          if (value !== '') timerRef.current = window.setTimeout(() => updateSearch(''), 1e3);
        })(search);
      },
      [handleSearchChange]
    );
    const resetTypeahead = react.useCallback(() => {
      searchRef.current = '';
      window.clearTimeout(timerRef.current);
    }, []);
    react.useEffect(() => {
      return () => window.clearTimeout(timerRef.current);
    }, []);
    return [searchRef, handleTypeaheadSearch, resetTypeahead];
  }
  function findNextItem(items, search, currentItem) {
    const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);
    const normalizedSearch = isRepeated ? search[0] : search;
    const currentItemIndex = currentItem ? items.indexOf(currentItem) : -1;
    let wrappedItems = wrapArray(items, Math.max(currentItemIndex, 0));
    const excludeCurrentItem = normalizedSearch.length === 1;
    if (excludeCurrentItem) wrappedItems = wrappedItems.filter((v) => v !== currentItem);
    const nextItem = wrappedItems.find((item) =>
      item.textValue.toLowerCase().startsWith(normalizedSearch.toLowerCase())
    );
    return nextItem !== currentItem ? nextItem : void 0;
  }
  function wrapArray(array, startIndex) {
    return array.map((_, index) => array[(startIndex + index) % array.length]);
  }
  var dist_Root2 = Select;
  var Trigger = SelectTrigger;
  var Value = SelectValue;
  var Icon = SelectIcon;
  var dist_Portal = SelectPortal;
  var Content2 = SelectContent;
  var Viewport = SelectViewport;
  var Group = /* unused pure expression or super */ null && SelectGroup;
  var Label = /* unused pure expression or super */ null && SelectLabel;
  var Item = SelectItem;
  var ItemText = SelectItemText;
  var ItemIndicator = SelectItemIndicator;
  var ScrollUpButton = SelectScrollUpButton;
  var ScrollDownButton = SelectScrollDownButton;
  var Separator = /* unused pure expression or super */ null && SelectSeparator;
  var Arrow2 = /* unused pure expression or super */ null && SelectArrow; // ./components/livekit/select.tsx

  //# sourceMappingURL=index.mjs.map

  ('use client');
  var select_rest =
    (undefined && undefined.__rest) ||
    function (s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === 'function')
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };

  function select_Select(_a) {
    var props = select_rest(_a, []);
    return (0, jsx_runtime.jsx)(dist_Root2, Object.assign({ 'data-slot': 'select' }, props));
  }
  function select_SelectGroup(_a) {
    var props = select_rest(_a, []);
    return _jsx(SelectPrimitive.Group, Object.assign({ 'data-slot': 'select-group' }, props));
  }
  function select_SelectValue(_a) {
    var props = select_rest(_a, []);
    return (0, jsx_runtime.jsx)(Value, Object.assign({ 'data-slot': 'select-value' }, props));
  }
  function select_SelectTrigger(_a) {
    var { className, size = 'default', children } = _a,
      props = select_rest(_a, ['className', 'size', 'children']);
    return (0, jsx_runtime.jsxs)(
      Trigger,
      Object.assign(
        {
          'data-slot': 'select-trigger',
          'data-size': size,
          className: utils_cn(
            [
              'flex w-fit cursor-pointer items-center justify-between gap-2',
              'rounded-full px-3 py-2 text-sm whitespace-nowrap',
              'bg-muted transition-[color,border,background-color]',
              'disabled:cursor-not-allowed disabled:opacity-50',
              'focus-visible:border-ring focus-visible:ring-ring/50 hover:bg-foreground/10 focus:bg-foreground/10 outline-none focus-visible:ring-[3px]',
              'aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive',
              'data-[placeholder]:text-muted-foreground',
              'data-[size=default]:h-9 data-[size=sm]:h-8',
              '*:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2',
              "[&:not([class*='text-'])_svg:not([class*='text-'])]:text-muted-foreground",
              "[&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
            ],
            className
          ),
        },
        props,
        {
          children: [
            children,
            (0, jsx_runtime.jsx)(Icon, {
              asChild: true,
              children: (0, jsx_runtime.jsx)(CaretDown_es_e, {
                weight: 'bold',
                className: 'size-4 transition-colors',
              }),
            }),
          ],
        }
      )
    );
  }
  function select_SelectContent(_a) {
    var { className, children, position = 'popper' } = _a,
      props = select_rest(_a, ['className', 'children', 'position']);
    return (0, jsx_runtime.jsx)(dist_Portal, {
      children: (0, jsx_runtime.jsxs)(
        Content2,
        Object.assign(
          {
            'data-slot': 'select-content',
            className: utils_cn(
              [
                'bg-popover text-popover-foreground relative z-50 overflow-x-hidden overflow-y-auto rounded-md border drop-shadow-xl/5',
                'max-h-(--radix-select-content-available-height) min-w-[8rem]',
                'origin-(--radix-select-content-transform-origin)',
                'data-[state=open]:animate-in data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95',
                'data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95',
                'data-[side=top]:slide-in-from-bottom-2',
                'data-[side=right]:slide-in-from-left-2',
                'data-[side=bottom]:slide-in-from-top-2',
                'data-[side=left]:slide-in-from-right-2',
              ],
              position === 'popper' &&
                'data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1',
              className
            ),
            position: position,
          },
          props,
          {
            children: [
              (0, jsx_runtime.jsx)(select_SelectScrollUpButton, {}),
              (0, jsx_runtime.jsx)(Viewport, {
                className: utils_cn(
                  'p-1',
                  position === 'popper' &&
                    'h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1'
                ),
                children: children,
              }),
              (0, jsx_runtime.jsx)(select_SelectScrollDownButton, {}),
            ],
          }
        )
      ),
    });
  }
  function select_SelectLabel(_a) {
    var { className } = _a,
      props = select_rest(_a, ['className']);
    return _jsx(
      SelectPrimitive.Label,
      Object.assign(
        {
          'data-slot': 'select-label',
          className: cn('text-muted-foreground px-2 py-1.5 text-xs', className),
        },
        props
      )
    );
  }
  function select_SelectItem(_a) {
    var { className, children } = _a,
      props = select_rest(_a, ['className', 'children']);
    return (0, jsx_runtime.jsxs)(
      Item,
      Object.assign(
        {
          'data-slot': 'select-item',
          className: utils_cn(
            [
              'relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none',
              'cursor-pointer disabled:cursor-not-allowed',
              'focus:bg-accent focus:text-accent-foreground',
              'data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
              '*:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2',
              "[&_svg:not([class*='text-'])]:text-muted-foreground [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
            ],
            className
          ),
        },
        props,
        {
          children: [
            (0, jsx_runtime.jsx)('span', {
              className: 'absolute right-2 flex size-3.5 items-center justify-center',
              children: (0, jsx_runtime.jsx)(ItemIndicator, {
                children: (0, jsx_runtime.jsx)(Check_es_o, { className: 'size-4', weight: 'bold' }),
              }),
            }),
            (0, jsx_runtime.jsx)(ItemText, { children: children }),
          ],
        }
      )
    );
  }
  function select_SelectSeparator(_a) {
    var { className } = _a,
      props = select_rest(_a, ['className']);
    return _jsx(
      SelectPrimitive.Separator,
      Object.assign(
        {
          'data-slot': 'select-separator',
          className: cn('bg-border pointer-events-none -mx-1 my-1 h-px', className),
        },
        props
      )
    );
  }
  function select_SelectScrollUpButton(_a) {
    var { className } = _a,
      props = select_rest(_a, ['className']);
    return (0, jsx_runtime.jsx)(
      ScrollUpButton,
      Object.assign(
        {
          'data-slot': 'select-scroll-up-button',
          className: utils_cn('flex cursor-default items-center justify-center py-1', className),
        },
        props,
        { children: (0, jsx_runtime.jsx)(CaretUp_es_r, { className: 'size-4', weight: 'bold' }) }
      )
    );
  }
  function select_SelectScrollDownButton(_a) {
    var { className } = _a,
      props = select_rest(_a, ['className']);
    return (0, jsx_runtime.jsx)(
      ScrollDownButton,
      Object.assign(
        {
          'data-slot': 'select-scroll-down-button',
          className: utils_cn('flex cursor-default items-center justify-center py-1', className),
        },
        props,
        { children: (0, jsx_runtime.jsx)(CaretDown_es_e, { className: 'size-4', weight: 'bold' }) }
      )
    );
  } // ./components/livekit/device-select.tsx

  ('use client');
  var device_select_rest =
    (undefined && undefined.__rest) ||
    function (s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === 'function')
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };

  const selectVariants = cva(
    [
      'w-full rounded-full px-3 py-2 text-sm cursor-pointer',
      'disabled:not-allowed hover:bg-button-hover focus:bg-button-hover',
    ],
    {
      variants: {
        size: {
          default: 'w-[180px]',
          sm: 'w-auto',
        },
      },
      defaultVariants: {
        size: 'default',
      },
    }
  );
  function DeviceSelect(_a) {
    var { kind, track, requestPermissions, onMediaDeviceError } = _a,
      // initialSelection,
      // onActiveDeviceChange,
      // onDeviceListChange,
      props = device_select_rest(_a, ['kind', 'track', 'requestPermissions', 'onMediaDeviceError']);
    const size = props.size || 'default';
    const room = Mo();
    const { devices, activeDeviceId, setActiveMediaDevice } = hooks_4Z76Vz30_qt({
      kind,
      room,
      track,
      requestPermissions,
      onError: onMediaDeviceError,
    });
    if (devices.length < 2) {
      return null;
    }
    return (0, jsx_runtime.jsxs)(select_Select, {
      value: activeDeviceId,
      onValueChange: setActiveMediaDevice,
      children: [
        (0, jsx_runtime.jsx)(select_SelectTrigger, {
          className: utils_cn(selectVariants({ size }), props.className),
          children:
            size !== 'sm' &&
            (0, jsx_runtime.jsx)(select_SelectValue, {
              className: 'font-mono text-sm',
              placeholder: `Select a ${kind}`,
            }),
        }),
        (0, jsx_runtime.jsx)(select_SelectContent, {
          children: devices.map((device) =>
            (0, jsx_runtime.jsx)(
              select_SelectItem,
              { value: device.deviceId, className: 'font-mono text-xs', children: device.label },
              device.deviceId
            )
          ),
        }),
      ],
    });
  } // ./node_modules/.pnpm/@radix-ui+react-toggle@1.1.10_@types+react-dom@19.1.9_@types+react@19.1.12__@types+react@19.1_h4sxtqvq4l6rwfanqiuzgfpm4e/node_modules/@radix-ui/react-toggle/dist/index.mjs

  ('use client');

  // src/toggle.tsx

  var react_toggle_dist_NAME = 'Toggle';
  var Toggle = react.forwardRef((props, forwardedRef) => {
    const { pressed: pressedProp, defaultPressed, onPressedChange, ...buttonProps } = props;
    const [pressed, setPressed] = useControllableState({
      prop: pressedProp,
      onChange: onPressedChange,
      defaultProp: defaultPressed ?? false,
      caller: react_toggle_dist_NAME,
    });
    return /* @__PURE__ */ (0, jsx_runtime.jsx)(Primitive.button, {
      type: 'button',
      'aria-pressed': pressed,
      'data-state': pressed ? 'on' : 'off',
      'data-disabled': props.disabled ? '' : void 0,
      ...buttonProps,
      ref: forwardedRef,
      onClick: composeEventHandlers(props.onClick, () => {
        if (!props.disabled) {
          setPressed(!pressed);
        }
      }),
    });
  });
  Toggle.displayName = react_toggle_dist_NAME;
  var react_toggle_dist_Root = Toggle; // ./components/livekit/toggle.tsx

  //# sourceMappingURL=index.mjs.map

  ('use client');
  var toggle_rest =
    (undefined && undefined.__rest) ||
    function (s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === 'function')
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };

  const toggleVariants = cva(
    [
      'inline-flex items-center justify-center gap-2 rounded-full',
      'text-sm font-medium whitespace-nowrap',
      'cursor-pointer outline-none transition-[color,box-shadow,background-color]',
      'hover:bg-muted hover:text-muted-foreground',
      'disabled:pointer-events-none disabled:opacity-50',
      'data-[state=on]:bg-accent data-[state=on]:text-accent-foreground',
      'focus-visible:ring-ring/50 focus-visible:ring-[3px] focus-visible:border-ring',
      'aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive ',
      "[&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 [&_svg]:shrink-0",
    ],
    {
      variants: {
        variant: {
          default: 'bg-transparent',
          primary:
            'bg-muted data-[state=on]:bg-muted hover:text-foreground text-destructive hover:text-foreground hover:bg-foreground/10 hover:data-[state=on]:bg-foreground/10',
          secondary:
            'bg-muted data-[state=on]:bg-muted hover:text-foreground hover:bg-foreground/10 hover:data-[state=on]:bg-foreground/10 data-[state=on]:bg-blue-500/20 data-[state=on]:hover:bg-blue-500/30 data-[state=on]:text-blue-700 dark:data-[state=on]:text-blue-300',
          outline:
            'border border-input bg-transparent shadow-xs hover:bg-accent hover:text-accent-foreground',
        },
        size: {
          default: 'h-9 px-4 py-2 has-[>svg]:px-3',
          sm: 'h-8 gap-1.5 px-3 has-[>svg]:px-2.5',
          lg: 'h-10 px-6 has-[>svg]:px-4',
          icon: 'size-9',
        },
      },
      defaultVariants: {
        variant: 'default',
        size: 'default',
      },
    }
  );
  function toggle_Toggle(_a) {
    var { className, variant, size } = _a,
      props = toggle_rest(_a, ['className', 'variant', 'size']);
    return (0, jsx_runtime.jsx)(
      react_toggle_dist_Root,
      Object.assign(
        {
          'data-slot': 'toggle',
          className: utils_cn(toggleVariants({ variant, size, className })),
        },
        props
      )
    );
  } // ./node_modules/.pnpm/@phosphor-icons+react@2.1.10_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/@phosphor-icons/react/dist/defs/Spinner.es.js

  const Spinner_es_e = /* @__PURE__ */ new Map([
    [
      'bold',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M140,32V64a12,12,0,0,1-24,0V32a12,12,0,0,1,24,0Zm33.25,62.75a12,12,0,0,0,8.49-3.52L204.37,68.6a12,12,0,0,0-17-17L164.77,74.26a12,12,0,0,0,8.48,20.49ZM224,116H192a12,12,0,0,0,0,24h32a12,12,0,0,0,0-24Zm-42.26,48.77a12,12,0,1,0-17,17l22.63,22.63a12,12,0,0,0,17-17ZM128,180a12,12,0,0,0-12,12v32a12,12,0,0,0,24,0V192A12,12,0,0,0,128,180ZM74.26,164.77,51.63,187.4a12,12,0,0,0,17,17l22.63-22.63a12,12,0,1,0-17-17ZM76,128a12,12,0,0,0-12-12H32a12,12,0,0,0,0,24H64A12,12,0,0,0,76,128ZM68.6,51.63a12,12,0,1,0-17,17L74.26,91.23a12,12,0,0,0,17-17Z',
        })
      ),
    ],
    [
      'duotone',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M224,128a96,96,0,1,1-96-96A96,96,0,0,1,224,128Z',
          opacity: '0.2',
        }),
        /* @__PURE__ */ react.createElement('path', {
          d: 'M136,32V64a8,8,0,0,1-16,0V32a8,8,0,0,1,16,0Zm37.25,58.75a8,8,0,0,0,5.66-2.35l22.63-22.62a8,8,0,0,0-11.32-11.32L167.6,77.09a8,8,0,0,0,5.65,13.66ZM224,120H192a8,8,0,0,0,0,16h32a8,8,0,0,0,0-16Zm-45.09,47.6a8,8,0,0,0-11.31,11.31l22.62,22.63a8,8,0,0,0,11.32-11.32ZM128,184a8,8,0,0,0-8,8v32a8,8,0,0,0,16,0V192A8,8,0,0,0,128,184ZM77.09,167.6,54.46,190.22a8,8,0,0,0,11.32,11.32L88.4,178.91A8,8,0,0,0,77.09,167.6ZM72,128a8,8,0,0,0-8-8H32a8,8,0,0,0,0,16H64A8,8,0,0,0,72,128ZM65.78,54.46A8,8,0,0,0,54.46,65.78L77.09,88.4A8,8,0,0,0,88.4,77.09Z',
        })
      ),
    ],
    [
      'fill',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M128,24A104,104,0,1,0,232,128,104.11,104.11,0,0,0,128,24Zm33.94,58.75,17-17a8,8,0,0,1,11.32,11.32l-17,17a8,8,0,0,1-11.31-11.31ZM48,136a8,8,0,0,1,0-16H72a8,8,0,0,1,0,16Zm46.06,37.25-17,17a8,8,0,0,1-11.32-11.32l17-17a8,8,0,0,1,11.31,11.31Zm0-79.19a8,8,0,0,1-11.31,0l-17-17A8,8,0,0,1,77.09,65.77l17,17A8,8,0,0,1,94.06,94.06ZM136,208a8,8,0,0,1-16,0V184a8,8,0,0,1,16,0Zm0-136a8,8,0,0,1-16,0V48a8,8,0,0,1,16,0Zm54.23,118.23a8,8,0,0,1-11.32,0l-17-17a8,8,0,0,1,11.31-11.31l17,17A8,8,0,0,1,190.23,190.23ZM208,136H184a8,8,0,0,1,0-16h24a8,8,0,0,1,0,16Z',
        })
      ),
    ],
    [
      'light',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M134,32V64a6,6,0,0,1-12,0V32a6,6,0,0,1,12,0Zm39.25,56.75A6,6,0,0,0,177.5,87l22.62-22.63a6,6,0,0,0-8.48-8.48L169,78.5a6,6,0,0,0,4.24,10.25ZM224,122H192a6,6,0,0,0,0,12h32a6,6,0,0,0,0-12Zm-46.5,47A6,6,0,0,0,169,177.5l22.63,22.62a6,6,0,0,0,8.48-8.48ZM128,186a6,6,0,0,0-6,6v32a6,6,0,0,0,12,0V192A6,6,0,0,0,128,186ZM78.5,169,55.88,191.64a6,6,0,1,0,8.48,8.48L87,177.5A6,6,0,1,0,78.5,169ZM70,128a6,6,0,0,0-6-6H32a6,6,0,0,0,0,12H64A6,6,0,0,0,70,128ZM64.36,55.88a6,6,0,0,0-8.48,8.48L78.5,87A6,6,0,1,0,87,78.5Z',
        })
      ),
    ],
    [
      'regular',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M136,32V64a8,8,0,0,1-16,0V32a8,8,0,0,1,16,0Zm37.25,58.75a8,8,0,0,0,5.66-2.35l22.63-22.62a8,8,0,0,0-11.32-11.32L167.6,77.09a8,8,0,0,0,5.65,13.66ZM224,120H192a8,8,0,0,0,0,16h32a8,8,0,0,0,0-16Zm-45.09,47.6a8,8,0,0,0-11.31,11.31l22.62,22.63a8,8,0,0,0,11.32-11.32ZM128,184a8,8,0,0,0-8,8v32a8,8,0,0,0,16,0V192A8,8,0,0,0,128,184ZM77.09,167.6,54.46,190.22a8,8,0,0,0,11.32,11.32L88.4,178.91A8,8,0,0,0,77.09,167.6ZM72,128a8,8,0,0,0-8-8H32a8,8,0,0,0,0,16H64A8,8,0,0,0,72,128ZM65.78,54.46A8,8,0,0,0,54.46,65.78L77.09,88.4A8,8,0,0,0,88.4,77.09Z',
        })
      ),
    ],
    [
      'thin',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M132,32V64a4,4,0,0,1-8,0V32a4,4,0,0,1,8,0Zm41.25,54.75a4,4,0,0,0,2.83-1.18L198.71,63a4,4,0,0,0-5.66-5.66L170.43,79.92a4,4,0,0,0,2.82,6.83ZM224,124H192a4,4,0,0,0,0,8h32a4,4,0,0,0,0-8Zm-47.92,46.43a4,4,0,1,0-5.65,5.65l22.62,22.63a4,4,0,0,0,5.66-5.66ZM128,188a4,4,0,0,0-4,4v32a4,4,0,0,0,8,0V192A4,4,0,0,0,128,188ZM79.92,170.43,57.29,193.05A4,4,0,0,0,63,198.71l22.62-22.63a4,4,0,1,0-5.65-5.65ZM68,128a4,4,0,0,0-4-4H32a4,4,0,0,0,0,8H64A4,4,0,0,0,68,128ZM63,57.29A4,4,0,0,0,57.29,63L79.92,85.57a4,4,0,1,0,5.65-5.65Z',
        })
      ),
    ],
  ]); // ./node_modules/.pnpm/@phosphor-icons+react@2.1.10_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/@phosphor-icons/react/dist/ssr/Spinner.es.js

  const Spinner_es_r = react.forwardRef((o, n) =>
    /* @__PURE__ */ react.createElement(SSRBase_es_w, { ref: n, ...o, weights: Spinner_es_e })
  );
  Spinner_es_r.displayName = 'SpinnerIcon';
  const Spinner_es_p = /* unused pure expression or super */ null && Spinner_es_r; // ./node_modules/.pnpm/@phosphor-icons+react@2.1.10_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/@phosphor-icons/react/dist/defs/Microphone.es.js

  const Microphone_es_e = /* @__PURE__ */ new Map([
    [
      'bold',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M128,180a52.06,52.06,0,0,0,52-52V64A52,52,0,0,0,76,64v64A52.06,52.06,0,0,0,128,180ZM100,64a28,28,0,0,1,56,0v64a28,28,0,0,1-56,0Zm40,155.22V240a12,12,0,0,1-24,0V219.22A92.14,92.14,0,0,1,36,128a12,12,0,0,1,24,0,68,68,0,0,0,136,0,12,12,0,0,1,24,0A92.14,92.14,0,0,1,140,219.22Z',
        })
      ),
    ],
    [
      'duotone',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M168,64v64a40,40,0,0,1-40,40h0a40,40,0,0,1-40-40V64a40,40,0,0,1,40-40h0A40,40,0,0,1,168,64Z',
          opacity: '0.2',
        }),
        /* @__PURE__ */ react.createElement('path', {
          d: 'M128,176a48.05,48.05,0,0,0,48-48V64a48,48,0,0,0-96,0v64A48.05,48.05,0,0,0,128,176ZM96,64a32,32,0,0,1,64,0v64a32,32,0,0,1-64,0Zm40,143.6V240a8,8,0,0,1-16,0V207.6A80.11,80.11,0,0,1,48,128a8,8,0,0,1,16,0,64,64,0,0,0,128,0,8,8,0,0,1,16,0A80.11,80.11,0,0,1,136,207.6Z',
        })
      ),
    ],
    [
      'fill',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M80,128V64a48,48,0,0,1,96,0v64a48,48,0,0,1-96,0Zm128,0a8,8,0,0,0-16,0,64,64,0,0,1-128,0,8,8,0,0,0-16,0,80.11,80.11,0,0,0,72,79.6V240a8,8,0,0,0,16,0V207.6A80.11,80.11,0,0,0,208,128Z',
        })
      ),
    ],
    [
      'light',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M128,174a46.06,46.06,0,0,0,46-46V64a46,46,0,0,0-92,0v64A46.06,46.06,0,0,0,128,174ZM94,64a34,34,0,0,1,68,0v64a34,34,0,0,1-68,0Zm40,141.75V240a6,6,0,0,1-12,0V205.75A78.09,78.09,0,0,1,50,128a6,6,0,0,1,12,0,66,66,0,0,0,132,0,6,6,0,0,1,12,0A78.09,78.09,0,0,1,134,205.75Z',
        })
      ),
    ],
    [
      'regular',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M128,176a48.05,48.05,0,0,0,48-48V64a48,48,0,0,0-96,0v64A48.05,48.05,0,0,0,128,176ZM96,64a32,32,0,0,1,64,0v64a32,32,0,0,1-64,0Zm40,143.6V240a8,8,0,0,1-16,0V207.6A80.11,80.11,0,0,1,48,128a8,8,0,0,1,16,0,64,64,0,0,0,128,0,8,8,0,0,1,16,0A80.11,80.11,0,0,1,136,207.6Z',
        })
      ),
    ],
    [
      'thin',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M128,172a44.05,44.05,0,0,0,44-44V64a44,44,0,0,0-88,0v64A44.05,44.05,0,0,0,128,172ZM92,64a36,36,0,0,1,72,0v64a36,36,0,0,1-72,0Zm40,139.89V240a4,4,0,0,1-8,0V203.89A76.09,76.09,0,0,1,52,128a4,4,0,0,1,8,0,68,68,0,0,0,136,0,4,4,0,0,1,8,0A76.09,76.09,0,0,1,132,203.89Z',
        })
      ),
    ],
  ]); // ./node_modules/.pnpm/@phosphor-icons+react@2.1.10_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/@phosphor-icons/react/dist/ssr/Microphone.es.js

  const ssr_Microphone_es_e = react.forwardRef((r, t) =>
    /* @__PURE__ */ react.createElement(SSRBase_es_w, { ref: t, ...r, weights: Microphone_es_e })
  );
  ssr_Microphone_es_e.displayName = 'MicrophoneIcon';
  const n = /* unused pure expression or super */ null && ssr_Microphone_es_e; // ./node_modules/.pnpm/@phosphor-icons+react@2.1.10_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/@phosphor-icons/react/dist/defs/MicrophoneSlash.es.js

  const MicrophoneSlash_es_e = /* @__PURE__ */ new Map([
    [
      'bold',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M56.88,39.93A12,12,0,1,0,39.12,56.07L76,96.64V128a52,52,0,0,0,72.11,48l11.26,12.39A67.34,67.34,0,0,1,128,196a68.07,68.07,0,0,1-68-68,12,12,0,0,0-24,0,92.14,92.14,0,0,0,80,91.22V240a12,12,0,0,0,24,0V219.23a90.39,90.39,0,0,0,35.92-12.68l23.2,25.52a12,12,0,0,0,17.76-16.14ZM128,156a28,28,0,0,1-28-28v-5l29.9,32.89C129.27,156,128.64,156,128,156Zm63-2.42A67.63,67.63,0,0,0,196,128a12,12,0,0,1,24,0,91.48,91.48,0,0,1-6.74,34.61,12,12,0,0,1-22.23-9ZM85.7,33.75A52,52,0,0,1,180,64v56.54a12,12,0,0,1-24,0V64a28,28,0,0,0-50.79-16.28,12,12,0,0,1-19.51-14Z',
        })
      ),
    ],
    [
      'duotone',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M168,64v64a40,40,0,0,1-40,40h0a40,40,0,0,1-40-40V64a40,40,0,0,1,40-40h0A40,40,0,0,1,168,64Z',
          opacity: '0.2',
        }),
        /* @__PURE__ */ react.createElement('path', {
          d: 'M213.92,218.62l-160-176A8,8,0,0,0,42.08,53.38L80,95.09V128a48,48,0,0,0,69.11,43.12l11.1,12.2A63.41,63.41,0,0,1,128,192a64.07,64.07,0,0,1-64-64,8,8,0,0,0-16,0,80.11,80.11,0,0,0,72,79.6V240a8,8,0,0,0,16,0V207.59a78.83,78.83,0,0,0,35.16-12.22l30.92,34a8,8,0,1,0,11.84-10.76ZM128,160a32,32,0,0,1-32-32V112.69l41.66,45.82A32,32,0,0,1,128,160Zm57.52-3.91A63.32,63.32,0,0,0,192,128a8,8,0,0,1,16,0,79.16,79.16,0,0,1-8.11,35.12,8,8,0,0,1-7.19,4.49,7.88,7.88,0,0,1-3.51-.82A8,8,0,0,1,185.52,156.09ZM84,44.87A48,48,0,0,1,176,64v64a49.19,49.19,0,0,1-.26,5,8,8,0,0,1-8,7.17,8.13,8.13,0,0,1-.84,0,8,8,0,0,1-7.12-8.79c.11-1.1.17-2.24.17-3.36V64A32,32,0,0,0,98.64,51.25,8,8,0,1,1,84,44.87Z',
        })
      ),
    ],
    [
      'fill',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M213.38,229.92a8,8,0,0,1-11.3-.54l-30.92-34A78.83,78.83,0,0,1,136,207.59V240a8,8,0,0,1-16,0V207.6A80.11,80.11,0,0,1,48,128a8,8,0,0,1,16,0,64.07,64.07,0,0,0,64,64,63.41,63.41,0,0,0,32.21-8.68l-11.1-12.2A48,48,0,0,1,80,128V95.09L42.08,53.38A8,8,0,0,1,53.92,42.62l160,176A8,8,0,0,1,213.38,229.92Zm-24.19-63.13a7.88,7.88,0,0,0,3.51.82,8,8,0,0,0,7.19-4.49A79.16,79.16,0,0,0,208,128a8,8,0,0,0-16,0,63.32,63.32,0,0,1-6.48,28.09A8,8,0,0,0,189.19,166.79Zm-27.33-29.22A8,8,0,0,0,175.74,133a49.49,49.49,0,0,0,.26-5V64A48,48,0,0,0,84,44.87a8,8,0,0,0,1.41,8.57Z',
        })
      ),
    ],
    [
      'light',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M212.44,220,52.44,44A6,6,0,0,0,43.56,52L82,94.32V128a46,46,0,0,0,67.56,40.64l13.75,15.12A65.26,65.26,0,0,1,128,194a66.08,66.08,0,0,1-66-66,6,6,0,0,0-12,0,78.09,78.09,0,0,0,72,77.75V240a6,6,0,0,0,12,0V205.77a76.93,76.93,0,0,0,37.48-13L203.56,228a6,6,0,0,0,8.88-8.08ZM128,162a34,34,0,0,1-34-34V107.52l47.12,51.84A33.82,33.82,0,0,1,128,162Zm59.32-5A65.38,65.38,0,0,0,194,128a6,6,0,0,1,12,0,77.33,77.33,0,0,1-7.9,34.25A6,6,0,1,1,187.32,157ZM85.8,45.67A46,46,0,0,1,174,64v64a45.17,45.17,0,0,1-.25,4.81,6,6,0,0,1-6,5.38q-.31,0-.63,0a6,6,0,0,1-5.34-6.59A35.41,35.41,0,0,0,162,128V64A34,34,0,0,0,96.8,50.45a6,6,0,0,1-11-4.78Z',
        })
      ),
    ],
    [
      'regular',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M213.92,218.62l-160-176A8,8,0,0,0,42.08,53.38L80,95.09V128a48,48,0,0,0,69.11,43.12l11.1,12.2A63.41,63.41,0,0,1,128,192a64.07,64.07,0,0,1-64-64,8,8,0,0,0-16,0,80.11,80.11,0,0,0,72,79.6V240a8,8,0,0,0,16,0V207.59a78.83,78.83,0,0,0,35.16-12.22l30.92,34a8,8,0,1,0,11.84-10.76ZM128,160a32,32,0,0,1-32-32V112.69l41.66,45.82A32,32,0,0,1,128,160Zm57.52-3.91A63.32,63.32,0,0,0,192,128a8,8,0,0,1,16,0,79.16,79.16,0,0,1-8.11,35.12,8,8,0,0,1-7.19,4.49,7.88,7.88,0,0,1-3.51-.82A8,8,0,0,1,185.52,156.09ZM84,44.87A48,48,0,0,1,176,64v64a49.19,49.19,0,0,1-.26,5,8,8,0,0,1-8,7.17,8.13,8.13,0,0,1-.84,0,8,8,0,0,1-7.12-8.79c.11-1.1.17-2.24.17-3.36V64A32,32,0,0,0,98.64,51.25,8,8,0,1,1,84,44.87Z',
        })
      ),
    ],
    [
      'thin',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M211,221.31,51,45.31A4,4,0,0,0,45,50.69L84,93.55V128a44,44,0,0,0,66,38.12l16.38,18A67.21,67.21,0,0,1,128,196a68.07,68.07,0,0,1-68-68,4,4,0,0,0-8,0,76.09,76.09,0,0,0,72,75.89V240a4,4,0,0,0,8,0V203.89a75.1,75.1,0,0,0,39.79-13.77L205,226.69a4,4,0,1,0,5.92-5.38ZM128,164a36,36,0,0,1-36-36V102.35L144.43,160A35.83,35.83,0,0,1,128,164Zm61.12-6.15A67.44,67.44,0,0,0,196,128a4,4,0,0,1,8,0,75.28,75.28,0,0,1-7.7,33.37,4,4,0,0,1-7.18-3.52ZM87.63,46.46A44,44,0,0,1,172,64v64a44.2,44.2,0,0,1-.24,4.61,4,4,0,0,1-4,3.58l-.42,0a4,4,0,0,1-3.57-4.39A36.67,36.67,0,0,0,164,128V64A36,36,0,0,0,95,49.66a4,4,0,0,1-7.34-3.2Z',
        })
      ),
    ],
  ]); // ./node_modules/.pnpm/@phosphor-icons+react@2.1.10_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/@phosphor-icons/react/dist/ssr/MicrophoneSlash.es.js

  const ssr_MicrophoneSlash_es_e = react.forwardRef((r, a) =>
    /* @__PURE__ */ react.createElement(SSRBase_es_w, {
      ref: a,
      ...r,
      weights: MicrophoneSlash_es_e,
    })
  );
  ssr_MicrophoneSlash_es_e.displayName = 'MicrophoneSlashIcon';
  const m = /* unused pure expression or super */ null && ssr_MicrophoneSlash_es_e; // ./node_modules/.pnpm/@phosphor-icons+react@2.1.10_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/@phosphor-icons/react/dist/defs/VideoCamera.es.js

  const VideoCamera_es_e = /* @__PURE__ */ new Map([
    [
      'bold',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M249.45,69.31a12,12,0,0,0-12.51,1L212,88.43V72a20,20,0,0,0-20-20H32A20,20,0,0,0,12,72V184a20,20,0,0,0,20,20H192a20,20,0,0,0,20-20V167.57l24.94,18.14A12,12,0,0,0,256,176V80A12,12,0,0,0,249.45,69.31ZM188,180H36V76H188Zm44-27.57-20-14.54V118.11l20-14.54Z',
        })
      ),
    ],
    [
      'duotone',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M200,72V184a8,8,0,0,1-8,8H32a8,8,0,0,1-8-8V72a8,8,0,0,1,8-8H192A8,8,0,0,1,200,72Z',
          opacity: '0.2',
        }),
        /* @__PURE__ */ react.createElement('path', {
          d: 'M251.77,73a8,8,0,0,0-8.21.39L208,97.05V72a16,16,0,0,0-16-16H32A16,16,0,0,0,16,72V184a16,16,0,0,0,16,16H192a16,16,0,0,0,16-16V159l35.56,23.71A8,8,0,0,0,248,184a8,8,0,0,0,8-8V80A8,8,0,0,0,251.77,73ZM192,184H32V72H192V184Zm48-22.95-32-21.33V116.28L240,95Z',
        })
      ),
    ],
    [
      'fill',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M192,72V184a16,16,0,0,1-16,16H32a16,16,0,0,1-16-16V72A16,16,0,0,1,32,56H176A16,16,0,0,1,192,72Zm58,.25a8.23,8.23,0,0,0-6.63,1.22L209.78,95.86A4,4,0,0,0,208,99.19v57.62a4,4,0,0,0,1.78,3.33l33.78,22.52a8,8,0,0,0,8.58.19,8.33,8.33,0,0,0,3.86-7.17V80A8,8,0,0,0,250,72.25Z',
        })
      ),
    ],
    [
      'light',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M250.83,74.71a6,6,0,0,0-6.16.3L206,100.79V72a14,14,0,0,0-14-14H32A14,14,0,0,0,18,72V184a14,14,0,0,0,14,14H192a14,14,0,0,0,14-14V155.21L244.67,181a6,6,0,0,0,9.33-5V80A6,6,0,0,0,250.83,74.71ZM194,184a2,2,0,0,1-2,2H32a2,2,0,0,1-2-2V72a2,2,0,0,1,2-2H192a2,2,0,0,1,2,2Zm48-19.21-36-24V115.21l36-24Z',
        })
      ),
    ],
    [
      'regular',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M251.77,73a8,8,0,0,0-8.21.39L208,97.05V72a16,16,0,0,0-16-16H32A16,16,0,0,0,16,72V184a16,16,0,0,0,16,16H192a16,16,0,0,0,16-16V159l35.56,23.71A8,8,0,0,0,248,184a8,8,0,0,0,8-8V80A8,8,0,0,0,251.77,73ZM192,184H32V72H192V184Zm48-22.95-32-21.33V116.28L240,95Z',
        })
      ),
    ],
    [
      'thin',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M249.89,76.47a4,4,0,0,0-4.11.2L204,104.53V72a12,12,0,0,0-12-12H32A12,12,0,0,0,20,72V184a12,12,0,0,0,12,12H192a12,12,0,0,0,12-12V151.47l41.78,27.86A4,4,0,0,0,252,176V80A4,4,0,0,0,249.89,76.47ZM196,184a4,4,0,0,1-4,4H32a4,4,0,0,1-4-4V72a4,4,0,0,1,4-4H192a4,4,0,0,1,4,4Zm48-15.47-40-26.67V114.14l40-26.67Z',
        })
      ),
    ],
  ]); // ./node_modules/.pnpm/@phosphor-icons+react@2.1.10_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/@phosphor-icons/react/dist/ssr/VideoCamera.es.js

  const VideoCamera_es_o = react.forwardRef((a, r) =>
    /* @__PURE__ */ react.createElement(SSRBase_es_w, { ref: r, ...a, weights: VideoCamera_es_e })
  );
  VideoCamera_es_o.displayName = 'VideoCameraIcon';
  const VideoCamera_es_c = /* unused pure expression or super */ null && VideoCamera_es_o; // ./node_modules/.pnpm/@phosphor-icons+react@2.1.10_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/@phosphor-icons/react/dist/defs/VideoCameraSlash.es.js

  const VideoCameraSlash_es_e = /* @__PURE__ */ new Map([
    [
      'bold',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M249.45,69.31a12,12,0,0,0-12.51,1L212,88.43V72a20,20,0,0,0-20-20H123.88a12,12,0,0,0,0,24H188v68a12,12,0,0,0,4.46,9.33c.15.13.31.25.48.38l44,32A12,12,0,0,0,256,176V80A12,12,0,0,0,249.45,69.31ZM232,152.43l-20-14.54V118.11l20-14.54ZM56.88,31.93A12,12,0,1,0,39.12,48.07L42.69,52H32A20,20,0,0,0,12,72V184a20,20,0,0,0,20,20H180.87l18.25,20.07a12,12,0,0,0,17.76-16.14ZM36,180V76H64.51l94.55,104Z',
        })
      ),
    ],
    [
      'duotone',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M200,72V184a8,8,0,0,1-8,8H32a8,8,0,0,1-8-8V72a8,8,0,0,1,8-8H192A8,8,0,0,1,200,72Z',
          opacity: '0.2',
        }),
        /* @__PURE__ */ react.createElement('path', {
          d: 'M251.77,73a8,8,0,0,0-8.21.39L208,97.05V72a16,16,0,0,0-16-16H113.06a8,8,0,0,0,0,16H192v87.63a8,8,0,0,0,16,0V159l35.56,23.71A8,8,0,0,0,248,184a8,8,0,0,0,8-8V80A8,8,0,0,0,251.77,73ZM240,161.05l-32-21.33V116.28L240,95ZM53.92,34.62A8,8,0,1,0,42.08,45.38L51.73,56H32A16,16,0,0,0,16,72V184a16,16,0,0,0,16,16H182.64l19.44,21.38a8,8,0,1,0,11.84-10.76ZM32,184V72H66.28L168.1,184Z',
        })
      ),
    ],
    [
      'fill',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M256,80.23v95.45a8.33,8.33,0,0,1-3.86,7.17,8,8,0,0,1-8.58-.19l-33.78-22.52a4,4,0,0,1-1.78-3.33V99.19a4,4,0,0,1,1.78-3.32l33.78-22.53a8,8,0,0,1,9.73.66A8.23,8.23,0,0,1,256,80.23ZM53.92,34.62A8,8,0,1,0,42.08,45.38L51.73,56H32A16,16,0,0,0,16,72V184a16,16,0,0,0,16,16H182.64l19.44,21.38a8,8,0,1,0,11.84-10.76ZM185,155.07a4,4,0,0,0,7-2.7V72a16,16,0,0,0-16-16H104a4,4,0,0,0-3,6.69Z',
        })
      ),
    ],
    [
      'light',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M250.83,74.71a6,6,0,0,0-6.16.3L206,100.79V72a14,14,0,0,0-14-14H113.06a6,6,0,0,0,0,12H192a2,2,0,0,1,2,2v87.63a6,6,0,0,0,12,0v-4.42L244.67,181a6,6,0,0,0,9.33-5V80A6,6,0,0,0,250.83,74.71ZM242,164.79l-36-24V115.21l36-24ZM52.44,36A6,6,0,0,0,43.56,44L56.25,58H32A14,14,0,0,0,18,72V184a14,14,0,0,0,14,14H183.53l20,22a6,6,0,0,0,8.88-8.08ZM32,186a2,2,0,0,1-2-2V72a2,2,0,0,1,2-2H67.16L172.62,186Z',
        })
      ),
    ],
    [
      'regular',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M251.77,73a8,8,0,0,0-8.21.39L208,97.05V72a16,16,0,0,0-16-16H113.06a8,8,0,0,0,0,16H192v87.63a8,8,0,0,0,16,0V159l35.56,23.71A8,8,0,0,0,248,184a8,8,0,0,0,8-8V80A8,8,0,0,0,251.77,73ZM240,161.05l-32-21.33V116.28L240,95ZM53.92,34.62A8,8,0,1,0,42.08,45.38L51.73,56H32A16,16,0,0,0,16,72V184a16,16,0,0,0,16,16H182.64l19.44,21.38a8,8,0,1,0,11.84-10.76ZM32,184V72H66.28L168.1,184Z',
        })
      ),
    ],
    [
      'thin',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M249.89,76.47a4,4,0,0,0-4.11.2L204,104.53V72a12,12,0,0,0-12-12H113.06a4,4,0,0,0,0,8H192a4,4,0,0,1,4,4v87.63a4,4,0,0,0,8,0v-8.16l41.78,27.86A4,4,0,0,0,252,176V80A4,4,0,0,0,249.89,76.47ZM244,168.53l-40-26.67V114.14l40-26.67ZM51,37.31A4,4,0,0,0,45,42.69L60.78,60H32A12,12,0,0,0,20,72V184a12,12,0,0,0,12,12H184.41L205,218.69a4,4,0,1,0,5.92-5.38ZM32,188a4,4,0,0,1-4-4V72a4,4,0,0,1,4-4H68.05L177.14,188Z',
        })
      ),
    ],
  ]); // ./node_modules/.pnpm/@phosphor-icons+react@2.1.10_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/@phosphor-icons/react/dist/ssr/VideoCameraSlash.es.js

  const ssr_VideoCameraSlash_es_e = react.forwardRef((o, r) =>
    /* @__PURE__ */ react.createElement(SSRBase_es_w, {
      ref: r,
      ...o,
      weights: VideoCameraSlash_es_e,
    })
  );
  ssr_VideoCameraSlash_es_e.displayName = 'VideoCameraSlashIcon';
  const VideoCameraSlash_es_c =
    /* unused pure expression or super */ null && ssr_VideoCameraSlash_es_e; // ./node_modules/.pnpm/@phosphor-icons+react@2.1.10_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/@phosphor-icons/react/dist/defs/MonitorArrowUp.es.js

  const MonitorArrowUp_es_e = /* @__PURE__ */ new Map([
    [
      'bold',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M208,36H48A28,28,0,0,0,20,64V176a28,28,0,0,0,28,28H208a28,28,0,0,0,28-28V64A28,28,0,0,0,208,36Zm4,140a4,4,0,0,1-4,4H48a4,4,0,0,1-4-4V64a4,4,0,0,1,4-4H208a4,4,0,0,1,4,4Zm-40,52a12,12,0,0,1-12,12H96a12,12,0,0,1,0-24h64A12,12,0,0,1,172,228ZM160.49,103.51a12,12,0,0,1-17,17L140,117v35a12,12,0,0,1-24,0V117l-3.51,3.52a12,12,0,0,1-17-17l24-24a12,12,0,0,1,17,0Z',
        })
      ),
    ],
    [
      'duotone',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M224,64V176a16,16,0,0,1-16,16H48a16,16,0,0,1-16-16V64A16,16,0,0,1,48,48H208A16,16,0,0,1,224,64Z',
          opacity: '0.2',
        }),
        /* @__PURE__ */ react.createElement('path', {
          d: 'M208,40H48A24,24,0,0,0,24,64V176a24,24,0,0,0,24,24H208a24,24,0,0,0,24-24V64A24,24,0,0,0,208,40Zm8,136a8,8,0,0,1-8,8H48a8,8,0,0,1-8-8V64a8,8,0,0,1,8-8H208a8,8,0,0,1,8,8Zm-48,48a8,8,0,0,1-8,8H96a8,8,0,0,1,0-16h64A8,8,0,0,1,168,224ZM157.66,106.34a8,8,0,0,1-11.32,11.32L136,107.31V152a8,8,0,0,1-16,0V107.31l-10.34,10.35a8,8,0,0,1-11.32-11.32l24-24a8,8,0,0,1,11.32,0Z',
        })
      ),
    ],
    [
      'fill',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M168,224a8,8,0,0,1-8,8H96a8,8,0,0,1,0-16h64A8,8,0,0,1,168,224ZM232,64V176a24,24,0,0,1-24,24H48a24,24,0,0,1-24-24V64A24,24,0,0,1,48,40H208A24,24,0,0,1,232,64Zm-74.34,42.34-24-24a8,8,0,0,0-11.32,0l-24,24a8,8,0,0,0,11.32,11.32L120,107.31V152a8,8,0,0,0,16,0V107.31l10.34,10.35a8,8,0,0,0,11.32-11.32Z',
        })
      ),
    ],
    [
      'light',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M208,42H48A22,22,0,0,0,26,64V176a22,22,0,0,0,22,22H208a22,22,0,0,0,22-22V64A22,22,0,0,0,208,42Zm10,134a10,10,0,0,1-10,10H48a10,10,0,0,1-10-10V64A10,10,0,0,1,48,54H208a10,10,0,0,1,10,10Zm-52,48a6,6,0,0,1-6,6H96a6,6,0,0,1,0-12h64A6,6,0,0,1,166,224Zm-9.76-116.24a6,6,0,1,1-8.48,8.48L134,102.49V152a6,6,0,0,1-12,0V102.49l-13.76,13.75a6,6,0,0,1-8.48-8.48l24-24a6,6,0,0,1,8.48,0Z',
        })
      ),
    ],
    [
      'regular',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M208,40H48A24,24,0,0,0,24,64V176a24,24,0,0,0,24,24H208a24,24,0,0,0,24-24V64A24,24,0,0,0,208,40Zm8,136a8,8,0,0,1-8,8H48a8,8,0,0,1-8-8V64a8,8,0,0,1,8-8H208a8,8,0,0,1,8,8Zm-48,48a8,8,0,0,1-8,8H96a8,8,0,0,1,0-16h64A8,8,0,0,1,168,224ZM157.66,106.34a8,8,0,0,1-11.32,11.32L136,107.31V152a8,8,0,0,1-16,0V107.31l-10.34,10.35a8,8,0,0,1-11.32-11.32l24-24a8,8,0,0,1,11.32,0Z',
        })
      ),
    ],
    [
      'thin',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M208,44H48A20,20,0,0,0,28,64V176a20,20,0,0,0,20,20H208a20,20,0,0,0,20-20V64A20,20,0,0,0,208,44Zm12,132a12,12,0,0,1-12,12H48a12,12,0,0,1-12-12V64A12,12,0,0,1,48,52H208a12,12,0,0,1,12,12Zm-56,48a4,4,0,0,1-4,4H96a4,4,0,0,1,0-8h64A4,4,0,0,1,164,224Zm-9.17-114.83a4,4,0,0,1-5.66,5.66L132,97.66V152a4,4,0,0,1-8,0V97.66l-17.17,17.17a4,4,0,0,1-5.66-5.66l24-24a4,4,0,0,1,5.66,0Z',
        })
      ),
    ],
  ]); // ./node_modules/.pnpm/@phosphor-icons+react@2.1.10_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/@phosphor-icons/react/dist/ssr/MonitorArrowUp.es.js

  const MonitorArrowUp_es_r = react.forwardRef((t, e) =>
    /* @__PURE__ */ react.createElement(SSRBase_es_w, {
      ref: e,
      ...t,
      weights: MonitorArrowUp_es_e,
    })
  );
  MonitorArrowUp_es_r.displayName = 'MonitorArrowUpIcon';
  const MonitorArrowUp_es_p = /* unused pure expression or super */ null && MonitorArrowUp_es_r; // ./components/livekit/track-toggle.tsx

  ('use client');
  var track_toggle_rest =
    (undefined && undefined.__rest) ||
    function (s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === 'function')
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };

  function getSourceIcon(source, enabled, pending = false) {
    if (pending) {
      return Spinner_es_r;
    }
    switch (source) {
      case Track.Source.Microphone:
        return enabled ? ssr_Microphone_es_e : ssr_MicrophoneSlash_es_e;
      case Track.Source.Camera:
        return enabled ? VideoCamera_es_o : ssr_VideoCameraSlash_es_e;
      case Track.Source.ScreenShare:
        return MonitorArrowUp_es_r;
      default:
        return react.Fragment;
    }
  }
  function TrackToggle(_a) {
    var { source, pressed, pending, className } = _a,
      props = track_toggle_rest(_a, ['source', 'pressed', 'pending', 'className']);
    const IconComponent = getSourceIcon(
      source,
      pressed !== null && pressed !== void 0 ? pressed : false,
      pending
    );
    return (0, jsx_runtime.jsxs)(
      toggle_Toggle,
      Object.assign(
        { pressed: pressed, 'aria-label': `Toggle ${source}`, className: utils_cn(className) },
        props,
        {
          children: [
            (0, jsx_runtime.jsx)(IconComponent, {
              weight: 'bold',
              className: utils_cn(pending && 'animate-spin'),
            }),
            props.children,
          ],
        }
      )
    );
  } // ./hooks/use-publish-permissions.ts

  const trackSourceToProtocol = (source) => {
    // NOTE: this mapping avoids importing the protocol package as that leads to a significant bundle size increase
    switch (source) {
      case Track.Source.Camera:
        return 1;
      case Track.Source.Microphone:
        return 2;
      case Track.Source.ScreenShare:
        return 3;
      default:
        return 0;
    }
  };
  function usePublishPermissions() {
    var _a;
    const localPermissions = hooks_4Z76Vz30_Vt();
    const canPublishSource = (source) => {
      return (
        !!(localPermissions === null || localPermissions === void 0
          ? void 0
          : localPermissions.canPublish) &&
        (localPermissions.canPublishSources.length === 0 ||
          localPermissions.canPublishSources.includes(trackSourceToProtocol(source)))
      );
    };
    return {
      camera: canPublishSource(Track.Source.Camera),
      microphone: canPublishSource(Track.Source.Microphone),
      screenShare: canPublishSource(Track.Source.ScreenShare),
      data:
        (_a =
          localPermissions === null || localPermissions === void 0
            ? void 0
            : localPermissions.canPublishData) !== null && _a !== void 0
          ? _a
          : false,
    };
  } // ./hooks/use-agent-control-bar.ts

  function useAgentControlBar({ controls, saveUserChoices = true, onDeviceError } = {}) {
    var _a, _b, _c, _d;
    const { microphoneTrack, localParticipant } = hooks_4Z76Vz30_it();
    const publishPermissions = usePublishPermissions();
    const room = zs();
    const microphoneToggle = hooks_4Z76Vz30_en({
      source: Track.Source.Microphone,
      onDeviceError: (error) =>
        onDeviceError === null || onDeviceError === void 0
          ? void 0
          : onDeviceError({ source: Track.Source.Microphone, error }),
    });
    const cameraToggle = hooks_4Z76Vz30_en({
      source: Track.Source.Camera,
      onDeviceError: (error) =>
        onDeviceError === null || onDeviceError === void 0
          ? void 0
          : onDeviceError({ source: Track.Source.Camera, error }),
    });
    const screenShareToggle = hooks_4Z76Vz30_en({
      source: Track.Source.ScreenShare,
      onDeviceError: (error) =>
        onDeviceError === null || onDeviceError === void 0
          ? void 0
          : onDeviceError({ source: Track.Source.ScreenShare, error }),
    });
    const micTrackRef = react.useMemo(() => {
      return {
        participant: localParticipant,
        source: Track.Source.Microphone,
        publication: microphoneTrack,
      };
    }, [localParticipant, microphoneTrack]);
    const visibleControls = Object.assign({ leave: true }, controls);
    (_a = visibleControls.microphone) !== null && _a !== void 0
      ? _a
      : (visibleControls.microphone = publishPermissions.microphone);
    (_b = visibleControls.screenShare) !== null && _b !== void 0
      ? _b
      : (visibleControls.screenShare = publishPermissions.screenShare);
    (_c = visibleControls.camera) !== null && _c !== void 0
      ? _c
      : (visibleControls.camera = publishPermissions.camera);
    (_d = visibleControls.chat) !== null && _d !== void 0
      ? _d
      : (visibleControls.chat = publishPermissions.data);
    const {
      saveAudioInputEnabled,
      saveAudioInputDeviceId,
      saveVideoInputEnabled,
      saveVideoInputDeviceId,
    } = hooks_4Z76Vz30_an({
      preventSave: !saveUserChoices,
    });
    const handleDisconnect = react.useCallback(() => {
      if (room) {
        room.disconnect();
      }
    }, [room]);
    const handleAudioDeviceChange = react.useCallback(
      (deviceId) => {
        saveAudioInputDeviceId(deviceId !== null && deviceId !== void 0 ? deviceId : 'default');
      },
      [saveAudioInputDeviceId]
    );
    const handleVideoDeviceChange = react.useCallback(
      (deviceId) => {
        saveVideoInputDeviceId(deviceId !== null && deviceId !== void 0 ? deviceId : 'default');
      },
      [saveVideoInputDeviceId]
    );
    const handleToggleCamera = react.useCallback(
      async (enabled) => {
        if (screenShareToggle.enabled) {
          screenShareToggle.toggle(false);
        }
        await cameraToggle.toggle(enabled);
        // persist video input enabled preference
        saveVideoInputEnabled(!cameraToggle.enabled);
      },
      [screenShareToggle.enabled, screenShareToggle.toggle, cameraToggle.toggle]
    );
    const handleToggleMicrophone = react.useCallback(
      async (enabled) => {
        await microphoneToggle.toggle(enabled);
        // persist audio input enabled preference
        saveAudioInputEnabled(!microphoneToggle.enabled);
      },
      [microphoneToggle.enabled, microphoneToggle.toggle]
    );
    const handleToggleScreenShare = react.useCallback(
      async (enabled) => {
        if (cameraToggle.enabled) {
          cameraToggle.toggle(false);
        }
        await screenShareToggle.toggle(enabled);
      },
      [cameraToggle.enabled, cameraToggle.toggle, screenShareToggle.toggle]
    );
    return {
      micTrackRef,
      visibleControls,
      cameraToggle: Object.assign(Object.assign({}, cameraToggle), { toggle: handleToggleCamera }),
      microphoneToggle: Object.assign(Object.assign({}, microphoneToggle), {
        toggle: handleToggleMicrophone,
      }),
      screenShareToggle: Object.assign(Object.assign({}, screenShareToggle), {
        toggle: handleToggleScreenShare,
      }),
      handleDisconnect,
      handleAudioDeviceChange,
      handleVideoDeviceChange,
    };
  } // ./components/embed-popup/action-bar.tsx

  ('use client');
  var action_bar_rest =
    (undefined && undefined.__rest) ||
    function (s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === 'function')
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };

  /**
   * A control bar specifically designed for voice assistant interfaces
   */
  function ActionBar(_a) {
    var {
        controls,
        saveUserChoices = true,
        capabilities,
        className,
        onSendMessage,
        onChatOpenChange,
        onDeviceError,
      } = _a,
      props = action_bar_rest(_a, [
        'controls',
        'saveUserChoices',
        'capabilities',
        'className',
        'onSendMessage',
        'onChatOpenChange',
        'onDeviceError',
      ]);
    const participants = hooks_4Z76Vz30_ee();
    const [chatOpen, setChatOpen] = react.useState(false);
    const [isSendingMessage, setIsSendingMessage] = react.useState(false);
    const isAgentAvailable = participants.some((p) => p.isAgent);
    const isInputDisabled = !chatOpen || !isAgentAvailable || isSendingMessage;
    const {
      micTrackRef,
      visibleControls,
      cameraToggle,
      microphoneToggle,
      screenShareToggle,
      handleAudioDeviceChange,
      handleVideoDeviceChange,
    } = useAgentControlBar({
      controls,
      saveUserChoices,
    });
    const handleSendMessage = async (message) => {
      setIsSendingMessage(true);
      try {
        await (onSendMessage === null || onSendMessage === void 0
          ? void 0
          : onSendMessage(message));
      } finally {
        setIsSendingMessage(false);
      }
    };
    react.useEffect(() => {
      onChatOpenChange === null || onChatOpenChange === void 0
        ? void 0
        : onChatOpenChange(chatOpen);
    }, [chatOpen, onChatOpenChange]);
    const onMicrophoneDeviceSelectError = (0, react.useCallback)(
      (error) => {
        onDeviceError === null || onDeviceError === void 0
          ? void 0
          : onDeviceError({ source: Track.Source.Microphone, error });
      },
      [onDeviceError]
    );
    const onCameraDeviceSelectError = (0, react.useCallback)(
      (error) => {
        onDeviceError === null || onDeviceError === void 0
          ? void 0
          : onDeviceError({ source: Track.Source.Camera, error });
      },
      [onDeviceError]
    );
    return (0, jsx_runtime.jsxs)(
      'div',
      Object.assign(
        {
          'aria-label': 'Voice assistant controls',
          className: utils_cn(
            'bg-background border-separator1 dark:border-separator1 relative z-20 mx-2 mb-2 flex flex-col rounded-[24px] border p-1 drop-shadow-md',
            className
          ),
        },
        props,
        {
          children: [
            capabilities.supportsChatInput &&
              (0, jsx_runtime.jsxs)('div', {
                inert: !chatOpen,
                className: utils_cn(
                  'relative overflow-hidden transition-[height] duration-300 ease-out',
                  chatOpen ? 'h-[46px]' : 'h-0'
                ),
                children: [
                  (0, jsx_runtime.jsx)('div', {
                    className: utils_cn(
                      'absolute inset-x-0 top-0 flex h-9 w-full transition-opacity duration-150 ease-linear',
                      chatOpen ? 'opacity-100 delay-150' : 'opacity-0'
                    ),
                    children: (0, jsx_runtime.jsx)(ChatInput, {
                      onSend: handleSendMessage,
                      disabled: isInputDisabled,
                      className: 'w-full',
                    }),
                  }),
                  (0, jsx_runtime.jsx)('hr', {
                    className: 'border-bg2 absolute inset-x-0 bottom-0 my-1 w-full',
                  }),
                ],
              }),
            (0, jsx_runtime.jsxs)('div', {
              className: 'flex flex-row justify-between gap-1',
              children: [
                (0, jsx_runtime.jsxs)('div', {
                  className: 'flex gap-1',
                  children: [
                    visibleControls.microphone &&
                      (0, jsx_runtime.jsxs)('div', {
                        className: 'flex items-center gap-0',
                        children: [
                          (0, jsx_runtime.jsx)(TrackToggle, {
                            variant: 'primary',
                            source: Track.Source.Microphone,
                            pressed: microphoneToggle.enabled,
                            disabled: microphoneToggle.pending,
                            onPressedChange: microphoneToggle.toggle,
                            className:
                              'peer/track group/track relative w-auto pr-3 pl-3 has-[+_*]:rounded-r-none has-[+_*]:border-r-0 has-[+_*]:pr-2',
                            children: (0, jsx_runtime.jsx)(components_CwZ8kStA_Xt, {
                              barCount: 3,
                              trackRef: micTrackRef,
                              options: { minHeight: 5 },
                              className: 'flex h-full w-auto items-center justify-center gap-0.5',
                              children: (0, jsx_runtime.jsx)('span', {
                                className: utils_cn([
                                  'h-full w-0.5 origin-center rounded-2xl',
                                  'group-data-[state=on]/track:bg-fg1 group-data-[state=off]/track:bg-destructive-foreground',
                                  'data-lk-muted:bg-muted',
                                ]),
                              }),
                            }),
                          }),
                          (0, jsx_runtime.jsx)(DeviceSelect, {
                            size: 'sm',
                            kind: 'audioinput',
                            requestPermissions: false,
                            onMediaDeviceError: onMicrophoneDeviceSelectError,
                            onActiveDeviceChange: handleAudioDeviceChange,
                            className: utils_cn([
                              'pl-2',
                              'peer-data-[state=off]/track:text-destructive-foreground',
                              'hover:text-fg1 focus:text-fg1',
                              'hover:peer-data-[state=off]/track:text-destructive-foreground focus:peer-data-[state=off]/track:text-destructive-foreground',
                              'hidden rounded-l-none md:block',
                            ]),
                          }),
                        ],
                      }),
                    capabilities.supportsVideoInput &&
                      visibleControls.camera &&
                      (0, jsx_runtime.jsxs)('div', {
                        className: 'flex items-center gap-0',
                        children: [
                          (0, jsx_runtime.jsx)(TrackToggle, {
                            variant: 'primary',
                            source: Track.Source.Camera,
                            pressed: cameraToggle.enabled,
                            pending: cameraToggle.pending,
                            disabled: cameraToggle.pending,
                            onPressedChange: cameraToggle.toggle,
                            className:
                              'peer/track relative w-auto pr-3 pl-3 disabled:opacity-100 has-[+_*]:rounded-r-none has-[+_*]:border-r-0 has-[+_*]:pr-2',
                          }),
                          (0, jsx_runtime.jsx)(DeviceSelect, {
                            size: 'sm',
                            kind: 'videoinput',
                            requestPermissions: false,
                            onMediaDeviceError: onCameraDeviceSelectError,
                            onActiveDeviceChange: handleVideoDeviceChange,
                            className: utils_cn([
                              'pl-2',
                              'peer-data-[state=off]/track:text-destructive-foreground',
                              'hover:text-fg1 focus:text-fg1',
                              'hover:peer-data-[state=off]/track:text-destructive-foreground focus:peer-data-[state=off]/track:text-destructive-foreground',
                              'rounded-l-none',
                            ]),
                          }),
                        ],
                      }),
                  ],
                }),
                (0, jsx_runtime.jsxs)('div', {
                  className: 'flex gap-1',
                  children: [
                    capabilities.supportsScreenShare &&
                      visibleControls.screenShare &&
                      (0, jsx_runtime.jsx)('div', {
                        className: 'flex items-center gap-0',
                        children: (0, jsx_runtime.jsx)(TrackToggle, {
                          variant: 'secondary',
                          source: Track.Source.ScreenShare,
                          pressed: screenShareToggle.enabled,
                          disabled: screenShareToggle.pending,
                          onPressedChange: screenShareToggle.toggle,
                          className: 'relative w-auto',
                        }),
                      }),
                    visibleControls.chat &&
                      (0, jsx_runtime.jsx)(toggle_Toggle, {
                        variant: 'secondary',
                        'aria-label': 'Toggle chat',
                        pressed: chatOpen,
                        onPressedChange: setChatOpen,
                        disabled: !isAgentAvailable,
                        className: 'aspect-square h-full',
                        children: (0, jsx_runtime.jsx)(ssr_ChatText_es_e, { weight: 'bold' }),
                      }),
                  ],
                }),
              ],
            }),
          ],
        }
      )
    );
  } // ./components/embed-popup/audio-visualizer.tsx

  function AudioVisualizer({ agentState, audioTrack }) {
    return (0, jsx_runtime.jsx)(components_CwZ8kStA_Xt, {
      barCount: 5,
      state: agentState,
      trackRef: audioTrack,
      options: { minHeight: 5 },
      className: 'flex h-full w-auto items-center justify-center gap-3',
      children: (0, jsx_runtime.jsx)('span', {
        className: utils_cn([
          'bg-muted min-h-6 w-6 rounded-full',
          'origin-center transition-colors duration-250 ease-linear',
          'data-[lk-highlighted=true]:bg-foreground data-[lk-muted=true]:bg-muted',
        ]),
      }),
    });
  } // ./components/livekit/chat/hooks/utils.ts

  const useChatMessage = (entry, messageFormatter) => {
    var _a, _b;
    const formattedMessage = react.useMemo(() => {
      return messageFormatter ? messageFormatter(entry.message) : entry.message;
    }, [entry.message, messageFormatter]);
    const hasBeenEdited = !!entry.editTimestamp;
    const time = new Date(entry.timestamp);
    const locale = typeof navigator !== 'undefined' ? navigator.language : 'en-US';
    const name =
      ((_a = entry.from) === null || _a === void 0 ? void 0 : _a.name) && entry.from.name !== ''
        ? entry.from.name
        : (_b = entry.from) === null || _b === void 0
          ? void 0
          : _b.identity;
    return { message: formattedMessage, hasBeenEdited, time, locale, name };
  }; // ./components/livekit/chat/chat-entry.tsx

  var chat_entry_rest =
    (undefined && undefined.__rest) ||
    function (s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === 'function')
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };

  const ChatEntry = (_a) => {
    var _b, _c;
    var { entry, messageFormatter, hideName, hideTimestamp, className, ref } = _a,
      props = chat_entry_rest(_a, [
        'entry',
        'messageFormatter',
        'hideName',
        'hideTimestamp',
        'className',
        'ref',
      ]);
    const { message, hasBeenEdited, time, locale, name } = useChatMessage(entry, messageFormatter);
    const isUser =
      (_c = (_b = entry.from) === null || _b === void 0 ? void 0 : _b.isLocal) !== null &&
      _c !== void 0
        ? _c
        : false;
    const messageOrigin = isUser ? 'remote' : 'local';
    return (0, jsx_runtime.jsxs)(
      'li',
      Object.assign(
        {
          ref: ref,
          'data-lk-message-origin': messageOrigin,
          title: time.toLocaleTimeString(locale, { timeStyle: 'full' }),
          className: utils_cn('group flex flex-col gap-0.5', className),
        },
        props,
        {
          children: [
            (!hideTimestamp || !hideName || hasBeenEdited) &&
              (0, jsx_runtime.jsxs)('span', {
                className: 'text-muted-foreground flex text-sm',
                children: [
                  !hideName &&
                    (0, jsx_runtime.jsx)('strong', { className: 'mt-2', children: name }),
                  !hideTimestamp &&
                    (0, jsx_runtime.jsxs)('span', {
                      className:
                        'align-self-end ml-auto font-mono text-xs opacity-0 transition-opacity ease-linear group-hover:opacity-100',
                      children: [
                        hasBeenEdited && '*',
                        time.toLocaleTimeString(locale, { timeStyle: 'short' }),
                      ],
                    }),
                ],
              }),
            (0, jsx_runtime.jsx)('span', {
              className: utils_cn(
                'max-w-4/5 rounded-[20px] p-2 text-sm',
                isUser ? 'bg-bg3 ml-auto' : 'mr-auto'
              ),
              children: message,
            }),
          ],
        }
      )
    );
  }; // ./components/embed-popup/transcript.tsx

  const ChatEntryMotion = motion.create(ChatEntry);
  function Transcript({ ref, messages, className }) {
    const transcriptRef = (0, react.useRef)(null);
    const handleRef = (0, react.useCallback)(
      (node) => {
        transcriptRef.current = node;
        if (ref) {
          if (typeof ref === 'function') {
            ref(node);
          } else {
            ref.current = node;
          }
        }
      },
      [ref]
    );
    // auto scroll transcript
    (0, react.useEffect)(() => {
      function scrollToBottom() {
        const scrollingElement = transcriptRef.current;
        if (scrollingElement) {
          scrollingElement.scrollTop = scrollingElement.scrollHeight;
        }
      }
      if (transcriptRef.current) {
        const resizeObserver = new ResizeObserver(scrollToBottom);
        resizeObserver.observe(transcriptRef.current);
        scrollToBottom();
        return () => resizeObserver.disconnect();
      }
    }, [messages]);
    return (0, jsx_runtime.jsx)('div', {
      ref: handleRef,
      className: utils_cn(
        'scrollbar-on-hover flex grow flex-col overflow-x-hidden overflow-y-scroll py-3 pr-3 pl-1',
        '[mask-image:linear-gradient(0deg,rgba(0,0,0,0.2)_0%,rgba(0,0,0,1)_5%,rgba(0,0,0,1)_95%,rgba(0,0,0,0)_100%)]',
        className
      ),
      children: (0, jsx_runtime.jsx)('div', {
        className: 'flex flex-1 flex-col justify-end gap-2 pt-16',
        children: (0, jsx_runtime.jsx)(AnimatePresence, {
          children: messages.map((message) =>
            (0, jsx_runtime.jsx)(
              ChatEntryMotion,
              {
                hideName: true,
                initial: { opacity: 0, height: 0 },
                animate: { opacity: 1, height: 'auto' },
                exit: { opacity: 1, height: 'auto', translateY: 0.001 },
                transition: { duration: 0.5, ease: 'easeOut' },
                entry: message,
              },
              message.id
            )
          ),
        }),
      }),
    });
  } // ./hooks/use-chat-and-transcription.ts

  function useChatAndTranscription() {
    const transcriptions = hooks_4Z76Vz30_pn();
    const chat = hooks_4Z76Vz30_sn();
    const room = zs();
    const mergedTranscriptions = (0, react.useMemo)(() => {
      const merged = [
        ...transcriptions.map((transcription) => transcriptionToChatMessage(transcription, room)),
        ...chat.chatMessages,
      ];
      return merged.sort((a, b) => a.timestamp - b.timestamp);
    }, [transcriptions, chat.chatMessages, room]);
    return { messages: mergedTranscriptions, send: chat.send };
  } // ./hooks/useDebug.ts

  const useDebugMode = (options = {}) => {
    var _a, _b;
    const room = zs();
    const logLevel = (_a = options.logLevel) !== null && _a !== void 0 ? _a : 'debug';
    const enabled = (_b = options.enabled) !== null && _b !== void 0 ? _b : true;
    react.useEffect(() => {
      if (!enabled) {
        setLogLevel('silent');
        return;
      }
      setLogLevel(logLevel !== null && logLevel !== void 0 ? logLevel : 'debug');
      // @ts-expect-error this is a global variable
      window.__lk_room = room;
      return () => {
        // @ts-expect-error this is a global variable
        window.__lk_room = undefined;
        setLogLevel('silent');
      };
    }, [room, enabled, logLevel]);
  }; // ./components/embed-popup/popup-view.tsx

  ('use client');

  const TILE_TRANSITION = {
    type: 'spring',
    stiffness: 675,
    damping: 75,
    mass: 1,
  };
  const TranscriptMotion = motion.create(Transcript);
  function useLocalTrackRef(source) {
    const { localParticipant } = hooks_4Z76Vz30_it();
    const publication = localParticipant.getTrackPublication(source);
    const trackRef = (0, react.useMemo)(
      () => (publication ? { source, participant: localParticipant, publication } : undefined),
      [source, publication, localParticipant]
    );
    return trackRef;
  }
  function isAgentAvailable(agentState) {
    return agentState == 'listening' || agentState == 'thinking' || agentState == 'speaking';
  }
  const PopupView = ({ appConfig, disabled, sessionStarted, onEmbedError, ref }) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
    useDebugMode();
    const room = zs();
    const {
      state: agentState,
      audioTrack: agentAudioTrack,
      videoTrack: agentVideoTrack,
    } = hooks_4Z76Vz30_ln();
    const { isCameraEnabled, isScreenShareEnabled } = hooks_4Z76Vz30_it();
    const [screenShareTrack] = hooks_4Z76Vz30_tn([Track.Source.ScreenShare]);
    const cameraTrack = useLocalTrackRef(Track.Source.Camera);
    const [chatOpen, setChatOpen] = (0, react.useState)(false);
    const { messages, send } = useChatAndTranscription();
    const { supportsChatInput, supportsVideoInput, supportsScreenShare } = appConfig;
    const capabilities = {
      supportsChatInput,
      supportsVideoInput,
      supportsScreenShare,
    };
    async function onSendMessage(message) {
      await send(message);
      return;
    }
    // If the agent hasn't connected after an interval,
    // then show an error - something must not be working
    (0, react.useEffect)(() => {
      if (!sessionStarted) {
        return;
      }
      const timeout = setTimeout(() => {
        if (!isAgentAvailable(agentState)) {
          const reason =
            agentState === 'connecting'
              ? 'Agent did not join the room. '
              : 'Agent connected but did not complete initializing. ';
          onEmbedError({
            title: 'Session ended',
            description: (0, jsx_runtime.jsx)('p', { className: 'w-full', children: reason }),
          });
        }
      }, 10000);
      return () => clearTimeout(timeout);
    }, [agentState, sessionStarted, room, onEmbedError]);
    return (0, jsx_runtime.jsx)('div', {
      ref: ref,
      inert: disabled,
      className: 'flex h-full w-full flex-col overflow-hidden',
      children: (0, jsx_runtime.jsxs)('div', {
        className: 'relative flex h-full shrink-1 grow-1 flex-col',
        children: [
          (0, jsx_runtime.jsx)(TranscriptMotion, {
            initial: {
              y: 10,
              opacity: 0,
            },
            animate: {
              y: chatOpen ? 0 : 10,
              opacity: chatOpen ? 1 : 0,
            },
            transition: {
              type: 'spring',
              duration: 0.5,
              bounce: 0,
            },
            messages: messages,
          }),
          (0, jsx_runtime.jsx)(AnimatePresence, {
            children:
              !agentVideoTrack &&
              (0, jsx_runtime.jsx)(
                motion.div,
                {
                  initial: {
                    scale: 1,
                    left: '50%',
                    top: '50%',
                    translateX: '-50%',
                    translateY: '-50%',
                    transformOrigin: 'center top',
                  },
                  animate: {
                    left: chatOpen && (isCameraEnabled || isScreenShareEnabled) ? '39%' : '50%',
                    scale: chatOpen ? 0.275 : 1,
                    top: chatOpen ? '12px' : '50%',
                    translateY: chatOpen ? '0' : '-50%',
                    transformOrigin: chatOpen ? 'center top' : 'center center',
                  },
                  transition: TILE_TRANSITION,
                  className: utils_cn(
                    'bg-bg1 dark:bg-bg2 pointer-events-none absolute flex aspect-square w-64 items-center justify-center rounded-2xl border border-transparent transition-colors',
                    chatOpen && 'border-separator1 dark:border-separator2 drop-shadow-2xl'
                  ),
                  children: (0, jsx_runtime.jsx)(AudioVisualizer, {
                    agentState: agentState,
                    audioTrack: agentAudioTrack,
                  }),
                },
                'audio-visualizer'
              ),
          }),
          (0, jsx_runtime.jsx)(AnimatePresence, {
            children:
              agentVideoTrack &&
              (0, jsx_runtime.jsx)(
                motion.div,
                {
                  initial: {
                    maskImage:
                      'radial-gradient(circle, rgba(0, 0, 0, 1) 0, rgba(0, 0, 0, 1) 40px, transparent 40px)',
                    filter: 'blur(20px)',
                  },
                  animate: {
                    opacity: chatOpen ? 0 : 1,
                    maskImage:
                      'radial-gradient(circle, rgba(0, 0, 0, 1) 0, rgba(0, 0, 0, 1) 500px, transparent 500px)',
                    filter: 'blur(0px)',
                  },
                  transition: {
                    opacity: {
                      ease: 'linear',
                      duration: 0.2,
                    },
                    maskImage: {
                      ease: 'linear',
                      duration: 1,
                    },
                    filter: {
                      ease: 'linear',
                      duration: 1,
                    },
                  },
                  className:
                    'border-separator1 dark:border-separator2 pointer-events-none absolute inset-1 drop-shadow-lg/20',
                  children: (0, jsx_runtime.jsx)(components_CwZ8kStA_Ft, {
                    trackRef: agentVideoTrack,
                    width:
                      (_b =
                        (_a =
                          agentVideoTrack === null || agentVideoTrack === void 0
                            ? void 0
                            : agentVideoTrack.publication.dimensions) === null || _a === void 0
                          ? void 0
                          : _a.width) !== null && _b !== void 0
                        ? _b
                        : 0,
                    height:
                      (_d =
                        (_c =
                          agentVideoTrack === null || agentVideoTrack === void 0
                            ? void 0
                            : agentVideoTrack.publication.dimensions) === null || _c === void 0
                          ? void 0
                          : _c.height) !== null && _d !== void 0
                        ? _d
                        : 0,
                    className: 'h-full rounded-[24px] bg-black object-cover',
                  }),
                },
                'avatar'
              ),
          }),
          (0, jsx_runtime.jsx)(AnimatePresence, {
            children:
              agentVideoTrack &&
              chatOpen &&
              (0, jsx_runtime.jsx)(
                motion.div,
                {
                  initial: {
                    opacity: 0,
                    scale: 0.5,
                    left: isCameraEnabled || isScreenShareEnabled ? '39%' : '50%',
                    top: '12px',
                    translateX: '-50%',
                    transformOrigin: 'center top',
                  },
                  animate: {
                    opacity: 1,
                    scale: 1,
                    left: isCameraEnabled || isScreenShareEnabled ? '37.5%' : '50%',
                  },
                  transition: TILE_TRANSITION,
                  className:
                    'border-separator1 dark:border-separator2 pointer-events-none absolute drop-shadow-lg/20',
                  children: (0, jsx_runtime.jsx)(components_CwZ8kStA_Ft, {
                    trackRef: agentVideoTrack,
                    width:
                      (_f =
                        (_e =
                          agentVideoTrack === null || agentVideoTrack === void 0
                            ? void 0
                            : agentVideoTrack.publication.dimensions) === null || _e === void 0
                          ? void 0
                          : _e.width) !== null && _f !== void 0
                        ? _f
                        : 0,
                    height:
                      (_h =
                        (_g =
                          agentVideoTrack === null || agentVideoTrack === void 0
                            ? void 0
                            : agentVideoTrack.publication.dimensions) === null || _g === void 0
                          ? void 0
                          : _g.height) !== null && _h !== void 0
                        ? _h
                        : 0,
                    className: 'aspect-square w-[70px] rounded-md bg-black object-cover',
                  }),
                },
                'audio-visualizer'
              ),
          }),
          (0, jsx_runtime.jsx)(AnimatePresence, {
            children:
              ((cameraTrack && isCameraEnabled) || (screenShareTrack && isScreenShareEnabled)) &&
              (0, jsx_runtime.jsx)(
                motion.div,
                {
                  initial: {
                    scale: 0.5,
                    opacity: 0,
                    right: '12px',
                    top: '346px',
                    transformOrigin: 'center bottom',
                  },
                  animate: {
                    scale: 1,
                    opacity: 1,
                    top: chatOpen ? '12px' : '346px',
                    right: chatOpen ? '106px' : '12px',
                    transformOrigin: chatOpen ? 'center top' : 'center bottom',
                  },
                  exit: {
                    scale: 0.5,
                    opacity: 0,
                  },
                  transition: TILE_TRANSITION,
                  className:
                    'border-separator1 dark:border-separator2 pointer-events-none absolute drop-shadow-lg/20',
                  children: (0, jsx_runtime.jsx)(components_CwZ8kStA_Ft, {
                    trackRef: cameraTrack || screenShareTrack,
                    width:
                      (_l =
                        (_k =
                          (_j = cameraTrack || screenShareTrack) === null || _j === void 0
                            ? void 0
                            : _j.publication.dimensions) === null || _k === void 0
                          ? void 0
                          : _k.width) !== null && _l !== void 0
                        ? _l
                        : 0,
                    height:
                      (_p =
                        (_o =
                          (_m = cameraTrack || screenShareTrack) === null || _m === void 0
                            ? void 0
                            : _m.publication.dimensions) === null || _o === void 0
                          ? void 0
                          : _o.height) !== null && _p !== void 0
                        ? _p
                        : 0,
                    className: 'aspect-square w-[70px] rounded-md bg-black object-cover',
                  }),
                },
                'camera'
              ),
          }),
          (0, jsx_runtime.jsx)(motion.div, {
            initial: {
              opacity: 0,
              translateY: 8,
            },
            animate: {
              opacity: sessionStarted ? 1 : 0,
              translateY: sessionStarted ? 0 : 8,
            },
            transition: {
              delay: 0.5,
            },
            children: (0, jsx_runtime.jsx)(ActionBar, {
              capabilities: capabilities,
              onSendMessage: onSendMessage,
              onChatOpenChange: setChatOpen,
            }),
          }),
        ],
      }),
    });
  }; // ./node_modules/.pnpm/@phosphor-icons+react@2.1.10_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/@phosphor-icons/react/dist/defs/X.es.js

  const X_es_a = /* @__PURE__ */ new Map([
    [
      'bold',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M208.49,191.51a12,12,0,0,1-17,17L128,145,64.49,208.49a12,12,0,0,1-17-17L111,128,47.51,64.49a12,12,0,0,1,17-17L128,111l63.51-63.52a12,12,0,0,1,17,17L145,128Z',
        })
      ),
    ],
    [
      'duotone',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M216,56V200a16,16,0,0,1-16,16H56a16,16,0,0,1-16-16V56A16,16,0,0,1,56,40H200A16,16,0,0,1,216,56Z',
          opacity: '0.2',
        }),
        /* @__PURE__ */ react.createElement('path', {
          d: 'M205.66,194.34a8,8,0,0,1-11.32,11.32L128,139.31,61.66,205.66a8,8,0,0,1-11.32-11.32L116.69,128,50.34,61.66A8,8,0,0,1,61.66,50.34L128,116.69l66.34-66.35a8,8,0,0,1,11.32,11.32L139.31,128Z',
        })
      ),
    ],
    [
      'fill',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M208,32H48A16,16,0,0,0,32,48V208a16,16,0,0,0,16,16H208a16,16,0,0,0,16-16V48A16,16,0,0,0,208,32ZM181.66,170.34a8,8,0,0,1-11.32,11.32L128,139.31,85.66,181.66a8,8,0,0,1-11.32-11.32L116.69,128,74.34,85.66A8,8,0,0,1,85.66,74.34L128,116.69l42.34-42.35a8,8,0,0,1,11.32,11.32L139.31,128Z',
        })
      ),
    ],
    [
      'light',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M204.24,195.76a6,6,0,1,1-8.48,8.48L128,136.49,60.24,204.24a6,6,0,0,1-8.48-8.48L119.51,128,51.76,60.24a6,6,0,0,1,8.48-8.48L128,119.51l67.76-67.75a6,6,0,0,1,8.48,8.48L136.49,128Z',
        })
      ),
    ],
    [
      'regular',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M205.66,194.34a8,8,0,0,1-11.32,11.32L128,139.31,61.66,205.66a8,8,0,0,1-11.32-11.32L116.69,128,50.34,61.66A8,8,0,0,1,61.66,50.34L128,116.69l66.34-66.35a8,8,0,0,1,11.32,11.32L139.31,128Z',
        })
      ),
    ],
    [
      'thin',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M202.83,197.17a4,4,0,0,1-5.66,5.66L128,133.66,58.83,202.83a4,4,0,0,1-5.66-5.66L122.34,128,53.17,58.83a4,4,0,0,1,5.66-5.66L128,122.34l69.17-69.17a4,4,0,1,1,5.66,5.66L133.66,128Z',
        })
      ),
    ],
  ]); // ./node_modules/.pnpm/@phosphor-icons+react@2.1.10_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/@phosphor-icons/react/dist/csr/X.es.js

  const X_es_e = react.forwardRef((r, t) =>
    /* @__PURE__ */ react.createElement(p, { ref: t, ...r, weights: X_es_a })
  );
  X_es_e.displayName = 'XIcon';
  const X_es_n = /* unused pure expression or super */ null && X_es_e; // ./node_modules/.pnpm/@phosphor-icons+react@2.1.10_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/@phosphor-icons/react/dist/defs/PhoneDisconnect.es.js

  const PhoneDisconnect_es_l = /* @__PURE__ */ new Map([
    [
      'bold',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M234.39,87.29c-57.67-57.72-155.11-57.72-212.78,0-21.45,21.47-23.52,53.13-5,77a20,20,0,0,0,22.92,6.37L88.4,153.29l.45-.16A20,20,0,0,0,101,138.47l5.44-27.24a72.48,72.48,0,0,1,42.76-.09L155,138.62a20,20,0,0,0,12.14,14.49l.45.17,48.94,17.37a20,20,0,0,0,22.91-6.37C257.91,140.42,255.84,108.76,234.39,87.29Zm-12.23,59.9L178,131.5,172.24,104a20,20,0,0,0-13-14.8,96.49,96.49,0,0,0-62.94.14A20,20,0,0,0,83.4,104.24L78,131.53,33.84,147.19c-9.16-13.85-7.41-30.77,4.73-42.92C62.81,80,95.41,67.88,128,67.88S193.19,80,217.43,104.27C229.57,116.42,231.32,133.35,222.16,147.19ZM228,200a12,12,0,0,1-12,12H40a12,12,0,0,1,0-24H216A12,12,0,0,1,228,200Z',
        })
      ),
    ],
    [
      'duotone',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M230,157a8,8,0,0,1-9.26,2.47L171.58,142a8,8,0,0,1-4.86-5.8l-6.21-29.74a7.94,7.94,0,0,0-5.14-5.9,84.39,84.39,0,0,0-55.1.13,7.93,7.93,0,0,0-5.12,6l-5.9,29.51A8,8,0,0,1,84.38,142L35.29,159.42A8,8,0,0,1,26,157c-14.6-18.83-13.26-43.83,4-61.12,53.11-53.11,142.77-53.11,195.88,0C243.23,113.12,244.57,138.12,230,157Z',
          opacity: '0.2',
        }),
        /* @__PURE__ */ react.createElement('path', {
          d: 'M231.59,90.13h0C175.44,34,80.56,34,24.41,90.13c-20,20-21.92,49.49-4.69,71.71A16,16,0,0,0,32.35,168a15.8,15.8,0,0,0,5.75-1.08l49-17.37.29-.11a16,16,0,0,0,9.75-11.73l5.9-29.52a76.52,76.52,0,0,1,49.68-.11h0l6.21,29.75a16,16,0,0,0,9.72,11.59l.29.11,49,17.39a16,16,0,0,0,18.38-5.06C253.51,139.62,251.58,110.13,231.59,90.13ZM223.67,152l-.3-.12-48.82-17.33-6.21-29.74A16,16,0,0,0,158,93a92.56,92.56,0,0,0-60.34.13,16,16,0,0,0-10.32,12l-5.9,29.51L32.63,151.86c-.1,0-.17.13-.27.17-12.33-15.91-11-36.23,3.36-50.58,25-25,58.65-37.53,92.28-37.53s67.27,12.51,92.28,37.53C234.61,115.8,236,136.12,223.67,152Zm.32,48a8,8,0,0,1-8,8H40a8,8,0,0,1,0-16H216A8,8,0,0,1,224,200Z',
        })
      ),
    ],
    [
      'fill',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M236.28,161.84a16,16,0,0,1-18.38,5.06l-49-17.39-.29-.11a16,16,0,0,1-9.72-11.59l-6.21-29.75h0a76.52,76.52,0,0,0-49.68.11l-5.9,29.52a16,16,0,0,1-9.75,11.73l-.29.11-49,17.37A15.8,15.8,0,0,1,32.35,168a16,16,0,0,1-12.63-6.14c-17.23-22.22-15.3-51.71,4.69-71.71,56.15-56.17,151-56.17,207.18,0h0C251.58,110.13,253.51,139.62,236.28,161.84ZM216,192H40a8,8,0,0,0,0,16H216a8,8,0,0,0,0-16Z',
        })
      ),
    ],
    [
      'light',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M230.19,91.55h0c-55.39-55.4-149-55.4-204.38,0C6.56,110.82,4.7,139.22,21.29,160.61A14,14,0,0,0,37.39,165l49-17.38.22-.09a13.93,13.93,0,0,0,8.53-10.25l5.9-29.52a1.93,1.93,0,0,1,1.21-1.47,78.53,78.53,0,0,1,51.18-.11,1.93,1.93,0,0,1,1.22,1.45l6.21,29.75a14,14,0,0,0,8.5,10.14l.23.08,49,17.4a14,14,0,0,0,16.1-4.42C251.3,139.22,249.44,110.82,230.19,91.55Zm-5,61.71a2,2,0,0,1-2.29.58l-.22-.09-49-17.38A2,2,0,0,1,172.6,135l-6.22-29.74a14,14,0,0,0-9.06-10.35,90.53,90.53,0,0,0-59,.13,14,14,0,0,0-9,10.45L83.37,135a2,2,0,0,1-1.15,1.44L33.28,153.75l-.22.09a2,2,0,0,1-2.29-.58c-13-16.74-11.56-38.12,3.53-53.22,25.39-25.4,59.55-38.1,93.7-38.1s68.31,12.7,93.7,38.1C236.79,115.14,238.21,136.52,225.23,153.26ZM222,200a6,6,0,0,1-6,6H40a6,6,0,0,1,0-12H216A6,6,0,0,1,222,200Z',
        })
      ),
    ],
    [
      'regular',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M231.59,90.13h0C175.44,34,80.56,34,24.41,90.13c-20,20-21.92,49.49-4.69,71.71A16,16,0,0,0,32.35,168a15.8,15.8,0,0,0,5.75-1.08l49-17.37.29-.11a16,16,0,0,0,9.75-11.73l5.9-29.52a76.52,76.52,0,0,1,49.68-.11h0l6.21,29.75a16,16,0,0,0,9.72,11.59l.29.11,49,17.39a16,16,0,0,0,18.38-5.06C253.51,139.62,251.58,110.13,231.59,90.13ZM223.67,152l-.3-.12-48.82-17.33-6.21-29.74A16,16,0,0,0,158,93a92.56,92.56,0,0,0-60.34.13,16,16,0,0,0-10.32,12l-5.9,29.51L32.63,151.86c-.1,0-.17.13-.27.17-12.33-15.91-11-36.23,3.36-50.58,25-25,58.65-37.53,92.28-37.53s67.27,12.51,92.28,37.53C234.61,115.8,236,136.12,223.67,152Zm.32,48a8,8,0,0,1-8,8H40a8,8,0,0,1,0-16H216A8,8,0,0,1,224,200Z',
        })
      ),
    ],
    [
      'thin',
      /* @__PURE__ */ react.createElement(
        react.Fragment,
        null,
        /* @__PURE__ */ react.createElement('path', {
          d: 'M228.79,93C174.15,38.34,81.85,38.34,27.21,93,8.69,111.5,6.9,138.81,22.85,159.39a12,12,0,0,0,13.83,3.77l49-17.39.15-.06a12,12,0,0,0,7.31-8.79l5.9-29.51a3.93,3.93,0,0,1,2.51-3,80.59,80.59,0,0,1,52.5-.12,3.94,3.94,0,0,1,2.52,2.94L162.81,137a12,12,0,0,0,7.29,8.69l.15.06,49.07,17.41a12,12,0,0,0,13.83-3.77C249.1,138.81,247.31,111.5,228.79,93Zm-2,61.51a4,4,0,0,1-4.61,1.21l-.15-.06L173,138.24a4,4,0,0,1-2.37-2.87l-6.21-29.75a12,12,0,0,0-7.75-8.87,88.63,88.63,0,0,0-57.74.14,12,12,0,0,0-7.72,9l-5.9,29.51A4,4,0,0,1,83,138.26l-49,17.38-.15.06a4,4,0,0,1-4.61-1.21c-13.42-17.3-11.9-40.26,3.69-55.85C58.65,72.85,93.33,60,128,60s69.35,12.89,95.13,38.68C238.71,114.23,240.24,137.19,226.82,154.49ZM220,200a4,4,0,0,1-4,4H40a4,4,0,0,1,0-8H216A4,4,0,0,1,220,200Z',
        })
      ),
    ],
  ]); // ./node_modules/.pnpm/@phosphor-icons+react@2.1.10_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/@phosphor-icons/react/dist/csr/PhoneDisconnect.es.js

  const PhoneDisconnect_es_e = react.forwardRef((n, c) =>
    /* @__PURE__ */ react.createElement(p, { ref: c, ...n, weights: PhoneDisconnect_es_l })
  );
  PhoneDisconnect_es_e.displayName = 'PhoneDisconnectIcon';
  const PhoneDisconnect_es_i = /* unused pure expression or super */ null && PhoneDisconnect_es_e; // ./components/embed-popup/trigger.tsx

  const AnimatedButton = motion.create(Button);
  function trigger_Trigger({ error = null, popupOpen, onToggle }) {
    const { state: agentState } = hooks_4Z76Vz30_ln();
    const isAgentConnecting =
      popupOpen && (agentState === 'connecting' || agentState === 'initializing');
    const isAgentConnected =
      popupOpen &&
      agentState !== 'disconnected' &&
      agentState !== 'connecting' &&
      agentState !== 'initializing';
    return (0, jsx_runtime.jsx)(AnimatePresence, {
      children: (0, jsx_runtime.jsxs)(
        AnimatedButton,
        {
          size: 'lg',
          initial: {
            scale: 0,
          },
          animate: {
            scale: 1,
          },
          exit: { scale: 0 },
          transition: {
            type: 'spring',
            duration: 1,
            bounce: 0.2,
          },
          onClick: onToggle,
          className: utils_cn(
            'relative m-0 block size-12 p-0.5 drop-shadow-md',
            'scale-100 transition-[scale] duration-300 hover:scale-105 focus:scale-105',
            'fixed right-4 bottom-4 z-50'
          ),
          children: [
            (0, jsx_runtime.jsx)(motion.div, {
              className: utils_cn(
                'absolute inset-0 z-10 rounded-full transition-colors',
                !popupOpen && 'bg-fgAccent',
                !error &&
                  isAgentConnecting &&
                  'bg-fgAccent/30 animate-spin [background-image:conic-gradient(from_0deg,transparent_0%,transparent_30%,var(--color-fgAccent)_50%,transparent_70%,transparent_100%)]',
                (isAgentConnected || (error && popupOpen)) && 'bg-destructive-foreground'
              ),
            }),
            (0, jsx_runtime.jsx)('div', {
              className: utils_cn(
                'relative z-20 grid size-11 place-items-center rounded-full transition-colors',
                !popupOpen && 'bg-fgAccent',
                !error && isAgentConnecting && 'bg-bg1',
                (isAgentConnected || (error && popupOpen)) && 'bg-destructive'
              ),
              children: (0, jsx_runtime.jsxs)(AnimatePresence, {
                children: [
                  !popupOpen &&
                    (0, jsx_runtime.jsx)(
                      motion.div,
                      {
                        initial: { opacity: 0, y: -20 },
                        animate: { opacity: 1, y: 0 },
                        exit: { opacity: 0, y: popupOpen ? 20 : -20 },
                        className: 'absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2',
                        children: (0, jsx_runtime.jsx)('div', {
                          className: 'bg-bg1 size-5',
                          // webpack build throws if I use custom tailwind classes to achive this
                          style: {
                            maskImage: 'url(/lk-logo.svg)',
                            maskSize: 'contain',
                          },
                        }),
                      },
                      'lk-logo'
                    ),
                  (isAgentConnecting || (error && popupOpen)) &&
                    (0, jsx_runtime.jsx)(
                      motion.div,
                      {
                        initial: { opacity: 0, y: 20 },
                        animate: { opacity: 1, y: 0 },
                        exit: { opacity: 0, y: popupOpen ? -20 : 20 },
                        className: 'absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2',
                        children: (0, jsx_runtime.jsx)(X_es_e, {
                          size: 20,
                          weight: 'bold',
                          className: utils_cn(
                            'text-fg0 size-5',
                            error && 'text-destructive-foreground'
                          ),
                        }),
                      },
                      'dismiss'
                    ),
                  !error &&
                    isAgentConnected &&
                    (0, jsx_runtime.jsx)(
                      motion.div,
                      {
                        initial: { opacity: 0, y: 20 },
                        animate: { opacity: 1, y: 0 },
                        exit: { opacity: 0, y: popupOpen ? -20 : 20 },
                        className: 'absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2',
                        children: (0, jsx_runtime.jsx)(PhoneDisconnect_es_e, {
                          size: 20,
                          weight: 'bold',
                          className: 'text-destructive-foreground size-5',
                        }),
                      },
                      'disconnect'
                    ),
                ],
              }),
            }),
          ],
        },
        'trigger-button'
      ),
    });
  } // ./node_modules/.pnpm/jose@6.1.0/node_modules/jose/dist/webapi/lib/buffer_utils.js

  const buffer_utils_encoder = new TextEncoder();
  const buffer_utils_decoder = new TextDecoder();
  const MAX_INT32 = /* unused pure expression or super */ null && 2 ** 32;
  function concat(...buffers) {
    const size = buffers.reduce((acc, { length }) => acc + length, 0);
    const buf = new Uint8Array(size);
    let i = 0;
    for (const buffer of buffers) {
      buf.set(buffer, i);
      i += buffer.length;
    }
    return buf;
  }
  function writeUInt32BE(buf, value, offset) {
    if (value < 0 || value >= MAX_INT32) {
      throw new RangeError(`value must be >= 0 and <= ${MAX_INT32 - 1}. Received ${value}`);
    }
    buf.set([value >>> 24, value >>> 16, value >>> 8, value & 0xff], offset);
  }
  function uint64be(value) {
    const high = Math.floor(value / MAX_INT32);
    const low = value % MAX_INT32;
    const buf = new Uint8Array(8);
    writeUInt32BE(buf, high, 0);
    writeUInt32BE(buf, low, 4);
    return buf;
  }
  function uint32be(value) {
    const buf = new Uint8Array(4);
    writeUInt32BE(buf, value);
    return buf;
  } // ./node_modules/.pnpm/jose@6.1.0/node_modules/jose/dist/webapi/lib/base64.js

  function base64_encodeBase64(input) {
    if (Uint8Array.prototype.toBase64) {
      return input.toBase64();
    }
    const CHUNK_SIZE = 0x8000;
    const arr = [];
    for (let i = 0; i < input.length; i += CHUNK_SIZE) {
      arr.push(String.fromCharCode.apply(null, input.subarray(i, i + CHUNK_SIZE)));
    }
    return btoa(arr.join(''));
  }
  function base64_decodeBase64(encoded) {
    if (Uint8Array.fromBase64) {
      return Uint8Array.fromBase64(encoded);
    }
    const binary = atob(encoded);
    const bytes = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i++) {
      bytes[i] = binary.charCodeAt(i);
    }
    return bytes;
  } // ./node_modules/.pnpm/jose@6.1.0/node_modules/jose/dist/webapi/util/base64url.js

  function base64url_decode(input) {
    if (Uint8Array.fromBase64) {
      return Uint8Array.fromBase64(
        typeof input === 'string' ? input : buffer_utils_decoder.decode(input),
        {
          alphabet: 'base64url',
        }
      );
    }
    let encoded = input;
    if (encoded instanceof Uint8Array) {
      encoded = buffer_utils_decoder.decode(encoded);
    }
    encoded = encoded.replace(/-/g, '+').replace(/_/g, '/').replace(/\s/g, '');
    try {
      return base64_decodeBase64(encoded);
    } catch {
      throw new TypeError('The input to be decoded is not correctly encoded.');
    }
  }
  function encode(input) {
    let unencoded = input;
    if (typeof unencoded === 'string') {
      unencoded = encoder.encode(unencoded);
    }
    if (Uint8Array.prototype.toBase64) {
      return unencoded.toBase64({ alphabet: 'base64url', omitPadding: true });
    }
    return encodeBase64(unencoded).replace(/=/g, '').replace(/\+/g, '-').replace(/\//g, '_');
  } // ./node_modules/.pnpm/jose@6.1.0/node_modules/jose/dist/webapi/lib/is_object.js

  function is_object_isObjectLike(value) {
    return typeof value === 'object' && value !== null;
  }
  /* harmony default export */ const is_object = (input) => {
    if (
      !is_object_isObjectLike(input) ||
      Object.prototype.toString.call(input) !== '[object Object]'
    ) {
      return false;
    }
    if (Object.getPrototypeOf(input) === null) {
      return true;
    }
    let proto = input;
    while (Object.getPrototypeOf(proto) !== null) {
      proto = Object.getPrototypeOf(proto);
    }
    return Object.getPrototypeOf(input) === proto;
  }; // ./node_modules/.pnpm/jose@6.1.0/node_modules/jose/dist/webapi/util/errors.js

  class errors_JOSEError extends Error {
    static code = 'ERR_JOSE_GENERIC';
    code = 'ERR_JOSE_GENERIC';
    constructor(message, options) {
      super(message, options);
      this.name = this.constructor.name;
      Error.captureStackTrace?.(this, this.constructor);
    }
  }
  class errors_JWTClaimValidationFailed extends errors_JOSEError {
    static code = 'ERR_JWT_CLAIM_VALIDATION_FAILED';
    code = 'ERR_JWT_CLAIM_VALIDATION_FAILED';
    claim;
    reason;
    payload;
    constructor(message, payload, claim = 'unspecified', reason = 'unspecified') {
      super(message, { cause: { claim, reason, payload } });
      this.claim = claim;
      this.reason = reason;
      this.payload = payload;
    }
  }
  class errors_JWTExpired extends errors_JOSEError {
    static code = 'ERR_JWT_EXPIRED';
    code = 'ERR_JWT_EXPIRED';
    claim;
    reason;
    payload;
    constructor(message, payload, claim = 'unspecified', reason = 'unspecified') {
      super(message, { cause: { claim, reason, payload } });
      this.claim = claim;
      this.reason = reason;
      this.payload = payload;
    }
  }
  class errors_JOSEAlgNotAllowed
    extends /* unused pure expression or super */ (null && errors_JOSEError)
  {
    static code = /* unused pure expression or super */ null && 'ERR_JOSE_ALG_NOT_ALLOWED';
    code = 'ERR_JOSE_ALG_NOT_ALLOWED';
  }
  class errors_JOSENotSupported
    extends /* unused pure expression or super */ (null && errors_JOSEError)
  {
    static code = /* unused pure expression or super */ null && 'ERR_JOSE_NOT_SUPPORTED';
    code = 'ERR_JOSE_NOT_SUPPORTED';
  }
  class errors_JWEDecryptionFailed extends errors_JOSEError {
    static code = 'ERR_JWE_DECRYPTION_FAILED';
    code = 'ERR_JWE_DECRYPTION_FAILED';
    constructor(message = 'decryption operation failed', options) {
      super(message, options);
    }
  }
  class errors_JWEInvalid extends /* unused pure expression or super */ (null && errors_JOSEError) {
    static code = /* unused pure expression or super */ null && 'ERR_JWE_INVALID';
    code = 'ERR_JWE_INVALID';
  }
  class errors_JWSInvalid extends /* unused pure expression or super */ (null && errors_JOSEError) {
    static code = /* unused pure expression or super */ null && 'ERR_JWS_INVALID';
    code = 'ERR_JWS_INVALID';
  }
  class errors_JWTInvalid extends errors_JOSEError {
    static code = 'ERR_JWT_INVALID';
    code = 'ERR_JWT_INVALID';
  }
  class errors_JWKInvalid extends /* unused pure expression or super */ (null && errors_JOSEError) {
    static code = /* unused pure expression or super */ null && 'ERR_JWK_INVALID';
    code = 'ERR_JWK_INVALID';
  }
  class errors_JWKSInvalid
    extends /* unused pure expression or super */ (null && errors_JOSEError)
  {
    static code = /* unused pure expression or super */ null && 'ERR_JWKS_INVALID';
    code = 'ERR_JWKS_INVALID';
  }
  class errors_JWKSNoMatchingKey extends errors_JOSEError {
    static code = 'ERR_JWKS_NO_MATCHING_KEY';
    code = 'ERR_JWKS_NO_MATCHING_KEY';
    constructor(message = 'no applicable key found in the JSON Web Key Set', options) {
      super(message, options);
    }
  }
  class errors_JWKSMultipleMatchingKeys extends errors_JOSEError {
    [Symbol.asyncIterator];
    static code = 'ERR_JWKS_MULTIPLE_MATCHING_KEYS';
    code = 'ERR_JWKS_MULTIPLE_MATCHING_KEYS';
    constructor(message = 'multiple matching keys found in the JSON Web Key Set', options) {
      super(message, options);
    }
  }
  class errors_JWKSTimeout extends errors_JOSEError {
    static code = 'ERR_JWKS_TIMEOUT';
    code = 'ERR_JWKS_TIMEOUT';
    constructor(message = 'request timed out', options) {
      super(message, options);
    }
  }
  class errors_JWSSignatureVerificationFailed extends errors_JOSEError {
    static code = 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED';
    code = 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED';
    constructor(message = 'signature verification failed', options) {
      super(message, options);
    }
  } // ./node_modules/.pnpm/jose@6.1.0/node_modules/jose/dist/webapi/util/decode_jwt.js

  function decode_jwt_decodeJwt(jwt) {
    if (typeof jwt !== 'string')
      throw new errors_JWTInvalid('JWTs must use Compact JWS serialization, JWT must be a string');
    const { 1: payload, length } = jwt.split('.');
    if (length === 5)
      throw new errors_JWTInvalid('Only JWTs using Compact JWS serialization can be decoded');
    if (length !== 3) throw new errors_JWTInvalid('Invalid JWT');
    if (!payload) throw new errors_JWTInvalid('JWTs must contain a payload');
    let decoded;
    try {
      decoded = base64url_decode(payload);
    } catch {
      throw new errors_JWTInvalid('Failed to base64url decode the payload');
    }
    let result;
    try {
      result = JSON.parse(buffer_utils_decoder.decode(decoded));
    } catch {
      throw new errors_JWTInvalid('Failed to parse the decoded payload as JSON');
    }
    if (!is_object(result)) throw new errors_JWTInvalid('Invalid JWT Claims Set');
    return result;
  } // ./hooks/use-connection-details.ts

  const use_connection_details_ONE_MINUTE_IN_MILLISECONDS = 60 * 1000;
  function useConnectionDetails(appConfig) {
    // Generate room connection details, including:
    //   - A random Room name
    //   - A random Participant name
    //   - An Access Token to permit the participant to join the room
    //   - The URL of the LiveKit server to connect to
    //
    // In real-world application, you would likely allow the user to specify their
    // own participant name, and possibly to choose from existing rooms to join.
    const [connectionDetails, setConnectionDetails] = (0, react.useState)(null);
    const fetchConnectionDetails = (0, react.useCallback)(async () => {
      var _a, _b;
      setConnectionDetails(null);
      const url = new URL(
        (_a = 'MISSING_ENV_VAR'.NEXT_PUBLIC_CONN_DETAILS_ENDPOINT) !== null && _a !== void 0
          ? _a
          : '/api/connection-details',
        window.location.origin
      );
      let data;
      try {
        const res = await fetch(url.toString(), {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-Sandbox-Id': (_b = appConfig.sandboxId) !== null && _b !== void 0 ? _b : '',
          },
          body: JSON.stringify({
            room_config: appConfig.agentName
              ? {
                  agents: [{ agent_name: appConfig.agentName }],
                }
              : undefined,
          }),
        });
        data = await res.json();
      } catch (error) {
        console.error('Error fetching connection details:', error);
        throw new Error('Error fetching connection details!');
      }
      setConnectionDetails(data);
      return data;
    }, []);
    (0, react.useEffect)(() => {
      fetchConnectionDetails();
    }, [fetchConnectionDetails]);
    const isConnectionDetailsExpired = (0, react.useCallback)(() => {
      const token =
        connectionDetails === null || connectionDetails === void 0
          ? void 0
          : connectionDetails.participantToken;
      if (!token) {
        return true;
      }
      const jwtPayload = decode_jwt_decodeJwt(token);
      if (!jwtPayload.exp) {
        return true;
      }
      const expiresAt = new Date(
        jwtPayload.exp - use_connection_details_ONE_MINUTE_IN_MILLISECONDS
      );
      const now = new Date();
      return expiresAt >= now;
    }, [
      connectionDetails === null || connectionDetails === void 0
        ? void 0
        : connectionDetails.participantToken,
    ]);
    const existingOrRefreshConnectionDetails = (0, react.useCallback)(async () => {
      if (isConnectionDetailsExpired() || !connectionDetails) {
        return fetchConnectionDetails();
      } else {
        return connectionDetails;
      }
    }, [connectionDetails, fetchConnectionDetails, isConnectionDetailsExpired]);
    return {
      connectionDetails,
      refreshConnectionDetails: fetchConnectionDetails,
      existingOrRefreshConnectionDetails,
    };
  } // ./components/embed-popup/agent-client.tsx

  ('use client');

  const PopupViewMotion = motion.create(PopupView);
  function AgentClient({ appConfig }) {
    const isAnimating = (0, react.useRef)(false);
    const room = (0, react.useMemo)(() => new Room(), []);
    const [popupOpen, setPopupOpen] = (0, react.useState)(false);
    const [error, setError] = (0, react.useState)(null);
    const { connectionDetails, refreshConnectionDetails, existingOrRefreshConnectionDetails } =
      useConnectionDetails(appConfig);
    const handleTogglePopup = () => {
      if (isAnimating.current) {
        // prevent re-opening before room has disconnected
        return;
      }
      setError(null);
      setPopupOpen((open) => !open);
    };
    const handlePanelAnimationStart = () => {
      isAnimating.current = true;
    };
    const handlePanelAnimationComplete = () => {
      isAnimating.current = false;
      if (!popupOpen && room.state !== 'disconnected') {
        room.disconnect();
      }
    };
    (0, react.useEffect)(() => {
      const onDisconnected = () => {
        setPopupOpen(false);
        refreshConnectionDetails();
      };
      const onMediaDevicesError = (error) => {
        setError({
          title: 'Encountered an error with your media devices',
          description: `${error.name}: ${error.message}`,
        });
      };
      room.on(RoomEvent.MediaDevicesError, onMediaDevicesError);
      room.on(RoomEvent.Disconnected, onDisconnected);
      return () => {
        room.off(RoomEvent.Disconnected, onDisconnected);
        room.off(RoomEvent.MediaDevicesError, onMediaDevicesError);
      };
    }, [room, refreshConnectionDetails]);
    (0, react.useEffect)(() => {
      if (!popupOpen) {
        return;
      }
      if (!connectionDetails) {
        setError({
          title: 'Error fetching connection details',
          description: 'Please try again later',
        });
        return;
      }
      if (room.state !== 'disconnected') {
        return;
      }
      const connect = async () => {
        Promise.all([
          room.localParticipant.setMicrophoneEnabled(true, undefined, {
            preConnectBuffer: appConfig.isPreConnectBufferEnabled,
          }),
          existingOrRefreshConnectionDetails().then((connectionDetails) =>
            room.connect(connectionDetails.serverUrl, connectionDetails.participantToken)
          ),
        ]).catch((error) => {
          if (error instanceof Error) {
            console.error('Error connecting to agent:', error);
            setError({
              title: 'There was an error connecting to the agent',
              description: `${error.name}: ${error.message}`,
            });
          }
        });
      };
      connect();
    }, [
      room,
      popupOpen,
      connectionDetails,
      existingOrRefreshConnectionDetails,
      appConfig.isPreConnectBufferEnabled,
    ]);
    return (0, jsx_runtime.jsxs)(Wn.Provider, {
      value: room,
      children: [
        (0, jsx_runtime.jsx)(Ra, {}),
        (0, jsx_runtime.jsx)(da, { label: 'Start Audio' }),
        (0, jsx_runtime.jsx)(trigger_Trigger, {
          error: error,
          popupOpen: popupOpen,
          onToggle: handleTogglePopup,
        }),
        (0, jsx_runtime.jsx)(motion.div, {
          inert: !popupOpen,
          initial: {
            opacity: 0,
            translateY: 8,
          },
          animate: {
            opacity: popupOpen ? 1 : 0,
            translateY: popupOpen ? 0 : 8,
          },
          transition: {
            type: 'spring',
            bounce: 0,
            duration: popupOpen ? 1 : 0.2,
          },
          onAnimationStart: handlePanelAnimationStart,
          onAnimationComplete: handlePanelAnimationComplete,
          className: 'fixed right-4 bottom-20 left-4 z-50 md:left-auto',
          children: (0, jsx_runtime.jsx)('div', {
            className:
              'bg-bg1 dark:bg-bg2 border-separator1 dark:border-separator2 ml-auto h-[480px] w-full rounded-[28px] border border-solid drop-shadow-md md:w-[360px]',
            children: (0, jsx_runtime.jsxs)('div', {
              className: 'relative h-full w-full',
              children: [
                (0, jsx_runtime.jsx)(ErrorMessage, { error: error }),
                !error &&
                  (0, jsx_runtime.jsx)(PopupViewMotion, {
                    appConfig: appConfig,
                    initial: { opacity: 1 },
                    animate: { opacity: error === null ? 1 : 0 },
                    transition: {
                      type: 'linear',
                      duration: 0.2,
                    },
                    disabled: !popupOpen,
                    sessionStarted: popupOpen,
                    onEmbedError: setError,
                    className: 'absolute inset-0',
                  }),
              ],
            }),
          }),
        }),
      ],
    });
  }
  /* harmony default export */ const agent_client = AgentClient; // ./components/embed-popup/standalone-bundle-root.tsx

  const scriptTag = document.querySelector('script[data-lk-sandbox-id]');
  const sandboxIdAttribute =
    scriptTag === null || scriptTag === void 0 ? void 0 : scriptTag.dataset.lkSandboxId;
  if (sandboxIdAttribute) {
    const wrapper = document.createElement('div');
    wrapper.setAttribute('id', 'lk-embed-wrapper');
    document.body.appendChild(wrapper);
    // Use a shadow root so that any relevant css classes don't leak out and effect the broader page
    const shadowRoot = wrapper.attachShadow({ mode: 'open' });
    // Include all app styles into the shadow root
    // FIXME: this includes styles for the welcome page / etc, not just the popup embed!
    const styleTag = document.createElement('style');
    styleTag.textContent = globals /* default */.A;
    shadowRoot.appendChild(styleTag);
    const reactRoot = document.createElement('div');
    shadowRoot.appendChild(reactRoot);
    getAppConfig(window.location.origin, sandboxIdAttribute)
      .then((appConfig) => {
        const root = client.createRoot(reactRoot);
        root.render((0, jsx_runtime.jsx)(agent_client, { appConfig: appConfig }));
      })
      .catch((err) => {
        console.error('LiveKit popup embed error - Error loading app config:', err);
      });
  } else {
    console.error(
      'LiveKit popup embed error - no data-lk-sandbox-id attribute found on script tag. This is required!'
    );
  }

  /******/
})();
//# sourceMappingURL=embed-popup.js.map
